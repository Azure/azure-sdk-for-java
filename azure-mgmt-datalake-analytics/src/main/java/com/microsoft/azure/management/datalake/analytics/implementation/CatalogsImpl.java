/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.datalake.analytics.implementation;

import retrofit2.Retrofit;
import com.microsoft.azure.management.datalake.analytics.Catalogs;
import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceCall;
import com.microsoft.azure.AzureServiceResponseBuilder;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.datalake.analytics.models.DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters;
import com.microsoft.azure.management.datalake.analytics.models.PageImpl;
import com.microsoft.azure.management.datalake.analytics.models.USqlAssembly;
import com.microsoft.azure.management.datalake.analytics.models.USqlAssemblyClr;
import com.microsoft.azure.management.datalake.analytics.models.USqlCredential;
import com.microsoft.azure.management.datalake.analytics.models.USqlDatabase;
import com.microsoft.azure.management.datalake.analytics.models.USqlExternalDataSource;
import com.microsoft.azure.management.datalake.analytics.models.USqlProcedure;
import com.microsoft.azure.management.datalake.analytics.models.USqlSchema;
import com.microsoft.azure.management.datalake.analytics.models.USqlSecret;
import com.microsoft.azure.management.datalake.analytics.models.USqlTable;
import com.microsoft.azure.management.datalake.analytics.models.USqlTablePartition;
import com.microsoft.azure.management.datalake.analytics.models.USqlTableStatistics;
import com.microsoft.azure.management.datalake.analytics.models.USqlTableType;
import com.microsoft.azure.management.datalake.analytics.models.USqlTableValuedFunction;
import com.microsoft.azure.management.datalake.analytics.models.USqlType;
import com.microsoft.azure.management.datalake.analytics.models.USqlView;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Catalogs.
 */
public final class CatalogsImpl implements Catalogs {
    /** The Retrofit service to perform REST calls. */
    private CatalogsService service;
    /** The service client containing this operation class. */
    private DataLakeAnalyticsCatalogManagementClientImpl client;

    /**
     * Initializes an instance of CatalogsImpl.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public CatalogsImpl(Retrofit retrofit, DataLakeAnalyticsCatalogManagementClientImpl client) {
        this.service = retrofit.create(CatalogsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Catalogs to be
     * used by Retrofit to perform actually REST calls.
     */
    interface CatalogsService {
        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("catalog/usql/databases/{databaseName}/secrets/{secretName}")
        Observable<Response<ResponseBody>> createSecret(@Path("databaseName") String databaseName, @Path("secretName") String secretName, @Body DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters parameters, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("catalog/usql/databases/{databaseName}/secrets/{secretName}")
        Observable<Response<ResponseBody>> updateSecret(@Path("databaseName") String databaseName, @Path("secretName") String secretName, @Body DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters parameters, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/secrets/{secretName}")
        Observable<Response<ResponseBody>> getSecret(@Path("databaseName") String databaseName, @Path("secretName") String secretName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "catalog/usql/databases/{databaseName}/secrets/{secretName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSecret(@Path("databaseName") String databaseName, @Path("secretName") String secretName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "catalog/usql/databases/{databaseName}/secrets", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteAllSecrets(@Path("databaseName") String databaseName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/externaldatasources/{externalDataSourceName}")
        Observable<Response<ResponseBody>> getExternalDataSource(@Path("databaseName") String databaseName, @Path("externalDataSourceName") String externalDataSourceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/externaldatasources")
        Observable<Response<ResponseBody>> listExternalDataSources(@Path("databaseName") String databaseName, @Query("$filter") String filter, @Query("$top") Integer top, @Query("$skip") Integer skip, @Query("$expand") String expand, @Query("$select") String select, @Query("$orderby") String orderby, @Query("$count") Boolean count, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/credentials/{credentialName}")
        Observable<Response<ResponseBody>> getCredential(@Path("databaseName") String databaseName, @Path("credentialName") String credentialName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/credentials")
        Observable<Response<ResponseBody>> listCredentials(@Path("databaseName") String databaseName, @Query("$filter") String filter, @Query("$top") Integer top, @Query("$skip") Integer skip, @Query("$expand") String expand, @Query("$select") String select, @Query("$orderby") String orderby, @Query("$count") Boolean count, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}/procedures/{procedureName}")
        Observable<Response<ResponseBody>> getProcedure(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Path("procedureName") String procedureName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}/procedures")
        Observable<Response<ResponseBody>> listProcedures(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Query("$filter") String filter, @Query("$top") Integer top, @Query("$skip") Integer skip, @Query("$expand") String expand, @Query("$select") String select, @Query("$orderby") String orderby, @Query("$count") Boolean count, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}")
        Observable<Response<ResponseBody>> getTable(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Path("tableName") String tableName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}/tables")
        Observable<Response<ResponseBody>> listTables(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Query("$filter") String filter, @Query("$top") Integer top, @Query("$skip") Integer skip, @Query("$expand") String expand, @Query("$select") String select, @Query("$orderby") String orderby, @Query("$count") Boolean count, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}/tabletypes/{tableTypeName}")
        Observable<Response<ResponseBody>> getTableType(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Path("tableTypeName") String tableTypeName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}/tabletypes")
        Observable<Response<ResponseBody>> listTableTypes(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Query("$filter") String filter, @Query("$top") Integer top, @Query("$skip") Integer skip, @Query("$expand") String expand, @Query("$select") String select, @Query("$orderby") String orderby, @Query("$count") Boolean count, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}/views/{viewName}")
        Observable<Response<ResponseBody>> getView(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Path("viewName") String viewName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}/views")
        Observable<Response<ResponseBody>> listViews(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Query("$filter") String filter, @Query("$top") Integer top, @Query("$skip") Integer skip, @Query("$expand") String expand, @Query("$select") String select, @Query("$orderby") String orderby, @Query("$count") Boolean count, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/statistics/{statisticsName}")
        Observable<Response<ResponseBody>> getTableStatistic(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Path("tableName") String tableName, @Path("statisticsName") String statisticsName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/statistics")
        Observable<Response<ResponseBody>> listTableStatistics(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Path("tableName") String tableName, @Query("$filter") String filter, @Query("$top") Integer top, @Query("$skip") Integer skip, @Query("$expand") String expand, @Query("$select") String select, @Query("$orderby") String orderby, @Query("$count") Boolean count, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/partitions/{partitionName}")
        Observable<Response<ResponseBody>> getTablePartition(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Path("tableName") String tableName, @Path("partitionName") String partitionName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/partitions")
        Observable<Response<ResponseBody>> listTablePartitions(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Path("tableName") String tableName, @Query("$filter") String filter, @Query("$top") Integer top, @Query("$skip") Integer skip, @Query("$expand") String expand, @Query("$select") String select, @Query("$orderby") String orderby, @Query("$count") Boolean count, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}/types")
        Observable<Response<ResponseBody>> listTypes(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Query("$filter") String filter, @Query("$top") Integer top, @Query("$skip") Integer skip, @Query("$expand") String expand, @Query("$select") String select, @Query("$orderby") String orderby, @Query("$count") Boolean count, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}/tablevaluedfunctions/{tableValuedFunctionName}")
        Observable<Response<ResponseBody>> getTableValuedFunction(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Path("tableValuedFunctionName") String tableValuedFunctionName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}/tablevaluedfunctions")
        Observable<Response<ResponseBody>> listTableValuedFunctions(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Query("$filter") String filter, @Query("$top") Integer top, @Query("$skip") Integer skip, @Query("$expand") String expand, @Query("$select") String select, @Query("$orderby") String orderby, @Query("$count") Boolean count, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/assemblies/{assemblyName}")
        Observable<Response<ResponseBody>> getAssembly(@Path("databaseName") String databaseName, @Path("assemblyName") String assemblyName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/assemblies")
        Observable<Response<ResponseBody>> listAssemblies(@Path("databaseName") String databaseName, @Query("$filter") String filter, @Query("$top") Integer top, @Query("$skip") Integer skip, @Query("$expand") String expand, @Query("$select") String select, @Query("$orderby") String orderby, @Query("$count") Boolean count, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas/{schemaName}")
        Observable<Response<ResponseBody>> getSchema(@Path("databaseName") String databaseName, @Path("schemaName") String schemaName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}/schemas")
        Observable<Response<ResponseBody>> listSchemas(@Path("databaseName") String databaseName, @Query("$filter") String filter, @Query("$top") Integer top, @Query("$skip") Integer skip, @Query("$expand") String expand, @Query("$select") String select, @Query("$orderby") String orderby, @Query("$count") Boolean count, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases/{databaseName}")
        Observable<Response<ResponseBody>> getDatabase(@Path("databaseName") String databaseName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("catalog/usql/databases")
        Observable<Response<ResponseBody>> listDatabases(@Query("$filter") String filter, @Query("$top") Integer top, @Query("$skip") Integer skip, @Query("$expand") String expand, @Query("$select") String select, @Query("$orderby") String orderby, @Query("$count") Boolean count, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listExternalDataSourcesNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listCredentialsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listProceduresNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listTablesNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listTableTypesNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listViewsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listTableStatisticsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listTablePartitionsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listTypesNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listTableValuedFunctionsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listAssembliesNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listSchemasNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listDatabasesNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Creates the specified secret for use with external data sources in the specified database.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database in which to create the secret.
     * @param secretName The name of the secret.
     * @param parameters The parameters required to create the secret (name and password)
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the USqlSecret object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<USqlSecret> createSecret(String accountName, String databaseName, String secretName, DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters parameters) throws CloudException, IOException, IllegalArgumentException {
        return createSecretAsync(accountName, databaseName, secretName, parameters).toBlocking().single();
    }

    /**
     * Creates the specified secret for use with external data sources in the specified database.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database in which to create the secret.
     * @param secretName The name of the secret.
     * @param parameters The parameters required to create the secret (name and password)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<USqlSecret> createSecretAsync(String accountName, String databaseName, String secretName, DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters parameters, final ServiceCallback<USqlSecret> serviceCallback) {
        return ServiceCall.create(createSecretAsync(accountName, databaseName, secretName, parameters), serviceCallback);
    }

    /**
     * Creates the specified secret for use with external data sources in the specified database.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database in which to create the secret.
     * @param secretName The name of the secret.
     * @param parameters The parameters required to create the secret (name and password)
     * @return the observable to the USqlSecret object
     */
    public Observable<ServiceResponse<USqlSecret>> createSecretAsync(String accountName, String databaseName, String secretName, DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters parameters) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(parameters);
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.createSecret(databaseName, secretName, parameters, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<USqlSecret>>>() {
                @Override
                public Observable<ServiceResponse<USqlSecret>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<USqlSecret> clientResponse = createSecretDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<USqlSecret> createSecretDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<USqlSecret, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<USqlSecret>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Modifies the specified secret for use with external data sources in the specified database.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the secret.
     * @param secretName The name of the secret.
     * @param parameters The parameters required to modify the secret (name and password)
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the USqlSecret object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<USqlSecret> updateSecret(String accountName, String databaseName, String secretName, DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters parameters) throws CloudException, IOException, IllegalArgumentException {
        return updateSecretAsync(accountName, databaseName, secretName, parameters).toBlocking().single();
    }

    /**
     * Modifies the specified secret for use with external data sources in the specified database.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the secret.
     * @param secretName The name of the secret.
     * @param parameters The parameters required to modify the secret (name and password)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<USqlSecret> updateSecretAsync(String accountName, String databaseName, String secretName, DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters parameters, final ServiceCallback<USqlSecret> serviceCallback) {
        return ServiceCall.create(updateSecretAsync(accountName, databaseName, secretName, parameters), serviceCallback);
    }

    /**
     * Modifies the specified secret for use with external data sources in the specified database.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the secret.
     * @param secretName The name of the secret.
     * @param parameters The parameters required to modify the secret (name and password)
     * @return the observable to the USqlSecret object
     */
    public Observable<ServiceResponse<USqlSecret>> updateSecretAsync(String accountName, String databaseName, String secretName, DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters parameters) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(parameters);
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.updateSecret(databaseName, secretName, parameters, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<USqlSecret>>>() {
                @Override
                public Observable<ServiceResponse<USqlSecret>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<USqlSecret> clientResponse = updateSecretDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<USqlSecret> updateSecretDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<USqlSecret, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<USqlSecret>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the specified secret in the specified database.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the secret.
     * @param secretName The name of the secret to get
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the USqlSecret object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<USqlSecret> getSecret(String accountName, String databaseName, String secretName) throws CloudException, IOException, IllegalArgumentException {
        return getSecretAsync(accountName, databaseName, secretName).toBlocking().single();
    }

    /**
     * Gets the specified secret in the specified database.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the secret.
     * @param secretName The name of the secret to get
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<USqlSecret> getSecretAsync(String accountName, String databaseName, String secretName, final ServiceCallback<USqlSecret> serviceCallback) {
        return ServiceCall.create(getSecretAsync(accountName, databaseName, secretName), serviceCallback);
    }

    /**
     * Gets the specified secret in the specified database.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the secret.
     * @param secretName The name of the secret to get
     * @return the observable to the USqlSecret object
     */
    public Observable<ServiceResponse<USqlSecret>> getSecretAsync(String accountName, String databaseName, String secretName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.getSecret(databaseName, secretName, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<USqlSecret>>>() {
                @Override
                public Observable<ServiceResponse<USqlSecret>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<USqlSecret> clientResponse = getSecretDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<USqlSecret> getSecretDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<USqlSecret, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<USqlSecret>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes the specified secret in the specified database.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the secret.
     * @param secretName The name of the secret to delete
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> deleteSecret(String accountName, String databaseName, String secretName) throws CloudException, IOException, IllegalArgumentException {
        return deleteSecretAsync(accountName, databaseName, secretName).toBlocking().single();
    }

    /**
     * Deletes the specified secret in the specified database.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the secret.
     * @param secretName The name of the secret to delete
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> deleteSecretAsync(String accountName, String databaseName, String secretName, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(deleteSecretAsync(accountName, databaseName, secretName), serviceCallback);
    }

    /**
     * Deletes the specified secret in the specified database.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the secret.
     * @param secretName The name of the secret to delete
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteSecretAsync(String accountName, String databaseName, String secretName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.deleteSecret(databaseName, secretName, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteSecretDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteSecretDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes all secrets in the specified database.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the secret.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> deleteAllSecrets(String accountName, String databaseName) throws CloudException, IOException, IllegalArgumentException {
        return deleteAllSecretsAsync(accountName, databaseName).toBlocking().single();
    }

    /**
     * Deletes all secrets in the specified database.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the secret.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> deleteAllSecretsAsync(String accountName, String databaseName, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(deleteAllSecretsAsync(accountName, databaseName), serviceCallback);
    }

    /**
     * Deletes all secrets in the specified database.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the secret.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteAllSecretsAsync(String accountName, String databaseName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.deleteAllSecrets(databaseName, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteAllSecretsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteAllSecretsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Retrieves the specified external data source from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the external data source.
     * @param externalDataSourceName The name of the external data source.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the USqlExternalDataSource object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<USqlExternalDataSource> getExternalDataSource(String accountName, String databaseName, String externalDataSourceName) throws CloudException, IOException, IllegalArgumentException {
        return getExternalDataSourceAsync(accountName, databaseName, externalDataSourceName).toBlocking().single();
    }

    /**
     * Retrieves the specified external data source from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the external data source.
     * @param externalDataSourceName The name of the external data source.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<USqlExternalDataSource> getExternalDataSourceAsync(String accountName, String databaseName, String externalDataSourceName, final ServiceCallback<USqlExternalDataSource> serviceCallback) {
        return ServiceCall.create(getExternalDataSourceAsync(accountName, databaseName, externalDataSourceName), serviceCallback);
    }

    /**
     * Retrieves the specified external data source from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the external data source.
     * @param externalDataSourceName The name of the external data source.
     * @return the observable to the USqlExternalDataSource object
     */
    public Observable<ServiceResponse<USqlExternalDataSource>> getExternalDataSourceAsync(String accountName, String databaseName, String externalDataSourceName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (externalDataSourceName == null) {
            throw new IllegalArgumentException("Parameter externalDataSourceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.getExternalDataSource(databaseName, externalDataSourceName, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<USqlExternalDataSource>>>() {
                @Override
                public Observable<ServiceResponse<USqlExternalDataSource>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<USqlExternalDataSource> clientResponse = getExternalDataSourceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<USqlExternalDataSource> getExternalDataSourceDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<USqlExternalDataSource, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<USqlExternalDataSource>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of external data sources from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the external data sources.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlExternalDataSource&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlExternalDataSource>> listExternalDataSources(final String accountName, final String databaseName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlExternalDataSource>> response = listExternalDataSourcesSinglePageAsync(accountName, databaseName).toBlocking().single();
        PagedList<USqlExternalDataSource> pagedList = new PagedList<USqlExternalDataSource>(response.getBody()) {
            @Override
            public Page<USqlExternalDataSource> nextPage(String nextPageLink) throws RestException, IOException {
                return listExternalDataSourcesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlExternalDataSource>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of external data sources from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the external data sources.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlExternalDataSource>> listExternalDataSourcesAsync(final String accountName, final String databaseName, final ListOperationCallback<USqlExternalDataSource> serviceCallback) {
        return AzureServiceCall.create(
            listExternalDataSourcesSinglePageAsync(accountName, databaseName),
            new Func1<String, Observable<ServiceResponse<Page<USqlExternalDataSource>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlExternalDataSource>>> call(String nextPageLink) {
                    return listExternalDataSourcesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of external data sources from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the external data sources.
     * @return the observable to the List&lt;USqlExternalDataSource&gt; object
     */
    public Observable<ServiceResponse<Page<USqlExternalDataSource>>> listExternalDataSourcesAsync(final String accountName, final String databaseName) {
        return listExternalDataSourcesSinglePageAsync(accountName, databaseName)
            .concatMap(new Func1<ServiceResponse<Page<USqlExternalDataSource>>, Observable<ServiceResponse<Page<USqlExternalDataSource>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlExternalDataSource>>> call(ServiceResponse<Page<USqlExternalDataSource>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listExternalDataSourcesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of external data sources from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the external data sources.
     * @return the List&lt;USqlExternalDataSource&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlExternalDataSource>>> listExternalDataSourcesSinglePageAsync(final String accountName, final String databaseName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Integer top = null;
        final Integer skip = null;
        final String expand = null;
        final String select = null;
        final String orderby = null;
        final Boolean count = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listExternalDataSources(databaseName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlExternalDataSource>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlExternalDataSource>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlExternalDataSource>> result = listExternalDataSourcesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlExternalDataSource>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the list of external data sources from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the external data sources.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlExternalDataSource&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlExternalDataSource>> listExternalDataSources(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlExternalDataSource>> response = listExternalDataSourcesSinglePageAsync(accountName, databaseName, filter, top, skip, expand, select, orderby, count).toBlocking().single();
        PagedList<USqlExternalDataSource> pagedList = new PagedList<USqlExternalDataSource>(response.getBody()) {
            @Override
            public Page<USqlExternalDataSource> nextPage(String nextPageLink) throws RestException, IOException {
                return listExternalDataSourcesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlExternalDataSource>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of external data sources from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the external data sources.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlExternalDataSource>> listExternalDataSourcesAsync(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count, final ListOperationCallback<USqlExternalDataSource> serviceCallback) {
        return AzureServiceCall.create(
            listExternalDataSourcesSinglePageAsync(accountName, databaseName, filter, top, skip, expand, select, orderby, count),
            new Func1<String, Observable<ServiceResponse<Page<USqlExternalDataSource>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlExternalDataSource>>> call(String nextPageLink) {
                    return listExternalDataSourcesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of external data sources from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the external data sources.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the observable to the List&lt;USqlExternalDataSource&gt; object
     */
    public Observable<ServiceResponse<Page<USqlExternalDataSource>>> listExternalDataSourcesAsync(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        return listExternalDataSourcesSinglePageAsync(accountName, databaseName, filter, top, skip, expand, select, orderby, count)
            .concatMap(new Func1<ServiceResponse<Page<USqlExternalDataSource>>, Observable<ServiceResponse<Page<USqlExternalDataSource>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlExternalDataSource>>> call(ServiceResponse<Page<USqlExternalDataSource>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listExternalDataSourcesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of external data sources from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlExternalDataSource>> * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
    ServiceResponse<PageImpl<USqlExternalDataSource>> * @param databaseName The name of the database containing the external data sources.
    ServiceResponse<PageImpl<USqlExternalDataSource>> * @param filter OData filter. Optional.
    ServiceResponse<PageImpl<USqlExternalDataSource>> * @param top The number of items to return. Optional.
    ServiceResponse<PageImpl<USqlExternalDataSource>> * @param skip The number of items to skip over before returning elements. Optional.
    ServiceResponse<PageImpl<USqlExternalDataSource>> * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
    ServiceResponse<PageImpl<USqlExternalDataSource>> * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
    ServiceResponse<PageImpl<USqlExternalDataSource>> * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
    ServiceResponse<PageImpl<USqlExternalDataSource>> * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the List&lt;USqlExternalDataSource&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlExternalDataSource>>> listExternalDataSourcesSinglePageAsync(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listExternalDataSources(databaseName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlExternalDataSource>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlExternalDataSource>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlExternalDataSource>> result = listExternalDataSourcesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlExternalDataSource>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlExternalDataSource>> listExternalDataSourcesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlExternalDataSource>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlExternalDataSource>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the specified credential from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @param credentialName The name of the credential.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the USqlCredential object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<USqlCredential> getCredential(String accountName, String databaseName, String credentialName) throws CloudException, IOException, IllegalArgumentException {
        return getCredentialAsync(accountName, databaseName, credentialName).toBlocking().single();
    }

    /**
     * Retrieves the specified credential from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @param credentialName The name of the credential.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<USqlCredential> getCredentialAsync(String accountName, String databaseName, String credentialName, final ServiceCallback<USqlCredential> serviceCallback) {
        return ServiceCall.create(getCredentialAsync(accountName, databaseName, credentialName), serviceCallback);
    }

    /**
     * Retrieves the specified credential from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @param credentialName The name of the credential.
     * @return the observable to the USqlCredential object
     */
    public Observable<ServiceResponse<USqlCredential>> getCredentialAsync(String accountName, String databaseName, String credentialName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (credentialName == null) {
            throw new IllegalArgumentException("Parameter credentialName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.getCredential(databaseName, credentialName, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<USqlCredential>>>() {
                @Override
                public Observable<ServiceResponse<USqlCredential>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<USqlCredential> clientResponse = getCredentialDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<USqlCredential> getCredentialDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<USqlCredential, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<USqlCredential>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of credentials from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlCredential&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlCredential>> listCredentials(final String accountName, final String databaseName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlCredential>> response = listCredentialsSinglePageAsync(accountName, databaseName).toBlocking().single();
        PagedList<USqlCredential> pagedList = new PagedList<USqlCredential>(response.getBody()) {
            @Override
            public Page<USqlCredential> nextPage(String nextPageLink) throws RestException, IOException {
                return listCredentialsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlCredential>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of credentials from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlCredential>> listCredentialsAsync(final String accountName, final String databaseName, final ListOperationCallback<USqlCredential> serviceCallback) {
        return AzureServiceCall.create(
            listCredentialsSinglePageAsync(accountName, databaseName),
            new Func1<String, Observable<ServiceResponse<Page<USqlCredential>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlCredential>>> call(String nextPageLink) {
                    return listCredentialsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of credentials from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @return the observable to the List&lt;USqlCredential&gt; object
     */
    public Observable<ServiceResponse<Page<USqlCredential>>> listCredentialsAsync(final String accountName, final String databaseName) {
        return listCredentialsSinglePageAsync(accountName, databaseName)
            .concatMap(new Func1<ServiceResponse<Page<USqlCredential>>, Observable<ServiceResponse<Page<USqlCredential>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlCredential>>> call(ServiceResponse<Page<USqlCredential>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listCredentialsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of credentials from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @return the List&lt;USqlCredential&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlCredential>>> listCredentialsSinglePageAsync(final String accountName, final String databaseName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Integer top = null;
        final Integer skip = null;
        final String expand = null;
        final String select = null;
        final String orderby = null;
        final Boolean count = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listCredentials(databaseName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlCredential>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlCredential>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlCredential>> result = listCredentialsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlCredential>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the list of credentials from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlCredential&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlCredential>> listCredentials(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlCredential>> response = listCredentialsSinglePageAsync(accountName, databaseName, filter, top, skip, expand, select, orderby, count).toBlocking().single();
        PagedList<USqlCredential> pagedList = new PagedList<USqlCredential>(response.getBody()) {
            @Override
            public Page<USqlCredential> nextPage(String nextPageLink) throws RestException, IOException {
                return listCredentialsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlCredential>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of credentials from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlCredential>> listCredentialsAsync(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count, final ListOperationCallback<USqlCredential> serviceCallback) {
        return AzureServiceCall.create(
            listCredentialsSinglePageAsync(accountName, databaseName, filter, top, skip, expand, select, orderby, count),
            new Func1<String, Observable<ServiceResponse<Page<USqlCredential>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlCredential>>> call(String nextPageLink) {
                    return listCredentialsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of credentials from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the observable to the List&lt;USqlCredential&gt; object
     */
    public Observable<ServiceResponse<Page<USqlCredential>>> listCredentialsAsync(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        return listCredentialsSinglePageAsync(accountName, databaseName, filter, top, skip, expand, select, orderby, count)
            .concatMap(new Func1<ServiceResponse<Page<USqlCredential>>, Observable<ServiceResponse<Page<USqlCredential>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlCredential>>> call(ServiceResponse<Page<USqlCredential>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listCredentialsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of credentials from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlCredential>> * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
    ServiceResponse<PageImpl<USqlCredential>> * @param databaseName The name of the database containing the schema.
    ServiceResponse<PageImpl<USqlCredential>> * @param filter OData filter. Optional.
    ServiceResponse<PageImpl<USqlCredential>> * @param top The number of items to return. Optional.
    ServiceResponse<PageImpl<USqlCredential>> * @param skip The number of items to skip over before returning elements. Optional.
    ServiceResponse<PageImpl<USqlCredential>> * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
    ServiceResponse<PageImpl<USqlCredential>> * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
    ServiceResponse<PageImpl<USqlCredential>> * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
    ServiceResponse<PageImpl<USqlCredential>> * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the List&lt;USqlCredential&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlCredential>>> listCredentialsSinglePageAsync(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listCredentials(databaseName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlCredential>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlCredential>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlCredential>> result = listCredentialsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlCredential>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlCredential>> listCredentialsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlCredential>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlCredential>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the specified procedure from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the procedure.
     * @param schemaName The name of the schema containing the procedure.
     * @param procedureName The name of the procedure.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the USqlProcedure object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<USqlProcedure> getProcedure(String accountName, String databaseName, String schemaName, String procedureName) throws CloudException, IOException, IllegalArgumentException {
        return getProcedureAsync(accountName, databaseName, schemaName, procedureName).toBlocking().single();
    }

    /**
     * Retrieves the specified procedure from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the procedure.
     * @param schemaName The name of the schema containing the procedure.
     * @param procedureName The name of the procedure.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<USqlProcedure> getProcedureAsync(String accountName, String databaseName, String schemaName, String procedureName, final ServiceCallback<USqlProcedure> serviceCallback) {
        return ServiceCall.create(getProcedureAsync(accountName, databaseName, schemaName, procedureName), serviceCallback);
    }

    /**
     * Retrieves the specified procedure from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the procedure.
     * @param schemaName The name of the schema containing the procedure.
     * @param procedureName The name of the procedure.
     * @return the observable to the USqlProcedure object
     */
    public Observable<ServiceResponse<USqlProcedure>> getProcedureAsync(String accountName, String databaseName, String schemaName, String procedureName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (procedureName == null) {
            throw new IllegalArgumentException("Parameter procedureName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.getProcedure(databaseName, schemaName, procedureName, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<USqlProcedure>>>() {
                @Override
                public Observable<ServiceResponse<USqlProcedure>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<USqlProcedure> clientResponse = getProcedureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<USqlProcedure> getProcedureDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<USqlProcedure, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<USqlProcedure>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of procedures from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the procedures.
     * @param schemaName The name of the schema containing the procedures.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlProcedure&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlProcedure>> listProcedures(final String accountName, final String databaseName, final String schemaName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlProcedure>> response = listProceduresSinglePageAsync(accountName, databaseName, schemaName).toBlocking().single();
        PagedList<USqlProcedure> pagedList = new PagedList<USqlProcedure>(response.getBody()) {
            @Override
            public Page<USqlProcedure> nextPage(String nextPageLink) throws RestException, IOException {
                return listProceduresNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlProcedure>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of procedures from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the procedures.
     * @param schemaName The name of the schema containing the procedures.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlProcedure>> listProceduresAsync(final String accountName, final String databaseName, final String schemaName, final ListOperationCallback<USqlProcedure> serviceCallback) {
        return AzureServiceCall.create(
            listProceduresSinglePageAsync(accountName, databaseName, schemaName),
            new Func1<String, Observable<ServiceResponse<Page<USqlProcedure>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlProcedure>>> call(String nextPageLink) {
                    return listProceduresNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of procedures from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the procedures.
     * @param schemaName The name of the schema containing the procedures.
     * @return the observable to the List&lt;USqlProcedure&gt; object
     */
    public Observable<ServiceResponse<Page<USqlProcedure>>> listProceduresAsync(final String accountName, final String databaseName, final String schemaName) {
        return listProceduresSinglePageAsync(accountName, databaseName, schemaName)
            .concatMap(new Func1<ServiceResponse<Page<USqlProcedure>>, Observable<ServiceResponse<Page<USqlProcedure>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlProcedure>>> call(ServiceResponse<Page<USqlProcedure>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listProceduresNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of procedures from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the procedures.
     * @param schemaName The name of the schema containing the procedures.
     * @return the List&lt;USqlProcedure&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlProcedure>>> listProceduresSinglePageAsync(final String accountName, final String databaseName, final String schemaName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Integer top = null;
        final Integer skip = null;
        final String expand = null;
        final String select = null;
        final String orderby = null;
        final Boolean count = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listProcedures(databaseName, schemaName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlProcedure>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlProcedure>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlProcedure>> result = listProceduresDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlProcedure>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the list of procedures from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the procedures.
     * @param schemaName The name of the schema containing the procedures.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlProcedure&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlProcedure>> listProcedures(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlProcedure>> response = listProceduresSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count).toBlocking().single();
        PagedList<USqlProcedure> pagedList = new PagedList<USqlProcedure>(response.getBody()) {
            @Override
            public Page<USqlProcedure> nextPage(String nextPageLink) throws RestException, IOException {
                return listProceduresNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlProcedure>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of procedures from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the procedures.
     * @param schemaName The name of the schema containing the procedures.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlProcedure>> listProceduresAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count, final ListOperationCallback<USqlProcedure> serviceCallback) {
        return AzureServiceCall.create(
            listProceduresSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count),
            new Func1<String, Observable<ServiceResponse<Page<USqlProcedure>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlProcedure>>> call(String nextPageLink) {
                    return listProceduresNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of procedures from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the procedures.
     * @param schemaName The name of the schema containing the procedures.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the observable to the List&lt;USqlProcedure&gt; object
     */
    public Observable<ServiceResponse<Page<USqlProcedure>>> listProceduresAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        return listProceduresSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count)
            .concatMap(new Func1<ServiceResponse<Page<USqlProcedure>>, Observable<ServiceResponse<Page<USqlProcedure>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlProcedure>>> call(ServiceResponse<Page<USqlProcedure>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listProceduresNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of procedures from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlProcedure>> * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
    ServiceResponse<PageImpl<USqlProcedure>> * @param databaseName The name of the database containing the procedures.
    ServiceResponse<PageImpl<USqlProcedure>> * @param schemaName The name of the schema containing the procedures.
    ServiceResponse<PageImpl<USqlProcedure>> * @param filter OData filter. Optional.
    ServiceResponse<PageImpl<USqlProcedure>> * @param top The number of items to return. Optional.
    ServiceResponse<PageImpl<USqlProcedure>> * @param skip The number of items to skip over before returning elements. Optional.
    ServiceResponse<PageImpl<USqlProcedure>> * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
    ServiceResponse<PageImpl<USqlProcedure>> * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
    ServiceResponse<PageImpl<USqlProcedure>> * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
    ServiceResponse<PageImpl<USqlProcedure>> * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the List&lt;USqlProcedure&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlProcedure>>> listProceduresSinglePageAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listProcedures(databaseName, schemaName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlProcedure>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlProcedure>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlProcedure>> result = listProceduresDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlProcedure>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlProcedure>> listProceduresDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlProcedure>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlProcedure>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the specified table from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table.
     * @param schemaName The name of the schema containing the table.
     * @param tableName The name of the table.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the USqlTable object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<USqlTable> getTable(String accountName, String databaseName, String schemaName, String tableName) throws CloudException, IOException, IllegalArgumentException {
        return getTableAsync(accountName, databaseName, schemaName, tableName).toBlocking().single();
    }

    /**
     * Retrieves the specified table from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table.
     * @param schemaName The name of the schema containing the table.
     * @param tableName The name of the table.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<USqlTable> getTableAsync(String accountName, String databaseName, String schemaName, String tableName, final ServiceCallback<USqlTable> serviceCallback) {
        return ServiceCall.create(getTableAsync(accountName, databaseName, schemaName, tableName), serviceCallback);
    }

    /**
     * Retrieves the specified table from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table.
     * @param schemaName The name of the schema containing the table.
     * @param tableName The name of the table.
     * @return the observable to the USqlTable object
     */
    public Observable<ServiceResponse<USqlTable>> getTableAsync(String accountName, String databaseName, String schemaName, String tableName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (tableName == null) {
            throw new IllegalArgumentException("Parameter tableName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.getTable(databaseName, schemaName, tableName, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<USqlTable>>>() {
                @Override
                public Observable<ServiceResponse<USqlTable>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<USqlTable> clientResponse = getTableDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<USqlTable> getTableDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<USqlTable, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<USqlTable>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of tables from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the tables.
     * @param schemaName The name of the schema containing the tables.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlTable&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlTable>> listTables(final String accountName, final String databaseName, final String schemaName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlTable>> response = listTablesSinglePageAsync(accountName, databaseName, schemaName).toBlocking().single();
        PagedList<USqlTable> pagedList = new PagedList<USqlTable>(response.getBody()) {
            @Override
            public Page<USqlTable> nextPage(String nextPageLink) throws RestException, IOException {
                return listTablesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlTable>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of tables from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the tables.
     * @param schemaName The name of the schema containing the tables.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlTable>> listTablesAsync(final String accountName, final String databaseName, final String schemaName, final ListOperationCallback<USqlTable> serviceCallback) {
        return AzureServiceCall.create(
            listTablesSinglePageAsync(accountName, databaseName, schemaName),
            new Func1<String, Observable<ServiceResponse<Page<USqlTable>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTable>>> call(String nextPageLink) {
                    return listTablesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of tables from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the tables.
     * @param schemaName The name of the schema containing the tables.
     * @return the observable to the List&lt;USqlTable&gt; object
     */
    public Observable<ServiceResponse<Page<USqlTable>>> listTablesAsync(final String accountName, final String databaseName, final String schemaName) {
        return listTablesSinglePageAsync(accountName, databaseName, schemaName)
            .concatMap(new Func1<ServiceResponse<Page<USqlTable>>, Observable<ServiceResponse<Page<USqlTable>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTable>>> call(ServiceResponse<Page<USqlTable>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTablesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of tables from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the tables.
     * @param schemaName The name of the schema containing the tables.
     * @return the List&lt;USqlTable&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlTable>>> listTablesSinglePageAsync(final String accountName, final String databaseName, final String schemaName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Integer top = null;
        final Integer skip = null;
        final String expand = null;
        final String select = null;
        final String orderby = null;
        final Boolean count = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listTables(databaseName, schemaName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlTable>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTable>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlTable>> result = listTablesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlTable>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the list of tables from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the tables.
     * @param schemaName The name of the schema containing the tables.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlTable&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlTable>> listTables(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlTable>> response = listTablesSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count).toBlocking().single();
        PagedList<USqlTable> pagedList = new PagedList<USqlTable>(response.getBody()) {
            @Override
            public Page<USqlTable> nextPage(String nextPageLink) throws RestException, IOException {
                return listTablesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlTable>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of tables from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the tables.
     * @param schemaName The name of the schema containing the tables.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlTable>> listTablesAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count, final ListOperationCallback<USqlTable> serviceCallback) {
        return AzureServiceCall.create(
            listTablesSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count),
            new Func1<String, Observable<ServiceResponse<Page<USqlTable>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTable>>> call(String nextPageLink) {
                    return listTablesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of tables from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the tables.
     * @param schemaName The name of the schema containing the tables.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the observable to the List&lt;USqlTable&gt; object
     */
    public Observable<ServiceResponse<Page<USqlTable>>> listTablesAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        return listTablesSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count)
            .concatMap(new Func1<ServiceResponse<Page<USqlTable>>, Observable<ServiceResponse<Page<USqlTable>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTable>>> call(ServiceResponse<Page<USqlTable>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTablesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of tables from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlTable>> * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
    ServiceResponse<PageImpl<USqlTable>> * @param databaseName The name of the database containing the tables.
    ServiceResponse<PageImpl<USqlTable>> * @param schemaName The name of the schema containing the tables.
    ServiceResponse<PageImpl<USqlTable>> * @param filter OData filter. Optional.
    ServiceResponse<PageImpl<USqlTable>> * @param top The number of items to return. Optional.
    ServiceResponse<PageImpl<USqlTable>> * @param skip The number of items to skip over before returning elements. Optional.
    ServiceResponse<PageImpl<USqlTable>> * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
    ServiceResponse<PageImpl<USqlTable>> * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
    ServiceResponse<PageImpl<USqlTable>> * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
    ServiceResponse<PageImpl<USqlTable>> * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the List&lt;USqlTable&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlTable>>> listTablesSinglePageAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listTables(databaseName, schemaName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlTable>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTable>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlTable>> result = listTablesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlTable>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlTable>> listTablesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlTable>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlTable>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the specified table type from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table type.
     * @param schemaName The name of the schema containing the table type.
     * @param tableTypeName The name of the table type to retrieve.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the USqlTableType object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<USqlTableType> getTableType(String accountName, String databaseName, String schemaName, String tableTypeName) throws CloudException, IOException, IllegalArgumentException {
        return getTableTypeAsync(accountName, databaseName, schemaName, tableTypeName).toBlocking().single();
    }

    /**
     * Retrieves the specified table type from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table type.
     * @param schemaName The name of the schema containing the table type.
     * @param tableTypeName The name of the table type to retrieve.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<USqlTableType> getTableTypeAsync(String accountName, String databaseName, String schemaName, String tableTypeName, final ServiceCallback<USqlTableType> serviceCallback) {
        return ServiceCall.create(getTableTypeAsync(accountName, databaseName, schemaName, tableTypeName), serviceCallback);
    }

    /**
     * Retrieves the specified table type from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table type.
     * @param schemaName The name of the schema containing the table type.
     * @param tableTypeName The name of the table type to retrieve.
     * @return the observable to the USqlTableType object
     */
    public Observable<ServiceResponse<USqlTableType>> getTableTypeAsync(String accountName, String databaseName, String schemaName, String tableTypeName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (tableTypeName == null) {
            throw new IllegalArgumentException("Parameter tableTypeName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.getTableType(databaseName, schemaName, tableTypeName, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<USqlTableType>>>() {
                @Override
                public Observable<ServiceResponse<USqlTableType>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<USqlTableType> clientResponse = getTableTypeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<USqlTableType> getTableTypeDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<USqlTableType, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<USqlTableType>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of table types from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table types.
     * @param schemaName The name of the schema containing the table types.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlTableType&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlTableType>> listTableTypes(final String accountName, final String databaseName, final String schemaName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlTableType>> response = listTableTypesSinglePageAsync(accountName, databaseName, schemaName).toBlocking().single();
        PagedList<USqlTableType> pagedList = new PagedList<USqlTableType>(response.getBody()) {
            @Override
            public Page<USqlTableType> nextPage(String nextPageLink) throws RestException, IOException {
                return listTableTypesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlTableType>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of table types from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table types.
     * @param schemaName The name of the schema containing the table types.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlTableType>> listTableTypesAsync(final String accountName, final String databaseName, final String schemaName, final ListOperationCallback<USqlTableType> serviceCallback) {
        return AzureServiceCall.create(
            listTableTypesSinglePageAsync(accountName, databaseName, schemaName),
            new Func1<String, Observable<ServiceResponse<Page<USqlTableType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableType>>> call(String nextPageLink) {
                    return listTableTypesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of table types from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table types.
     * @param schemaName The name of the schema containing the table types.
     * @return the observable to the List&lt;USqlTableType&gt; object
     */
    public Observable<ServiceResponse<Page<USqlTableType>>> listTableTypesAsync(final String accountName, final String databaseName, final String schemaName) {
        return listTableTypesSinglePageAsync(accountName, databaseName, schemaName)
            .concatMap(new Func1<ServiceResponse<Page<USqlTableType>>, Observable<ServiceResponse<Page<USqlTableType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableType>>> call(ServiceResponse<Page<USqlTableType>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTableTypesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of table types from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table types.
     * @param schemaName The name of the schema containing the table types.
     * @return the List&lt;USqlTableType&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlTableType>>> listTableTypesSinglePageAsync(final String accountName, final String databaseName, final String schemaName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Integer top = null;
        final Integer skip = null;
        final String expand = null;
        final String select = null;
        final String orderby = null;
        final Boolean count = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listTableTypes(databaseName, schemaName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlTableType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableType>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlTableType>> result = listTableTypesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlTableType>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the list of table types from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table types.
     * @param schemaName The name of the schema containing the table types.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlTableType&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlTableType>> listTableTypes(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlTableType>> response = listTableTypesSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count).toBlocking().single();
        PagedList<USqlTableType> pagedList = new PagedList<USqlTableType>(response.getBody()) {
            @Override
            public Page<USqlTableType> nextPage(String nextPageLink) throws RestException, IOException {
                return listTableTypesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlTableType>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of table types from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table types.
     * @param schemaName The name of the schema containing the table types.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlTableType>> listTableTypesAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count, final ListOperationCallback<USqlTableType> serviceCallback) {
        return AzureServiceCall.create(
            listTableTypesSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count),
            new Func1<String, Observable<ServiceResponse<Page<USqlTableType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableType>>> call(String nextPageLink) {
                    return listTableTypesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of table types from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table types.
     * @param schemaName The name of the schema containing the table types.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the observable to the List&lt;USqlTableType&gt; object
     */
    public Observable<ServiceResponse<Page<USqlTableType>>> listTableTypesAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        return listTableTypesSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count)
            .concatMap(new Func1<ServiceResponse<Page<USqlTableType>>, Observable<ServiceResponse<Page<USqlTableType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableType>>> call(ServiceResponse<Page<USqlTableType>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTableTypesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of table types from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlTableType>> * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
    ServiceResponse<PageImpl<USqlTableType>> * @param databaseName The name of the database containing the table types.
    ServiceResponse<PageImpl<USqlTableType>> * @param schemaName The name of the schema containing the table types.
    ServiceResponse<PageImpl<USqlTableType>> * @param filter OData filter. Optional.
    ServiceResponse<PageImpl<USqlTableType>> * @param top The number of items to return. Optional.
    ServiceResponse<PageImpl<USqlTableType>> * @param skip The number of items to skip over before returning elements. Optional.
    ServiceResponse<PageImpl<USqlTableType>> * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
    ServiceResponse<PageImpl<USqlTableType>> * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
    ServiceResponse<PageImpl<USqlTableType>> * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
    ServiceResponse<PageImpl<USqlTableType>> * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the List&lt;USqlTableType&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlTableType>>> listTableTypesSinglePageAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listTableTypes(databaseName, schemaName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlTableType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableType>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlTableType>> result = listTableTypesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlTableType>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlTableType>> listTableTypesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlTableType>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlTableType>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the specified view from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the view.
     * @param schemaName The name of the schema containing the view.
     * @param viewName The name of the view.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the USqlView object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<USqlView> getView(String accountName, String databaseName, String schemaName, String viewName) throws CloudException, IOException, IllegalArgumentException {
        return getViewAsync(accountName, databaseName, schemaName, viewName).toBlocking().single();
    }

    /**
     * Retrieves the specified view from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the view.
     * @param schemaName The name of the schema containing the view.
     * @param viewName The name of the view.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<USqlView> getViewAsync(String accountName, String databaseName, String schemaName, String viewName, final ServiceCallback<USqlView> serviceCallback) {
        return ServiceCall.create(getViewAsync(accountName, databaseName, schemaName, viewName), serviceCallback);
    }

    /**
     * Retrieves the specified view from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the view.
     * @param schemaName The name of the schema containing the view.
     * @param viewName The name of the view.
     * @return the observable to the USqlView object
     */
    public Observable<ServiceResponse<USqlView>> getViewAsync(String accountName, String databaseName, String schemaName, String viewName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (viewName == null) {
            throw new IllegalArgumentException("Parameter viewName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.getView(databaseName, schemaName, viewName, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<USqlView>>>() {
                @Override
                public Observable<ServiceResponse<USqlView>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<USqlView> clientResponse = getViewDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<USqlView> getViewDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<USqlView, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<USqlView>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of views from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the views.
     * @param schemaName The name of the schema containing the views.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlView&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlView>> listViews(final String accountName, final String databaseName, final String schemaName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlView>> response = listViewsSinglePageAsync(accountName, databaseName, schemaName).toBlocking().single();
        PagedList<USqlView> pagedList = new PagedList<USqlView>(response.getBody()) {
            @Override
            public Page<USqlView> nextPage(String nextPageLink) throws RestException, IOException {
                return listViewsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlView>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of views from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the views.
     * @param schemaName The name of the schema containing the views.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlView>> listViewsAsync(final String accountName, final String databaseName, final String schemaName, final ListOperationCallback<USqlView> serviceCallback) {
        return AzureServiceCall.create(
            listViewsSinglePageAsync(accountName, databaseName, schemaName),
            new Func1<String, Observable<ServiceResponse<Page<USqlView>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlView>>> call(String nextPageLink) {
                    return listViewsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of views from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the views.
     * @param schemaName The name of the schema containing the views.
     * @return the observable to the List&lt;USqlView&gt; object
     */
    public Observable<ServiceResponse<Page<USqlView>>> listViewsAsync(final String accountName, final String databaseName, final String schemaName) {
        return listViewsSinglePageAsync(accountName, databaseName, schemaName)
            .concatMap(new Func1<ServiceResponse<Page<USqlView>>, Observable<ServiceResponse<Page<USqlView>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlView>>> call(ServiceResponse<Page<USqlView>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listViewsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of views from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the views.
     * @param schemaName The name of the schema containing the views.
     * @return the List&lt;USqlView&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlView>>> listViewsSinglePageAsync(final String accountName, final String databaseName, final String schemaName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Integer top = null;
        final Integer skip = null;
        final String expand = null;
        final String select = null;
        final String orderby = null;
        final Boolean count = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listViews(databaseName, schemaName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlView>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlView>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlView>> result = listViewsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlView>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the list of views from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the views.
     * @param schemaName The name of the schema containing the views.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlView&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlView>> listViews(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlView>> response = listViewsSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count).toBlocking().single();
        PagedList<USqlView> pagedList = new PagedList<USqlView>(response.getBody()) {
            @Override
            public Page<USqlView> nextPage(String nextPageLink) throws RestException, IOException {
                return listViewsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlView>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of views from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the views.
     * @param schemaName The name of the schema containing the views.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlView>> listViewsAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count, final ListOperationCallback<USqlView> serviceCallback) {
        return AzureServiceCall.create(
            listViewsSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count),
            new Func1<String, Observable<ServiceResponse<Page<USqlView>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlView>>> call(String nextPageLink) {
                    return listViewsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of views from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the views.
     * @param schemaName The name of the schema containing the views.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the observable to the List&lt;USqlView&gt; object
     */
    public Observable<ServiceResponse<Page<USqlView>>> listViewsAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        return listViewsSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count)
            .concatMap(new Func1<ServiceResponse<Page<USqlView>>, Observable<ServiceResponse<Page<USqlView>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlView>>> call(ServiceResponse<Page<USqlView>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listViewsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of views from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlView>> * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
    ServiceResponse<PageImpl<USqlView>> * @param databaseName The name of the database containing the views.
    ServiceResponse<PageImpl<USqlView>> * @param schemaName The name of the schema containing the views.
    ServiceResponse<PageImpl<USqlView>> * @param filter OData filter. Optional.
    ServiceResponse<PageImpl<USqlView>> * @param top The number of items to return. Optional.
    ServiceResponse<PageImpl<USqlView>> * @param skip The number of items to skip over before returning elements. Optional.
    ServiceResponse<PageImpl<USqlView>> * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
    ServiceResponse<PageImpl<USqlView>> * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
    ServiceResponse<PageImpl<USqlView>> * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
    ServiceResponse<PageImpl<USqlView>> * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the List&lt;USqlView&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlView>>> listViewsSinglePageAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listViews(databaseName, schemaName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlView>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlView>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlView>> result = listViewsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlView>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlView>> listViewsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlView>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlView>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the specified table statistics from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the statistics.
     * @param schemaName The name of the schema containing the statistics.
     * @param tableName The name of the table containing the statistics.
     * @param statisticsName The name of the table statistics.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the USqlTableStatistics object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<USqlTableStatistics> getTableStatistic(String accountName, String databaseName, String schemaName, String tableName, String statisticsName) throws CloudException, IOException, IllegalArgumentException {
        return getTableStatisticAsync(accountName, databaseName, schemaName, tableName, statisticsName).toBlocking().single();
    }

    /**
     * Retrieves the specified table statistics from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the statistics.
     * @param schemaName The name of the schema containing the statistics.
     * @param tableName The name of the table containing the statistics.
     * @param statisticsName The name of the table statistics.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<USqlTableStatistics> getTableStatisticAsync(String accountName, String databaseName, String schemaName, String tableName, String statisticsName, final ServiceCallback<USqlTableStatistics> serviceCallback) {
        return ServiceCall.create(getTableStatisticAsync(accountName, databaseName, schemaName, tableName, statisticsName), serviceCallback);
    }

    /**
     * Retrieves the specified table statistics from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the statistics.
     * @param schemaName The name of the schema containing the statistics.
     * @param tableName The name of the table containing the statistics.
     * @param statisticsName The name of the table statistics.
     * @return the observable to the USqlTableStatistics object
     */
    public Observable<ServiceResponse<USqlTableStatistics>> getTableStatisticAsync(String accountName, String databaseName, String schemaName, String tableName, String statisticsName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (tableName == null) {
            throw new IllegalArgumentException("Parameter tableName is required and cannot be null.");
        }
        if (statisticsName == null) {
            throw new IllegalArgumentException("Parameter statisticsName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.getTableStatistic(databaseName, schemaName, tableName, statisticsName, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<USqlTableStatistics>>>() {
                @Override
                public Observable<ServiceResponse<USqlTableStatistics>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<USqlTableStatistics> clientResponse = getTableStatisticDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<USqlTableStatistics> getTableStatisticDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<USqlTableStatistics, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<USqlTableStatistics>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of table statistics from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the statistics.
     * @param schemaName The name of the schema containing the statistics.
     * @param tableName The name of the table containing the statistics.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlTableStatistics&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlTableStatistics>> listTableStatistics(final String accountName, final String databaseName, final String schemaName, final String tableName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlTableStatistics>> response = listTableStatisticsSinglePageAsync(accountName, databaseName, schemaName, tableName).toBlocking().single();
        PagedList<USqlTableStatistics> pagedList = new PagedList<USqlTableStatistics>(response.getBody()) {
            @Override
            public Page<USqlTableStatistics> nextPage(String nextPageLink) throws RestException, IOException {
                return listTableStatisticsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlTableStatistics>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of table statistics from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the statistics.
     * @param schemaName The name of the schema containing the statistics.
     * @param tableName The name of the table containing the statistics.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlTableStatistics>> listTableStatisticsAsync(final String accountName, final String databaseName, final String schemaName, final String tableName, final ListOperationCallback<USqlTableStatistics> serviceCallback) {
        return AzureServiceCall.create(
            listTableStatisticsSinglePageAsync(accountName, databaseName, schemaName, tableName),
            new Func1<String, Observable<ServiceResponse<Page<USqlTableStatistics>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableStatistics>>> call(String nextPageLink) {
                    return listTableStatisticsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of table statistics from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the statistics.
     * @param schemaName The name of the schema containing the statistics.
     * @param tableName The name of the table containing the statistics.
     * @return the observable to the List&lt;USqlTableStatistics&gt; object
     */
    public Observable<ServiceResponse<Page<USqlTableStatistics>>> listTableStatisticsAsync(final String accountName, final String databaseName, final String schemaName, final String tableName) {
        return listTableStatisticsSinglePageAsync(accountName, databaseName, schemaName, tableName)
            .concatMap(new Func1<ServiceResponse<Page<USqlTableStatistics>>, Observable<ServiceResponse<Page<USqlTableStatistics>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableStatistics>>> call(ServiceResponse<Page<USqlTableStatistics>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTableStatisticsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of table statistics from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the statistics.
     * @param schemaName The name of the schema containing the statistics.
     * @param tableName The name of the table containing the statistics.
     * @return the List&lt;USqlTableStatistics&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlTableStatistics>>> listTableStatisticsSinglePageAsync(final String accountName, final String databaseName, final String schemaName, final String tableName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (tableName == null) {
            throw new IllegalArgumentException("Parameter tableName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Integer top = null;
        final Integer skip = null;
        final String expand = null;
        final String select = null;
        final String orderby = null;
        final Boolean count = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listTableStatistics(databaseName, schemaName, tableName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlTableStatistics>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableStatistics>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlTableStatistics>> result = listTableStatisticsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlTableStatistics>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the list of table statistics from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the statistics.
     * @param schemaName The name of the schema containing the statistics.
     * @param tableName The name of the table containing the statistics.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlTableStatistics&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlTableStatistics>> listTableStatistics(final String accountName, final String databaseName, final String schemaName, final String tableName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlTableStatistics>> response = listTableStatisticsSinglePageAsync(accountName, databaseName, schemaName, tableName, filter, top, skip, expand, select, orderby, count).toBlocking().single();
        PagedList<USqlTableStatistics> pagedList = new PagedList<USqlTableStatistics>(response.getBody()) {
            @Override
            public Page<USqlTableStatistics> nextPage(String nextPageLink) throws RestException, IOException {
                return listTableStatisticsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlTableStatistics>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of table statistics from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the statistics.
     * @param schemaName The name of the schema containing the statistics.
     * @param tableName The name of the table containing the statistics.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlTableStatistics>> listTableStatisticsAsync(final String accountName, final String databaseName, final String schemaName, final String tableName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count, final ListOperationCallback<USqlTableStatistics> serviceCallback) {
        return AzureServiceCall.create(
            listTableStatisticsSinglePageAsync(accountName, databaseName, schemaName, tableName, filter, top, skip, expand, select, orderby, count),
            new Func1<String, Observable<ServiceResponse<Page<USqlTableStatistics>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableStatistics>>> call(String nextPageLink) {
                    return listTableStatisticsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of table statistics from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the statistics.
     * @param schemaName The name of the schema containing the statistics.
     * @param tableName The name of the table containing the statistics.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the observable to the List&lt;USqlTableStatistics&gt; object
     */
    public Observable<ServiceResponse<Page<USqlTableStatistics>>> listTableStatisticsAsync(final String accountName, final String databaseName, final String schemaName, final String tableName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        return listTableStatisticsSinglePageAsync(accountName, databaseName, schemaName, tableName, filter, top, skip, expand, select, orderby, count)
            .concatMap(new Func1<ServiceResponse<Page<USqlTableStatistics>>, Observable<ServiceResponse<Page<USqlTableStatistics>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableStatistics>>> call(ServiceResponse<Page<USqlTableStatistics>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTableStatisticsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of table statistics from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlTableStatistics>> * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
    ServiceResponse<PageImpl<USqlTableStatistics>> * @param databaseName The name of the database containing the statistics.
    ServiceResponse<PageImpl<USqlTableStatistics>> * @param schemaName The name of the schema containing the statistics.
    ServiceResponse<PageImpl<USqlTableStatistics>> * @param tableName The name of the table containing the statistics.
    ServiceResponse<PageImpl<USqlTableStatistics>> * @param filter OData filter. Optional.
    ServiceResponse<PageImpl<USqlTableStatistics>> * @param top The number of items to return. Optional.
    ServiceResponse<PageImpl<USqlTableStatistics>> * @param skip The number of items to skip over before returning elements. Optional.
    ServiceResponse<PageImpl<USqlTableStatistics>> * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
    ServiceResponse<PageImpl<USqlTableStatistics>> * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
    ServiceResponse<PageImpl<USqlTableStatistics>> * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
    ServiceResponse<PageImpl<USqlTableStatistics>> * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the List&lt;USqlTableStatistics&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlTableStatistics>>> listTableStatisticsSinglePageAsync(final String accountName, final String databaseName, final String schemaName, final String tableName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (tableName == null) {
            throw new IllegalArgumentException("Parameter tableName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listTableStatistics(databaseName, schemaName, tableName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlTableStatistics>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableStatistics>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlTableStatistics>> result = listTableStatisticsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlTableStatistics>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlTableStatistics>> listTableStatisticsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlTableStatistics>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlTableStatistics>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the specified table partition from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the partition.
     * @param schemaName The name of the schema containing the partition.
     * @param tableName The name of the table containing the partition.
     * @param partitionName The name of the table partition.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the USqlTablePartition object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<USqlTablePartition> getTablePartition(String accountName, String databaseName, String schemaName, String tableName, String partitionName) throws CloudException, IOException, IllegalArgumentException {
        return getTablePartitionAsync(accountName, databaseName, schemaName, tableName, partitionName).toBlocking().single();
    }

    /**
     * Retrieves the specified table partition from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the partition.
     * @param schemaName The name of the schema containing the partition.
     * @param tableName The name of the table containing the partition.
     * @param partitionName The name of the table partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<USqlTablePartition> getTablePartitionAsync(String accountName, String databaseName, String schemaName, String tableName, String partitionName, final ServiceCallback<USqlTablePartition> serviceCallback) {
        return ServiceCall.create(getTablePartitionAsync(accountName, databaseName, schemaName, tableName, partitionName), serviceCallback);
    }

    /**
     * Retrieves the specified table partition from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the partition.
     * @param schemaName The name of the schema containing the partition.
     * @param tableName The name of the table containing the partition.
     * @param partitionName The name of the table partition.
     * @return the observable to the USqlTablePartition object
     */
    public Observable<ServiceResponse<USqlTablePartition>> getTablePartitionAsync(String accountName, String databaseName, String schemaName, String tableName, String partitionName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (tableName == null) {
            throw new IllegalArgumentException("Parameter tableName is required and cannot be null.");
        }
        if (partitionName == null) {
            throw new IllegalArgumentException("Parameter partitionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.getTablePartition(databaseName, schemaName, tableName, partitionName, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<USqlTablePartition>>>() {
                @Override
                public Observable<ServiceResponse<USqlTablePartition>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<USqlTablePartition> clientResponse = getTablePartitionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<USqlTablePartition> getTablePartitionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<USqlTablePartition, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<USqlTablePartition>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of table partitions from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the partitions.
     * @param schemaName The name of the schema containing the partitions.
     * @param tableName The name of the table containing the partitions.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlTablePartition&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlTablePartition>> listTablePartitions(final String accountName, final String databaseName, final String schemaName, final String tableName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlTablePartition>> response = listTablePartitionsSinglePageAsync(accountName, databaseName, schemaName, tableName).toBlocking().single();
        PagedList<USqlTablePartition> pagedList = new PagedList<USqlTablePartition>(response.getBody()) {
            @Override
            public Page<USqlTablePartition> nextPage(String nextPageLink) throws RestException, IOException {
                return listTablePartitionsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlTablePartition>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of table partitions from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the partitions.
     * @param schemaName The name of the schema containing the partitions.
     * @param tableName The name of the table containing the partitions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlTablePartition>> listTablePartitionsAsync(final String accountName, final String databaseName, final String schemaName, final String tableName, final ListOperationCallback<USqlTablePartition> serviceCallback) {
        return AzureServiceCall.create(
            listTablePartitionsSinglePageAsync(accountName, databaseName, schemaName, tableName),
            new Func1<String, Observable<ServiceResponse<Page<USqlTablePartition>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTablePartition>>> call(String nextPageLink) {
                    return listTablePartitionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of table partitions from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the partitions.
     * @param schemaName The name of the schema containing the partitions.
     * @param tableName The name of the table containing the partitions.
     * @return the observable to the List&lt;USqlTablePartition&gt; object
     */
    public Observable<ServiceResponse<Page<USqlTablePartition>>> listTablePartitionsAsync(final String accountName, final String databaseName, final String schemaName, final String tableName) {
        return listTablePartitionsSinglePageAsync(accountName, databaseName, schemaName, tableName)
            .concatMap(new Func1<ServiceResponse<Page<USqlTablePartition>>, Observable<ServiceResponse<Page<USqlTablePartition>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTablePartition>>> call(ServiceResponse<Page<USqlTablePartition>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTablePartitionsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of table partitions from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the partitions.
     * @param schemaName The name of the schema containing the partitions.
     * @param tableName The name of the table containing the partitions.
     * @return the List&lt;USqlTablePartition&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlTablePartition>>> listTablePartitionsSinglePageAsync(final String accountName, final String databaseName, final String schemaName, final String tableName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (tableName == null) {
            throw new IllegalArgumentException("Parameter tableName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Integer top = null;
        final Integer skip = null;
        final String expand = null;
        final String select = null;
        final String orderby = null;
        final Boolean count = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listTablePartitions(databaseName, schemaName, tableName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlTablePartition>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTablePartition>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlTablePartition>> result = listTablePartitionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlTablePartition>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the list of table partitions from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the partitions.
     * @param schemaName The name of the schema containing the partitions.
     * @param tableName The name of the table containing the partitions.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlTablePartition&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlTablePartition>> listTablePartitions(final String accountName, final String databaseName, final String schemaName, final String tableName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlTablePartition>> response = listTablePartitionsSinglePageAsync(accountName, databaseName, schemaName, tableName, filter, top, skip, expand, select, orderby, count).toBlocking().single();
        PagedList<USqlTablePartition> pagedList = new PagedList<USqlTablePartition>(response.getBody()) {
            @Override
            public Page<USqlTablePartition> nextPage(String nextPageLink) throws RestException, IOException {
                return listTablePartitionsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlTablePartition>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of table partitions from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the partitions.
     * @param schemaName The name of the schema containing the partitions.
     * @param tableName The name of the table containing the partitions.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlTablePartition>> listTablePartitionsAsync(final String accountName, final String databaseName, final String schemaName, final String tableName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count, final ListOperationCallback<USqlTablePartition> serviceCallback) {
        return AzureServiceCall.create(
            listTablePartitionsSinglePageAsync(accountName, databaseName, schemaName, tableName, filter, top, skip, expand, select, orderby, count),
            new Func1<String, Observable<ServiceResponse<Page<USqlTablePartition>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTablePartition>>> call(String nextPageLink) {
                    return listTablePartitionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of table partitions from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the partitions.
     * @param schemaName The name of the schema containing the partitions.
     * @param tableName The name of the table containing the partitions.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the observable to the List&lt;USqlTablePartition&gt; object
     */
    public Observable<ServiceResponse<Page<USqlTablePartition>>> listTablePartitionsAsync(final String accountName, final String databaseName, final String schemaName, final String tableName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        return listTablePartitionsSinglePageAsync(accountName, databaseName, schemaName, tableName, filter, top, skip, expand, select, orderby, count)
            .concatMap(new Func1<ServiceResponse<Page<USqlTablePartition>>, Observable<ServiceResponse<Page<USqlTablePartition>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTablePartition>>> call(ServiceResponse<Page<USqlTablePartition>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTablePartitionsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of table partitions from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlTablePartition>> * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
    ServiceResponse<PageImpl<USqlTablePartition>> * @param databaseName The name of the database containing the partitions.
    ServiceResponse<PageImpl<USqlTablePartition>> * @param schemaName The name of the schema containing the partitions.
    ServiceResponse<PageImpl<USqlTablePartition>> * @param tableName The name of the table containing the partitions.
    ServiceResponse<PageImpl<USqlTablePartition>> * @param filter OData filter. Optional.
    ServiceResponse<PageImpl<USqlTablePartition>> * @param top The number of items to return. Optional.
    ServiceResponse<PageImpl<USqlTablePartition>> * @param skip The number of items to skip over before returning elements. Optional.
    ServiceResponse<PageImpl<USqlTablePartition>> * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
    ServiceResponse<PageImpl<USqlTablePartition>> * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
    ServiceResponse<PageImpl<USqlTablePartition>> * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
    ServiceResponse<PageImpl<USqlTablePartition>> * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the List&lt;USqlTablePartition&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlTablePartition>>> listTablePartitionsSinglePageAsync(final String accountName, final String databaseName, final String schemaName, final String tableName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (tableName == null) {
            throw new IllegalArgumentException("Parameter tableName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listTablePartitions(databaseName, schemaName, tableName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlTablePartition>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTablePartition>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlTablePartition>> result = listTablePartitionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlTablePartition>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlTablePartition>> listTablePartitionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlTablePartition>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlTablePartition>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of types within the specified database and schema from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the types.
     * @param schemaName The name of the schema containing the types.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlType&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlType>> listTypes(final String accountName, final String databaseName, final String schemaName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlType>> response = listTypesSinglePageAsync(accountName, databaseName, schemaName).toBlocking().single();
        PagedList<USqlType> pagedList = new PagedList<USqlType>(response.getBody()) {
            @Override
            public Page<USqlType> nextPage(String nextPageLink) throws RestException, IOException {
                return listTypesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlType>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of types within the specified database and schema from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the types.
     * @param schemaName The name of the schema containing the types.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlType>> listTypesAsync(final String accountName, final String databaseName, final String schemaName, final ListOperationCallback<USqlType> serviceCallback) {
        return AzureServiceCall.create(
            listTypesSinglePageAsync(accountName, databaseName, schemaName),
            new Func1<String, Observable<ServiceResponse<Page<USqlType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlType>>> call(String nextPageLink) {
                    return listTypesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of types within the specified database and schema from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the types.
     * @param schemaName The name of the schema containing the types.
     * @return the observable to the List&lt;USqlType&gt; object
     */
    public Observable<ServiceResponse<Page<USqlType>>> listTypesAsync(final String accountName, final String databaseName, final String schemaName) {
        return listTypesSinglePageAsync(accountName, databaseName, schemaName)
            .concatMap(new Func1<ServiceResponse<Page<USqlType>>, Observable<ServiceResponse<Page<USqlType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlType>>> call(ServiceResponse<Page<USqlType>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTypesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of types within the specified database and schema from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the types.
     * @param schemaName The name of the schema containing the types.
     * @return the List&lt;USqlType&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlType>>> listTypesSinglePageAsync(final String accountName, final String databaseName, final String schemaName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Integer top = null;
        final Integer skip = null;
        final String expand = null;
        final String select = null;
        final String orderby = null;
        final Boolean count = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listTypes(databaseName, schemaName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlType>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlType>> result = listTypesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlType>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the list of types within the specified database and schema from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the types.
     * @param schemaName The name of the schema containing the types.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlType&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlType>> listTypes(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlType>> response = listTypesSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count).toBlocking().single();
        PagedList<USqlType> pagedList = new PagedList<USqlType>(response.getBody()) {
            @Override
            public Page<USqlType> nextPage(String nextPageLink) throws RestException, IOException {
                return listTypesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlType>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of types within the specified database and schema from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the types.
     * @param schemaName The name of the schema containing the types.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlType>> listTypesAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count, final ListOperationCallback<USqlType> serviceCallback) {
        return AzureServiceCall.create(
            listTypesSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count),
            new Func1<String, Observable<ServiceResponse<Page<USqlType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlType>>> call(String nextPageLink) {
                    return listTypesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of types within the specified database and schema from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the types.
     * @param schemaName The name of the schema containing the types.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the observable to the List&lt;USqlType&gt; object
     */
    public Observable<ServiceResponse<Page<USqlType>>> listTypesAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        return listTypesSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count)
            .concatMap(new Func1<ServiceResponse<Page<USqlType>>, Observable<ServiceResponse<Page<USqlType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlType>>> call(ServiceResponse<Page<USqlType>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTypesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of types within the specified database and schema from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlType>> * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
    ServiceResponse<PageImpl<USqlType>> * @param databaseName The name of the database containing the types.
    ServiceResponse<PageImpl<USqlType>> * @param schemaName The name of the schema containing the types.
    ServiceResponse<PageImpl<USqlType>> * @param filter OData filter. Optional.
    ServiceResponse<PageImpl<USqlType>> * @param top The number of items to return. Optional.
    ServiceResponse<PageImpl<USqlType>> * @param skip The number of items to skip over before returning elements. Optional.
    ServiceResponse<PageImpl<USqlType>> * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
    ServiceResponse<PageImpl<USqlType>> * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
    ServiceResponse<PageImpl<USqlType>> * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
    ServiceResponse<PageImpl<USqlType>> * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the List&lt;USqlType&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlType>>> listTypesSinglePageAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listTypes(databaseName, schemaName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlType>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlType>> result = listTypesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlType>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlType>> listTypesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlType>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlType>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the specified table valued function from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table valued function.
     * @param schemaName The name of the schema containing the table valued function.
     * @param tableValuedFunctionName The name of the tableValuedFunction.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the USqlTableValuedFunction object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<USqlTableValuedFunction> getTableValuedFunction(String accountName, String databaseName, String schemaName, String tableValuedFunctionName) throws CloudException, IOException, IllegalArgumentException {
        return getTableValuedFunctionAsync(accountName, databaseName, schemaName, tableValuedFunctionName).toBlocking().single();
    }

    /**
     * Retrieves the specified table valued function from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table valued function.
     * @param schemaName The name of the schema containing the table valued function.
     * @param tableValuedFunctionName The name of the tableValuedFunction.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<USqlTableValuedFunction> getTableValuedFunctionAsync(String accountName, String databaseName, String schemaName, String tableValuedFunctionName, final ServiceCallback<USqlTableValuedFunction> serviceCallback) {
        return ServiceCall.create(getTableValuedFunctionAsync(accountName, databaseName, schemaName, tableValuedFunctionName), serviceCallback);
    }

    /**
     * Retrieves the specified table valued function from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table valued function.
     * @param schemaName The name of the schema containing the table valued function.
     * @param tableValuedFunctionName The name of the tableValuedFunction.
     * @return the observable to the USqlTableValuedFunction object
     */
    public Observable<ServiceResponse<USqlTableValuedFunction>> getTableValuedFunctionAsync(String accountName, String databaseName, String schemaName, String tableValuedFunctionName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (tableValuedFunctionName == null) {
            throw new IllegalArgumentException("Parameter tableValuedFunctionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.getTableValuedFunction(databaseName, schemaName, tableValuedFunctionName, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<USqlTableValuedFunction>>>() {
                @Override
                public Observable<ServiceResponse<USqlTableValuedFunction>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<USqlTableValuedFunction> clientResponse = getTableValuedFunctionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<USqlTableValuedFunction> getTableValuedFunctionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<USqlTableValuedFunction, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<USqlTableValuedFunction>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of table valued functions from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table valued functions.
     * @param schemaName The name of the schema containing the table valued functions.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlTableValuedFunction&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlTableValuedFunction>> listTableValuedFunctions(final String accountName, final String databaseName, final String schemaName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlTableValuedFunction>> response = listTableValuedFunctionsSinglePageAsync(accountName, databaseName, schemaName).toBlocking().single();
        PagedList<USqlTableValuedFunction> pagedList = new PagedList<USqlTableValuedFunction>(response.getBody()) {
            @Override
            public Page<USqlTableValuedFunction> nextPage(String nextPageLink) throws RestException, IOException {
                return listTableValuedFunctionsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlTableValuedFunction>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of table valued functions from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table valued functions.
     * @param schemaName The name of the schema containing the table valued functions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlTableValuedFunction>> listTableValuedFunctionsAsync(final String accountName, final String databaseName, final String schemaName, final ListOperationCallback<USqlTableValuedFunction> serviceCallback) {
        return AzureServiceCall.create(
            listTableValuedFunctionsSinglePageAsync(accountName, databaseName, schemaName),
            new Func1<String, Observable<ServiceResponse<Page<USqlTableValuedFunction>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableValuedFunction>>> call(String nextPageLink) {
                    return listTableValuedFunctionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of table valued functions from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table valued functions.
     * @param schemaName The name of the schema containing the table valued functions.
     * @return the observable to the List&lt;USqlTableValuedFunction&gt; object
     */
    public Observable<ServiceResponse<Page<USqlTableValuedFunction>>> listTableValuedFunctionsAsync(final String accountName, final String databaseName, final String schemaName) {
        return listTableValuedFunctionsSinglePageAsync(accountName, databaseName, schemaName)
            .concatMap(new Func1<ServiceResponse<Page<USqlTableValuedFunction>>, Observable<ServiceResponse<Page<USqlTableValuedFunction>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableValuedFunction>>> call(ServiceResponse<Page<USqlTableValuedFunction>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTableValuedFunctionsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of table valued functions from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table valued functions.
     * @param schemaName The name of the schema containing the table valued functions.
     * @return the List&lt;USqlTableValuedFunction&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlTableValuedFunction>>> listTableValuedFunctionsSinglePageAsync(final String accountName, final String databaseName, final String schemaName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Integer top = null;
        final Integer skip = null;
        final String expand = null;
        final String select = null;
        final String orderby = null;
        final Boolean count = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listTableValuedFunctions(databaseName, schemaName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlTableValuedFunction>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableValuedFunction>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlTableValuedFunction>> result = listTableValuedFunctionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlTableValuedFunction>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the list of table valued functions from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table valued functions.
     * @param schemaName The name of the schema containing the table valued functions.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlTableValuedFunction&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlTableValuedFunction>> listTableValuedFunctions(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlTableValuedFunction>> response = listTableValuedFunctionsSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count).toBlocking().single();
        PagedList<USqlTableValuedFunction> pagedList = new PagedList<USqlTableValuedFunction>(response.getBody()) {
            @Override
            public Page<USqlTableValuedFunction> nextPage(String nextPageLink) throws RestException, IOException {
                return listTableValuedFunctionsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlTableValuedFunction>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of table valued functions from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table valued functions.
     * @param schemaName The name of the schema containing the table valued functions.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlTableValuedFunction>> listTableValuedFunctionsAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count, final ListOperationCallback<USqlTableValuedFunction> serviceCallback) {
        return AzureServiceCall.create(
            listTableValuedFunctionsSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count),
            new Func1<String, Observable<ServiceResponse<Page<USqlTableValuedFunction>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableValuedFunction>>> call(String nextPageLink) {
                    return listTableValuedFunctionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of table valued functions from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the table valued functions.
     * @param schemaName The name of the schema containing the table valued functions.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the observable to the List&lt;USqlTableValuedFunction&gt; object
     */
    public Observable<ServiceResponse<Page<USqlTableValuedFunction>>> listTableValuedFunctionsAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        return listTableValuedFunctionsSinglePageAsync(accountName, databaseName, schemaName, filter, top, skip, expand, select, orderby, count)
            .concatMap(new Func1<ServiceResponse<Page<USqlTableValuedFunction>>, Observable<ServiceResponse<Page<USqlTableValuedFunction>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableValuedFunction>>> call(ServiceResponse<Page<USqlTableValuedFunction>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTableValuedFunctionsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of table valued functions from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlTableValuedFunction>> * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
    ServiceResponse<PageImpl<USqlTableValuedFunction>> * @param databaseName The name of the database containing the table valued functions.
    ServiceResponse<PageImpl<USqlTableValuedFunction>> * @param schemaName The name of the schema containing the table valued functions.
    ServiceResponse<PageImpl<USqlTableValuedFunction>> * @param filter OData filter. Optional.
    ServiceResponse<PageImpl<USqlTableValuedFunction>> * @param top The number of items to return. Optional.
    ServiceResponse<PageImpl<USqlTableValuedFunction>> * @param skip The number of items to skip over before returning elements. Optional.
    ServiceResponse<PageImpl<USqlTableValuedFunction>> * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
    ServiceResponse<PageImpl<USqlTableValuedFunction>> * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
    ServiceResponse<PageImpl<USqlTableValuedFunction>> * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
    ServiceResponse<PageImpl<USqlTableValuedFunction>> * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the List&lt;USqlTableValuedFunction&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlTableValuedFunction>>> listTableValuedFunctionsSinglePageAsync(final String accountName, final String databaseName, final String schemaName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listTableValuedFunctions(databaseName, schemaName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlTableValuedFunction>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableValuedFunction>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlTableValuedFunction>> result = listTableValuedFunctionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlTableValuedFunction>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlTableValuedFunction>> listTableValuedFunctionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlTableValuedFunction>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlTableValuedFunction>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the specified assembly from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the assembly.
     * @param assemblyName The name of the assembly.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the USqlAssembly object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<USqlAssembly> getAssembly(String accountName, String databaseName, String assemblyName) throws CloudException, IOException, IllegalArgumentException {
        return getAssemblyAsync(accountName, databaseName, assemblyName).toBlocking().single();
    }

    /**
     * Retrieves the specified assembly from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the assembly.
     * @param assemblyName The name of the assembly.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<USqlAssembly> getAssemblyAsync(String accountName, String databaseName, String assemblyName, final ServiceCallback<USqlAssembly> serviceCallback) {
        return ServiceCall.create(getAssemblyAsync(accountName, databaseName, assemblyName), serviceCallback);
    }

    /**
     * Retrieves the specified assembly from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the assembly.
     * @param assemblyName The name of the assembly.
     * @return the observable to the USqlAssembly object
     */
    public Observable<ServiceResponse<USqlAssembly>> getAssemblyAsync(String accountName, String databaseName, String assemblyName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (assemblyName == null) {
            throw new IllegalArgumentException("Parameter assemblyName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.getAssembly(databaseName, assemblyName, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<USqlAssembly>>>() {
                @Override
                public Observable<ServiceResponse<USqlAssembly>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<USqlAssembly> clientResponse = getAssemblyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<USqlAssembly> getAssemblyDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<USqlAssembly, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<USqlAssembly>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of assemblies from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the assembly.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlAssemblyClr&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlAssemblyClr>> listAssemblies(final String accountName, final String databaseName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlAssemblyClr>> response = listAssembliesSinglePageAsync(accountName, databaseName).toBlocking().single();
        PagedList<USqlAssemblyClr> pagedList = new PagedList<USqlAssemblyClr>(response.getBody()) {
            @Override
            public Page<USqlAssemblyClr> nextPage(String nextPageLink) throws RestException, IOException {
                return listAssembliesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlAssemblyClr>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of assemblies from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the assembly.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlAssemblyClr>> listAssembliesAsync(final String accountName, final String databaseName, final ListOperationCallback<USqlAssemblyClr> serviceCallback) {
        return AzureServiceCall.create(
            listAssembliesSinglePageAsync(accountName, databaseName),
            new Func1<String, Observable<ServiceResponse<Page<USqlAssemblyClr>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlAssemblyClr>>> call(String nextPageLink) {
                    return listAssembliesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of assemblies from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the assembly.
     * @return the observable to the List&lt;USqlAssemblyClr&gt; object
     */
    public Observable<ServiceResponse<Page<USqlAssemblyClr>>> listAssembliesAsync(final String accountName, final String databaseName) {
        return listAssembliesSinglePageAsync(accountName, databaseName)
            .concatMap(new Func1<ServiceResponse<Page<USqlAssemblyClr>>, Observable<ServiceResponse<Page<USqlAssemblyClr>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlAssemblyClr>>> call(ServiceResponse<Page<USqlAssemblyClr>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listAssembliesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of assemblies from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the assembly.
     * @return the List&lt;USqlAssemblyClr&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlAssemblyClr>>> listAssembliesSinglePageAsync(final String accountName, final String databaseName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Integer top = null;
        final Integer skip = null;
        final String expand = null;
        final String select = null;
        final String orderby = null;
        final Boolean count = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listAssemblies(databaseName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlAssemblyClr>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlAssemblyClr>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlAssemblyClr>> result = listAssembliesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlAssemblyClr>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the list of assemblies from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the assembly.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlAssemblyClr&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlAssemblyClr>> listAssemblies(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlAssemblyClr>> response = listAssembliesSinglePageAsync(accountName, databaseName, filter, top, skip, expand, select, orderby, count).toBlocking().single();
        PagedList<USqlAssemblyClr> pagedList = new PagedList<USqlAssemblyClr>(response.getBody()) {
            @Override
            public Page<USqlAssemblyClr> nextPage(String nextPageLink) throws RestException, IOException {
                return listAssembliesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlAssemblyClr>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of assemblies from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the assembly.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlAssemblyClr>> listAssembliesAsync(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count, final ListOperationCallback<USqlAssemblyClr> serviceCallback) {
        return AzureServiceCall.create(
            listAssembliesSinglePageAsync(accountName, databaseName, filter, top, skip, expand, select, orderby, count),
            new Func1<String, Observable<ServiceResponse<Page<USqlAssemblyClr>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlAssemblyClr>>> call(String nextPageLink) {
                    return listAssembliesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of assemblies from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the assembly.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the observable to the List&lt;USqlAssemblyClr&gt; object
     */
    public Observable<ServiceResponse<Page<USqlAssemblyClr>>> listAssembliesAsync(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        return listAssembliesSinglePageAsync(accountName, databaseName, filter, top, skip, expand, select, orderby, count)
            .concatMap(new Func1<ServiceResponse<Page<USqlAssemblyClr>>, Observable<ServiceResponse<Page<USqlAssemblyClr>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlAssemblyClr>>> call(ServiceResponse<Page<USqlAssemblyClr>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listAssembliesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of assemblies from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlAssemblyClr>> * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
    ServiceResponse<PageImpl<USqlAssemblyClr>> * @param databaseName The name of the database containing the assembly.
    ServiceResponse<PageImpl<USqlAssemblyClr>> * @param filter OData filter. Optional.
    ServiceResponse<PageImpl<USqlAssemblyClr>> * @param top The number of items to return. Optional.
    ServiceResponse<PageImpl<USqlAssemblyClr>> * @param skip The number of items to skip over before returning elements. Optional.
    ServiceResponse<PageImpl<USqlAssemblyClr>> * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
    ServiceResponse<PageImpl<USqlAssemblyClr>> * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
    ServiceResponse<PageImpl<USqlAssemblyClr>> * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
    ServiceResponse<PageImpl<USqlAssemblyClr>> * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the List&lt;USqlAssemblyClr&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlAssemblyClr>>> listAssembliesSinglePageAsync(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listAssemblies(databaseName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlAssemblyClr>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlAssemblyClr>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlAssemblyClr>> result = listAssembliesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlAssemblyClr>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlAssemblyClr>> listAssembliesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlAssemblyClr>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlAssemblyClr>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the specified schema from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @param schemaName The name of the schema.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the USqlSchema object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<USqlSchema> getSchema(String accountName, String databaseName, String schemaName) throws CloudException, IOException, IllegalArgumentException {
        return getSchemaAsync(accountName, databaseName, schemaName).toBlocking().single();
    }

    /**
     * Retrieves the specified schema from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @param schemaName The name of the schema.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<USqlSchema> getSchemaAsync(String accountName, String databaseName, String schemaName, final ServiceCallback<USqlSchema> serviceCallback) {
        return ServiceCall.create(getSchemaAsync(accountName, databaseName, schemaName), serviceCallback);
    }

    /**
     * Retrieves the specified schema from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @param schemaName The name of the schema.
     * @return the observable to the USqlSchema object
     */
    public Observable<ServiceResponse<USqlSchema>> getSchemaAsync(String accountName, String databaseName, String schemaName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (schemaName == null) {
            throw new IllegalArgumentException("Parameter schemaName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.getSchema(databaseName, schemaName, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<USqlSchema>>>() {
                @Override
                public Observable<ServiceResponse<USqlSchema>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<USqlSchema> clientResponse = getSchemaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<USqlSchema> getSchemaDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<USqlSchema, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<USqlSchema>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of schemas from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlSchema&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlSchema>> listSchemas(final String accountName, final String databaseName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlSchema>> response = listSchemasSinglePageAsync(accountName, databaseName).toBlocking().single();
        PagedList<USqlSchema> pagedList = new PagedList<USqlSchema>(response.getBody()) {
            @Override
            public Page<USqlSchema> nextPage(String nextPageLink) throws RestException, IOException {
                return listSchemasNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlSchema>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of schemas from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlSchema>> listSchemasAsync(final String accountName, final String databaseName, final ListOperationCallback<USqlSchema> serviceCallback) {
        return AzureServiceCall.create(
            listSchemasSinglePageAsync(accountName, databaseName),
            new Func1<String, Observable<ServiceResponse<Page<USqlSchema>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlSchema>>> call(String nextPageLink) {
                    return listSchemasNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of schemas from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @return the observable to the List&lt;USqlSchema&gt; object
     */
    public Observable<ServiceResponse<Page<USqlSchema>>> listSchemasAsync(final String accountName, final String databaseName) {
        return listSchemasSinglePageAsync(accountName, databaseName)
            .concatMap(new Func1<ServiceResponse<Page<USqlSchema>>, Observable<ServiceResponse<Page<USqlSchema>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlSchema>>> call(ServiceResponse<Page<USqlSchema>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listSchemasNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of schemas from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @return the List&lt;USqlSchema&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlSchema>>> listSchemasSinglePageAsync(final String accountName, final String databaseName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Integer top = null;
        final Integer skip = null;
        final String expand = null;
        final String select = null;
        final String orderby = null;
        final Boolean count = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listSchemas(databaseName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlSchema>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlSchema>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlSchema>> result = listSchemasDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlSchema>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the list of schemas from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlSchema&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlSchema>> listSchemas(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlSchema>> response = listSchemasSinglePageAsync(accountName, databaseName, filter, top, skip, expand, select, orderby, count).toBlocking().single();
        PagedList<USqlSchema> pagedList = new PagedList<USqlSchema>(response.getBody()) {
            @Override
            public Page<USqlSchema> nextPage(String nextPageLink) throws RestException, IOException {
                return listSchemasNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlSchema>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of schemas from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlSchema>> listSchemasAsync(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count, final ListOperationCallback<USqlSchema> serviceCallback) {
        return AzureServiceCall.create(
            listSchemasSinglePageAsync(accountName, databaseName, filter, top, skip, expand, select, orderby, count),
            new Func1<String, Observable<ServiceResponse<Page<USqlSchema>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlSchema>>> call(String nextPageLink) {
                    return listSchemasNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of schemas from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database containing the schema.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the observable to the List&lt;USqlSchema&gt; object
     */
    public Observable<ServiceResponse<Page<USqlSchema>>> listSchemasAsync(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        return listSchemasSinglePageAsync(accountName, databaseName, filter, top, skip, expand, select, orderby, count)
            .concatMap(new Func1<ServiceResponse<Page<USqlSchema>>, Observable<ServiceResponse<Page<USqlSchema>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlSchema>>> call(ServiceResponse<Page<USqlSchema>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listSchemasNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of schemas from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlSchema>> * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
    ServiceResponse<PageImpl<USqlSchema>> * @param databaseName The name of the database containing the schema.
    ServiceResponse<PageImpl<USqlSchema>> * @param filter OData filter. Optional.
    ServiceResponse<PageImpl<USqlSchema>> * @param top The number of items to return. Optional.
    ServiceResponse<PageImpl<USqlSchema>> * @param skip The number of items to skip over before returning elements. Optional.
    ServiceResponse<PageImpl<USqlSchema>> * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
    ServiceResponse<PageImpl<USqlSchema>> * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
    ServiceResponse<PageImpl<USqlSchema>> * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
    ServiceResponse<PageImpl<USqlSchema>> * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the List&lt;USqlSchema&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlSchema>>> listSchemasSinglePageAsync(final String accountName, final String databaseName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listSchemas(databaseName, filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlSchema>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlSchema>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlSchema>> result = listSchemasDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlSchema>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlSchema>> listSchemasDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlSchema>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlSchema>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the specified database from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the USqlDatabase object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<USqlDatabase> getDatabase(String accountName, String databaseName) throws CloudException, IOException, IllegalArgumentException {
        return getDatabaseAsync(accountName, databaseName).toBlocking().single();
    }

    /**
     * Retrieves the specified database from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<USqlDatabase> getDatabaseAsync(String accountName, String databaseName, final ServiceCallback<USqlDatabase> serviceCallback) {
        return ServiceCall.create(getDatabaseAsync(accountName, databaseName), serviceCallback);
    }

    /**
     * Retrieves the specified database from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param databaseName The name of the database.
     * @return the observable to the USqlDatabase object
     */
    public Observable<ServiceResponse<USqlDatabase>> getDatabaseAsync(String accountName, String databaseName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (databaseName == null) {
            throw new IllegalArgumentException("Parameter databaseName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.getDatabase(databaseName, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<USqlDatabase>>>() {
                @Override
                public Observable<ServiceResponse<USqlDatabase>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<USqlDatabase> clientResponse = getDatabaseDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<USqlDatabase> getDatabaseDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<USqlDatabase, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<USqlDatabase>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of databases from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlDatabase&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlDatabase>> listDatabases(final String accountName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlDatabase>> response = listDatabasesSinglePageAsync(accountName).toBlocking().single();
        PagedList<USqlDatabase> pagedList = new PagedList<USqlDatabase>(response.getBody()) {
            @Override
            public Page<USqlDatabase> nextPage(String nextPageLink) throws RestException, IOException {
                return listDatabasesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlDatabase>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of databases from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlDatabase>> listDatabasesAsync(final String accountName, final ListOperationCallback<USqlDatabase> serviceCallback) {
        return AzureServiceCall.create(
            listDatabasesSinglePageAsync(accountName),
            new Func1<String, Observable<ServiceResponse<Page<USqlDatabase>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlDatabase>>> call(String nextPageLink) {
                    return listDatabasesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of databases from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @return the observable to the List&lt;USqlDatabase&gt; object
     */
    public Observable<ServiceResponse<Page<USqlDatabase>>> listDatabasesAsync(final String accountName) {
        return listDatabasesSinglePageAsync(accountName)
            .concatMap(new Func1<ServiceResponse<Page<USqlDatabase>>, Observable<ServiceResponse<Page<USqlDatabase>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlDatabase>>> call(ServiceResponse<Page<USqlDatabase>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listDatabasesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of databases from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @return the List&lt;USqlDatabase&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlDatabase>>> listDatabasesSinglePageAsync(final String accountName) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Integer top = null;
        final Integer skip = null;
        final String expand = null;
        final String select = null;
        final String orderby = null;
        final Boolean count = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listDatabases(filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlDatabase>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlDatabase>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlDatabase>> result = listDatabasesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlDatabase>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieves the list of databases from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlDatabase&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlDatabase>> listDatabases(final String accountName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlDatabase>> response = listDatabasesSinglePageAsync(accountName, filter, top, skip, expand, select, orderby, count).toBlocking().single();
        PagedList<USqlDatabase> pagedList = new PagedList<USqlDatabase>(response.getBody()) {
            @Override
            public Page<USqlDatabase> nextPage(String nextPageLink) throws RestException, IOException {
                return listDatabasesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlDatabase>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of databases from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlDatabase>> listDatabasesAsync(final String accountName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count, final ListOperationCallback<USqlDatabase> serviceCallback) {
        return AzureServiceCall.create(
            listDatabasesSinglePageAsync(accountName, filter, top, skip, expand, select, orderby, count),
            new Func1<String, Observable<ServiceResponse<Page<USqlDatabase>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlDatabase>>> call(String nextPageLink) {
                    return listDatabasesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of databases from the Data Lake Analytics catalog.
     *
     * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
     * @param filter OData filter. Optional.
     * @param top The number of items to return. Optional.
     * @param skip The number of items to skip over before returning elements. Optional.
     * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
     * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
     * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
     * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the observable to the List&lt;USqlDatabase&gt; object
     */
    public Observable<ServiceResponse<Page<USqlDatabase>>> listDatabasesAsync(final String accountName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        return listDatabasesSinglePageAsync(accountName, filter, top, skip, expand, select, orderby, count)
            .concatMap(new Func1<ServiceResponse<Page<USqlDatabase>>, Observable<ServiceResponse<Page<USqlDatabase>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlDatabase>>> call(ServiceResponse<Page<USqlDatabase>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listDatabasesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of databases from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlDatabase>> * @param accountName The Azure Data Lake Analytics account to execute catalog operations on.
    ServiceResponse<PageImpl<USqlDatabase>> * @param filter OData filter. Optional.
    ServiceResponse<PageImpl<USqlDatabase>> * @param top The number of items to return. Optional.
    ServiceResponse<PageImpl<USqlDatabase>> * @param skip The number of items to skip over before returning elements. Optional.
    ServiceResponse<PageImpl<USqlDatabase>> * @param expand OData expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
    ServiceResponse<PageImpl<USqlDatabase>> * @param select OData Select statement. Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
    ServiceResponse<PageImpl<USqlDatabase>> * @param orderby OrderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
    ServiceResponse<PageImpl<USqlDatabase>> * @param count The Boolean value of true or false to request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
     * @return the List&lt;USqlDatabase&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlDatabase>>> listDatabasesSinglePageAsync(final String accountName, final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlaCatalogDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlaCatalogDnsSuffix() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlaCatalogDnsSuffix}", this.client.adlaCatalogDnsSuffix());
        return service.listDatabases(filter, top, skip, expand, select, orderby, count, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlDatabase>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlDatabase>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlDatabase>> result = listDatabasesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlDatabase>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlDatabase>> listDatabasesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlDatabase>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlDatabase>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of external data sources from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlExternalDataSource&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlExternalDataSource>> listExternalDataSourcesNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlExternalDataSource>> response = listExternalDataSourcesNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<USqlExternalDataSource> pagedList = new PagedList<USqlExternalDataSource>(response.getBody()) {
            @Override
            public Page<USqlExternalDataSource> nextPage(String nextPageLink) throws RestException, IOException {
                return listExternalDataSourcesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlExternalDataSource>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of external data sources from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlExternalDataSource>> listExternalDataSourcesNextAsync(final String nextPageLink, final ServiceCall<List<USqlExternalDataSource>> serviceCall, final ListOperationCallback<USqlExternalDataSource> serviceCallback) {
        return AzureServiceCall.create(
            listExternalDataSourcesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<USqlExternalDataSource>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlExternalDataSource>>> call(String nextPageLink) {
                    return listExternalDataSourcesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of external data sources from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;USqlExternalDataSource&gt; object
     */
    public Observable<ServiceResponse<Page<USqlExternalDataSource>>> listExternalDataSourcesNextAsync(final String nextPageLink) {
        return listExternalDataSourcesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<USqlExternalDataSource>>, Observable<ServiceResponse<Page<USqlExternalDataSource>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlExternalDataSource>>> call(ServiceResponse<Page<USqlExternalDataSource>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listExternalDataSourcesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of external data sources from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlExternalDataSource>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;USqlExternalDataSource&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlExternalDataSource>>> listExternalDataSourcesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listExternalDataSourcesNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlExternalDataSource>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlExternalDataSource>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlExternalDataSource>> result = listExternalDataSourcesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlExternalDataSource>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlExternalDataSource>> listExternalDataSourcesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlExternalDataSource>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlExternalDataSource>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of credentials from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlCredential&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlCredential>> listCredentialsNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlCredential>> response = listCredentialsNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<USqlCredential> pagedList = new PagedList<USqlCredential>(response.getBody()) {
            @Override
            public Page<USqlCredential> nextPage(String nextPageLink) throws RestException, IOException {
                return listCredentialsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlCredential>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of credentials from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlCredential>> listCredentialsNextAsync(final String nextPageLink, final ServiceCall<List<USqlCredential>> serviceCall, final ListOperationCallback<USqlCredential> serviceCallback) {
        return AzureServiceCall.create(
            listCredentialsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<USqlCredential>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlCredential>>> call(String nextPageLink) {
                    return listCredentialsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of credentials from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;USqlCredential&gt; object
     */
    public Observable<ServiceResponse<Page<USqlCredential>>> listCredentialsNextAsync(final String nextPageLink) {
        return listCredentialsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<USqlCredential>>, Observable<ServiceResponse<Page<USqlCredential>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlCredential>>> call(ServiceResponse<Page<USqlCredential>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listCredentialsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of credentials from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlCredential>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;USqlCredential&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlCredential>>> listCredentialsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listCredentialsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlCredential>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlCredential>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlCredential>> result = listCredentialsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlCredential>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlCredential>> listCredentialsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlCredential>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlCredential>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of procedures from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlProcedure&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlProcedure>> listProceduresNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlProcedure>> response = listProceduresNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<USqlProcedure> pagedList = new PagedList<USqlProcedure>(response.getBody()) {
            @Override
            public Page<USqlProcedure> nextPage(String nextPageLink) throws RestException, IOException {
                return listProceduresNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlProcedure>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of procedures from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlProcedure>> listProceduresNextAsync(final String nextPageLink, final ServiceCall<List<USqlProcedure>> serviceCall, final ListOperationCallback<USqlProcedure> serviceCallback) {
        return AzureServiceCall.create(
            listProceduresNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<USqlProcedure>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlProcedure>>> call(String nextPageLink) {
                    return listProceduresNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of procedures from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;USqlProcedure&gt; object
     */
    public Observable<ServiceResponse<Page<USqlProcedure>>> listProceduresNextAsync(final String nextPageLink) {
        return listProceduresNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<USqlProcedure>>, Observable<ServiceResponse<Page<USqlProcedure>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlProcedure>>> call(ServiceResponse<Page<USqlProcedure>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listProceduresNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of procedures from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlProcedure>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;USqlProcedure&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlProcedure>>> listProceduresNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listProceduresNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlProcedure>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlProcedure>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlProcedure>> result = listProceduresNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlProcedure>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlProcedure>> listProceduresNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlProcedure>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlProcedure>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of tables from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlTable&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlTable>> listTablesNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlTable>> response = listTablesNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<USqlTable> pagedList = new PagedList<USqlTable>(response.getBody()) {
            @Override
            public Page<USqlTable> nextPage(String nextPageLink) throws RestException, IOException {
                return listTablesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlTable>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of tables from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlTable>> listTablesNextAsync(final String nextPageLink, final ServiceCall<List<USqlTable>> serviceCall, final ListOperationCallback<USqlTable> serviceCallback) {
        return AzureServiceCall.create(
            listTablesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<USqlTable>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTable>>> call(String nextPageLink) {
                    return listTablesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of tables from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;USqlTable&gt; object
     */
    public Observable<ServiceResponse<Page<USqlTable>>> listTablesNextAsync(final String nextPageLink) {
        return listTablesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<USqlTable>>, Observable<ServiceResponse<Page<USqlTable>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTable>>> call(ServiceResponse<Page<USqlTable>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTablesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of tables from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlTable>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;USqlTable&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlTable>>> listTablesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listTablesNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlTable>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTable>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlTable>> result = listTablesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlTable>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlTable>> listTablesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlTable>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlTable>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of table types from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlTableType&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlTableType>> listTableTypesNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlTableType>> response = listTableTypesNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<USqlTableType> pagedList = new PagedList<USqlTableType>(response.getBody()) {
            @Override
            public Page<USqlTableType> nextPage(String nextPageLink) throws RestException, IOException {
                return listTableTypesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlTableType>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of table types from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlTableType>> listTableTypesNextAsync(final String nextPageLink, final ServiceCall<List<USqlTableType>> serviceCall, final ListOperationCallback<USqlTableType> serviceCallback) {
        return AzureServiceCall.create(
            listTableTypesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<USqlTableType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableType>>> call(String nextPageLink) {
                    return listTableTypesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of table types from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;USqlTableType&gt; object
     */
    public Observable<ServiceResponse<Page<USqlTableType>>> listTableTypesNextAsync(final String nextPageLink) {
        return listTableTypesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<USqlTableType>>, Observable<ServiceResponse<Page<USqlTableType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableType>>> call(ServiceResponse<Page<USqlTableType>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTableTypesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of table types from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlTableType>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;USqlTableType&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlTableType>>> listTableTypesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listTableTypesNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlTableType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableType>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlTableType>> result = listTableTypesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlTableType>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlTableType>> listTableTypesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlTableType>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlTableType>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of views from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlView&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlView>> listViewsNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlView>> response = listViewsNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<USqlView> pagedList = new PagedList<USqlView>(response.getBody()) {
            @Override
            public Page<USqlView> nextPage(String nextPageLink) throws RestException, IOException {
                return listViewsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlView>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of views from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlView>> listViewsNextAsync(final String nextPageLink, final ServiceCall<List<USqlView>> serviceCall, final ListOperationCallback<USqlView> serviceCallback) {
        return AzureServiceCall.create(
            listViewsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<USqlView>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlView>>> call(String nextPageLink) {
                    return listViewsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of views from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;USqlView&gt; object
     */
    public Observable<ServiceResponse<Page<USqlView>>> listViewsNextAsync(final String nextPageLink) {
        return listViewsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<USqlView>>, Observable<ServiceResponse<Page<USqlView>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlView>>> call(ServiceResponse<Page<USqlView>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listViewsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of views from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlView>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;USqlView&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlView>>> listViewsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listViewsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlView>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlView>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlView>> result = listViewsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlView>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlView>> listViewsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlView>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlView>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of table statistics from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlTableStatistics&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlTableStatistics>> listTableStatisticsNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlTableStatistics>> response = listTableStatisticsNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<USqlTableStatistics> pagedList = new PagedList<USqlTableStatistics>(response.getBody()) {
            @Override
            public Page<USqlTableStatistics> nextPage(String nextPageLink) throws RestException, IOException {
                return listTableStatisticsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlTableStatistics>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of table statistics from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlTableStatistics>> listTableStatisticsNextAsync(final String nextPageLink, final ServiceCall<List<USqlTableStatistics>> serviceCall, final ListOperationCallback<USqlTableStatistics> serviceCallback) {
        return AzureServiceCall.create(
            listTableStatisticsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<USqlTableStatistics>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableStatistics>>> call(String nextPageLink) {
                    return listTableStatisticsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of table statistics from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;USqlTableStatistics&gt; object
     */
    public Observable<ServiceResponse<Page<USqlTableStatistics>>> listTableStatisticsNextAsync(final String nextPageLink) {
        return listTableStatisticsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<USqlTableStatistics>>, Observable<ServiceResponse<Page<USqlTableStatistics>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableStatistics>>> call(ServiceResponse<Page<USqlTableStatistics>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTableStatisticsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of table statistics from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlTableStatistics>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;USqlTableStatistics&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlTableStatistics>>> listTableStatisticsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listTableStatisticsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlTableStatistics>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableStatistics>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlTableStatistics>> result = listTableStatisticsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlTableStatistics>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlTableStatistics>> listTableStatisticsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlTableStatistics>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlTableStatistics>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of table partitions from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlTablePartition&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlTablePartition>> listTablePartitionsNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlTablePartition>> response = listTablePartitionsNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<USqlTablePartition> pagedList = new PagedList<USqlTablePartition>(response.getBody()) {
            @Override
            public Page<USqlTablePartition> nextPage(String nextPageLink) throws RestException, IOException {
                return listTablePartitionsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlTablePartition>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of table partitions from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlTablePartition>> listTablePartitionsNextAsync(final String nextPageLink, final ServiceCall<List<USqlTablePartition>> serviceCall, final ListOperationCallback<USqlTablePartition> serviceCallback) {
        return AzureServiceCall.create(
            listTablePartitionsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<USqlTablePartition>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTablePartition>>> call(String nextPageLink) {
                    return listTablePartitionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of table partitions from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;USqlTablePartition&gt; object
     */
    public Observable<ServiceResponse<Page<USqlTablePartition>>> listTablePartitionsNextAsync(final String nextPageLink) {
        return listTablePartitionsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<USqlTablePartition>>, Observable<ServiceResponse<Page<USqlTablePartition>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTablePartition>>> call(ServiceResponse<Page<USqlTablePartition>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTablePartitionsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of table partitions from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlTablePartition>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;USqlTablePartition&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlTablePartition>>> listTablePartitionsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listTablePartitionsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlTablePartition>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTablePartition>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlTablePartition>> result = listTablePartitionsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlTablePartition>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlTablePartition>> listTablePartitionsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlTablePartition>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlTablePartition>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of types within the specified database and schema from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlType&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlType>> listTypesNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlType>> response = listTypesNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<USqlType> pagedList = new PagedList<USqlType>(response.getBody()) {
            @Override
            public Page<USqlType> nextPage(String nextPageLink) throws RestException, IOException {
                return listTypesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlType>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of types within the specified database and schema from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlType>> listTypesNextAsync(final String nextPageLink, final ServiceCall<List<USqlType>> serviceCall, final ListOperationCallback<USqlType> serviceCallback) {
        return AzureServiceCall.create(
            listTypesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<USqlType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlType>>> call(String nextPageLink) {
                    return listTypesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of types within the specified database and schema from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;USqlType&gt; object
     */
    public Observable<ServiceResponse<Page<USqlType>>> listTypesNextAsync(final String nextPageLink) {
        return listTypesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<USqlType>>, Observable<ServiceResponse<Page<USqlType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlType>>> call(ServiceResponse<Page<USqlType>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTypesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of types within the specified database and schema from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlType>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;USqlType&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlType>>> listTypesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listTypesNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlType>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlType>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlType>> result = listTypesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlType>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlType>> listTypesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlType>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlType>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of table valued functions from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlTableValuedFunction&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlTableValuedFunction>> listTableValuedFunctionsNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlTableValuedFunction>> response = listTableValuedFunctionsNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<USqlTableValuedFunction> pagedList = new PagedList<USqlTableValuedFunction>(response.getBody()) {
            @Override
            public Page<USqlTableValuedFunction> nextPage(String nextPageLink) throws RestException, IOException {
                return listTableValuedFunctionsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlTableValuedFunction>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of table valued functions from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlTableValuedFunction>> listTableValuedFunctionsNextAsync(final String nextPageLink, final ServiceCall<List<USqlTableValuedFunction>> serviceCall, final ListOperationCallback<USqlTableValuedFunction> serviceCallback) {
        return AzureServiceCall.create(
            listTableValuedFunctionsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<USqlTableValuedFunction>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableValuedFunction>>> call(String nextPageLink) {
                    return listTableValuedFunctionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of table valued functions from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;USqlTableValuedFunction&gt; object
     */
    public Observable<ServiceResponse<Page<USqlTableValuedFunction>>> listTableValuedFunctionsNextAsync(final String nextPageLink) {
        return listTableValuedFunctionsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<USqlTableValuedFunction>>, Observable<ServiceResponse<Page<USqlTableValuedFunction>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableValuedFunction>>> call(ServiceResponse<Page<USqlTableValuedFunction>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listTableValuedFunctionsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of table valued functions from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlTableValuedFunction>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;USqlTableValuedFunction&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlTableValuedFunction>>> listTableValuedFunctionsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listTableValuedFunctionsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlTableValuedFunction>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlTableValuedFunction>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlTableValuedFunction>> result = listTableValuedFunctionsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlTableValuedFunction>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlTableValuedFunction>> listTableValuedFunctionsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlTableValuedFunction>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlTableValuedFunction>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of assemblies from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlAssemblyClr&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlAssemblyClr>> listAssembliesNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlAssemblyClr>> response = listAssembliesNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<USqlAssemblyClr> pagedList = new PagedList<USqlAssemblyClr>(response.getBody()) {
            @Override
            public Page<USqlAssemblyClr> nextPage(String nextPageLink) throws RestException, IOException {
                return listAssembliesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlAssemblyClr>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of assemblies from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlAssemblyClr>> listAssembliesNextAsync(final String nextPageLink, final ServiceCall<List<USqlAssemblyClr>> serviceCall, final ListOperationCallback<USqlAssemblyClr> serviceCallback) {
        return AzureServiceCall.create(
            listAssembliesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<USqlAssemblyClr>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlAssemblyClr>>> call(String nextPageLink) {
                    return listAssembliesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of assemblies from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;USqlAssemblyClr&gt; object
     */
    public Observable<ServiceResponse<Page<USqlAssemblyClr>>> listAssembliesNextAsync(final String nextPageLink) {
        return listAssembliesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<USqlAssemblyClr>>, Observable<ServiceResponse<Page<USqlAssemblyClr>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlAssemblyClr>>> call(ServiceResponse<Page<USqlAssemblyClr>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listAssembliesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of assemblies from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlAssemblyClr>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;USqlAssemblyClr&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlAssemblyClr>>> listAssembliesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listAssembliesNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlAssemblyClr>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlAssemblyClr>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlAssemblyClr>> result = listAssembliesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlAssemblyClr>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlAssemblyClr>> listAssembliesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlAssemblyClr>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlAssemblyClr>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of schemas from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlSchema&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlSchema>> listSchemasNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlSchema>> response = listSchemasNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<USqlSchema> pagedList = new PagedList<USqlSchema>(response.getBody()) {
            @Override
            public Page<USqlSchema> nextPage(String nextPageLink) throws RestException, IOException {
                return listSchemasNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlSchema>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of schemas from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlSchema>> listSchemasNextAsync(final String nextPageLink, final ServiceCall<List<USqlSchema>> serviceCall, final ListOperationCallback<USqlSchema> serviceCallback) {
        return AzureServiceCall.create(
            listSchemasNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<USqlSchema>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlSchema>>> call(String nextPageLink) {
                    return listSchemasNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of schemas from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;USqlSchema&gt; object
     */
    public Observable<ServiceResponse<Page<USqlSchema>>> listSchemasNextAsync(final String nextPageLink) {
        return listSchemasNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<USqlSchema>>, Observable<ServiceResponse<Page<USqlSchema>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlSchema>>> call(ServiceResponse<Page<USqlSchema>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listSchemasNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of schemas from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlSchema>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;USqlSchema&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlSchema>>> listSchemasNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listSchemasNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlSchema>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlSchema>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlSchema>> result = listSchemasNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlSchema>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlSchema>> listSchemasNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlSchema>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlSchema>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves the list of databases from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;USqlDatabase&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<USqlDatabase>> listDatabasesNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<USqlDatabase>> response = listDatabasesNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<USqlDatabase> pagedList = new PagedList<USqlDatabase>(response.getBody()) {
            @Override
            public Page<USqlDatabase> nextPage(String nextPageLink) throws RestException, IOException {
                return listDatabasesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<USqlDatabase>>(pagedList, response.getResponse());
    }

    /**
     * Retrieves the list of databases from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<USqlDatabase>> listDatabasesNextAsync(final String nextPageLink, final ServiceCall<List<USqlDatabase>> serviceCall, final ListOperationCallback<USqlDatabase> serviceCallback) {
        return AzureServiceCall.create(
            listDatabasesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<USqlDatabase>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlDatabase>>> call(String nextPageLink) {
                    return listDatabasesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Retrieves the list of databases from the Data Lake Analytics catalog.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;USqlDatabase&gt; object
     */
    public Observable<ServiceResponse<Page<USqlDatabase>>> listDatabasesNextAsync(final String nextPageLink) {
        return listDatabasesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<USqlDatabase>>, Observable<ServiceResponse<Page<USqlDatabase>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlDatabase>>> call(ServiceResponse<Page<USqlDatabase>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listDatabasesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Retrieves the list of databases from the Data Lake Analytics catalog.
     *
    ServiceResponse<PageImpl<USqlDatabase>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;USqlDatabase&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<USqlDatabase>>> listDatabasesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listDatabasesNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<USqlDatabase>>>>() {
                @Override
                public Observable<ServiceResponse<Page<USqlDatabase>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<USqlDatabase>> result = listDatabasesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<USqlDatabase>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<USqlDatabase>> listDatabasesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<USqlDatabase>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<USqlDatabase>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
