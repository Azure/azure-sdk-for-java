/**
 * Code generated by Microsoft (R) AutoRest Code Generator 0.17.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.azure.keyvault;

import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureClient;
import com.microsoft.azure.AzureServiceClient;
import com.microsoft.azure.AzureServiceResponseBuilder;
import com.microsoft.azure.keyvault.models.BackupKeyResult;
import com.microsoft.azure.keyvault.models.CertificateAttributes;
import com.microsoft.azure.keyvault.models.CertificateBundle;
import com.microsoft.azure.keyvault.models.CertificateCreateParameters;
import com.microsoft.azure.keyvault.models.CertificateImportParameters;
import com.microsoft.azure.keyvault.models.CertificateIssuerItem;
import com.microsoft.azure.keyvault.models.CertificateItem;
import com.microsoft.azure.keyvault.models.CertificateMergeParameters;
import com.microsoft.azure.keyvault.models.CertificateOperation;
import com.microsoft.azure.keyvault.models.CertificatePolicy;
import com.microsoft.azure.keyvault.models.CertificateUpdateParameters;
import com.microsoft.azure.keyvault.models.Contacts;
import com.microsoft.azure.keyvault.models.IssuerBundle;
import com.microsoft.azure.keyvault.models.JsonWebKey;
import com.microsoft.azure.keyvault.models.KeyAttributes;
import com.microsoft.azure.keyvault.models.KeyBundle;
import com.microsoft.azure.keyvault.models.KeyCreateParameters;
import com.microsoft.azure.keyvault.models.KeyImportParameters;
import com.microsoft.azure.keyvault.models.KeyItem;
import com.microsoft.azure.keyvault.models.KeyOperationResult;
import com.microsoft.azure.keyvault.models.KeyOperationsParameters;
import com.microsoft.azure.keyvault.models.KeyRestoreParameters;
import com.microsoft.azure.keyvault.models.KeySignParameters;
import com.microsoft.azure.keyvault.models.KeyUpdateParameters;
import com.microsoft.azure.keyvault.models.KeyVaultErrorException;
import com.microsoft.azure.keyvault.models.KeyVerifyParameters;
import com.microsoft.azure.keyvault.models.KeyVerifyResult;
import com.microsoft.azure.keyvault.models.PageImpl;
import com.microsoft.azure.keyvault.models.SecretAttributes;
import com.microsoft.azure.keyvault.models.SecretBundle;
import com.microsoft.azure.keyvault.models.SecretItem;
import com.microsoft.azure.keyvault.models.SecretSetParameters;
import com.microsoft.azure.keyvault.models.SecretUpdateParameters;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.azure.RestClient;
import com.microsoft.rest.credentials.ServiceClientCredentials;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseCallback;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import okhttp3.ResponseBody;
import retrofit2.Call;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;

/**
 * Initializes a new instance of the KeyVaultClientImpl class.
 */
final class KeyVaultClientImpl extends AzureServiceClient {
    /** The Retrofit service to perform REST calls. */
    private KeyVaultClientService service;
    /** the {@link AzureClient} used for long running operations. */
    private AzureClient azureClient;

    /**
     * Gets the {@link AzureClient} used for long running operations.
     * @return the azure client;
     */
    public AzureClient getAzureClient() {
        return this.azureClient;
    }

    /** Client Api Version. */
    private String apiVersion;

    /**
     * Gets Client Api Version.
     *
     * @return the apiVersion value.
     */
    public String apiVersion() {
        return this.apiVersion;
    }

    /** Gets or sets the preferred language for the response. */
    private String acceptLanguage;

    /**
     * Gets Gets or sets the preferred language for the response.
     *
     * @return the acceptLanguage value.
     */
    public String acceptLanguage() {
        return this.acceptLanguage;
    }

    /**
     * Sets Gets or sets the preferred language for the response.
     *
     * @param acceptLanguage the acceptLanguage value.
     * @return the service client itself
     */
    public KeyVaultClientImpl withAcceptLanguage(String acceptLanguage) {
        this.acceptLanguage = acceptLanguage;
        return this;
    }

    /** Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30. */
    private int longRunningOperationRetryTimeout;

    /**
     * Gets Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @return the longRunningOperationRetryTimeout value.
     */
    public int longRunningOperationRetryTimeout() {
        return this.longRunningOperationRetryTimeout;
    }

    /**
     * Sets Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param longRunningOperationRetryTimeout the longRunningOperationRetryTimeout value.
     * @return the service client itself
     */
    public KeyVaultClientImpl withLongRunningOperationRetryTimeout(int longRunningOperationRetryTimeout) {
        this.longRunningOperationRetryTimeout = longRunningOperationRetryTimeout;
        return this;
    }

    /** When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true. */
    private boolean generateClientRequestId;

    /**
     * Gets When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @return the generateClientRequestId value.
     */
    public boolean generateClientRequestId() {
        return this.generateClientRequestId;
    }

    /**
     * Sets When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @param generateClientRequestId the generateClientRequestId value.
     * @return the service client itself
     */
    public KeyVaultClientImpl withGenerateClientRequestId(boolean generateClientRequestId) {
        this.generateClientRequestId = generateClientRequestId;
        return this;
    }

    /**
     * Initializes an instance of KeyVaultClient client.
     *
     * @param credentials the management credentials for Azure
     */
    KeyVaultClientImpl(ServiceClientCredentials credentials) {
        this("https://{vaultBaseUrl}", credentials);
    }

    /**
     * Initializes an instance of KeyVaultClient client.
     *
     * @param baseUrl the base URL of the host
     * @param credentials the management credentials for Azure
     */
    private KeyVaultClientImpl(String baseUrl, ServiceClientCredentials credentials) {
        this(new RestClient.Builder()
                .withBaseUrl(baseUrl)
                .withCredentials(credentials)
                .build());
    }

    /**
     * Initializes an instance of KeyVaultClient client.
     *
     * @param restClient the REST client to connect to Azure.
     */
    KeyVaultClientImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    protected void initialize() {
        this.apiVersion = "2015-06-01";
        this.acceptLanguage = "en-US";
        this.longRunningOperationRetryTimeout = 30;
        this.generateClientRequestId = true;
        this.azureClient = new AzureClient(this);
        initializeService();
    }

    /**
     * Gets the User-Agent header for the client.
     *
     * @return the user agent string.
     */
    @Override
    public String userAgent() {
        return String.format("Azure-SDK-For-Java/%s (%s)",
                getClass().getPackage().getImplementationVersion(),
                "KeyVaultClient, 2015-06-01");
    }

    private void initializeService() {
        service = restClient().retrofit().create(KeyVaultClientService.class);
    }

    /**
     * The interface defining all the services for KeyVaultClient to be
     * used by Retrofit to perform actually REST calls.
     */
    interface KeyVaultClientService {
        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/create")
        Call<ResponseBody> createKey(@Path("key-name") String keyName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyCreateParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("keys/{key-name}")
        Call<ResponseBody> importKey(@Path("key-name") String keyName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyImportParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "keys/{key-name}", method = "DELETE", hasBody = true)
        Call<ResponseBody> deleteKey(@Path("key-name") String keyName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("keys/{key-name}/{key-version}")
        Call<ResponseBody> updateKey(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyUpdateParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("keys/{key-name}/{key-version}")
        Call<ResponseBody> getKey(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("keys/{key-name}/versions")
        Call<ResponseBody> getKeyVersions(@Path("key-name") String keyName, @Query("maxresults") Integer maxresults, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("keys")
        Call<ResponseBody> getKeys(@Query("maxresults") Integer maxresults, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/backup")
        Call<ResponseBody> backupKey(@Path("key-name") String keyName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/restore")
        Call<ResponseBody> restoreKey(@Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyRestoreParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/{key-version}/encrypt")
        Call<ResponseBody> encrypt(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyOperationsParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/{key-version}/decrypt")
        Call<ResponseBody> decrypt(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyOperationsParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/{key-version}/sign")
        Call<ResponseBody> sign(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeySignParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/{key-version}/verify")
        Call<ResponseBody> verify(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyVerifyParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/{key-version}/wrapkey")
        Call<ResponseBody> wrapKey(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyOperationsParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/{key-version}/unwrapkey")
        Call<ResponseBody> unwrapKey(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyOperationsParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("secrets/{secret-name}")
        Call<ResponseBody> setSecret(@Path("secret-name") String secretName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body SecretSetParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "secrets/{secret-name}", method = "DELETE", hasBody = true)
        Call<ResponseBody> deleteSecret(@Path("secret-name") String secretName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("secrets/{secret-name}/{secret-version}")
        Call<ResponseBody> updateSecret(@Path("secret-name") String secretName, @Path("secret-version") String secretVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body SecretUpdateParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("secrets/{secret-name}/{secret-version}")
        Call<ResponseBody> getSecret(@Path("secret-name") String secretName, @Path("secret-version") String secretVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("secrets")
        Call<ResponseBody> getSecrets(@Query("maxresults") Integer maxresults, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("secrets/{secret-name}/versions")
        Call<ResponseBody> getSecretVersions(@Path("secret-name") String secretName, @Query("maxresults") Integer maxresults, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates")
        Call<ResponseBody> getCertificates(@Query("maxresults") Integer maxresults, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "certificates/{certificate-name}", method = "DELETE", hasBody = true)
        Call<ResponseBody> deleteCertificate(@Path("certificate-name") String certificateName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("certificates/contacts")
        Call<ResponseBody> setCertificateContacts(@Body Contacts contacts, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates/contacts")
        Call<ResponseBody> getCertificateContacts(@Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "certificates/contacts", method = "DELETE", hasBody = true)
        Call<ResponseBody> deleteCertificateContacts(@Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates/issuers")
        Call<ResponseBody> getCertificateIssuers(@Query("maxresults") Integer maxresults, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("certificates/issuers/{issuer-name}")
        Call<ResponseBody> setCertificateIssuer(@Path("issuer-name") String issuerName, @Body IssuerBundle issuer, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("certificates/issuers/{issuer-name}")
        Call<ResponseBody> updateCertificateIssuer(@Path("issuer-name") String issuerName, @Body IssuerBundle issuer, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates/issuers/{issuer-name}")
        Call<ResponseBody> getCertificateIssuer(@Path("issuer-name") String issuerName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "certificates/issuers/{issuer-name}", method = "DELETE", hasBody = true)
        Call<ResponseBody> deleteCertificateIssuer(@Path("issuer-name") String issuerName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("certificates/{certificate-name}/create")
        Call<ResponseBody> createCertificate(@Path("certificate-name") String certificateName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CertificateCreateParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("certificates/{certificate-name}/import")
        Call<ResponseBody> importCertificate(@Path("certificate-name") String certificateName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CertificateImportParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates/{certificate-name}/versions")
        Call<ResponseBody> getCertificateVersions(@Path("certificate-name") String certificateName, @Query("maxresults") Integer maxresults, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates/{certificate-name}/policy")
        Call<ResponseBody> getCertificatePolicy(@Path("certificate-name") String certificateName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("certificates/{certificate-name}/policy")
        Call<ResponseBody> updateCertificatePolicy(@Path("certificate-name") String certificateName, @Body CertificatePolicy certificatePolicy, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("certificates/{certificate-name}/{certificate-version}")
        Call<ResponseBody> updateCertificate(@Path("certificate-name") String certificateName, @Path("certificate-version") String certificateVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CertificateUpdateParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates/{certificate-name}/{certificate-version}")
        Call<ResponseBody> getCertificate(@Path("certificate-name") String certificateName, @Path("certificate-version") String certificateVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("certificates/{certificate-name}/pending")
        Call<ResponseBody> updateCertificateOperation(@Path("certificate-name") String certificateName, @Body CertificateOperation certificateOperation, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates/{certificate-name}/pending")
        Call<ResponseBody> getCertificateOperation(@Path("certificate-name") String certificateName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "certificates/{certificate-name}/pending", method = "DELETE", hasBody = true)
        Call<ResponseBody> deleteCertificateOperation(@Path("certificate-name") String certificateName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("certificates/{certificate-name}/pending/merge")
        Call<ResponseBody> mergeCertificate(@Path("certificate-name") String certificateName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CertificateMergeParameters parameters, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET
        Call<ResponseBody> getKeyVersionsNext(@Url String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET
        Call<ResponseBody> getKeysNext(@Url String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET
        Call<ResponseBody> getSecretsNext(@Url String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET
        Call<ResponseBody> getSecretVersionsNext(@Url String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET
        Call<ResponseBody> getCertificatesNext(@Url String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET
        Call<ResponseBody> getCertificateIssuersNext(@Url String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET
        Call<ResponseBody> getCertificateVersionsNext(@Url String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Creates a new, named, key in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param kty The type of key to create. Valid key types, see JsonWebKeyType. Possible values include: 'EC', 'RSA', 'RSA-HSM', 'oct'
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundle> createKey(String vaultBaseUrl, String keyName, String kty) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (kty == null) {
            throw new IllegalArgumentException("Parameter kty is required and cannot be null.");
        }
        final Integer keySize = null;
        final List<String> keyOps = null;
        final KeyAttributes keyAttributes = null;
        final Map<String, String> tags = null;
        KeyCreateParameters parameters = new KeyCreateParameters();
        parameters.withKty(kty);
        parameters.withKeySize(null);
        parameters.withKeyOps(null);
        parameters.withKeyAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return createKeyDelegate(call.execute());
    }

    /**
     * Creates a new, named, key in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param kty The type of key to create. Valid key types, see JsonWebKeyType. Possible values include: 'EC', 'RSA', 'RSA-HSM', 'oct'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<KeyBundle> createKeyAsync(String vaultBaseUrl, String keyName, String kty, final ServiceCallback<KeyBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (kty == null) {
            throw new IllegalArgumentException("Parameter kty is required and cannot be null.");
        }
        final Integer keySize = null;
        final List<String> keyOps = null;
        final KeyAttributes keyAttributes = null;
        final Map<String, String> tags = null;
        KeyCreateParameters parameters = new KeyCreateParameters();
        parameters.withKty(kty);
        parameters.withKeySize(null);
        parameters.withKeyOps(null);
        parameters.withKeyAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<KeyBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<KeyBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<KeyBundle> clientResponse = createKeyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Creates a new, named, key in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param kty The type of key to create. Valid key types, see JsonWebKeyType. Possible values include: 'EC', 'RSA', 'RSA-HSM', 'oct'
     * @param keySize The key size in bytes. e.g. 1024 or 2048.
     * @param keyOps the List&lt;String&gt; value
     * @param keyAttributes the KeyAttributes value
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundle> createKey(String vaultBaseUrl, String keyName, String kty, Integer keySize, List<String> keyOps, KeyAttributes keyAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (kty == null) {
            throw new IllegalArgumentException("Parameter kty is required and cannot be null.");
        }
        Validator.validate(keyOps);
        Validator.validate(keyAttributes);
        Validator.validate(tags);
        KeyCreateParameters parameters = new KeyCreateParameters();
        parameters.withKty(kty);
        parameters.withKeySize(keySize);
        parameters.withKeyOps(keyOps);
        parameters.withKeyAttributes(keyAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return createKeyDelegate(call.execute());
    }

    /**
     * Creates a new, named, key in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param kty The type of key to create. Valid key types, see JsonWebKeyType. Possible values include: 'EC', 'RSA', 'RSA-HSM', 'oct'
     * @param keySize The key size in bytes. e.g. 1024 or 2048.
     * @param keyOps the List&lt;String&gt; value
     * @param keyAttributes the KeyAttributes value
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<KeyBundle> createKeyAsync(String vaultBaseUrl, String keyName, String kty, Integer keySize, List<String> keyOps, KeyAttributes keyAttributes, Map<String, String> tags, final ServiceCallback<KeyBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (kty == null) {
            throw new IllegalArgumentException("Parameter kty is required and cannot be null.");
        }
        Validator.validate(keyOps);
        Validator.validate(keyAttributes);
        Validator.validate(tags);
        KeyCreateParameters parameters = new KeyCreateParameters();
        parameters.withKty(kty);
        parameters.withKeySize(keySize);
        parameters.withKeyOps(keyOps);
        parameters.withKeyAttributes(keyAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<KeyBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<KeyBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<KeyBundle> clientResponse = createKeyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyBundle> createKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<KeyBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Imports a key into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param key The Json web key
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundle> importKey(String vaultBaseUrl, String keyName, JsonWebKey key) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (key == null) {
            throw new IllegalArgumentException("Parameter key is required and cannot be null.");
        }
        Validator.validate(key);
        final Boolean hsm = null;
        final KeyAttributes keyAttributes = null;
        final Map<String, String> tags = null;
        KeyImportParameters parameters = new KeyImportParameters();
        parameters.withHsm(null);
        parameters.withKey(key);
        parameters.withKeyAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return importKeyDelegate(call.execute());
    }

    /**
     * Imports a key into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param key The Json web key
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<KeyBundle> importKeyAsync(String vaultBaseUrl, String keyName, JsonWebKey key, final ServiceCallback<KeyBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (key == null) {
            throw new IllegalArgumentException("Parameter key is required and cannot be null.");
        }
        Validator.validate(key);
        final Boolean hsm = null;
        final KeyAttributes keyAttributes = null;
        final Map<String, String> tags = null;
        KeyImportParameters parameters = new KeyImportParameters();
        parameters.withHsm(null);
        parameters.withKey(key);
        parameters.withKeyAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<KeyBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<KeyBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<KeyBundle> clientResponse = importKeyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Imports a key into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param key The Json web key
     * @param hsm Whether to import as a hardware key (HSM) or software key
     * @param keyAttributes The key management attributes
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundle> importKey(String vaultBaseUrl, String keyName, JsonWebKey key, Boolean hsm, KeyAttributes keyAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (key == null) {
            throw new IllegalArgumentException("Parameter key is required and cannot be null.");
        }
        Validator.validate(key);
        Validator.validate(keyAttributes);
        Validator.validate(tags);
        KeyImportParameters parameters = new KeyImportParameters();
        parameters.withHsm(hsm);
        parameters.withKey(key);
        parameters.withKeyAttributes(keyAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return importKeyDelegate(call.execute());
    }

    /**
     * Imports a key into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param key The Json web key
     * @param hsm Whether to import as a hardware key (HSM) or software key
     * @param keyAttributes The key management attributes
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<KeyBundle> importKeyAsync(String vaultBaseUrl, String keyName, JsonWebKey key, Boolean hsm, KeyAttributes keyAttributes, Map<String, String> tags, final ServiceCallback<KeyBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (key == null) {
            throw new IllegalArgumentException("Parameter key is required and cannot be null.");
        }
        Validator.validate(key);
        Validator.validate(keyAttributes);
        Validator.validate(tags);
        KeyImportParameters parameters = new KeyImportParameters();
        parameters.withHsm(hsm);
        parameters.withKey(key);
        parameters.withKeyAttributes(keyAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<KeyBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<KeyBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<KeyBundle> clientResponse = importKeyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyBundle> importKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<KeyBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Deletes the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundle> deleteKey(String vaultBaseUrl, String keyName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteKey(keyName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return deleteKeyDelegate(call.execute());
    }

    /**
     * Deletes the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<KeyBundle> deleteKeyAsync(String vaultBaseUrl, String keyName, final ServiceCallback<KeyBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteKey(keyName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<KeyBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<KeyBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<KeyBundle> clientResponse = deleteKeyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyBundle> deleteKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<KeyBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Updates the Key Attributes associated with the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundle> updateKey(String vaultBaseUrl, String keyName, String keyVersion) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final List<String> keyOps = null;
        final KeyAttributes keyAttributes = null;
        final Map<String, String> tags = null;
        KeyUpdateParameters parameters = new KeyUpdateParameters();
        parameters.withKeyOps(null);
        parameters.withKeyAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return updateKeyDelegate(call.execute());
    }

    /**
     * Updates the Key Attributes associated with the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<KeyBundle> updateKeyAsync(String vaultBaseUrl, String keyName, String keyVersion, final ServiceCallback<KeyBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final List<String> keyOps = null;
        final KeyAttributes keyAttributes = null;
        final Map<String, String> tags = null;
        KeyUpdateParameters parameters = new KeyUpdateParameters();
        parameters.withKeyOps(null);
        parameters.withKeyAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<KeyBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<KeyBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<KeyBundle> clientResponse = updateKeyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Updates the Key Attributes associated with the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param keyOps Json web key operations. For more information on possible key operations, see JsonWebKeyOperation.
     * @param keyAttributes the KeyAttributes value
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundle> updateKey(String vaultBaseUrl, String keyName, String keyVersion, List<String> keyOps, KeyAttributes keyAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(keyOps);
        Validator.validate(keyAttributes);
        Validator.validate(tags);
        KeyUpdateParameters parameters = new KeyUpdateParameters();
        parameters.withKeyOps(keyOps);
        parameters.withKeyAttributes(keyAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return updateKeyDelegate(call.execute());
    }

    /**
     * Updates the Key Attributes associated with the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param keyOps Json web key operations. For more information on possible key operations, see JsonWebKeyOperation.
     * @param keyAttributes the KeyAttributes value
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<KeyBundle> updateKeyAsync(String vaultBaseUrl, String keyName, String keyVersion, List<String> keyOps, KeyAttributes keyAttributes, Map<String, String> tags, final ServiceCallback<KeyBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(keyOps);
        Validator.validate(keyAttributes);
        Validator.validate(tags);
        KeyUpdateParameters parameters = new KeyUpdateParameters();
        parameters.withKeyOps(keyOps);
        parameters.withKeyAttributes(keyAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<KeyBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<KeyBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<KeyBundle> clientResponse = updateKeyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyBundle> updateKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<KeyBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Retrieves the public portion of a key plus its attributes.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundle> getKey(String vaultBaseUrl, String keyName, String keyVersion) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return getKeyDelegate(call.execute());
    }

    /**
     * Retrieves the public portion of a key plus its attributes.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<KeyBundle> getKeyAsync(String vaultBaseUrl, String keyName, String keyVersion, final ServiceCallback<KeyBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<KeyBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<KeyBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<KeyBundle> clientResponse = getKeyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyBundle> getKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<KeyBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List the versions of the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;KeyItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<KeyItem>> getKeyVersions(final String vaultBaseUrl, final String keyName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeyVersions(keyName, maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        ServiceResponse<PageImpl<KeyItem>> response = getKeyVersionsDelegate(call.execute());
        PagedList<KeyItem> result = new PagedList<KeyItem>(response.getBody()) {
            @Override
            public Page<KeyItem> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getKeyVersionsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List the versions of the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<KeyItem>> getKeyVersionsAsync(final String vaultBaseUrl, final String keyName, final ListOperationCallback<KeyItem> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeyVersions(keyName, maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<List<KeyItem>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<KeyItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<KeyItem>> result = getKeyVersionsDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.load(result.getBody().getItems());
                        if (result.getBody().getNextPageLink() != null
                                && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                            getKeyVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                        } else {
                            serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                        }
                    }
                    serviceCall.success(new ServiceResponse<>(result.getBody().getItems(), response));
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * List the versions of the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param maxresults Maximum number of results to return.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;KeyItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<KeyItem>> getKeyVersions(final String vaultBaseUrl, final String keyName, final Integer maxresults) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeyVersions(keyName, maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        ServiceResponse<PageImpl<KeyItem>> response = getKeyVersionsDelegate(call.execute());
        PagedList<KeyItem> result = new PagedList<KeyItem>(response.getBody()) {
            @Override
            public Page<KeyItem> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getKeyVersionsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List the versions of the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param maxresults Maximum number of results to return.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<KeyItem>> getKeyVersionsAsync(final String vaultBaseUrl, final String keyName, final Integer maxresults, final ListOperationCallback<KeyItem> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeyVersions(keyName, maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<List<KeyItem>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<KeyItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<KeyItem>> result = getKeyVersionsDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.load(result.getBody().getItems());
                        if (result.getBody().getNextPageLink() != null
                                && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                            getKeyVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                        } else {
                            serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                        }
                    }
                    serviceCall.success(new ServiceResponse<>(result.getBody().getItems(), response));
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<KeyItem>> getKeyVersionsDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<KeyItem>, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<PageImpl<KeyItem>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List keys in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;KeyItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<KeyItem>> getKeys(final String vaultBaseUrl) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeys(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        ServiceResponse<PageImpl<KeyItem>> response = getKeysDelegate(call.execute());
        PagedList<KeyItem> result = new PagedList<KeyItem>(response.getBody()) {
            @Override
            public Page<KeyItem> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getKeysNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List keys in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<KeyItem>> getKeysAsync(final String vaultBaseUrl, final ListOperationCallback<KeyItem> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeys(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<List<KeyItem>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<KeyItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<KeyItem>> result = getKeysDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.load(result.getBody().getItems());
                        if (result.getBody().getNextPageLink() != null
                                && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                            getKeysNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                        } else {
                            serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                        }
                    }
                    serviceCall.success(new ServiceResponse<>(result.getBody().getItems(), response));
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * List keys in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of results to return.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;KeyItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<KeyItem>> getKeys(final String vaultBaseUrl, final Integer maxresults) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeys(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        ServiceResponse<PageImpl<KeyItem>> response = getKeysDelegate(call.execute());
        PagedList<KeyItem> result = new PagedList<KeyItem>(response.getBody()) {
            @Override
            public Page<KeyItem> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getKeysNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List keys in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of results to return.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<KeyItem>> getKeysAsync(final String vaultBaseUrl, final Integer maxresults, final ListOperationCallback<KeyItem> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeys(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<List<KeyItem>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<KeyItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<KeyItem>> result = getKeysDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.load(result.getBody().getItems());
                        if (result.getBody().getNextPageLink() != null
                                && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                            getKeysNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                        } else {
                            serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                        }
                    }
                    serviceCall.success(new ServiceResponse<>(result.getBody().getItems(), response));
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<KeyItem>> getKeysDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<KeyItem>, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<PageImpl<KeyItem>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Requests that a backup of the specified key be downloaded to the client.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the BackupKeyResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<BackupKeyResult> backupKey(String vaultBaseUrl, String keyName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.backupKey(keyName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return backupKeyDelegate(call.execute());
    }

    /**
     * Requests that a backup of the specified key be downloaded to the client.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<BackupKeyResult> backupKeyAsync(String vaultBaseUrl, String keyName, final ServiceCallback<BackupKeyResult> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.backupKey(keyName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<BackupKeyResult> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<BackupKeyResult>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<BackupKeyResult> clientResponse = backupKeyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<BackupKeyResult> backupKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupKeyResult, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<BackupKeyResult>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Restores the backup key in to a vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyBundleBackup the backup blob associated with a key bundle
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundle> restoreKey(String vaultBaseUrl, byte[] keyBundleBackup) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (keyBundleBackup == null) {
            throw new IllegalArgumentException("Parameter keyBundleBackup is required and cannot be null.");
        }
        KeyRestoreParameters parameters = new KeyRestoreParameters();
        parameters.withKeyBundleBackup(keyBundleBackup);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.restoreKey(this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return restoreKeyDelegate(call.execute());
    }

    /**
     * Restores the backup key in to a vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyBundleBackup the backup blob associated with a key bundle
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<KeyBundle> restoreKeyAsync(String vaultBaseUrl, byte[] keyBundleBackup, final ServiceCallback<KeyBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (keyBundleBackup == null) {
            throw new IllegalArgumentException("Parameter keyBundleBackup is required and cannot be null.");
        }
        KeyRestoreParameters parameters = new KeyRestoreParameters();
        parameters.withKeyBundleBackup(keyBundleBackup);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.restoreKey(this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<KeyBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<KeyBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<KeyBundle> clientResponse = restoreKeyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyBundle> restoreKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<KeyBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Encrypts an arbitrary sequence of bytes using an encryption key that is stored in Azure Key Vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the Base64Url value
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyOperationResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyOperationResult> encrypt(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, byte[] value) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.withAlgorithm(algorithm);
        parameters.withValue(value);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.encrypt(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return encryptDelegate(call.execute());
    }

    /**
     * Encrypts an arbitrary sequence of bytes using an encryption key that is stored in Azure Key Vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the Base64Url value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<KeyOperationResult> encryptAsync(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, byte[] value, final ServiceCallback<KeyOperationResult> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.withAlgorithm(algorithm);
        parameters.withValue(value);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.encrypt(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<KeyOperationResult> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<KeyOperationResult>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<KeyOperationResult> clientResponse = encryptDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyOperationResult> encryptDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyOperationResult, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<KeyOperationResult>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Decrypts a single block of encrypted data.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the Base64Url value
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyOperationResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyOperationResult> decrypt(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, byte[] value) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.withAlgorithm(algorithm);
        parameters.withValue(value);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.decrypt(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return decryptDelegate(call.execute());
    }

    /**
     * Decrypts a single block of encrypted data.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the Base64Url value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<KeyOperationResult> decryptAsync(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, byte[] value, final ServiceCallback<KeyOperationResult> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.withAlgorithm(algorithm);
        parameters.withValue(value);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.decrypt(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<KeyOperationResult> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<KeyOperationResult>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<KeyOperationResult> clientResponse = decryptDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyOperationResult> decryptDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyOperationResult, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<KeyOperationResult>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Creates a signature from a digest using the specified key in the vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm The signing/verification algorithm identifier. For more information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
     * @param value the Base64Url value
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyOperationResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyOperationResult> sign(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, byte[] value) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        KeySignParameters parameters = new KeySignParameters();
        parameters.withAlgorithm(algorithm);
        parameters.withValue(value);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.sign(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return signDelegate(call.execute());
    }

    /**
     * Creates a signature from a digest using the specified key in the vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm The signing/verification algorithm identifier. For more information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
     * @param value the Base64Url value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<KeyOperationResult> signAsync(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, byte[] value, final ServiceCallback<KeyOperationResult> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        KeySignParameters parameters = new KeySignParameters();
        parameters.withAlgorithm(algorithm);
        parameters.withValue(value);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.sign(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<KeyOperationResult> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<KeyOperationResult>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<KeyOperationResult> clientResponse = signDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyOperationResult> signDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyOperationResult, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<KeyOperationResult>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Verifies a signature using the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm The signing/verification algorithm. For more information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
     * @param digest The digest used for signing
     * @param signature The signature to be verified
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyVerifyResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyVerifyResult> verify(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, byte[] digest, byte[] signature) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (digest == null) {
            throw new IllegalArgumentException("Parameter digest is required and cannot be null.");
        }
        if (signature == null) {
            throw new IllegalArgumentException("Parameter signature is required and cannot be null.");
        }
        KeyVerifyParameters parameters = new KeyVerifyParameters();
        parameters.withAlgorithm(algorithm);
        parameters.withDigest(digest);
        parameters.withSignature(signature);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.verify(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return verifyDelegate(call.execute());
    }

    /**
     * Verifies a signature using the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm The signing/verification algorithm. For more information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
     * @param digest The digest used for signing
     * @param signature The signature to be verified
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<KeyVerifyResult> verifyAsync(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, byte[] digest, byte[] signature, final ServiceCallback<KeyVerifyResult> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (digest == null) {
            throw new IllegalArgumentException("Parameter digest is required and cannot be null.");
        }
        if (signature == null) {
            throw new IllegalArgumentException("Parameter signature is required and cannot be null.");
        }
        KeyVerifyParameters parameters = new KeyVerifyParameters();
        parameters.withAlgorithm(algorithm);
        parameters.withDigest(digest);
        parameters.withSignature(signature);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.verify(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<KeyVerifyResult> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<KeyVerifyResult>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<KeyVerifyResult> clientResponse = verifyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyVerifyResult> verifyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyVerifyResult, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<KeyVerifyResult>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Wraps a symmetric key using the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the Base64Url value
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyOperationResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyOperationResult> wrapKey(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, byte[] value) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.withAlgorithm(algorithm);
        parameters.withValue(value);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.wrapKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return wrapKeyDelegate(call.execute());
    }

    /**
     * Wraps a symmetric key using the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the Base64Url value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<KeyOperationResult> wrapKeyAsync(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, byte[] value, final ServiceCallback<KeyOperationResult> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.withAlgorithm(algorithm);
        parameters.withValue(value);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.wrapKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<KeyOperationResult> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<KeyOperationResult>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<KeyOperationResult> clientResponse = wrapKeyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyOperationResult> wrapKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyOperationResult, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<KeyOperationResult>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Unwraps a symmetric key using the specified key in the vault that has initially been used for wrapping the key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the Base64Url value
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyOperationResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyOperationResult> unwrapKey(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, byte[] value) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.withAlgorithm(algorithm);
        parameters.withValue(value);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.unwrapKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return unwrapKeyDelegate(call.execute());
    }

    /**
     * Unwraps a symmetric key using the specified key in the vault that has initially been used for wrapping the key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the Base64Url value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<KeyOperationResult> unwrapKeyAsync(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, byte[] value, final ServiceCallback<KeyOperationResult> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.withAlgorithm(algorithm);
        parameters.withValue(value);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.unwrapKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<KeyOperationResult> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<KeyOperationResult>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<KeyOperationResult> clientResponse = unwrapKeyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyOperationResult> unwrapKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyOperationResult, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<KeyOperationResult>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Sets a secret in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param value The value of the secret
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SecretBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SecretBundle> setSecret(String vaultBaseUrl, String secretName, String value) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        final Map<String, String> tags = null;
        final String contentType = null;
        final SecretAttributes secretAttributes = null;
        SecretSetParameters parameters = new SecretSetParameters();
        parameters.withValue(value);
        parameters.withTags(null);
        parameters.withContentType(null);
        parameters.withSecretAttributes(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setSecret(secretName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return setSecretDelegate(call.execute());
    }

    /**
     * Sets a secret in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param value The value of the secret
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<SecretBundle> setSecretAsync(String vaultBaseUrl, String secretName, String value, final ServiceCallback<SecretBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        final Map<String, String> tags = null;
        final String contentType = null;
        final SecretAttributes secretAttributes = null;
        SecretSetParameters parameters = new SecretSetParameters();
        parameters.withValue(value);
        parameters.withTags(null);
        parameters.withContentType(null);
        parameters.withSecretAttributes(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setSecret(secretName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<SecretBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<SecretBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<SecretBundle> clientResponse = setSecretDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Sets a secret in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param value The value of the secret
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param contentType Type of the secret value such as a password
     * @param secretAttributes The secret management attributes
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SecretBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SecretBundle> setSecret(String vaultBaseUrl, String secretName, String value, Map<String, String> tags, String contentType, SecretAttributes secretAttributes) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        Validator.validate(tags);
        Validator.validate(secretAttributes);
        SecretSetParameters parameters = new SecretSetParameters();
        parameters.withValue(value);
        parameters.withTags(tags);
        parameters.withContentType(contentType);
        parameters.withSecretAttributes(secretAttributes);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setSecret(secretName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return setSecretDelegate(call.execute());
    }

    /**
     * Sets a secret in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param value The value of the secret
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param contentType Type of the secret value such as a password
     * @param secretAttributes The secret management attributes
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<SecretBundle> setSecretAsync(String vaultBaseUrl, String secretName, String value, Map<String, String> tags, String contentType, SecretAttributes secretAttributes, final ServiceCallback<SecretBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        Validator.validate(tags);
        Validator.validate(secretAttributes);
        SecretSetParameters parameters = new SecretSetParameters();
        parameters.withValue(value);
        parameters.withTags(tags);
        parameters.withContentType(contentType);
        parameters.withSecretAttributes(secretAttributes);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setSecret(secretName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<SecretBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<SecretBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<SecretBundle> clientResponse = setSecretDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<SecretBundle> setSecretDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SecretBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<SecretBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Deletes a secret from the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SecretBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SecretBundle> deleteSecret(String vaultBaseUrl, String secretName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteSecret(secretName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return deleteSecretDelegate(call.execute());
    }

    /**
     * Deletes a secret from the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<SecretBundle> deleteSecretAsync(String vaultBaseUrl, String secretName, final ServiceCallback<SecretBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteSecret(secretName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<SecretBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<SecretBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<SecretBundle> clientResponse = deleteSecretDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<SecretBundle> deleteSecretDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SecretBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<SecretBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Updates the attributes associated with the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param secretVersion The version of the secret
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SecretBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SecretBundle> updateSecret(String vaultBaseUrl, String secretName, String secretVersion) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (secretVersion == null) {
            throw new IllegalArgumentException("Parameter secretVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final String contentType = null;
        final SecretAttributes secretAttributes = null;
        final Map<String, String> tags = null;
        SecretUpdateParameters parameters = new SecretUpdateParameters();
        parameters.withContentType(null);
        parameters.withSecretAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateSecret(secretName, secretVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return updateSecretDelegate(call.execute());
    }

    /**
     * Updates the attributes associated with the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param secretVersion The version of the secret
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<SecretBundle> updateSecretAsync(String vaultBaseUrl, String secretName, String secretVersion, final ServiceCallback<SecretBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (secretVersion == null) {
            throw new IllegalArgumentException("Parameter secretVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final String contentType = null;
        final SecretAttributes secretAttributes = null;
        final Map<String, String> tags = null;
        SecretUpdateParameters parameters = new SecretUpdateParameters();
        parameters.withContentType(null);
        parameters.withSecretAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateSecret(secretName, secretVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<SecretBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<SecretBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<SecretBundle> clientResponse = updateSecretDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Updates the attributes associated with the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param secretVersion The version of the secret
     * @param contentType Type of the secret value such as a password
     * @param secretAttributes The secret management attributes
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SecretBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SecretBundle> updateSecret(String vaultBaseUrl, String secretName, String secretVersion, String contentType, SecretAttributes secretAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (secretVersion == null) {
            throw new IllegalArgumentException("Parameter secretVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(secretAttributes);
        Validator.validate(tags);
        SecretUpdateParameters parameters = new SecretUpdateParameters();
        parameters.withContentType(contentType);
        parameters.withSecretAttributes(secretAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateSecret(secretName, secretVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return updateSecretDelegate(call.execute());
    }

    /**
     * Updates the attributes associated with the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param secretVersion The version of the secret
     * @param contentType Type of the secret value such as a password
     * @param secretAttributes The secret management attributes
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<SecretBundle> updateSecretAsync(String vaultBaseUrl, String secretName, String secretVersion, String contentType, SecretAttributes secretAttributes, Map<String, String> tags, final ServiceCallback<SecretBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (secretVersion == null) {
            throw new IllegalArgumentException("Parameter secretVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(secretAttributes);
        Validator.validate(tags);
        SecretUpdateParameters parameters = new SecretUpdateParameters();
        parameters.withContentType(contentType);
        parameters.withSecretAttributes(secretAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateSecret(secretName, secretVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<SecretBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<SecretBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<SecretBundle> clientResponse = updateSecretDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<SecretBundle> updateSecretDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SecretBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<SecretBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Gets a secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param secretVersion The version of the secret
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SecretBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SecretBundle> getSecret(String vaultBaseUrl, String secretName, String secretVersion) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (secretVersion == null) {
            throw new IllegalArgumentException("Parameter secretVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecret(secretName, secretVersion, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return getSecretDelegate(call.execute());
    }

    /**
     * Gets a secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param secretVersion The version of the secret
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<SecretBundle> getSecretAsync(String vaultBaseUrl, String secretName, String secretVersion, final ServiceCallback<SecretBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (secretVersion == null) {
            throw new IllegalArgumentException("Parameter secretVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecret(secretName, secretVersion, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<SecretBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<SecretBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<SecretBundle> clientResponse = getSecretDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<SecretBundle> getSecretDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SecretBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<SecretBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List secrets in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SecretItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SecretItem>> getSecrets(final String vaultBaseUrl) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecrets(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        ServiceResponse<PageImpl<SecretItem>> response = getSecretsDelegate(call.execute());
        PagedList<SecretItem> result = new PagedList<SecretItem>(response.getBody()) {
            @Override
            public Page<SecretItem> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getSecretsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List secrets in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<SecretItem>> getSecretsAsync(final String vaultBaseUrl, final ListOperationCallback<SecretItem> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecrets(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<List<SecretItem>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<SecretItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<SecretItem>> result = getSecretsDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.load(result.getBody().getItems());
                        if (result.getBody().getNextPageLink() != null
                                && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                            getSecretsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                        } else {
                            serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                        }
                    }
                    serviceCall.success(new ServiceResponse<>(result.getBody().getItems(), response));
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * List secrets in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of secrets to return.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SecretItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SecretItem>> getSecrets(final String vaultBaseUrl, final Integer maxresults) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecrets(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        ServiceResponse<PageImpl<SecretItem>> response = getSecretsDelegate(call.execute());
        PagedList<SecretItem> result = new PagedList<SecretItem>(response.getBody()) {
            @Override
            public Page<SecretItem> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getSecretsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List secrets in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of secrets to return.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<SecretItem>> getSecretsAsync(final String vaultBaseUrl, final Integer maxresults, final ListOperationCallback<SecretItem> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecrets(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<List<SecretItem>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<SecretItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<SecretItem>> result = getSecretsDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.load(result.getBody().getItems());
                        if (result.getBody().getNextPageLink() != null
                                && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                            getSecretsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                        } else {
                            serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                        }
                    }
                    serviceCall.success(new ServiceResponse<>(result.getBody().getItems(), response));
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<SecretItem>> getSecretsDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SecretItem>, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SecretItem>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List the versions of the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SecretItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SecretItem>> getSecretVersions(final String vaultBaseUrl, final String secretName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecretVersions(secretName, maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        ServiceResponse<PageImpl<SecretItem>> response = getSecretVersionsDelegate(call.execute());
        PagedList<SecretItem> result = new PagedList<SecretItem>(response.getBody()) {
            @Override
            public Page<SecretItem> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getSecretVersionsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List the versions of the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<SecretItem>> getSecretVersionsAsync(final String vaultBaseUrl, final String secretName, final ListOperationCallback<SecretItem> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecretVersions(secretName, maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<List<SecretItem>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<SecretItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<SecretItem>> result = getSecretVersionsDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.load(result.getBody().getItems());
                        if (result.getBody().getNextPageLink() != null
                                && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                            getSecretVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                        } else {
                            serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                        }
                    }
                    serviceCall.success(new ServiceResponse<>(result.getBody().getItems(), response));
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * List the versions of the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param maxresults Maximum number of results to return.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SecretItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SecretItem>> getSecretVersions(final String vaultBaseUrl, final String secretName, final Integer maxresults) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecretVersions(secretName, maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        ServiceResponse<PageImpl<SecretItem>> response = getSecretVersionsDelegate(call.execute());
        PagedList<SecretItem> result = new PagedList<SecretItem>(response.getBody()) {
            @Override
            public Page<SecretItem> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getSecretVersionsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List the versions of the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param maxresults Maximum number of results to return.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<SecretItem>> getSecretVersionsAsync(final String vaultBaseUrl, final String secretName, final Integer maxresults, final ListOperationCallback<SecretItem> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecretVersions(secretName, maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<List<SecretItem>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<SecretItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<SecretItem>> result = getSecretVersionsDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.load(result.getBody().getItems());
                        if (result.getBody().getNextPageLink() != null
                                && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                            getSecretVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                        } else {
                            serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                        }
                    }
                    serviceCall.success(new ServiceResponse<>(result.getBody().getItems(), response));
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<SecretItem>> getSecretVersionsDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SecretItem>, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SecretItem>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List certificates in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CertificateItem>> getCertificates(final String vaultBaseUrl) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificates(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        ServiceResponse<PageImpl<CertificateItem>> response = getCertificatesDelegate(call.execute());
        PagedList<CertificateItem> result = new PagedList<CertificateItem>(response.getBody()) {
            @Override
            public Page<CertificateItem> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getCertificatesNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List certificates in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<CertificateItem>> getCertificatesAsync(final String vaultBaseUrl, final ListOperationCallback<CertificateItem> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificates(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<List<CertificateItem>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateItem>> result = getCertificatesDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.load(result.getBody().getItems());
                        if (result.getBody().getNextPageLink() != null
                                && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                            getCertificatesNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                        } else {
                            serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                        }
                    }
                    serviceCall.success(new ServiceResponse<>(result.getBody().getItems(), response));
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * List certificates in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of results to return.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CertificateItem>> getCertificates(final String vaultBaseUrl, final Integer maxresults) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificates(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        ServiceResponse<PageImpl<CertificateItem>> response = getCertificatesDelegate(call.execute());
        PagedList<CertificateItem> result = new PagedList<CertificateItem>(response.getBody()) {
            @Override
            public Page<CertificateItem> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getCertificatesNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List certificates in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of results to return.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<CertificateItem>> getCertificatesAsync(final String vaultBaseUrl, final Integer maxresults, final ListOperationCallback<CertificateItem> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificates(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<List<CertificateItem>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateItem>> result = getCertificatesDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.load(result.getBody().getItems());
                        if (result.getBody().getNextPageLink() != null
                                && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                            getCertificatesNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                        } else {
                            serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                        }
                    }
                    serviceCall.success(new ServiceResponse<>(result.getBody().getItems(), response));
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<CertificateItem>> getCertificatesDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateItem>, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateItem>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Deletes a certificate from the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundle> deleteCertificate(String vaultBaseUrl, String certificateName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return deleteCertificateDelegate(call.execute());
    }

    /**
     * Deletes a certificate from the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<CertificateBundle> deleteCertificateAsync(String vaultBaseUrl, String certificateName, final ServiceCallback<CertificateBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<CertificateBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<CertificateBundle> clientResponse = deleteCertificateDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateBundle> deleteCertificateDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<CertificateBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Sets the certificate contacts for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param contacts The contacts for the vault certificates.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Contacts object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Contacts> setCertificateContacts(String vaultBaseUrl, Contacts contacts) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (contacts == null) {
            throw new IllegalArgumentException("Parameter contacts is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(contacts);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setCertificateContacts(contacts, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return setCertificateContactsDelegate(call.execute());
    }

    /**
     * Sets the certificate contacts for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param contacts The contacts for the vault certificates.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Contacts> setCertificateContactsAsync(String vaultBaseUrl, Contacts contacts, final ServiceCallback<Contacts> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (contacts == null) {
            throw new IllegalArgumentException("Parameter contacts is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(contacts);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setCertificateContacts(contacts, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<Contacts> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Contacts>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Contacts> clientResponse = setCertificateContactsDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Contacts> setCertificateContactsDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Contacts, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<Contacts>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Gets the certificate contacts for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Contacts object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Contacts> getCertificateContacts(String vaultBaseUrl) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateContacts(this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return getCertificateContactsDelegate(call.execute());
    }

    /**
     * Gets the certificate contacts for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Contacts> getCertificateContactsAsync(String vaultBaseUrl, final ServiceCallback<Contacts> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateContacts(this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<Contacts> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Contacts>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Contacts> clientResponse = getCertificateContactsDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Contacts> getCertificateContactsDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Contacts, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<Contacts>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Deletes the certificate contacts for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Contacts object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Contacts> deleteCertificateContacts(String vaultBaseUrl) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificateContacts(this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return deleteCertificateContactsDelegate(call.execute());
    }

    /**
     * Deletes the certificate contacts for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Contacts> deleteCertificateContactsAsync(String vaultBaseUrl, final ServiceCallback<Contacts> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificateContacts(this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<Contacts> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Contacts>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Contacts> clientResponse = deleteCertificateContactsDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Contacts> deleteCertificateContactsDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Contacts, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<Contacts>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List certificate issuers for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateIssuerItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CertificateIssuerItem>> getCertificateIssuers(final String vaultBaseUrl) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateIssuers(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        ServiceResponse<PageImpl<CertificateIssuerItem>> response = getCertificateIssuersDelegate(call.execute());
        PagedList<CertificateIssuerItem> result = new PagedList<CertificateIssuerItem>(response.getBody()) {
            @Override
            public Page<CertificateIssuerItem> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getCertificateIssuersNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List certificate issuers for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<CertificateIssuerItem>> getCertificateIssuersAsync(final String vaultBaseUrl, final ListOperationCallback<CertificateIssuerItem> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateIssuers(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<List<CertificateIssuerItem>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateIssuerItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateIssuerItem>> result = getCertificateIssuersDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.load(result.getBody().getItems());
                        if (result.getBody().getNextPageLink() != null
                                && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                            getCertificateIssuersNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                        } else {
                            serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                        }
                    }
                    serviceCall.success(new ServiceResponse<>(result.getBody().getItems(), response));
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * List certificate issuers for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of results to return.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateIssuerItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CertificateIssuerItem>> getCertificateIssuers(final String vaultBaseUrl, final Integer maxresults) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateIssuers(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        ServiceResponse<PageImpl<CertificateIssuerItem>> response = getCertificateIssuersDelegate(call.execute());
        PagedList<CertificateIssuerItem> result = new PagedList<CertificateIssuerItem>(response.getBody()) {
            @Override
            public Page<CertificateIssuerItem> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getCertificateIssuersNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List certificate issuers for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of results to return.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<CertificateIssuerItem>> getCertificateIssuersAsync(final String vaultBaseUrl, final Integer maxresults, final ListOperationCallback<CertificateIssuerItem> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateIssuers(maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<List<CertificateIssuerItem>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateIssuerItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateIssuerItem>> result = getCertificateIssuersDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.load(result.getBody().getItems());
                        if (result.getBody().getNextPageLink() != null
                                && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                            getCertificateIssuersNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                        } else {
                            serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                        }
                    }
                    serviceCall.success(new ServiceResponse<>(result.getBody().getItems(), response));
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<CertificateIssuerItem>> getCertificateIssuersDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateIssuerItem>, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateIssuerItem>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Sets the specified certificate issuer.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @param issuer The issuer bundle.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the IssuerBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<IssuerBundle> setCertificateIssuer(String vaultBaseUrl, String issuerName, IssuerBundle issuer) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (issuerName == null) {
            throw new IllegalArgumentException("Parameter issuerName is required and cannot be null.");
        }
        if (issuer == null) {
            throw new IllegalArgumentException("Parameter issuer is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(issuer);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setCertificateIssuer(issuerName, issuer, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return setCertificateIssuerDelegate(call.execute());
    }

    /**
     * Sets the specified certificate issuer.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @param issuer The issuer bundle.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<IssuerBundle> setCertificateIssuerAsync(String vaultBaseUrl, String issuerName, IssuerBundle issuer, final ServiceCallback<IssuerBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (issuerName == null) {
            throw new IllegalArgumentException("Parameter issuerName is required and cannot be null.");
        }
        if (issuer == null) {
            throw new IllegalArgumentException("Parameter issuer is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(issuer);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setCertificateIssuer(issuerName, issuer, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<IssuerBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<IssuerBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<IssuerBundle> clientResponse = setCertificateIssuerDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<IssuerBundle> setCertificateIssuerDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<IssuerBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<IssuerBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Updates the specified certificate issuer.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @param issuer The issuer bundle.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the IssuerBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<IssuerBundle> updateCertificateIssuer(String vaultBaseUrl, String issuerName, IssuerBundle issuer) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (issuerName == null) {
            throw new IllegalArgumentException("Parameter issuerName is required and cannot be null.");
        }
        if (issuer == null) {
            throw new IllegalArgumentException("Parameter issuer is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(issuer);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificateIssuer(issuerName, issuer, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return updateCertificateIssuerDelegate(call.execute());
    }

    /**
     * Updates the specified certificate issuer.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @param issuer The issuer bundle.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<IssuerBundle> updateCertificateIssuerAsync(String vaultBaseUrl, String issuerName, IssuerBundle issuer, final ServiceCallback<IssuerBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (issuerName == null) {
            throw new IllegalArgumentException("Parameter issuerName is required and cannot be null.");
        }
        if (issuer == null) {
            throw new IllegalArgumentException("Parameter issuer is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(issuer);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificateIssuer(issuerName, issuer, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<IssuerBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<IssuerBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<IssuerBundle> clientResponse = updateCertificateIssuerDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<IssuerBundle> updateCertificateIssuerDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<IssuerBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<IssuerBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Gets the specified certificate issuer.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the IssuerBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<IssuerBundle> getCertificateIssuer(String vaultBaseUrl, String issuerName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (issuerName == null) {
            throw new IllegalArgumentException("Parameter issuerName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateIssuer(issuerName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return getCertificateIssuerDelegate(call.execute());
    }

    /**
     * Gets the specified certificate issuer.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<IssuerBundle> getCertificateIssuerAsync(String vaultBaseUrl, String issuerName, final ServiceCallback<IssuerBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (issuerName == null) {
            throw new IllegalArgumentException("Parameter issuerName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateIssuer(issuerName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<IssuerBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<IssuerBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<IssuerBundle> clientResponse = getCertificateIssuerDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<IssuerBundle> getCertificateIssuerDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<IssuerBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<IssuerBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Deletes the specified certificate issuer.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the IssuerBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<IssuerBundle> deleteCertificateIssuer(String vaultBaseUrl, String issuerName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (issuerName == null) {
            throw new IllegalArgumentException("Parameter issuerName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificateIssuer(issuerName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return deleteCertificateIssuerDelegate(call.execute());
    }

    /**
     * Deletes the specified certificate issuer.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<IssuerBundle> deleteCertificateIssuerAsync(String vaultBaseUrl, String issuerName, final ServiceCallback<IssuerBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (issuerName == null) {
            throw new IllegalArgumentException("Parameter issuerName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificateIssuer(issuerName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<IssuerBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<IssuerBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<IssuerBundle> clientResponse = deleteCertificateIssuerDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<IssuerBundle> deleteCertificateIssuerDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<IssuerBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<IssuerBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Creates a new certificate version. If this is the first version, the certificate resource is created.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOperation object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateOperation> createCertificate(String vaultBaseUrl, String certificateName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final CertificatePolicy certificatePolicy = null;
        final CertificateAttributes certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateCreateParameters parameters = new CertificateCreateParameters();
        parameters.withCertificatePolicy(null);
        parameters.withCertificateAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return createCertificateDelegate(call.execute());
    }

    /**
     * Creates a new certificate version. If this is the first version, the certificate resource is created.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<CertificateOperation> createCertificateAsync(String vaultBaseUrl, String certificateName, final ServiceCallback<CertificateOperation> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final CertificatePolicy certificatePolicy = null;
        final CertificateAttributes certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateCreateParameters parameters = new CertificateCreateParameters();
        parameters.withCertificatePolicy(null);
        parameters.withCertificateAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<CertificateOperation> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<CertificateOperation>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<CertificateOperation> clientResponse = createCertificateDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Creates a new certificate version. If this is the first version, the certificate resource is created.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param certificatePolicy The management policy for the certificate
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOperation object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateOperation> createCertificate(String vaultBaseUrl, String certificateName, CertificatePolicy certificatePolicy, CertificateAttributes certificateAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(certificatePolicy);
        Validator.validate(certificateAttributes);
        Validator.validate(tags);
        CertificateCreateParameters parameters = new CertificateCreateParameters();
        parameters.withCertificatePolicy(certificatePolicy);
        parameters.withCertificateAttributes(certificateAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return createCertificateDelegate(call.execute());
    }

    /**
     * Creates a new certificate version. If this is the first version, the certificate resource is created.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param certificatePolicy The management policy for the certificate
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<CertificateOperation> createCertificateAsync(String vaultBaseUrl, String certificateName, CertificatePolicy certificatePolicy, CertificateAttributes certificateAttributes, Map<String, String> tags, final ServiceCallback<CertificateOperation> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(certificatePolicy);
        Validator.validate(certificateAttributes);
        Validator.validate(tags);
        CertificateCreateParameters parameters = new CertificateCreateParameters();
        parameters.withCertificatePolicy(certificatePolicy);
        parameters.withCertificateAttributes(certificateAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<CertificateOperation> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<CertificateOperation>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<CertificateOperation> clientResponse = createCertificateDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateOperation> createCertificateDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateOperation, KeyVaultErrorException>(this.mapperAdapter())
                .register(202, new TypeToken<CertificateOperation>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Imports a certificate into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param base64EncodedCertificate Base64 encoded representation of the certificate object to import. This certificate needs to contain the private key.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundle> importCertificate(String vaultBaseUrl, String certificateName, String base64EncodedCertificate) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (base64EncodedCertificate == null) {
            throw new IllegalArgumentException("Parameter base64EncodedCertificate is required and cannot be null.");
        }
        final String password = null;
        final CertificatePolicy certificatePolicy = null;
        final CertificateAttributes certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateImportParameters parameters = new CertificateImportParameters();
        parameters.withBase64EncodedCertificate(base64EncodedCertificate);
        parameters.withPassword(null);
        parameters.withCertificatePolicy(null);
        parameters.withCertificateAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return importCertificateDelegate(call.execute());
    }

    /**
     * Imports a certificate into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param base64EncodedCertificate Base64 encoded representation of the certificate object to import. This certificate needs to contain the private key.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<CertificateBundle> importCertificateAsync(String vaultBaseUrl, String certificateName, String base64EncodedCertificate, final ServiceCallback<CertificateBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (base64EncodedCertificate == null) {
            throw new IllegalArgumentException("Parameter base64EncodedCertificate is required and cannot be null.");
        }
        final String password = null;
        final CertificatePolicy certificatePolicy = null;
        final CertificateAttributes certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateImportParameters parameters = new CertificateImportParameters();
        parameters.withBase64EncodedCertificate(base64EncodedCertificate);
        parameters.withPassword(null);
        parameters.withCertificatePolicy(null);
        parameters.withCertificateAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<CertificateBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<CertificateBundle> clientResponse = importCertificateDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Imports a certificate into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param base64EncodedCertificate Base64 encoded representation of the certificate object to import. This certificate needs to contain the private key.
     * @param password If the private key in base64EncodedCertificate is encrypted, the password used for encryption
     * @param certificatePolicy The management policy for the certificate
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundle> importCertificate(String vaultBaseUrl, String certificateName, String base64EncodedCertificate, String password, CertificatePolicy certificatePolicy, CertificateAttributes certificateAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (base64EncodedCertificate == null) {
            throw new IllegalArgumentException("Parameter base64EncodedCertificate is required and cannot be null.");
        }
        Validator.validate(certificatePolicy);
        Validator.validate(certificateAttributes);
        Validator.validate(tags);
        CertificateImportParameters parameters = new CertificateImportParameters();
        parameters.withBase64EncodedCertificate(base64EncodedCertificate);
        parameters.withPassword(password);
        parameters.withCertificatePolicy(certificatePolicy);
        parameters.withCertificateAttributes(certificateAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return importCertificateDelegate(call.execute());
    }

    /**
     * Imports a certificate into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param base64EncodedCertificate Base64 encoded representation of the certificate object to import. This certificate needs to contain the private key.
     * @param password If the private key in base64EncodedCertificate is encrypted, the password used for encryption
     * @param certificatePolicy The management policy for the certificate
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<CertificateBundle> importCertificateAsync(String vaultBaseUrl, String certificateName, String base64EncodedCertificate, String password, CertificatePolicy certificatePolicy, CertificateAttributes certificateAttributes, Map<String, String> tags, final ServiceCallback<CertificateBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (base64EncodedCertificate == null) {
            throw new IllegalArgumentException("Parameter base64EncodedCertificate is required and cannot be null.");
        }
        Validator.validate(certificatePolicy);
        Validator.validate(certificateAttributes);
        Validator.validate(tags);
        CertificateImportParameters parameters = new CertificateImportParameters();
        parameters.withBase64EncodedCertificate(base64EncodedCertificate);
        parameters.withPassword(password);
        parameters.withCertificatePolicy(certificatePolicy);
        parameters.withCertificateAttributes(certificateAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<CertificateBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<CertificateBundle> clientResponse = importCertificateDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateBundle> importCertificateDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<CertificateBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List the versions of a certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CertificateItem>> getCertificateVersions(final String vaultBaseUrl, final String certificateName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateVersions(certificateName, maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        ServiceResponse<PageImpl<CertificateItem>> response = getCertificateVersionsDelegate(call.execute());
        PagedList<CertificateItem> result = new PagedList<CertificateItem>(response.getBody()) {
            @Override
            public Page<CertificateItem> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getCertificateVersionsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List the versions of a certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<CertificateItem>> getCertificateVersionsAsync(final String vaultBaseUrl, final String certificateName, final ListOperationCallback<CertificateItem> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateVersions(certificateName, maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<List<CertificateItem>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateItem>> result = getCertificateVersionsDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.load(result.getBody().getItems());
                        if (result.getBody().getNextPageLink() != null
                                && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                            getCertificateVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                        } else {
                            serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                        }
                    }
                    serviceCall.success(new ServiceResponse<>(result.getBody().getItems(), response));
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * List the versions of a certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param maxresults Maximum number of results to return.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CertificateItem>> getCertificateVersions(final String vaultBaseUrl, final String certificateName, final Integer maxresults) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateVersions(certificateName, maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        ServiceResponse<PageImpl<CertificateItem>> response = getCertificateVersionsDelegate(call.execute());
        PagedList<CertificateItem> result = new PagedList<CertificateItem>(response.getBody()) {
            @Override
            public Page<CertificateItem> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getCertificateVersionsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List the versions of a certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param maxresults Maximum number of results to return.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<CertificateItem>> getCertificateVersionsAsync(final String vaultBaseUrl, final String certificateName, final Integer maxresults, final ListOperationCallback<CertificateItem> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateVersions(certificateName, maxresults, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<List<CertificateItem>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateItem>> result = getCertificateVersionsDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.load(result.getBody().getItems());
                        if (result.getBody().getNextPageLink() != null
                                && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                            getCertificateVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                        } else {
                            serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                        }
                    }
                    serviceCall.success(new ServiceResponse<>(result.getBody().getItems(), response));
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<CertificateItem>> getCertificateVersionsDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateItem>, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateItem>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Gets the policy for a certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificatePolicy object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificatePolicy> getCertificatePolicy(String vaultBaseUrl, String certificateName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificatePolicy(certificateName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return getCertificatePolicyDelegate(call.execute());
    }

    /**
     * Gets the policy for a certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<CertificatePolicy> getCertificatePolicyAsync(String vaultBaseUrl, String certificateName, final ServiceCallback<CertificatePolicy> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificatePolicy(certificateName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<CertificatePolicy> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<CertificatePolicy>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<CertificatePolicy> clientResponse = getCertificatePolicyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificatePolicy> getCertificatePolicyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificatePolicy, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<CertificatePolicy>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Updates the policy for a certificate. Set appropriate members in the certificatePolicy that must be updated. Leave others as null.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault.
     * @param certificatePolicy The policy for the certificate.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificatePolicy object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificatePolicy> updateCertificatePolicy(String vaultBaseUrl, String certificateName, CertificatePolicy certificatePolicy) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (certificatePolicy == null) {
            throw new IllegalArgumentException("Parameter certificatePolicy is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(certificatePolicy);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificatePolicy(certificateName, certificatePolicy, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return updateCertificatePolicyDelegate(call.execute());
    }

    /**
     * Updates the policy for a certificate. Set appropriate members in the certificatePolicy that must be updated. Leave others as null.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault.
     * @param certificatePolicy The policy for the certificate.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<CertificatePolicy> updateCertificatePolicyAsync(String vaultBaseUrl, String certificateName, CertificatePolicy certificatePolicy, final ServiceCallback<CertificatePolicy> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (certificatePolicy == null) {
            throw new IllegalArgumentException("Parameter certificatePolicy is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(certificatePolicy);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificatePolicy(certificateName, certificatePolicy, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<CertificatePolicy> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<CertificatePolicy>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<CertificatePolicy> clientResponse = updateCertificatePolicyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificatePolicy> updateCertificatePolicyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificatePolicy, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<CertificatePolicy>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Updates the attributes associated with the specified certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @param certificateVersion The version of the certificate
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundle> updateCertificate(String vaultBaseUrl, String certificateName, String certificateVersion) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (certificateVersion == null) {
            throw new IllegalArgumentException("Parameter certificateVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final CertificateAttributes certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateUpdateParameters parameters = new CertificateUpdateParameters();
        parameters.withCertificateAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificate(certificateName, certificateVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return updateCertificateDelegate(call.execute());
    }

    /**
     * Updates the attributes associated with the specified certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @param certificateVersion The version of the certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<CertificateBundle> updateCertificateAsync(String vaultBaseUrl, String certificateName, String certificateVersion, final ServiceCallback<CertificateBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (certificateVersion == null) {
            throw new IllegalArgumentException("Parameter certificateVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final CertificateAttributes certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateUpdateParameters parameters = new CertificateUpdateParameters();
        parameters.withCertificateAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificate(certificateName, certificateVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<CertificateBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<CertificateBundle> clientResponse = updateCertificateDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Updates the attributes associated with the specified certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @param certificateVersion The version of the certificate
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundle> updateCertificate(String vaultBaseUrl, String certificateName, String certificateVersion, CertificateAttributes certificateAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (certificateVersion == null) {
            throw new IllegalArgumentException("Parameter certificateVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(certificateAttributes);
        Validator.validate(tags);
        CertificateUpdateParameters parameters = new CertificateUpdateParameters();
        parameters.withCertificateAttributes(certificateAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificate(certificateName, certificateVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return updateCertificateDelegate(call.execute());
    }

    /**
     * Updates the attributes associated with the specified certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @param certificateVersion The version of the certificate
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<CertificateBundle> updateCertificateAsync(String vaultBaseUrl, String certificateName, String certificateVersion, CertificateAttributes certificateAttributes, Map<String, String> tags, final ServiceCallback<CertificateBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (certificateVersion == null) {
            throw new IllegalArgumentException("Parameter certificateVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(certificateAttributes);
        Validator.validate(tags);
        CertificateUpdateParameters parameters = new CertificateUpdateParameters();
        parameters.withCertificateAttributes(certificateAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificate(certificateName, certificateVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<CertificateBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<CertificateBundle> clientResponse = updateCertificateDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateBundle> updateCertificateDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<CertificateBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Gets a Certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @param certificateVersion The version of the certificate
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundle> getCertificate(String vaultBaseUrl, String certificateName, String certificateVersion) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (certificateVersion == null) {
            throw new IllegalArgumentException("Parameter certificateVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificate(certificateName, certificateVersion, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return getCertificateDelegate(call.execute());
    }

    /**
     * Gets a Certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @param certificateVersion The version of the certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<CertificateBundle> getCertificateAsync(String vaultBaseUrl, String certificateName, String certificateVersion, final ServiceCallback<CertificateBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (certificateVersion == null) {
            throw new IllegalArgumentException("Parameter certificateVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificate(certificateName, certificateVersion, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<CertificateBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<CertificateBundle> clientResponse = getCertificateDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateBundle> getCertificateDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<CertificateBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Updates a certificate operation.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param certificateOperation The certificate operation response.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOperation object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateOperation> updateCertificateOperation(String vaultBaseUrl, String certificateName, CertificateOperation certificateOperation) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (certificateOperation == null) {
            throw new IllegalArgumentException("Parameter certificateOperation is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(certificateOperation);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificateOperation(certificateName, certificateOperation, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return updateCertificateOperationDelegate(call.execute());
    }

    /**
     * Updates a certificate operation.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param certificateOperation The certificate operation response.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<CertificateOperation> updateCertificateOperationAsync(String vaultBaseUrl, String certificateName, CertificateOperation certificateOperation, final ServiceCallback<CertificateOperation> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (certificateOperation == null) {
            throw new IllegalArgumentException("Parameter certificateOperation is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(certificateOperation);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificateOperation(certificateName, certificateOperation, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<CertificateOperation> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<CertificateOperation>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<CertificateOperation> clientResponse = updateCertificateOperationDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateOperation> updateCertificateOperationDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateOperation, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<CertificateOperation>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Gets the certificate operation response.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOperation object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateOperation> getCertificateOperation(String vaultBaseUrl, String certificateName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateOperation(certificateName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return getCertificateOperationDelegate(call.execute());
    }

    /**
     * Gets the certificate operation response.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<CertificateOperation> getCertificateOperationAsync(String vaultBaseUrl, String certificateName, final ServiceCallback<CertificateOperation> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateOperation(certificateName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<CertificateOperation> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<CertificateOperation>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<CertificateOperation> clientResponse = getCertificateOperationDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateOperation> getCertificateOperationDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateOperation, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<CertificateOperation>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Deletes the certificate operation.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOperation object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateOperation> deleteCertificateOperation(String vaultBaseUrl, String certificateName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificateOperation(certificateName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        return deleteCertificateOperationDelegate(call.execute());
    }

    /**
     * Deletes the certificate operation.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<CertificateOperation> deleteCertificateOperationAsync(String vaultBaseUrl, String certificateName, final ServiceCallback<CertificateOperation> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificateOperation(certificateName, this.apiVersion(), this.acceptLanguage(), parameterizedHost, this.userAgent());
        final ServiceCall<CertificateOperation> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<CertificateOperation>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<CertificateOperation> clientResponse = deleteCertificateOperationDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateOperation> deleteCertificateOperationDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateOperation, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<CertificateOperation>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Merges a certificate or a certificate chain with a key pair existing on the server.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param x509Certificates The certificate or the certificate chain to merge
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundle> mergeCertificate(String vaultBaseUrl, String certificateName, List<byte[]> x509Certificates) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (x509Certificates == null) {
            throw new IllegalArgumentException("Parameter x509Certificates is required and cannot be null.");
        }
        Validator.validate(x509Certificates);
        final CertificateAttributes certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateMergeParameters parameters = new CertificateMergeParameters();
        parameters.withX509Certificates(x509Certificates);
        parameters.withCertificateAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.mergeCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return mergeCertificateDelegate(call.execute());
    }

    /**
     * Merges a certificate or a certificate chain with a key pair existing on the server.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param x509Certificates The certificate or the certificate chain to merge
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<CertificateBundle> mergeCertificateAsync(String vaultBaseUrl, String certificateName, List<byte[]> x509Certificates, final ServiceCallback<CertificateBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (x509Certificates == null) {
            throw new IllegalArgumentException("Parameter x509Certificates is required and cannot be null.");
        }
        Validator.validate(x509Certificates);
        final CertificateAttributes certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateMergeParameters parameters = new CertificateMergeParameters();
        parameters.withX509Certificates(x509Certificates);
        parameters.withCertificateAttributes(null);
        parameters.withTags(null);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.mergeCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<CertificateBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<CertificateBundle> clientResponse = mergeCertificateDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Merges a certificate or a certificate chain with a key pair existing on the server.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param x509Certificates The certificate or the certificate chain to merge
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundle object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundle> mergeCertificate(String vaultBaseUrl, String certificateName, List<byte[]> x509Certificates, CertificateAttributes certificateAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (x509Certificates == null) {
            throw new IllegalArgumentException("Parameter x509Certificates is required and cannot be null.");
        }
        Validator.validate(x509Certificates);
        Validator.validate(certificateAttributes);
        Validator.validate(tags);
        CertificateMergeParameters parameters = new CertificateMergeParameters();
        parameters.withX509Certificates(x509Certificates);
        parameters.withCertificateAttributes(certificateAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.mergeCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        return mergeCertificateDelegate(call.execute());
    }

    /**
     * Merges a certificate or a certificate chain with a key pair existing on the server.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param x509Certificates The certificate or the certificate chain to merge
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<CertificateBundle> mergeCertificateAsync(String vaultBaseUrl, String certificateName, List<byte[]> x509Certificates, CertificateAttributes certificateAttributes, Map<String, String> tags, final ServiceCallback<CertificateBundle> serviceCallback) {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (x509Certificates == null) {
            throw new IllegalArgumentException("Parameter x509Certificates is required and cannot be null.");
        }
        Validator.validate(x509Certificates);
        Validator.validate(certificateAttributes);
        Validator.validate(tags);
        CertificateMergeParameters parameters = new CertificateMergeParameters();
        parameters.withX509Certificates(x509Certificates);
        parameters.withCertificateAttributes(certificateAttributes);
        parameters.withTags(tags);
        String parameterizedHost = Joiner.on(", ").join("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.mergeCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent());
        final ServiceCall<CertificateBundle> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundle>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<CertificateBundle> clientResponse = mergeCertificateDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateBundle> mergeCertificateDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateBundle, KeyVaultErrorException>(this.mapperAdapter())
                .register(201, new TypeToken<CertificateBundle>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List the versions of the specified key.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;KeyItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PageImpl<KeyItem>> getKeyVersionsNext(final String nextPageLink) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        Call<ResponseBody> call = service.getKeyVersionsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        return getKeyVersionsNextDelegate(call.execute());
    }

    /**
     * List the versions of the specified key.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<KeyItem>> getKeyVersionsNextAsync(final String nextPageLink, final ServiceCall<List<KeyItem>> serviceCall, final ListOperationCallback<KeyItem> serviceCallback) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        Call<ResponseBody> call = service.getKeyVersionsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        serviceCall.newCall(call);
        call.enqueue(new ServiceResponseCallback<List<KeyItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<KeyItem>> result = getKeyVersionsNextDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getKeyVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<KeyItem>> getKeyVersionsNextDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<KeyItem>, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<PageImpl<KeyItem>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List keys in the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;KeyItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PageImpl<KeyItem>> getKeysNext(final String nextPageLink) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        Call<ResponseBody> call = service.getKeysNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        return getKeysNextDelegate(call.execute());
    }

    /**
     * List keys in the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<KeyItem>> getKeysNextAsync(final String nextPageLink, final ServiceCall<List<KeyItem>> serviceCall, final ListOperationCallback<KeyItem> serviceCallback) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        Call<ResponseBody> call = service.getKeysNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        serviceCall.newCall(call);
        call.enqueue(new ServiceResponseCallback<List<KeyItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<KeyItem>> result = getKeysNextDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getKeysNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<KeyItem>> getKeysNextDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<KeyItem>, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<PageImpl<KeyItem>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List secrets in the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SecretItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PageImpl<SecretItem>> getSecretsNext(final String nextPageLink) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        Call<ResponseBody> call = service.getSecretsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        return getSecretsNextDelegate(call.execute());
    }

    /**
     * List secrets in the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<SecretItem>> getSecretsNextAsync(final String nextPageLink, final ServiceCall<List<SecretItem>> serviceCall, final ListOperationCallback<SecretItem> serviceCallback) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        Call<ResponseBody> call = service.getSecretsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        serviceCall.newCall(call);
        call.enqueue(new ServiceResponseCallback<List<SecretItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<SecretItem>> result = getSecretsNextDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getSecretsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<SecretItem>> getSecretsNextDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SecretItem>, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SecretItem>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List the versions of the specified secret.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SecretItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PageImpl<SecretItem>> getSecretVersionsNext(final String nextPageLink) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        Call<ResponseBody> call = service.getSecretVersionsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        return getSecretVersionsNextDelegate(call.execute());
    }

    /**
     * List the versions of the specified secret.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<SecretItem>> getSecretVersionsNextAsync(final String nextPageLink, final ServiceCall<List<SecretItem>> serviceCall, final ListOperationCallback<SecretItem> serviceCallback) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        Call<ResponseBody> call = service.getSecretVersionsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        serviceCall.newCall(call);
        call.enqueue(new ServiceResponseCallback<List<SecretItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<SecretItem>> result = getSecretVersionsNextDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getSecretVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<SecretItem>> getSecretVersionsNextDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SecretItem>, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SecretItem>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List certificates in the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PageImpl<CertificateItem>> getCertificatesNext(final String nextPageLink) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        Call<ResponseBody> call = service.getCertificatesNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        return getCertificatesNextDelegate(call.execute());
    }

    /**
     * List certificates in the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<CertificateItem>> getCertificatesNextAsync(final String nextPageLink, final ServiceCall<List<CertificateItem>> serviceCall, final ListOperationCallback<CertificateItem> serviceCallback) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        Call<ResponseBody> call = service.getCertificatesNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        serviceCall.newCall(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateItem>> result = getCertificatesNextDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getCertificatesNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<CertificateItem>> getCertificatesNextDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateItem>, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateItem>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List certificate issuers for the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateIssuerItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PageImpl<CertificateIssuerItem>> getCertificateIssuersNext(final String nextPageLink) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        Call<ResponseBody> call = service.getCertificateIssuersNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        return getCertificateIssuersNextDelegate(call.execute());
    }

    /**
     * List certificate issuers for the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<CertificateIssuerItem>> getCertificateIssuersNextAsync(final String nextPageLink, final ServiceCall<List<CertificateIssuerItem>> serviceCall, final ListOperationCallback<CertificateIssuerItem> serviceCallback) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        Call<ResponseBody> call = service.getCertificateIssuersNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        serviceCall.newCall(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateIssuerItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateIssuerItem>> result = getCertificateIssuersNextDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getCertificateIssuersNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<CertificateIssuerItem>> getCertificateIssuersNextDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateIssuerItem>, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateIssuerItem>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List the versions of a certificate.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateItem&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PageImpl<CertificateItem>> getCertificateVersionsNext(final String nextPageLink) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        Call<ResponseBody> call = service.getCertificateVersionsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        return getCertificateVersionsNextDelegate(call.execute());
    }

    /**
     * List the versions of a certificate.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<CertificateItem>> getCertificateVersionsNextAsync(final String nextPageLink, final ServiceCall<List<CertificateItem>> serviceCall, final ListOperationCallback<CertificateItem> serviceCallback) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        Call<ResponseBody> call = service.getCertificateVersionsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        serviceCall.newCall(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateItem>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateItem>> result = getCertificateVersionsNextDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getCertificateVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<CertificateItem>> getCertificateVersionsNextDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateItem>, KeyVaultErrorException>(this.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateItem>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

}
