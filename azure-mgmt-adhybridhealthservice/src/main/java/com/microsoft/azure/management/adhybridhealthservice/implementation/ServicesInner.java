/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.adhybridhealthservice.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import org.joda.time.DateTime;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Services.
 */
public class ServicesInner {
    /** The Retrofit service to perform REST calls. */
    private ServicesService service;
    /** The service client containing this operation class. */
    private ADHybridHealthServiceImpl client;

    /**
     * Initializes an instance of ServicesInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ServicesInner(Retrofit retrofit, ADHybridHealthServiceImpl client) {
        this.service = retrofit.create(ServicesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Services to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ServicesService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services list" })
        @GET("providers/Microsoft.ADHybridHealthService/services")
        Observable<Response<ResponseBody>> list(@Query("$filter") String filter, @Query("serviceType") String serviceType, @Query("skipCount") Integer skipCount, @Query("takeCount") Integer takeCount, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services add" })
        @POST("providers/Microsoft.ADHybridHealthService/services")
        Observable<Response<ResponseBody>> add(@Query("api-version") String apiVersion, @Body ServicePropertiesInner service, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listPremium" })
        @GET("providers/Microsoft.ADHybridHealthService/services/premiumCheck")
        Observable<Response<ResponseBody>> listPremium(@Query("$filter") String filter, @Query("serviceType") String serviceType, @Query("skipCount") Integer skipCount, @Query("takeCount") Integer takeCount, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services get" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}")
        Observable<Response<ResponseBody>> get(@Path("serviceName") String serviceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services delete" })
        @HTTP(path = "providers/Microsoft.ADHybridHealthService/services/{serviceName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("serviceName") String serviceName, @Query("confirm") Boolean confirm, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services update" })
        @PATCH("providers/Microsoft.ADHybridHealthService/services/{serviceName}")
        Observable<Response<ResponseBody>> update(@Path("serviceName") String serviceName, @Body ServicePropertiesInner service, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listAlerts" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/alerts")
        Observable<Response<ResponseBody>> listAlerts(@Path("serviceName") String serviceName, @Query("$filter") String filter, @Query("state") String state, @Query("from") DateTime from, @Query("to") DateTime to, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services getFeatureAvailibility" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/checkServiceFeatureAvailibility/{featureName}")
        Observable<Response<ResponseBody>> getFeatureAvailibility(@Path("serviceName") String serviceName, @Path("featureName") String featureName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listExportErrors" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/exporterrors/counts")
        Observable<Response<ResponseBody>> listExportErrors(@Path("serviceName") String serviceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listExportErrorsV2" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/exporterrors/listV2")
        Observable<Response<ResponseBody>> listExportErrorsV2(@Path("serviceName") String serviceName, @Query("errorBucket") String errorBucket, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listExportStatus" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/exportstatus")
        Observable<Response<ResponseBody>> listExportStatus(@Path("serviceName") String serviceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services addAlertFeedback" })
        @POST("providers/Microsoft.ADHybridHealthService/services/{serviceName}/feedbacktype/alerts/feedback")
        Observable<Response<ResponseBody>> addAlertFeedback(@Path("serviceName") String serviceName, @Body AlertFeedbackInner alertFeedback, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listAlertFeedback" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/feedbacktype/alerts/{shortName}/alertfeedback")
        Observable<Response<ResponseBody>> listAlertFeedback(@Path("serviceName") String serviceName, @Path("shortName") String shortName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services getMetrics" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/metrics/{metricName}/groups/{groupName}")
        Observable<Response<ResponseBody>> getMetrics(@Path("serviceName") String serviceName, @Path("metricName") String metricName, @Path("groupName") String groupName, @Query("groupKey") String groupKey, @Query("fromDate") DateTime fromDate, @Query("toDate") DateTime toDate, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listMetricsAverage" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/metrics/{metricName}/groups/{groupName}/average")
        Observable<Response<ResponseBody>> listMetricsAverage(@Path("serviceName") String serviceName, @Path("metricName") String metricName, @Path("groupName") String groupName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listMetricsSum" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/metrics/{metricName}/groups/{groupName}/sum")
        Observable<Response<ResponseBody>> listMetricsSum(@Path("serviceName") String serviceName, @Path("metricName") String metricName, @Path("groupName") String groupName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listMetricMetadata" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/metricmetadata")
        Observable<Response<ResponseBody>> listMetricMetadata(@Path("serviceName") String serviceName, @Query("$filter") String filter, @Query("perfCounter") Boolean perfCounter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services getMetricMetadata" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/metricmetadata/{metricName}")
        Observable<Response<ResponseBody>> getMetricMetadata(@Path("serviceName") String serviceName, @Path("metricName") String metricName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services getMetricMetadataForGroup" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/metricmetadata/{metricName}/groups/{groupName}")
        Observable<Response<ResponseBody>> getMetricMetadataForGroup(@Path("serviceName") String serviceName, @Path("metricName") String metricName, @Path("groupName") String groupName, @Query("groupKey") String groupKey, @Query("fromDate") DateTime fromDate, @Query("toDate") DateTime toDate, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services updateMonitoringConfiguration" })
        @PATCH("providers/Microsoft.ADHybridHealthService/services/{serviceName}/monitoringconfiguration")
        Observable<Response<ResponseBody>> updateMonitoringConfiguration(@Path("serviceName") String serviceName, @Body ItemInner configurationSetting, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listMonitoringConfigurations" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/monitoringconfigurations")
        Observable<Response<ResponseBody>> listMonitoringConfigurations(@Path("serviceName") String serviceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listUserBadPasswordReport" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/reports/badpassword/details/user")
        Observable<Response<ResponseBody>> listUserBadPasswordReport(@Path("serviceName") String serviceName, @Query("dataSource") String dataSource, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services getTenantWhitelisting" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/TenantWhitelisting/{featureName}")
        Observable<Response<ResponseBody>> getTenantWhitelisting(@Path("serviceName") String serviceName, @Path("featureName") String featureName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listNext" })
        @GET
        Observable<Response<ResponseBody>> listNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listPremiumNext" })
        @GET
        Observable<Response<ResponseBody>> listPremiumNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listAlertsNext" })
        @GET
        Observable<Response<ResponseBody>> listAlertsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listExportStatusNext" })
        @GET
        Observable<Response<ResponseBody>> listExportStatusNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listMetricsAverageNext" })
        @GET
        Observable<Response<ResponseBody>> listMetricsAverageNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listMetricsSumNext" })
        @GET
        Observable<Response<ResponseBody>> listMetricsSumNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.Services listMetricMetadataNext" })
        @GET
        Observable<Response<ResponseBody>> listMetricMetadataNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Gets the details of services, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ServicePropertiesInner&gt; object if successful.
     */
    public PagedList<ServicePropertiesInner> list() {
        ServiceResponse<Page<ServicePropertiesInner>> response = listSinglePageAsync().toBlocking().single();
        return new PagedList<ServicePropertiesInner>(response.body()) {
            @Override
            public Page<ServicePropertiesInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of services, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServicePropertiesInner>> listAsync(final ListOperationCallback<ServicePropertiesInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of services, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<Page<ServicePropertiesInner>> listAsync() {
        return listWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Page<ServicePropertiesInner>>() {
                @Override
                public Page<ServicePropertiesInner> call(ServiceResponse<Page<ServicePropertiesInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of services, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listWithServiceResponseAsync() {
        return listSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(ServiceResponse<Page<ServicePropertiesInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of services, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ServicePropertiesInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listSinglePageAsync() {
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final String serviceType = null;
        final Integer skipCount = null;
        final Integer takeCount = null;
        return service.list(filter, serviceType, skipCount, takeCount, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServicePropertiesInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ServicePropertiesInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the details of services, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ServicePropertiesInner&gt; object if successful.
     */
    public PagedList<ServicePropertiesInner> list(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        ServiceResponse<Page<ServicePropertiesInner>> response = listSinglePageAsync(filter, serviceType, skipCount, takeCount).toBlocking().single();
        return new PagedList<ServicePropertiesInner>(response.body()) {
            @Override
            public Page<ServicePropertiesInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of services, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServicePropertiesInner>> listAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount, final ListOperationCallback<ServicePropertiesInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(filter, serviceType, skipCount, takeCount),
            new Func1<String, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of services, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<Page<ServicePropertiesInner>> listAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        return listWithServiceResponseAsync(filter, serviceType, skipCount, takeCount)
            .map(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Page<ServicePropertiesInner>>() {
                @Override
                public Page<ServicePropertiesInner> call(ServiceResponse<Page<ServicePropertiesInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of services, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listWithServiceResponseAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        return listSinglePageAsync(filter, serviceType, skipCount, takeCount)
            .concatMap(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(ServiceResponse<Page<ServicePropertiesInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of services, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param filter The service property filter to apply.
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ServicePropertiesInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listSinglePageAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.list(filter, serviceType, skipCount, takeCount, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServicePropertiesInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ServicePropertiesInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ServicePropertiesInner>> listDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ServicePropertiesInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ServicePropertiesInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Onboards a service for a given tenant in Azure Active Directory Connect Health.
     *
     * @param service The service object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServicePropertiesInner object if successful.
     */
    public ServicePropertiesInner add(ServicePropertiesInner service) {
        return addWithServiceResponseAsync(service).toBlocking().single().body();
    }

    /**
     * Onboards a service for a given tenant in Azure Active Directory Connect Health.
     *
     * @param service The service object.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServicePropertiesInner> addAsync(ServicePropertiesInner service, final ServiceCallback<ServicePropertiesInner> serviceCallback) {
        return ServiceFuture.fromResponse(addWithServiceResponseAsync(service), serviceCallback);
    }

    /**
     * Onboards a service for a given tenant in Azure Active Directory Connect Health.
     *
     * @param service The service object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePropertiesInner object
     */
    public Observable<ServicePropertiesInner> addAsync(ServicePropertiesInner service) {
        return addWithServiceResponseAsync(service).map(new Func1<ServiceResponse<ServicePropertiesInner>, ServicePropertiesInner>() {
            @Override
            public ServicePropertiesInner call(ServiceResponse<ServicePropertiesInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Onboards a service for a given tenant in Azure Active Directory Connect Health.
     *
     * @param service The service object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePropertiesInner object
     */
    public Observable<ServiceResponse<ServicePropertiesInner>> addWithServiceResponseAsync(ServicePropertiesInner service) {
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (service == null) {
            throw new IllegalArgumentException("Parameter service is required and cannot be null.");
        }
        Validator.validate(service);
        return service.add(this.client.apiVersion(), service, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServicePropertiesInner>>>() {
                @Override
                public Observable<ServiceResponse<ServicePropertiesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServicePropertiesInner> clientResponse = addDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServicePropertiesInner> addDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ServicePropertiesInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ServicePropertiesInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ServicePropertiesInner&gt; object if successful.
     */
    public PagedList<ServicePropertiesInner> listPremium() {
        ServiceResponse<Page<ServicePropertiesInner>> response = listPremiumSinglePageAsync().toBlocking().single();
        return new PagedList<ServicePropertiesInner>(response.body()) {
            @Override
            public Page<ServicePropertiesInner> nextPage(String nextPageLink) {
                return listPremiumNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServicePropertiesInner>> listPremiumAsync(final ListOperationCallback<ServicePropertiesInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPremiumSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(String nextPageLink) {
                    return listPremiumNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<Page<ServicePropertiesInner>> listPremiumAsync() {
        return listPremiumWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Page<ServicePropertiesInner>>() {
                @Override
                public Page<ServicePropertiesInner> call(ServiceResponse<Page<ServicePropertiesInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listPremiumWithServiceResponseAsync() {
        return listPremiumSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(ServiceResponse<Page<ServicePropertiesInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPremiumNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ServicePropertiesInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listPremiumSinglePageAsync() {
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final String serviceType = null;
        final Integer skipCount = null;
        final Integer takeCount = null;
        return service.listPremium(filter, serviceType, skipCount, takeCount, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServicePropertiesInner>> result = listPremiumDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ServicePropertiesInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the details of services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ServicePropertiesInner&gt; object if successful.
     */
    public PagedList<ServicePropertiesInner> listPremium(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        ServiceResponse<Page<ServicePropertiesInner>> response = listPremiumSinglePageAsync(filter, serviceType, skipCount, takeCount).toBlocking().single();
        return new PagedList<ServicePropertiesInner>(response.body()) {
            @Override
            public Page<ServicePropertiesInner> nextPage(String nextPageLink) {
                return listPremiumNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServicePropertiesInner>> listPremiumAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount, final ListOperationCallback<ServicePropertiesInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPremiumSinglePageAsync(filter, serviceType, skipCount, takeCount),
            new Func1<String, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(String nextPageLink) {
                    return listPremiumNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<Page<ServicePropertiesInner>> listPremiumAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        return listPremiumWithServiceResponseAsync(filter, serviceType, skipCount, takeCount)
            .map(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Page<ServicePropertiesInner>>() {
                @Override
                public Page<ServicePropertiesInner> call(ServiceResponse<Page<ServicePropertiesInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listPremiumWithServiceResponseAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        return listPremiumSinglePageAsync(filter, serviceType, skipCount, takeCount)
            .concatMap(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(ServiceResponse<Page<ServicePropertiesInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPremiumNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param filter The service property filter to apply.
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ServicePropertiesInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listPremiumSinglePageAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listPremium(filter, serviceType, skipCount, takeCount, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServicePropertiesInner>> result = listPremiumDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ServicePropertiesInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ServicePropertiesInner>> listPremiumDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ServicePropertiesInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ServicePropertiesInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of a service for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServicePropertiesInner object if successful.
     */
    public ServicePropertiesInner get(String serviceName) {
        return getWithServiceResponseAsync(serviceName).toBlocking().single().body();
    }

    /**
     * Gets the details of a service for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServicePropertiesInner> getAsync(String serviceName, final ServiceCallback<ServicePropertiesInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(serviceName), serviceCallback);
    }

    /**
     * Gets the details of a service for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePropertiesInner object
     */
    public Observable<ServicePropertiesInner> getAsync(String serviceName) {
        return getWithServiceResponseAsync(serviceName).map(new Func1<ServiceResponse<ServicePropertiesInner>, ServicePropertiesInner>() {
            @Override
            public ServicePropertiesInner call(ServiceResponse<ServicePropertiesInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the details of a service for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePropertiesInner object
     */
    public Observable<ServiceResponse<ServicePropertiesInner>> getWithServiceResponseAsync(String serviceName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(serviceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServicePropertiesInner>>>() {
                @Override
                public Observable<ServiceResponse<ServicePropertiesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServicePropertiesInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServicePropertiesInner> getDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ServicePropertiesInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ServicePropertiesInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String serviceName) {
        deleteWithServiceResponseAsync(serviceName).toBlocking().single().body();
    }

    /**
     * Deletes a service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String serviceName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(serviceName), serviceCallback);
    }

    /**
     * Deletes a service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String serviceName) {
        return deleteWithServiceResponseAsync(serviceName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String serviceName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean confirm = null;
        return service.delete(serviceName, confirm, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param confirm Indicates if the service will be permanently deleted or disabled. True indicates that the service will be permanently deleted and False indicates that the service will be marked disabled and then deleted after 30 days, if it is not re-registered.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String serviceName, Boolean confirm) {
        deleteWithServiceResponseAsync(serviceName, confirm).toBlocking().single().body();
    }

    /**
     * Deletes a service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param confirm Indicates if the service will be permanently deleted or disabled. True indicates that the service will be permanently deleted and False indicates that the service will be marked disabled and then deleted after 30 days, if it is not re-registered.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String serviceName, Boolean confirm, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(serviceName, confirm), serviceCallback);
    }

    /**
     * Deletes a service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param confirm Indicates if the service will be permanently deleted or disabled. True indicates that the service will be permanently deleted and False indicates that the service will be marked disabled and then deleted after 30 days, if it is not re-registered.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String serviceName, Boolean confirm) {
        return deleteWithServiceResponseAsync(serviceName, confirm).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param confirm Indicates if the service will be permanently deleted or disabled. True indicates that the service will be permanently deleted and False indicates that the service will be marked disabled and then deleted after 30 days, if it is not re-registered.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String serviceName, Boolean confirm) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.delete(serviceName, confirm, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the service properties of an onboarded service.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param service The service object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServicePropertiesInner object if successful.
     */
    public ServicePropertiesInner update(String serviceName, ServicePropertiesInner service) {
        return updateWithServiceResponseAsync(serviceName, service).toBlocking().single().body();
    }

    /**
     * Updates the service properties of an onboarded service.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param service The service object.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServicePropertiesInner> updateAsync(String serviceName, ServicePropertiesInner service, final ServiceCallback<ServicePropertiesInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(serviceName, service), serviceCallback);
    }

    /**
     * Updates the service properties of an onboarded service.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param service The service object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePropertiesInner object
     */
    public Observable<ServicePropertiesInner> updateAsync(String serviceName, ServicePropertiesInner service) {
        return updateWithServiceResponseAsync(serviceName, service).map(new Func1<ServiceResponse<ServicePropertiesInner>, ServicePropertiesInner>() {
            @Override
            public ServicePropertiesInner call(ServiceResponse<ServicePropertiesInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the service properties of an onboarded service.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param service The service object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePropertiesInner object
     */
    public Observable<ServiceResponse<ServicePropertiesInner>> updateWithServiceResponseAsync(String serviceName, ServicePropertiesInner service) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (service == null) {
            throw new IllegalArgumentException("Parameter service is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(service);
        return service.update(serviceName, service, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServicePropertiesInner>>>() {
                @Override
                public Observable<ServiceResponse<ServicePropertiesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServicePropertiesInner> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServicePropertiesInner> updateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ServicePropertiesInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ServicePropertiesInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the alerts for a given service.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;AlertInner&gt; object if successful.
     */
    public PagedList<AlertInner> listAlerts(final String serviceName) {
        ServiceResponse<Page<AlertInner>> response = listAlertsSinglePageAsync(serviceName).toBlocking().single();
        return new PagedList<AlertInner>(response.body()) {
            @Override
            public Page<AlertInner> nextPage(String nextPageLink) {
                return listAlertsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the alerts for a given service.
     *
     * @param serviceName The name of the service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AlertInner>> listAlertsAsync(final String serviceName, final ListOperationCallback<AlertInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listAlertsSinglePageAsync(serviceName),
            new Func1<String, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(String nextPageLink) {
                    return listAlertsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the alerts for a given service.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<Page<AlertInner>> listAlertsAsync(final String serviceName) {
        return listAlertsWithServiceResponseAsync(serviceName)
            .map(new Func1<ServiceResponse<Page<AlertInner>>, Page<AlertInner>>() {
                @Override
                public Page<AlertInner> call(ServiceResponse<Page<AlertInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the alerts for a given service.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listAlertsWithServiceResponseAsync(final String serviceName) {
        return listAlertsSinglePageAsync(serviceName)
            .concatMap(new Func1<ServiceResponse<Page<AlertInner>>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(ServiceResponse<Page<AlertInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listAlertsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the alerts for a given service.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;AlertInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listAlertsSinglePageAsync(final String serviceName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final String state = null;
        final DateTime from = null;
        final DateTime to = null;
        return service.listAlerts(serviceName, filter, state, from, to, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AlertInner>> result = listAlertsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AlertInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the alerts for a given service.
     *
     * @param serviceName The name of the service.
     * @param filter The alert property filter to apply.
     * @param state The alert state to query for.
     * @param from The start date to query for.
     * @param to The end date till when to query for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;AlertInner&gt; object if successful.
     */
    public PagedList<AlertInner> listAlerts(final String serviceName, final String filter, final String state, final DateTime from, final DateTime to) {
        ServiceResponse<Page<AlertInner>> response = listAlertsSinglePageAsync(serviceName, filter, state, from, to).toBlocking().single();
        return new PagedList<AlertInner>(response.body()) {
            @Override
            public Page<AlertInner> nextPage(String nextPageLink) {
                return listAlertsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the alerts for a given service.
     *
     * @param serviceName The name of the service.
     * @param filter The alert property filter to apply.
     * @param state The alert state to query for.
     * @param from The start date to query for.
     * @param to The end date till when to query for.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AlertInner>> listAlertsAsync(final String serviceName, final String filter, final String state, final DateTime from, final DateTime to, final ListOperationCallback<AlertInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listAlertsSinglePageAsync(serviceName, filter, state, from, to),
            new Func1<String, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(String nextPageLink) {
                    return listAlertsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the alerts for a given service.
     *
     * @param serviceName The name of the service.
     * @param filter The alert property filter to apply.
     * @param state The alert state to query for.
     * @param from The start date to query for.
     * @param to The end date till when to query for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<Page<AlertInner>> listAlertsAsync(final String serviceName, final String filter, final String state, final DateTime from, final DateTime to) {
        return listAlertsWithServiceResponseAsync(serviceName, filter, state, from, to)
            .map(new Func1<ServiceResponse<Page<AlertInner>>, Page<AlertInner>>() {
                @Override
                public Page<AlertInner> call(ServiceResponse<Page<AlertInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the alerts for a given service.
     *
     * @param serviceName The name of the service.
     * @param filter The alert property filter to apply.
     * @param state The alert state to query for.
     * @param from The start date to query for.
     * @param to The end date till when to query for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listAlertsWithServiceResponseAsync(final String serviceName, final String filter, final String state, final DateTime from, final DateTime to) {
        return listAlertsSinglePageAsync(serviceName, filter, state, from, to)
            .concatMap(new Func1<ServiceResponse<Page<AlertInner>>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(ServiceResponse<Page<AlertInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listAlertsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the alerts for a given service.
     *
    ServiceResponse<PageImpl<AlertInner>> * @param serviceName The name of the service.
    ServiceResponse<PageImpl<AlertInner>> * @param filter The alert property filter to apply.
    ServiceResponse<PageImpl<AlertInner>> * @param state The alert state to query for.
    ServiceResponse<PageImpl<AlertInner>> * @param from The start date to query for.
    ServiceResponse<PageImpl<AlertInner>> * @param to The end date till when to query for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;AlertInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listAlertsSinglePageAsync(final String serviceName, final String filter, final String state, final DateTime from, final DateTime to) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listAlerts(serviceName, filter, state, from, to, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AlertInner>> result = listAlertsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AlertInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<AlertInner>> listAlertsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<AlertInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<AlertInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Checks if the service has all the pre-requisites met to use a feature.
     *
     * @param serviceName The name of the service.
     * @param featureName The name of the feature.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResultInner object if successful.
     */
    public ResultInner getFeatureAvailibility(String serviceName, String featureName) {
        return getFeatureAvailibilityWithServiceResponseAsync(serviceName, featureName).toBlocking().single().body();
    }

    /**
     * Checks if the service has all the pre-requisites met to use a feature.
     *
     * @param serviceName The name of the service.
     * @param featureName The name of the feature.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResultInner> getFeatureAvailibilityAsync(String serviceName, String featureName, final ServiceCallback<ResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(getFeatureAvailibilityWithServiceResponseAsync(serviceName, featureName), serviceCallback);
    }

    /**
     * Checks if the service has all the pre-requisites met to use a feature.
     *
     * @param serviceName The name of the service.
     * @param featureName The name of the feature.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResultInner object
     */
    public Observable<ResultInner> getFeatureAvailibilityAsync(String serviceName, String featureName) {
        return getFeatureAvailibilityWithServiceResponseAsync(serviceName, featureName).map(new Func1<ServiceResponse<ResultInner>, ResultInner>() {
            @Override
            public ResultInner call(ServiceResponse<ResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Checks if the service has all the pre-requisites met to use a feature.
     *
     * @param serviceName The name of the service.
     * @param featureName The name of the feature.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResultInner object
     */
    public Observable<ServiceResponse<ResultInner>> getFeatureAvailibilityWithServiceResponseAsync(String serviceName, String featureName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (featureName == null) {
            throw new IllegalArgumentException("Parameter featureName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getFeatureAvailibility(serviceName, featureName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResultInner>>>() {
                @Override
                public Observable<ServiceResponse<ResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResultInner> clientResponse = getFeatureAvailibilityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ResultInner> getFeatureAvailibilityDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ResultInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ResultInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the count of latest AAD export errors.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ErrorCountInner&gt; object if successful.
     */
    public List<ErrorCountInner> listExportErrors(String serviceName) {
        return listExportErrorsWithServiceResponseAsync(serviceName).toBlocking().single().body();
    }

    /**
     * Gets the count of latest AAD export errors.
     *
     * @param serviceName The name of the service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ErrorCountInner>> listExportErrorsAsync(String serviceName, final ServiceCallback<List<ErrorCountInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listExportErrorsWithServiceResponseAsync(serviceName), serviceCallback);
    }

    /**
     * Gets the count of latest AAD export errors.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ErrorCountInner&gt; object
     */
    public Observable<List<ErrorCountInner>> listExportErrorsAsync(String serviceName) {
        return listExportErrorsWithServiceResponseAsync(serviceName).map(new Func1<ServiceResponse<List<ErrorCountInner>>, List<ErrorCountInner>>() {
            @Override
            public List<ErrorCountInner> call(ServiceResponse<List<ErrorCountInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the count of latest AAD export errors.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ErrorCountInner&gt; object
     */
    public Observable<ServiceResponse<List<ErrorCountInner>>> listExportErrorsWithServiceResponseAsync(String serviceName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listExportErrors(serviceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ErrorCountInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ErrorCountInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<ErrorCountInner>> result = listExportErrorsDelegate(response);
                        List<ErrorCountInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<ErrorCountInner>> clientResponse = new ServiceResponse<List<ErrorCountInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl1<ErrorCountInner>> listExportErrorsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl1<ErrorCountInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl1<ErrorCountInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the categorized export errors.
     *
     * @param serviceName The name of the service.
     * @param errorBucket The error category to query for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;MergedExportErrorInner&gt; object if successful.
     */
    public List<MergedExportErrorInner> listExportErrorsV2(String serviceName, String errorBucket) {
        return listExportErrorsV2WithServiceResponseAsync(serviceName, errorBucket).toBlocking().single().body();
    }

    /**
     * Gets the categorized export errors.
     *
     * @param serviceName The name of the service.
     * @param errorBucket The error category to query for.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<MergedExportErrorInner>> listExportErrorsV2Async(String serviceName, String errorBucket, final ServiceCallback<List<MergedExportErrorInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listExportErrorsV2WithServiceResponseAsync(serviceName, errorBucket), serviceCallback);
    }

    /**
     * Gets the categorized export errors.
     *
     * @param serviceName The name of the service.
     * @param errorBucket The error category to query for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;MergedExportErrorInner&gt; object
     */
    public Observable<List<MergedExportErrorInner>> listExportErrorsV2Async(String serviceName, String errorBucket) {
        return listExportErrorsV2WithServiceResponseAsync(serviceName, errorBucket).map(new Func1<ServiceResponse<List<MergedExportErrorInner>>, List<MergedExportErrorInner>>() {
            @Override
            public List<MergedExportErrorInner> call(ServiceResponse<List<MergedExportErrorInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the categorized export errors.
     *
     * @param serviceName The name of the service.
     * @param errorBucket The error category to query for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;MergedExportErrorInner&gt; object
     */
    public Observable<ServiceResponse<List<MergedExportErrorInner>>> listExportErrorsV2WithServiceResponseAsync(String serviceName, String errorBucket) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (errorBucket == null) {
            throw new IllegalArgumentException("Parameter errorBucket is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listExportErrorsV2(serviceName, errorBucket, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<MergedExportErrorInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<MergedExportErrorInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<MergedExportErrorInner>> result = listExportErrorsV2Delegate(response);
                        List<MergedExportErrorInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<MergedExportErrorInner>> clientResponse = new ServiceResponse<List<MergedExportErrorInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl1<MergedExportErrorInner>> listExportErrorsV2Delegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl1<MergedExportErrorInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl1<MergedExportErrorInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the export status.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ExportStatusInner&gt; object if successful.
     */
    public PagedList<ExportStatusInner> listExportStatus(final String serviceName) {
        ServiceResponse<Page<ExportStatusInner>> response = listExportStatusSinglePageAsync(serviceName).toBlocking().single();
        return new PagedList<ExportStatusInner>(response.body()) {
            @Override
            public Page<ExportStatusInner> nextPage(String nextPageLink) {
                return listExportStatusNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the export status.
     *
     * @param serviceName The name of the service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ExportStatusInner>> listExportStatusAsync(final String serviceName, final ListOperationCallback<ExportStatusInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listExportStatusSinglePageAsync(serviceName),
            new Func1<String, Observable<ServiceResponse<Page<ExportStatusInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ExportStatusInner>>> call(String nextPageLink) {
                    return listExportStatusNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the export status.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ExportStatusInner&gt; object
     */
    public Observable<Page<ExportStatusInner>> listExportStatusAsync(final String serviceName) {
        return listExportStatusWithServiceResponseAsync(serviceName)
            .map(new Func1<ServiceResponse<Page<ExportStatusInner>>, Page<ExportStatusInner>>() {
                @Override
                public Page<ExportStatusInner> call(ServiceResponse<Page<ExportStatusInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the export status.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ExportStatusInner&gt; object
     */
    public Observable<ServiceResponse<Page<ExportStatusInner>>> listExportStatusWithServiceResponseAsync(final String serviceName) {
        return listExportStatusSinglePageAsync(serviceName)
            .concatMap(new Func1<ServiceResponse<Page<ExportStatusInner>>, Observable<ServiceResponse<Page<ExportStatusInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ExportStatusInner>>> call(ServiceResponse<Page<ExportStatusInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listExportStatusNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the export status.
     *
    ServiceResponse<PageImpl<ExportStatusInner>> * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ExportStatusInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ExportStatusInner>>> listExportStatusSinglePageAsync(final String serviceName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listExportStatus(serviceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ExportStatusInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ExportStatusInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ExportStatusInner>> result = listExportStatusDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ExportStatusInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ExportStatusInner>> listExportStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ExportStatusInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ExportStatusInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds an alert feedback submitted by customer.
     *
     * @param serviceName The name of the service.
     * @param alertFeedback The alert feedback.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the AlertFeedbackInner object if successful.
     */
    public AlertFeedbackInner addAlertFeedback(String serviceName, AlertFeedbackInner alertFeedback) {
        return addAlertFeedbackWithServiceResponseAsync(serviceName, alertFeedback).toBlocking().single().body();
    }

    /**
     * Adds an alert feedback submitted by customer.
     *
     * @param serviceName The name of the service.
     * @param alertFeedback The alert feedback.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<AlertFeedbackInner> addAlertFeedbackAsync(String serviceName, AlertFeedbackInner alertFeedback, final ServiceCallback<AlertFeedbackInner> serviceCallback) {
        return ServiceFuture.fromResponse(addAlertFeedbackWithServiceResponseAsync(serviceName, alertFeedback), serviceCallback);
    }

    /**
     * Adds an alert feedback submitted by customer.
     *
     * @param serviceName The name of the service.
     * @param alertFeedback The alert feedback.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AlertFeedbackInner object
     */
    public Observable<AlertFeedbackInner> addAlertFeedbackAsync(String serviceName, AlertFeedbackInner alertFeedback) {
        return addAlertFeedbackWithServiceResponseAsync(serviceName, alertFeedback).map(new Func1<ServiceResponse<AlertFeedbackInner>, AlertFeedbackInner>() {
            @Override
            public AlertFeedbackInner call(ServiceResponse<AlertFeedbackInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds an alert feedback submitted by customer.
     *
     * @param serviceName The name of the service.
     * @param alertFeedback The alert feedback.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AlertFeedbackInner object
     */
    public Observable<ServiceResponse<AlertFeedbackInner>> addAlertFeedbackWithServiceResponseAsync(String serviceName, AlertFeedbackInner alertFeedback) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (alertFeedback == null) {
            throw new IllegalArgumentException("Parameter alertFeedback is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(alertFeedback);
        return service.addAlertFeedback(serviceName, alertFeedback, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<AlertFeedbackInner>>>() {
                @Override
                public Observable<ServiceResponse<AlertFeedbackInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<AlertFeedbackInner> clientResponse = addAlertFeedbackDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<AlertFeedbackInner> addAlertFeedbackDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<AlertFeedbackInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<AlertFeedbackInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a list of all alert feedback for a given tenant and alert type.
     *
     * @param serviceName The name of the service.
     * @param shortName The name of the alert.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;AlertFeedbackInner&gt; object if successful.
     */
    public List<AlertFeedbackInner> listAlertFeedback(String serviceName, String shortName) {
        return listAlertFeedbackWithServiceResponseAsync(serviceName, shortName).toBlocking().single().body();
    }

    /**
     * Gets a list of all alert feedback for a given tenant and alert type.
     *
     * @param serviceName The name of the service.
     * @param shortName The name of the alert.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AlertFeedbackInner>> listAlertFeedbackAsync(String serviceName, String shortName, final ServiceCallback<List<AlertFeedbackInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listAlertFeedbackWithServiceResponseAsync(serviceName, shortName), serviceCallback);
    }

    /**
     * Gets a list of all alert feedback for a given tenant and alert type.
     *
     * @param serviceName The name of the service.
     * @param shortName The name of the alert.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AlertFeedbackInner&gt; object
     */
    public Observable<List<AlertFeedbackInner>> listAlertFeedbackAsync(String serviceName, String shortName) {
        return listAlertFeedbackWithServiceResponseAsync(serviceName, shortName).map(new Func1<ServiceResponse<List<AlertFeedbackInner>>, List<AlertFeedbackInner>>() {
            @Override
            public List<AlertFeedbackInner> call(ServiceResponse<List<AlertFeedbackInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of all alert feedback for a given tenant and alert type.
     *
     * @param serviceName The name of the service.
     * @param shortName The name of the alert.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AlertFeedbackInner&gt; object
     */
    public Observable<ServiceResponse<List<AlertFeedbackInner>>> listAlertFeedbackWithServiceResponseAsync(String serviceName, String shortName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (shortName == null) {
            throw new IllegalArgumentException("Parameter shortName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listAlertFeedback(serviceName, shortName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<AlertFeedbackInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<AlertFeedbackInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<AlertFeedbackInner>> result = listAlertFeedbackDelegate(response);
                        List<AlertFeedbackInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<AlertFeedbackInner>> clientResponse = new ServiceResponse<List<AlertFeedbackInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl1<AlertFeedbackInner>> listAlertFeedbackDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl1<AlertFeedbackInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl1<AlertFeedbackInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MetricSetsInner object if successful.
     */
    public MetricSetsInner getMetrics(String serviceName, String metricName, String groupName) {
        return getMetricsWithServiceResponseAsync(serviceName, metricName, groupName).toBlocking().single().body();
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MetricSetsInner> getMetricsAsync(String serviceName, String metricName, String groupName, final ServiceCallback<MetricSetsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMetricsWithServiceResponseAsync(serviceName, metricName, groupName), serviceCallback);
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<MetricSetsInner> getMetricsAsync(String serviceName, String metricName, String groupName) {
        return getMetricsWithServiceResponseAsync(serviceName, metricName, groupName).map(new Func1<ServiceResponse<MetricSetsInner>, MetricSetsInner>() {
            @Override
            public MetricSetsInner call(ServiceResponse<MetricSetsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<ServiceResponse<MetricSetsInner>> getMetricsWithServiceResponseAsync(String serviceName, String metricName, String groupName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String groupKey = null;
        final DateTime fromDate = null;
        final DateTime toDate = null;
        return service.getMetrics(serviceName, metricName, groupName, groupKey, fromDate, toDate, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MetricSetsInner>>>() {
                @Override
                public Observable<ServiceResponse<MetricSetsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MetricSetsInner> clientResponse = getMetricsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MetricSetsInner object if successful.
     */
    public MetricSetsInner getMetrics(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate) {
        return getMetricsWithServiceResponseAsync(serviceName, metricName, groupName, groupKey, fromDate, toDate).toBlocking().single().body();
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MetricSetsInner> getMetricsAsync(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate, final ServiceCallback<MetricSetsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMetricsWithServiceResponseAsync(serviceName, metricName, groupName, groupKey, fromDate, toDate), serviceCallback);
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<MetricSetsInner> getMetricsAsync(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate) {
        return getMetricsWithServiceResponseAsync(serviceName, metricName, groupName, groupKey, fromDate, toDate).map(new Func1<ServiceResponse<MetricSetsInner>, MetricSetsInner>() {
            @Override
            public MetricSetsInner call(ServiceResponse<MetricSetsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<ServiceResponse<MetricSetsInner>> getMetricsWithServiceResponseAsync(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getMetrics(serviceName, metricName, groupName, groupKey, fromDate, toDate, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MetricSetsInner>>>() {
                @Override
                public Observable<ServiceResponse<MetricSetsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MetricSetsInner> clientResponse = getMetricsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MetricSetsInner> getMetricsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MetricSetsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MetricSetsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ItemInner&gt; object if successful.
     */
    public PagedList<ItemInner> listMetricsAverage(final String serviceName, final String metricName, final String groupName) {
        ServiceResponse<Page<ItemInner>> response = listMetricsAverageSinglePageAsync(serviceName, metricName, groupName).toBlocking().single();
        return new PagedList<ItemInner>(response.body()) {
            @Override
            public Page<ItemInner> nextPage(String nextPageLink) {
                return listMetricsAverageNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ItemInner>> listMetricsAverageAsync(final String serviceName, final String metricName, final String groupName, final ListOperationCallback<ItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsAverageSinglePageAsync(serviceName, metricName, groupName),
            new Func1<String, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(String nextPageLink) {
                    return listMetricsAverageNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<Page<ItemInner>> listMetricsAverageAsync(final String serviceName, final String metricName, final String groupName) {
        return listMetricsAverageWithServiceResponseAsync(serviceName, metricName, groupName)
            .map(new Func1<ServiceResponse<Page<ItemInner>>, Page<ItemInner>>() {
                @Override
                public Page<ItemInner> call(ServiceResponse<Page<ItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsAverageWithServiceResponseAsync(final String serviceName, final String metricName, final String groupName) {
        return listMetricsAverageSinglePageAsync(serviceName, metricName, groupName)
            .concatMap(new Func1<ServiceResponse<Page<ItemInner>>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(ServiceResponse<Page<ItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsAverageNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
    ServiceResponse<PageImpl<ItemInner>> * @param serviceName The name of the service.
    ServiceResponse<PageImpl<ItemInner>> * @param metricName The metric name
    ServiceResponse<PageImpl<ItemInner>> * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsAverageSinglePageAsync(final String serviceName, final String metricName, final String groupName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listMetricsAverage(serviceName, metricName, groupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ItemInner>> result = listMetricsAverageDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ItemInner>> listMetricsAverageDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ItemInner&gt; object if successful.
     */
    public PagedList<ItemInner> listMetricsSum(final String serviceName, final String metricName, final String groupName) {
        ServiceResponse<Page<ItemInner>> response = listMetricsSumSinglePageAsync(serviceName, metricName, groupName).toBlocking().single();
        return new PagedList<ItemInner>(response.body()) {
            @Override
            public Page<ItemInner> nextPage(String nextPageLink) {
                return listMetricsSumNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ItemInner>> listMetricsSumAsync(final String serviceName, final String metricName, final String groupName, final ListOperationCallback<ItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsSumSinglePageAsync(serviceName, metricName, groupName),
            new Func1<String, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(String nextPageLink) {
                    return listMetricsSumNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<Page<ItemInner>> listMetricsSumAsync(final String serviceName, final String metricName, final String groupName) {
        return listMetricsSumWithServiceResponseAsync(serviceName, metricName, groupName)
            .map(new Func1<ServiceResponse<Page<ItemInner>>, Page<ItemInner>>() {
                @Override
                public Page<ItemInner> call(ServiceResponse<Page<ItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsSumWithServiceResponseAsync(final String serviceName, final String metricName, final String groupName) {
        return listMetricsSumSinglePageAsync(serviceName, metricName, groupName)
            .concatMap(new Func1<ServiceResponse<Page<ItemInner>>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(ServiceResponse<Page<ItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsSumNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
    ServiceResponse<PageImpl<ItemInner>> * @param serviceName The name of the service.
    ServiceResponse<PageImpl<ItemInner>> * @param metricName The metric name
    ServiceResponse<PageImpl<ItemInner>> * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsSumSinglePageAsync(final String serviceName, final String metricName, final String groupName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listMetricsSum(serviceName, metricName, groupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ItemInner>> result = listMetricsSumDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ItemInner>> listMetricsSumDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;MetricMetadataInner&gt; object if successful.
     */
    public PagedList<MetricMetadataInner> listMetricMetadata(final String serviceName) {
        ServiceResponse<Page<MetricMetadataInner>> response = listMetricMetadataSinglePageAsync(serviceName).toBlocking().single();
        return new PagedList<MetricMetadataInner>(response.body()) {
            @Override
            public Page<MetricMetadataInner> nextPage(String nextPageLink) {
                return listMetricMetadataNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<MetricMetadataInner>> listMetricMetadataAsync(final String serviceName, final ListOperationCallback<MetricMetadataInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricMetadataSinglePageAsync(serviceName),
            new Func1<String, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(String nextPageLink) {
                    return listMetricMetadataNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MetricMetadataInner&gt; object
     */
    public Observable<Page<MetricMetadataInner>> listMetricMetadataAsync(final String serviceName) {
        return listMetricMetadataWithServiceResponseAsync(serviceName)
            .map(new Func1<ServiceResponse<Page<MetricMetadataInner>>, Page<MetricMetadataInner>>() {
                @Override
                public Page<MetricMetadataInner> call(ServiceResponse<Page<MetricMetadataInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MetricMetadataInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricMetadataInner>>> listMetricMetadataWithServiceResponseAsync(final String serviceName) {
        return listMetricMetadataSinglePageAsync(serviceName)
            .concatMap(new Func1<ServiceResponse<Page<MetricMetadataInner>>, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(ServiceResponse<Page<MetricMetadataInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricMetadataNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;MetricMetadataInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricMetadataInner>>> listMetricMetadataSinglePageAsync(final String serviceName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Boolean perfCounter = null;
        return service.listMetricMetadata(serviceName, filter, perfCounter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricMetadataInner>> result = listMetricMetadataDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricMetadataInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @param filter The metric metadata property filter to apply.
     * @param perfCounter Indicates if only performance counter metrics are requested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;MetricMetadataInner&gt; object if successful.
     */
    public PagedList<MetricMetadataInner> listMetricMetadata(final String serviceName, final String filter, final Boolean perfCounter) {
        ServiceResponse<Page<MetricMetadataInner>> response = listMetricMetadataSinglePageAsync(serviceName, filter, perfCounter).toBlocking().single();
        return new PagedList<MetricMetadataInner>(response.body()) {
            @Override
            public Page<MetricMetadataInner> nextPage(String nextPageLink) {
                return listMetricMetadataNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @param filter The metric metadata property filter to apply.
     * @param perfCounter Indicates if only performance counter metrics are requested.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<MetricMetadataInner>> listMetricMetadataAsync(final String serviceName, final String filter, final Boolean perfCounter, final ListOperationCallback<MetricMetadataInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricMetadataSinglePageAsync(serviceName, filter, perfCounter),
            new Func1<String, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(String nextPageLink) {
                    return listMetricMetadataNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @param filter The metric metadata property filter to apply.
     * @param perfCounter Indicates if only performance counter metrics are requested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MetricMetadataInner&gt; object
     */
    public Observable<Page<MetricMetadataInner>> listMetricMetadataAsync(final String serviceName, final String filter, final Boolean perfCounter) {
        return listMetricMetadataWithServiceResponseAsync(serviceName, filter, perfCounter)
            .map(new Func1<ServiceResponse<Page<MetricMetadataInner>>, Page<MetricMetadataInner>>() {
                @Override
                public Page<MetricMetadataInner> call(ServiceResponse<Page<MetricMetadataInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @param filter The metric metadata property filter to apply.
     * @param perfCounter Indicates if only performance counter metrics are requested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MetricMetadataInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricMetadataInner>>> listMetricMetadataWithServiceResponseAsync(final String serviceName, final String filter, final Boolean perfCounter) {
        return listMetricMetadataSinglePageAsync(serviceName, filter, perfCounter)
            .concatMap(new Func1<ServiceResponse<Page<MetricMetadataInner>>, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(ServiceResponse<Page<MetricMetadataInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricMetadataNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the service related metrics information.
     *
    ServiceResponse<PageImpl<MetricMetadataInner>> * @param serviceName The name of the service.
    ServiceResponse<PageImpl<MetricMetadataInner>> * @param filter The metric metadata property filter to apply.
    ServiceResponse<PageImpl<MetricMetadataInner>> * @param perfCounter Indicates if only performance counter metrics are requested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;MetricMetadataInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricMetadataInner>>> listMetricMetadataSinglePageAsync(final String serviceName, final String filter, final Boolean perfCounter) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listMetricMetadata(serviceName, filter, perfCounter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricMetadataInner>> result = listMetricMetadataDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricMetadataInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricMetadataInner>> listMetricMetadataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<MetricMetadataInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<MetricMetadataInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MetricMetadataInner object if successful.
     */
    public MetricMetadataInner getMetricMetadata(String serviceName, String metricName) {
        return getMetricMetadataWithServiceResponseAsync(serviceName, metricName).toBlocking().single().body();
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MetricMetadataInner> getMetricMetadataAsync(String serviceName, String metricName, final ServiceCallback<MetricMetadataInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMetricMetadataWithServiceResponseAsync(serviceName, metricName), serviceCallback);
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricMetadataInner object
     */
    public Observable<MetricMetadataInner> getMetricMetadataAsync(String serviceName, String metricName) {
        return getMetricMetadataWithServiceResponseAsync(serviceName, metricName).map(new Func1<ServiceResponse<MetricMetadataInner>, MetricMetadataInner>() {
            @Override
            public MetricMetadataInner call(ServiceResponse<MetricMetadataInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricMetadataInner object
     */
    public Observable<ServiceResponse<MetricMetadataInner>> getMetricMetadataWithServiceResponseAsync(String serviceName, String metricName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getMetricMetadata(serviceName, metricName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MetricMetadataInner>>>() {
                @Override
                public Observable<ServiceResponse<MetricMetadataInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MetricMetadataInner> clientResponse = getMetricMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MetricMetadataInner> getMetricMetadataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MetricMetadataInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MetricMetadataInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MetricSetsInner object if successful.
     */
    public MetricSetsInner getMetricMetadataForGroup(String serviceName, String metricName, String groupName) {
        return getMetricMetadataForGroupWithServiceResponseAsync(serviceName, metricName, groupName).toBlocking().single().body();
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MetricSetsInner> getMetricMetadataForGroupAsync(String serviceName, String metricName, String groupName, final ServiceCallback<MetricSetsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMetricMetadataForGroupWithServiceResponseAsync(serviceName, metricName, groupName), serviceCallback);
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<MetricSetsInner> getMetricMetadataForGroupAsync(String serviceName, String metricName, String groupName) {
        return getMetricMetadataForGroupWithServiceResponseAsync(serviceName, metricName, groupName).map(new Func1<ServiceResponse<MetricSetsInner>, MetricSetsInner>() {
            @Override
            public MetricSetsInner call(ServiceResponse<MetricSetsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<ServiceResponse<MetricSetsInner>> getMetricMetadataForGroupWithServiceResponseAsync(String serviceName, String metricName, String groupName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String groupKey = null;
        final DateTime fromDate = null;
        final DateTime toDate = null;
        return service.getMetricMetadataForGroup(serviceName, metricName, groupName, groupKey, fromDate, toDate, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MetricSetsInner>>>() {
                @Override
                public Observable<ServiceResponse<MetricSetsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MetricSetsInner> clientResponse = getMetricMetadataForGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MetricSetsInner object if successful.
     */
    public MetricSetsInner getMetricMetadataForGroup(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate) {
        return getMetricMetadataForGroupWithServiceResponseAsync(serviceName, metricName, groupName, groupKey, fromDate, toDate).toBlocking().single().body();
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MetricSetsInner> getMetricMetadataForGroupAsync(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate, final ServiceCallback<MetricSetsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMetricMetadataForGroupWithServiceResponseAsync(serviceName, metricName, groupName, groupKey, fromDate, toDate), serviceCallback);
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<MetricSetsInner> getMetricMetadataForGroupAsync(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate) {
        return getMetricMetadataForGroupWithServiceResponseAsync(serviceName, metricName, groupName, groupKey, fromDate, toDate).map(new Func1<ServiceResponse<MetricSetsInner>, MetricSetsInner>() {
            @Override
            public MetricSetsInner call(ServiceResponse<MetricSetsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<ServiceResponse<MetricSetsInner>> getMetricMetadataForGroupWithServiceResponseAsync(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getMetricMetadataForGroup(serviceName, metricName, groupName, groupKey, fromDate, toDate, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MetricSetsInner>>>() {
                @Override
                public Observable<ServiceResponse<MetricSetsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MetricSetsInner> clientResponse = getMetricMetadataForGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MetricSetsInner> getMetricMetadataForGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MetricSetsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MetricSetsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the service level monitoring configuration.
     *
     * @param serviceName The name of the service.
     * @param configurationSetting The monitoring configuration to update
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateMonitoringConfiguration(String serviceName, ItemInner configurationSetting) {
        updateMonitoringConfigurationWithServiceResponseAsync(serviceName, configurationSetting).toBlocking().single().body();
    }

    /**
     * Updates the service level monitoring configuration.
     *
     * @param serviceName The name of the service.
     * @param configurationSetting The monitoring configuration to update
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateMonitoringConfigurationAsync(String serviceName, ItemInner configurationSetting, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateMonitoringConfigurationWithServiceResponseAsync(serviceName, configurationSetting), serviceCallback);
    }

    /**
     * Updates the service level monitoring configuration.
     *
     * @param serviceName The name of the service.
     * @param configurationSetting The monitoring configuration to update
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateMonitoringConfigurationAsync(String serviceName, ItemInner configurationSetting) {
        return updateMonitoringConfigurationWithServiceResponseAsync(serviceName, configurationSetting).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the service level monitoring configuration.
     *
     * @param serviceName The name of the service.
     * @param configurationSetting The monitoring configuration to update
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateMonitoringConfigurationWithServiceResponseAsync(String serviceName, ItemInner configurationSetting) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (configurationSetting == null) {
            throw new IllegalArgumentException("Parameter configurationSetting is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(configurationSetting);
        return service.updateMonitoringConfiguration(serviceName, configurationSetting, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateMonitoringConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateMonitoringConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the service level monitoring configurations.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ItemInner&gt; object if successful.
     */
    public List<ItemInner> listMonitoringConfigurations(String serviceName) {
        return listMonitoringConfigurationsWithServiceResponseAsync(serviceName).toBlocking().single().body();
    }

    /**
     * Gets the service level monitoring configurations.
     *
     * @param serviceName The name of the service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ItemInner>> listMonitoringConfigurationsAsync(String serviceName, final ServiceCallback<List<ItemInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listMonitoringConfigurationsWithServiceResponseAsync(serviceName), serviceCallback);
    }

    /**
     * Gets the service level monitoring configurations.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ItemInner&gt; object
     */
    public Observable<List<ItemInner>> listMonitoringConfigurationsAsync(String serviceName) {
        return listMonitoringConfigurationsWithServiceResponseAsync(serviceName).map(new Func1<ServiceResponse<List<ItemInner>>, List<ItemInner>>() {
            @Override
            public List<ItemInner> call(ServiceResponse<List<ItemInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the service level monitoring configurations.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ItemInner&gt; object
     */
    public Observable<ServiceResponse<List<ItemInner>>> listMonitoringConfigurationsWithServiceResponseAsync(String serviceName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listMonitoringConfigurations(serviceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<ItemInner>> result = listMonitoringConfigurationsDelegate(response);
                        List<ItemInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<ItemInner>> clientResponse = new ServiceResponse<List<ItemInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl1<ItemInner>> listMonitoringConfigurationsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl1<ItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl1<ItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the bad password login attempt report for an user.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ErrorReportUsersEntryInner&gt; object if successful.
     */
    public List<ErrorReportUsersEntryInner> listUserBadPasswordReport(String serviceName) {
        return listUserBadPasswordReportWithServiceResponseAsync(serviceName).toBlocking().single().body();
    }

    /**
     * Gets the bad password login attempt report for an user.
     *
     * @param serviceName The name of the service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ErrorReportUsersEntryInner>> listUserBadPasswordReportAsync(String serviceName, final ServiceCallback<List<ErrorReportUsersEntryInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listUserBadPasswordReportWithServiceResponseAsync(serviceName), serviceCallback);
    }

    /**
     * Gets the bad password login attempt report for an user.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ErrorReportUsersEntryInner&gt; object
     */
    public Observable<List<ErrorReportUsersEntryInner>> listUserBadPasswordReportAsync(String serviceName) {
        return listUserBadPasswordReportWithServiceResponseAsync(serviceName).map(new Func1<ServiceResponse<List<ErrorReportUsersEntryInner>>, List<ErrorReportUsersEntryInner>>() {
            @Override
            public List<ErrorReportUsersEntryInner> call(ServiceResponse<List<ErrorReportUsersEntryInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the bad password login attempt report for an user.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ErrorReportUsersEntryInner&gt; object
     */
    public Observable<ServiceResponse<List<ErrorReportUsersEntryInner>>> listUserBadPasswordReportWithServiceResponseAsync(String serviceName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String dataSource = null;
        return service.listUserBadPasswordReport(serviceName, dataSource, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ErrorReportUsersEntryInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ErrorReportUsersEntryInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<ErrorReportUsersEntryInner>> result = listUserBadPasswordReportDelegate(response);
                        List<ErrorReportUsersEntryInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<ErrorReportUsersEntryInner>> clientResponse = new ServiceResponse<List<ErrorReportUsersEntryInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the bad password login attempt report for an user.
     *
     * @param serviceName The name of the service.
     * @param dataSource The source of data, if its test data or customer data.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ErrorReportUsersEntryInner&gt; object if successful.
     */
    public List<ErrorReportUsersEntryInner> listUserBadPasswordReport(String serviceName, String dataSource) {
        return listUserBadPasswordReportWithServiceResponseAsync(serviceName, dataSource).toBlocking().single().body();
    }

    /**
     * Gets the bad password login attempt report for an user.
     *
     * @param serviceName The name of the service.
     * @param dataSource The source of data, if its test data or customer data.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ErrorReportUsersEntryInner>> listUserBadPasswordReportAsync(String serviceName, String dataSource, final ServiceCallback<List<ErrorReportUsersEntryInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listUserBadPasswordReportWithServiceResponseAsync(serviceName, dataSource), serviceCallback);
    }

    /**
     * Gets the bad password login attempt report for an user.
     *
     * @param serviceName The name of the service.
     * @param dataSource The source of data, if its test data or customer data.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ErrorReportUsersEntryInner&gt; object
     */
    public Observable<List<ErrorReportUsersEntryInner>> listUserBadPasswordReportAsync(String serviceName, String dataSource) {
        return listUserBadPasswordReportWithServiceResponseAsync(serviceName, dataSource).map(new Func1<ServiceResponse<List<ErrorReportUsersEntryInner>>, List<ErrorReportUsersEntryInner>>() {
            @Override
            public List<ErrorReportUsersEntryInner> call(ServiceResponse<List<ErrorReportUsersEntryInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the bad password login attempt report for an user.
     *
     * @param serviceName The name of the service.
     * @param dataSource The source of data, if its test data or customer data.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ErrorReportUsersEntryInner&gt; object
     */
    public Observable<ServiceResponse<List<ErrorReportUsersEntryInner>>> listUserBadPasswordReportWithServiceResponseAsync(String serviceName, String dataSource) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listUserBadPasswordReport(serviceName, dataSource, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ErrorReportUsersEntryInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ErrorReportUsersEntryInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<ErrorReportUsersEntryInner>> result = listUserBadPasswordReportDelegate(response);
                        List<ErrorReportUsersEntryInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<ErrorReportUsersEntryInner>> clientResponse = new ServiceResponse<List<ErrorReportUsersEntryInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl1<ErrorReportUsersEntryInner>> listUserBadPasswordReportDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl1<ErrorReportUsersEntryInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl1<ErrorReportUsersEntryInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Checks if the tenant, to which a service is registered, is whitelisted to use a feature.
     *
     * @param serviceName The name of the service.
     * @param featureName The name of the feature.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResultInner object if successful.
     */
    public ResultInner getTenantWhitelisting(String serviceName, String featureName) {
        return getTenantWhitelistingWithServiceResponseAsync(serviceName, featureName).toBlocking().single().body();
    }

    /**
     * Checks if the tenant, to which a service is registered, is whitelisted to use a feature.
     *
     * @param serviceName The name of the service.
     * @param featureName The name of the feature.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResultInner> getTenantWhitelistingAsync(String serviceName, String featureName, final ServiceCallback<ResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(getTenantWhitelistingWithServiceResponseAsync(serviceName, featureName), serviceCallback);
    }

    /**
     * Checks if the tenant, to which a service is registered, is whitelisted to use a feature.
     *
     * @param serviceName The name of the service.
     * @param featureName The name of the feature.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResultInner object
     */
    public Observable<ResultInner> getTenantWhitelistingAsync(String serviceName, String featureName) {
        return getTenantWhitelistingWithServiceResponseAsync(serviceName, featureName).map(new Func1<ServiceResponse<ResultInner>, ResultInner>() {
            @Override
            public ResultInner call(ServiceResponse<ResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Checks if the tenant, to which a service is registered, is whitelisted to use a feature.
     *
     * @param serviceName The name of the service.
     * @param featureName The name of the feature.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResultInner object
     */
    public Observable<ServiceResponse<ResultInner>> getTenantWhitelistingWithServiceResponseAsync(String serviceName, String featureName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (featureName == null) {
            throw new IllegalArgumentException("Parameter featureName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getTenantWhitelisting(serviceName, featureName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResultInner>>>() {
                @Override
                public Observable<ServiceResponse<ResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResultInner> clientResponse = getTenantWhitelistingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ResultInner> getTenantWhitelistingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ResultInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ResultInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of services, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ServicePropertiesInner&gt; object if successful.
     */
    public PagedList<ServicePropertiesInner> listNext(final String nextPageLink) {
        ServiceResponse<Page<ServicePropertiesInner>> response = listNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ServicePropertiesInner>(response.body()) {
            @Override
            public Page<ServicePropertiesInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of services, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServicePropertiesInner>> listNextAsync(final String nextPageLink, final ServiceFuture<List<ServicePropertiesInner>> serviceFuture, final ListOperationCallback<ServicePropertiesInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of services, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<Page<ServicePropertiesInner>> listNextAsync(final String nextPageLink) {
        return listNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Page<ServicePropertiesInner>>() {
                @Override
                public Page<ServicePropertiesInner> call(ServiceResponse<Page<ServicePropertiesInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of services, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listNextWithServiceResponseAsync(final String nextPageLink) {
        return listNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(ServiceResponse<Page<ServicePropertiesInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of services, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ServicePropertiesInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServicePropertiesInner>> result = listNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ServicePropertiesInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ServicePropertiesInner>> listNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ServicePropertiesInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ServicePropertiesInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ServicePropertiesInner&gt; object if successful.
     */
    public PagedList<ServicePropertiesInner> listPremiumNext(final String nextPageLink) {
        ServiceResponse<Page<ServicePropertiesInner>> response = listPremiumNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ServicePropertiesInner>(response.body()) {
            @Override
            public Page<ServicePropertiesInner> nextPage(String nextPageLink) {
                return listPremiumNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServicePropertiesInner>> listPremiumNextAsync(final String nextPageLink, final ServiceFuture<List<ServicePropertiesInner>> serviceFuture, final ListOperationCallback<ServicePropertiesInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPremiumNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(String nextPageLink) {
                    return listPremiumNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<Page<ServicePropertiesInner>> listPremiumNextAsync(final String nextPageLink) {
        return listPremiumNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Page<ServicePropertiesInner>>() {
                @Override
                public Page<ServicePropertiesInner> call(ServiceResponse<Page<ServicePropertiesInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listPremiumNextWithServiceResponseAsync(final String nextPageLink) {
        return listPremiumNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(ServiceResponse<Page<ServicePropertiesInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPremiumNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ServicePropertiesInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listPremiumNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listPremiumNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServicePropertiesInner>> result = listPremiumNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ServicePropertiesInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ServicePropertiesInner>> listPremiumNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ServicePropertiesInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ServicePropertiesInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the alerts for a given service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;AlertInner&gt; object if successful.
     */
    public PagedList<AlertInner> listAlertsNext(final String nextPageLink) {
        ServiceResponse<Page<AlertInner>> response = listAlertsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<AlertInner>(response.body()) {
            @Override
            public Page<AlertInner> nextPage(String nextPageLink) {
                return listAlertsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the alerts for a given service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AlertInner>> listAlertsNextAsync(final String nextPageLink, final ServiceFuture<List<AlertInner>> serviceFuture, final ListOperationCallback<AlertInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listAlertsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(String nextPageLink) {
                    return listAlertsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the alerts for a given service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<Page<AlertInner>> listAlertsNextAsync(final String nextPageLink) {
        return listAlertsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<AlertInner>>, Page<AlertInner>>() {
                @Override
                public Page<AlertInner> call(ServiceResponse<Page<AlertInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the alerts for a given service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listAlertsNextWithServiceResponseAsync(final String nextPageLink) {
        return listAlertsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<AlertInner>>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(ServiceResponse<Page<AlertInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listAlertsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the alerts for a given service.
     *
    ServiceResponse<PageImpl<AlertInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;AlertInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listAlertsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listAlertsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AlertInner>> result = listAlertsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AlertInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<AlertInner>> listAlertsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<AlertInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<AlertInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the export status.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ExportStatusInner&gt; object if successful.
     */
    public PagedList<ExportStatusInner> listExportStatusNext(final String nextPageLink) {
        ServiceResponse<Page<ExportStatusInner>> response = listExportStatusNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ExportStatusInner>(response.body()) {
            @Override
            public Page<ExportStatusInner> nextPage(String nextPageLink) {
                return listExportStatusNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the export status.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ExportStatusInner>> listExportStatusNextAsync(final String nextPageLink, final ServiceFuture<List<ExportStatusInner>> serviceFuture, final ListOperationCallback<ExportStatusInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listExportStatusNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ExportStatusInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ExportStatusInner>>> call(String nextPageLink) {
                    return listExportStatusNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the export status.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ExportStatusInner&gt; object
     */
    public Observable<Page<ExportStatusInner>> listExportStatusNextAsync(final String nextPageLink) {
        return listExportStatusNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ExportStatusInner>>, Page<ExportStatusInner>>() {
                @Override
                public Page<ExportStatusInner> call(ServiceResponse<Page<ExportStatusInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the export status.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ExportStatusInner&gt; object
     */
    public Observable<ServiceResponse<Page<ExportStatusInner>>> listExportStatusNextWithServiceResponseAsync(final String nextPageLink) {
        return listExportStatusNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ExportStatusInner>>, Observable<ServiceResponse<Page<ExportStatusInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ExportStatusInner>>> call(ServiceResponse<Page<ExportStatusInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listExportStatusNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the export status.
     *
    ServiceResponse<PageImpl<ExportStatusInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ExportStatusInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ExportStatusInner>>> listExportStatusNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listExportStatusNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ExportStatusInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ExportStatusInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ExportStatusInner>> result = listExportStatusNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ExportStatusInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ExportStatusInner>> listExportStatusNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ExportStatusInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ExportStatusInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ItemInner&gt; object if successful.
     */
    public PagedList<ItemInner> listMetricsAverageNext(final String nextPageLink) {
        ServiceResponse<Page<ItemInner>> response = listMetricsAverageNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ItemInner>(response.body()) {
            @Override
            public Page<ItemInner> nextPage(String nextPageLink) {
                return listMetricsAverageNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ItemInner>> listMetricsAverageNextAsync(final String nextPageLink, final ServiceFuture<List<ItemInner>> serviceFuture, final ListOperationCallback<ItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsAverageNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(String nextPageLink) {
                    return listMetricsAverageNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<Page<ItemInner>> listMetricsAverageNextAsync(final String nextPageLink) {
        return listMetricsAverageNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ItemInner>>, Page<ItemInner>>() {
                @Override
                public Page<ItemInner> call(ServiceResponse<Page<ItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsAverageNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricsAverageNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ItemInner>>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(ServiceResponse<Page<ItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsAverageNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
    ServiceResponse<PageImpl<ItemInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsAverageNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listMetricsAverageNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ItemInner>> result = listMetricsAverageNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ItemInner>> listMetricsAverageNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ItemInner&gt; object if successful.
     */
    public PagedList<ItemInner> listMetricsSumNext(final String nextPageLink) {
        ServiceResponse<Page<ItemInner>> response = listMetricsSumNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ItemInner>(response.body()) {
            @Override
            public Page<ItemInner> nextPage(String nextPageLink) {
                return listMetricsSumNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ItemInner>> listMetricsSumNextAsync(final String nextPageLink, final ServiceFuture<List<ItemInner>> serviceFuture, final ListOperationCallback<ItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsSumNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(String nextPageLink) {
                    return listMetricsSumNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<Page<ItemInner>> listMetricsSumNextAsync(final String nextPageLink) {
        return listMetricsSumNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ItemInner>>, Page<ItemInner>>() {
                @Override
                public Page<ItemInner> call(ServiceResponse<Page<ItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsSumNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricsSumNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ItemInner>>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(ServiceResponse<Page<ItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsSumNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
    ServiceResponse<PageImpl<ItemInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsSumNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listMetricsSumNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ItemInner>> result = listMetricsSumNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ItemInner>> listMetricsSumNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the service related metrics information.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;MetricMetadataInner&gt; object if successful.
     */
    public PagedList<MetricMetadataInner> listMetricMetadataNext(final String nextPageLink) {
        ServiceResponse<Page<MetricMetadataInner>> response = listMetricMetadataNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<MetricMetadataInner>(response.body()) {
            @Override
            public Page<MetricMetadataInner> nextPage(String nextPageLink) {
                return listMetricMetadataNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the service related metrics information.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<MetricMetadataInner>> listMetricMetadataNextAsync(final String nextPageLink, final ServiceFuture<List<MetricMetadataInner>> serviceFuture, final ListOperationCallback<MetricMetadataInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricMetadataNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(String nextPageLink) {
                    return listMetricMetadataNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the service related metrics information.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MetricMetadataInner&gt; object
     */
    public Observable<Page<MetricMetadataInner>> listMetricMetadataNextAsync(final String nextPageLink) {
        return listMetricMetadataNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<MetricMetadataInner>>, Page<MetricMetadataInner>>() {
                @Override
                public Page<MetricMetadataInner> call(ServiceResponse<Page<MetricMetadataInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the service related metrics information.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MetricMetadataInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricMetadataInner>>> listMetricMetadataNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricMetadataNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<MetricMetadataInner>>, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(ServiceResponse<Page<MetricMetadataInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricMetadataNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the service related metrics information.
     *
    ServiceResponse<PageImpl<MetricMetadataInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;MetricMetadataInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricMetadataInner>>> listMetricMetadataNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listMetricMetadataNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricMetadataInner>> result = listMetricMetadataNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricMetadataInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricMetadataInner>> listMetricMetadataNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<MetricMetadataInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<MetricMetadataInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
