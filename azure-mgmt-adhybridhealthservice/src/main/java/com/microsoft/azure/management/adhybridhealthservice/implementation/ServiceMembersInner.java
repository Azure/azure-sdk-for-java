/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.adhybridhealthservice.implementation;

import com.microsoft.azure.arm.collection.InnerSupportsDelete;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import java.util.UUID;
import okhttp3.ResponseBody;
import org.joda.time.DateTime;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in ServiceMembers.
 */
public class ServiceMembersInner implements InnerSupportsDelete<Void> {
    /** The Retrofit service to perform REST calls. */
    private ServiceMembersService service;
    /** The service client containing this operation class. */
    private ADHybridHealthServiceImpl client;

    /**
     * Initializes an instance of ServiceMembersInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ServiceMembersInner(Retrofit retrofit, ADHybridHealthServiceImpl client) {
        this.service = retrofit.create(ServiceMembersService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for ServiceMembers to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ServiceMembersService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers list" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/servicemembers")
        Observable<Response<ResponseBody>> list(@Path("serviceName") String serviceName, @Query("$filter") String filter, @Query("dimensionType") String dimensionType, @Query("dimensionSignature") String dimensionSignature, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers add" })
        @POST("providers/Microsoft.ADHybridHealthService/services/{serviceName}/servicemembers")
        Observable<Response<ResponseBody>> add(@Path("serviceName") String serviceName, @Body ServiceMemberInner serviceMember, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers get" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/servicemembers/{serviceMemberId}")
        Observable<Response<ResponseBody>> get(@Path("serviceName") String serviceName, @Path("serviceMemberId") UUID serviceMemberId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers delete" })
        @HTTP(path = "providers/Microsoft.ADHybridHealthService/services/{serviceName}/servicemembers/{serviceMemberId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("serviceName") String serviceName, @Path("serviceMemberId") UUID serviceMemberId, @Query("confirm") Boolean confirm, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers listAlerts" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/servicemembers/{serviceMemberId}/alerts")
        Observable<Response<ResponseBody>> listAlerts(@Path("serviceMemberId") UUID serviceMemberId, @Path("serviceName") String serviceName, @Query("$filter") String filter, @Query("state") String state, @Query("from") DateTime from, @Query("to") DateTime to, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers listConnectors" })
        @GET("providers/Microsoft.ADHybridHealthService/service/{serviceName}/servicemembers/{serviceMemberId}/connectors")
        Observable<Response<ResponseBody>> listConnectors(@Path("serviceName") String serviceName, @Path("serviceMemberId") UUID serviceMemberId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers listCredentials" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/servicemembers/{serviceMemberId}/credentials")
        Observable<Response<ResponseBody>> listCredentials(@Path("serviceName") String serviceName, @Path("serviceMemberId") UUID serviceMemberId, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers deleteData" })
        @HTTP(path = "providers/Microsoft.ADHybridHealthService/services/{serviceName}/servicemembers/{serviceMemberId}/data", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteData(@Path("serviceName") String serviceName, @Path("serviceMemberId") UUID serviceMemberId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers listDataFreshness" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/servicemembers/{serviceMemberId}/datafreshness")
        Observable<Response<ResponseBody>> listDataFreshness(@Path("serviceName") String serviceName, @Path("serviceMemberId") UUID serviceMemberId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers listExportStatus" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/servicemembers/{serviceMemberId}/exportstatus")
        Observable<Response<ResponseBody>> listExportStatus(@Path("serviceName") String serviceName, @Path("serviceMemberId") UUID serviceMemberId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers listGlobalConfiguration" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/servicemembers/{serviceMemberId}/globalconfiguration")
        Observable<Response<ResponseBody>> listGlobalConfiguration(@Path("serviceName") String serviceName, @Path("serviceMemberId") String serviceMemberId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers getMetrics" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/servicemembers/{serviceMemberId}/metrics/{metricName}/groups/{groupName}")
        Observable<Response<ResponseBody>> getMetrics(@Path("serviceName") String serviceName, @Path("metricName") String metricName, @Path("groupName") String groupName, @Path("serviceMemberId") UUID serviceMemberId, @Query("groupKey") String groupKey, @Query("fromDate") DateTime fromDate, @Query("toDate") DateTime toDate, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers getServiceConfiguration" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/servicemembers/{serviceMemberId}/serviceconfiguration")
        Observable<Response<ResponseBody>> getServiceConfiguration(@Path("serviceName") String serviceName, @Path("serviceMemberId") String serviceMemberId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers getConnectorMetadata" })
        @GET("providers/Microsoft.ADHybridHealthService/services/{serviceName}/servicemembers/{serviceMemberId}/metrics/{metricName}")
        Observable<Response<ResponseBody>> getConnectorMetadata(@Path("serviceName") String serviceName, @Path("serviceMemberId") UUID serviceMemberId, @Path("metricName") String metricName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers listNext" })
        @GET
        Observable<Response<ResponseBody>> listNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers listAlertsNext" })
        @GET
        Observable<Response<ResponseBody>> listAlertsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.ServiceMembers listExportStatusNext" })
        @GET
        Observable<Response<ResponseBody>> listExportStatusNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Gets the details of the servers, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ServiceMemberInner&gt; object if successful.
     */
    public PagedList<ServiceMemberInner> list(final String serviceName) {
        ServiceResponse<Page<ServiceMemberInner>> response = listSinglePageAsync(serviceName).toBlocking().single();
        return new PagedList<ServiceMemberInner>(response.body()) {
            @Override
            public Page<ServiceMemberInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of the servers, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServiceMemberInner>> listAsync(final String serviceName, final ListOperationCallback<ServiceMemberInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(serviceName),
            new Func1<String, Observable<ServiceResponse<Page<ServiceMemberInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServiceMemberInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of the servers, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServiceMemberInner&gt; object
     */
    public Observable<Page<ServiceMemberInner>> listAsync(final String serviceName) {
        return listWithServiceResponseAsync(serviceName)
            .map(new Func1<ServiceResponse<Page<ServiceMemberInner>>, Page<ServiceMemberInner>>() {
                @Override
                public Page<ServiceMemberInner> call(ServiceResponse<Page<ServiceMemberInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of the servers, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServiceMemberInner&gt; object
     */
    public Observable<ServiceResponse<Page<ServiceMemberInner>>> listWithServiceResponseAsync(final String serviceName) {
        return listSinglePageAsync(serviceName)
            .concatMap(new Func1<ServiceResponse<Page<ServiceMemberInner>>, Observable<ServiceResponse<Page<ServiceMemberInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServiceMemberInner>>> call(ServiceResponse<Page<ServiceMemberInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of the servers, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ServiceMemberInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ServiceMemberInner>>> listSinglePageAsync(final String serviceName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final String dimensionType = null;
        final String dimensionSignature = null;
        return service.list(serviceName, filter, dimensionType, dimensionSignature, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ServiceMemberInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServiceMemberInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServiceMemberInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ServiceMemberInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the details of the servers, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param filter The server property filter to apply.
     * @param dimensionType The server specific dimension.
     * @param dimensionSignature The value of the dimension.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ServiceMemberInner&gt; object if successful.
     */
    public PagedList<ServiceMemberInner> list(final String serviceName, final String filter, final String dimensionType, final String dimensionSignature) {
        ServiceResponse<Page<ServiceMemberInner>> response = listSinglePageAsync(serviceName, filter, dimensionType, dimensionSignature).toBlocking().single();
        return new PagedList<ServiceMemberInner>(response.body()) {
            @Override
            public Page<ServiceMemberInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of the servers, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param filter The server property filter to apply.
     * @param dimensionType The server specific dimension.
     * @param dimensionSignature The value of the dimension.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServiceMemberInner>> listAsync(final String serviceName, final String filter, final String dimensionType, final String dimensionSignature, final ListOperationCallback<ServiceMemberInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(serviceName, filter, dimensionType, dimensionSignature),
            new Func1<String, Observable<ServiceResponse<Page<ServiceMemberInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServiceMemberInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of the servers, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param filter The server property filter to apply.
     * @param dimensionType The server specific dimension.
     * @param dimensionSignature The value of the dimension.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServiceMemberInner&gt; object
     */
    public Observable<Page<ServiceMemberInner>> listAsync(final String serviceName, final String filter, final String dimensionType, final String dimensionSignature) {
        return listWithServiceResponseAsync(serviceName, filter, dimensionType, dimensionSignature)
            .map(new Func1<ServiceResponse<Page<ServiceMemberInner>>, Page<ServiceMemberInner>>() {
                @Override
                public Page<ServiceMemberInner> call(ServiceResponse<Page<ServiceMemberInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of the servers, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param filter The server property filter to apply.
     * @param dimensionType The server specific dimension.
     * @param dimensionSignature The value of the dimension.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServiceMemberInner&gt; object
     */
    public Observable<ServiceResponse<Page<ServiceMemberInner>>> listWithServiceResponseAsync(final String serviceName, final String filter, final String dimensionType, final String dimensionSignature) {
        return listSinglePageAsync(serviceName, filter, dimensionType, dimensionSignature)
            .concatMap(new Func1<ServiceResponse<Page<ServiceMemberInner>>, Observable<ServiceResponse<Page<ServiceMemberInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServiceMemberInner>>> call(ServiceResponse<Page<ServiceMemberInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of the servers, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
    ServiceResponse<PageImpl<ServiceMemberInner>> * @param serviceName The name of the service.
    ServiceResponse<PageImpl<ServiceMemberInner>> * @param filter The server property filter to apply.
    ServiceResponse<PageImpl<ServiceMemberInner>> * @param dimensionType The server specific dimension.
    ServiceResponse<PageImpl<ServiceMemberInner>> * @param dimensionSignature The value of the dimension.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ServiceMemberInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ServiceMemberInner>>> listSinglePageAsync(final String serviceName, final String filter, final String dimensionType, final String dimensionSignature) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.list(serviceName, filter, dimensionType, dimensionSignature, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ServiceMemberInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServiceMemberInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServiceMemberInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ServiceMemberInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ServiceMemberInner>> listDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ServiceMemberInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ServiceMemberInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Onboards  a server, for a given service, to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service under which the server is to be onboarded.
     * @param serviceMember The server object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceMemberInner object if successful.
     */
    public ServiceMemberInner add(String serviceName, ServiceMemberInner serviceMember) {
        return addWithServiceResponseAsync(serviceName, serviceMember).toBlocking().single().body();
    }

    /**
     * Onboards  a server, for a given service, to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service under which the server is to be onboarded.
     * @param serviceMember The server object.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceMemberInner> addAsync(String serviceName, ServiceMemberInner serviceMember, final ServiceCallback<ServiceMemberInner> serviceCallback) {
        return ServiceFuture.fromResponse(addWithServiceResponseAsync(serviceName, serviceMember), serviceCallback);
    }

    /**
     * Onboards  a server, for a given service, to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service under which the server is to be onboarded.
     * @param serviceMember The server object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceMemberInner object
     */
    public Observable<ServiceMemberInner> addAsync(String serviceName, ServiceMemberInner serviceMember) {
        return addWithServiceResponseAsync(serviceName, serviceMember).map(new Func1<ServiceResponse<ServiceMemberInner>, ServiceMemberInner>() {
            @Override
            public ServiceMemberInner call(ServiceResponse<ServiceMemberInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Onboards  a server, for a given service, to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service under which the server is to be onboarded.
     * @param serviceMember The server object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceMemberInner object
     */
    public Observable<ServiceResponse<ServiceMemberInner>> addWithServiceResponseAsync(String serviceName, ServiceMemberInner serviceMember) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (serviceMember == null) {
            throw new IllegalArgumentException("Parameter serviceMember is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(serviceMember);
        return service.add(serviceName, serviceMember, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceMemberInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceMemberInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceMemberInner> clientResponse = addDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServiceMemberInner> addDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ServiceMemberInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ServiceMemberInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of a server, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceMemberInner object if successful.
     */
    public ServiceMemberInner get(String serviceName, UUID serviceMemberId) {
        return getWithServiceResponseAsync(serviceName, serviceMemberId).toBlocking().single().body();
    }

    /**
     * Gets the details of a server, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceMemberInner> getAsync(String serviceName, UUID serviceMemberId, final ServiceCallback<ServiceMemberInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(serviceName, serviceMemberId), serviceCallback);
    }

    /**
     * Gets the details of a server, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceMemberInner object
     */
    public Observable<ServiceMemberInner> getAsync(String serviceName, UUID serviceMemberId) {
        return getWithServiceResponseAsync(serviceName, serviceMemberId).map(new Func1<ServiceResponse<ServiceMemberInner>, ServiceMemberInner>() {
            @Override
            public ServiceMemberInner call(ServiceResponse<ServiceMemberInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the details of a server, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceMemberInner object
     */
    public Observable<ServiceResponse<ServiceMemberInner>> getWithServiceResponseAsync(String serviceName, UUID serviceMemberId) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(serviceName, serviceMemberId, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceMemberInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceMemberInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceMemberInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServiceMemberInner> getDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ServiceMemberInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ServiceMemberInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a server that has been onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String serviceName, UUID serviceMemberId) {
        deleteWithServiceResponseAsync(serviceName, serviceMemberId).toBlocking().single().body();
    }

    /**
     * Deletes a server that has been onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String serviceName, UUID serviceMemberId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(serviceName, serviceMemberId), serviceCallback);
    }

    /**
     * Deletes a server that has been onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String serviceName, UUID serviceMemberId) {
        return deleteWithServiceResponseAsync(serviceName, serviceMemberId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a server that has been onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String serviceName, UUID serviceMemberId) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean confirm = null;
        return service.delete(serviceName, serviceMemberId, confirm, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a server that has been onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param confirm Indicates if the server will be permanently deleted or disabled. True indicates that the server will be permanently deleted and False indicates that the server will be marked disabled and then deleted after 30 days, if it is not re-registered.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String serviceName, UUID serviceMemberId, Boolean confirm) {
        deleteWithServiceResponseAsync(serviceName, serviceMemberId, confirm).toBlocking().single().body();
    }

    /**
     * Deletes a server that has been onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param confirm Indicates if the server will be permanently deleted or disabled. True indicates that the server will be permanently deleted and False indicates that the server will be marked disabled and then deleted after 30 days, if it is not re-registered.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String serviceName, UUID serviceMemberId, Boolean confirm, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(serviceName, serviceMemberId, confirm), serviceCallback);
    }

    /**
     * Deletes a server that has been onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param confirm Indicates if the server will be permanently deleted or disabled. True indicates that the server will be permanently deleted and False indicates that the server will be marked disabled and then deleted after 30 days, if it is not re-registered.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String serviceName, UUID serviceMemberId, Boolean confirm) {
        return deleteWithServiceResponseAsync(serviceName, serviceMemberId, confirm).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a server that has been onboarded to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param confirm Indicates if the server will be permanently deleted or disabled. True indicates that the server will be permanently deleted and False indicates that the server will be marked disabled and then deleted after 30 days, if it is not re-registered.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String serviceName, UUID serviceMemberId, Boolean confirm) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.delete(serviceName, serviceMemberId, confirm, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of an alert for a given service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;AlertInner&gt; object if successful.
     */
    public PagedList<AlertInner> listAlerts(final UUID serviceMemberId, final String serviceName) {
        ServiceResponse<Page<AlertInner>> response = listAlertsSinglePageAsync(serviceMemberId, serviceName).toBlocking().single();
        return new PagedList<AlertInner>(response.body()) {
            @Override
            public Page<AlertInner> nextPage(String nextPageLink) {
                return listAlertsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of an alert for a given service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AlertInner>> listAlertsAsync(final UUID serviceMemberId, final String serviceName, final ListOperationCallback<AlertInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listAlertsSinglePageAsync(serviceMemberId, serviceName),
            new Func1<String, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(String nextPageLink) {
                    return listAlertsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of an alert for a given service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<Page<AlertInner>> listAlertsAsync(final UUID serviceMemberId, final String serviceName) {
        return listAlertsWithServiceResponseAsync(serviceMemberId, serviceName)
            .map(new Func1<ServiceResponse<Page<AlertInner>>, Page<AlertInner>>() {
                @Override
                public Page<AlertInner> call(ServiceResponse<Page<AlertInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of an alert for a given service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listAlertsWithServiceResponseAsync(final UUID serviceMemberId, final String serviceName) {
        return listAlertsSinglePageAsync(serviceMemberId, serviceName)
            .concatMap(new Func1<ServiceResponse<Page<AlertInner>>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(ServiceResponse<Page<AlertInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listAlertsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of an alert for a given service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;AlertInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listAlertsSinglePageAsync(final UUID serviceMemberId, final String serviceName) {
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final String state = null;
        final DateTime from = null;
        final DateTime to = null;
        return service.listAlerts(serviceMemberId, serviceName, filter, state, from, to, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AlertInner>> result = listAlertsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AlertInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the details of an alert for a given service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @param filter The alert property filter to apply.
     * @param state The alert state to query for.
     * @param from The start date to query for.
     * @param to The end date till when to query for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;AlertInner&gt; object if successful.
     */
    public PagedList<AlertInner> listAlerts(final UUID serviceMemberId, final String serviceName, final String filter, final String state, final DateTime from, final DateTime to) {
        ServiceResponse<Page<AlertInner>> response = listAlertsSinglePageAsync(serviceMemberId, serviceName, filter, state, from, to).toBlocking().single();
        return new PagedList<AlertInner>(response.body()) {
            @Override
            public Page<AlertInner> nextPage(String nextPageLink) {
                return listAlertsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of an alert for a given service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @param filter The alert property filter to apply.
     * @param state The alert state to query for.
     * @param from The start date to query for.
     * @param to The end date till when to query for.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AlertInner>> listAlertsAsync(final UUID serviceMemberId, final String serviceName, final String filter, final String state, final DateTime from, final DateTime to, final ListOperationCallback<AlertInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listAlertsSinglePageAsync(serviceMemberId, serviceName, filter, state, from, to),
            new Func1<String, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(String nextPageLink) {
                    return listAlertsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of an alert for a given service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @param filter The alert property filter to apply.
     * @param state The alert state to query for.
     * @param from The start date to query for.
     * @param to The end date till when to query for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<Page<AlertInner>> listAlertsAsync(final UUID serviceMemberId, final String serviceName, final String filter, final String state, final DateTime from, final DateTime to) {
        return listAlertsWithServiceResponseAsync(serviceMemberId, serviceName, filter, state, from, to)
            .map(new Func1<ServiceResponse<Page<AlertInner>>, Page<AlertInner>>() {
                @Override
                public Page<AlertInner> call(ServiceResponse<Page<AlertInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of an alert for a given service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @param filter The alert property filter to apply.
     * @param state The alert state to query for.
     * @param from The start date to query for.
     * @param to The end date till when to query for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listAlertsWithServiceResponseAsync(final UUID serviceMemberId, final String serviceName, final String filter, final String state, final DateTime from, final DateTime to) {
        return listAlertsSinglePageAsync(serviceMemberId, serviceName, filter, state, from, to)
            .concatMap(new Func1<ServiceResponse<Page<AlertInner>>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(ServiceResponse<Page<AlertInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listAlertsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of an alert for a given service and server combination.
     *
    ServiceResponse<PageImpl<AlertInner>> * @param serviceMemberId The server Id for which the alert details needs to be queried.
    ServiceResponse<PageImpl<AlertInner>> * @param serviceName The name of the service.
    ServiceResponse<PageImpl<AlertInner>> * @param filter The alert property filter to apply.
    ServiceResponse<PageImpl<AlertInner>> * @param state The alert state to query for.
    ServiceResponse<PageImpl<AlertInner>> * @param from The start date to query for.
    ServiceResponse<PageImpl<AlertInner>> * @param to The end date till when to query for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;AlertInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listAlertsSinglePageAsync(final UUID serviceMemberId, final String serviceName, final String filter, final String state, final DateTime from, final DateTime to) {
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listAlerts(serviceMemberId, serviceName, filter, state, from, to, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AlertInner>> result = listAlertsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AlertInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<AlertInner>> listAlertsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<AlertInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<AlertInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the connector details for a service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ConnectorInner&gt; object if successful.
     */
    public List<ConnectorInner> listConnectors(String serviceName, UUID serviceMemberId) {
        return listConnectorsWithServiceResponseAsync(serviceName, serviceMemberId).toBlocking().single().body();
    }

    /**
     * Gets the connector details for a service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ConnectorInner>> listConnectorsAsync(String serviceName, UUID serviceMemberId, final ServiceCallback<List<ConnectorInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listConnectorsWithServiceResponseAsync(serviceName, serviceMemberId), serviceCallback);
    }

    /**
     * Gets the connector details for a service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ConnectorInner&gt; object
     */
    public Observable<List<ConnectorInner>> listConnectorsAsync(String serviceName, UUID serviceMemberId) {
        return listConnectorsWithServiceResponseAsync(serviceName, serviceMemberId).map(new Func1<ServiceResponse<List<ConnectorInner>>, List<ConnectorInner>>() {
            @Override
            public List<ConnectorInner> call(ServiceResponse<List<ConnectorInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the connector details for a service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ConnectorInner&gt; object
     */
    public Observable<ServiceResponse<List<ConnectorInner>>> listConnectorsWithServiceResponseAsync(String serviceName, UUID serviceMemberId) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listConnectors(serviceName, serviceMemberId, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ConnectorInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ConnectorInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<ConnectorInner>> result = listConnectorsDelegate(response);
                        List<ConnectorInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<ConnectorInner>> clientResponse = new ServiceResponse<List<ConnectorInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl1<ConnectorInner>> listConnectorsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl1<ConnectorInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl1<ConnectorInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the credentials of the server which is needed by the agent to connect to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;CredentialInner&gt; object if successful.
     */
    public List<CredentialInner> listCredentials(String serviceName, UUID serviceMemberId) {
        return listCredentialsWithServiceResponseAsync(serviceName, serviceMemberId).toBlocking().single().body();
    }

    /**
     * Gets the credentials of the server which is needed by the agent to connect to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CredentialInner>> listCredentialsAsync(String serviceName, UUID serviceMemberId, final ServiceCallback<List<CredentialInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listCredentialsWithServiceResponseAsync(serviceName, serviceMemberId), serviceCallback);
    }

    /**
     * Gets the credentials of the server which is needed by the agent to connect to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CredentialInner&gt; object
     */
    public Observable<List<CredentialInner>> listCredentialsAsync(String serviceName, UUID serviceMemberId) {
        return listCredentialsWithServiceResponseAsync(serviceName, serviceMemberId).map(new Func1<ServiceResponse<List<CredentialInner>>, List<CredentialInner>>() {
            @Override
            public List<CredentialInner> call(ServiceResponse<List<CredentialInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the credentials of the server which is needed by the agent to connect to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CredentialInner&gt; object
     */
    public Observable<ServiceResponse<List<CredentialInner>>> listCredentialsWithServiceResponseAsync(String serviceName, UUID serviceMemberId) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        return service.listCredentials(serviceName, serviceMemberId, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<CredentialInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<CredentialInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<CredentialInner>> result = listCredentialsDelegate(response);
                        List<CredentialInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<CredentialInner>> clientResponse = new ServiceResponse<List<CredentialInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the credentials of the server which is needed by the agent to connect to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param filter The property filter to apply.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;CredentialInner&gt; object if successful.
     */
    public List<CredentialInner> listCredentials(String serviceName, UUID serviceMemberId, String filter) {
        return listCredentialsWithServiceResponseAsync(serviceName, serviceMemberId, filter).toBlocking().single().body();
    }

    /**
     * Gets the credentials of the server which is needed by the agent to connect to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param filter The property filter to apply.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CredentialInner>> listCredentialsAsync(String serviceName, UUID serviceMemberId, String filter, final ServiceCallback<List<CredentialInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listCredentialsWithServiceResponseAsync(serviceName, serviceMemberId, filter), serviceCallback);
    }

    /**
     * Gets the credentials of the server which is needed by the agent to connect to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param filter The property filter to apply.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CredentialInner&gt; object
     */
    public Observable<List<CredentialInner>> listCredentialsAsync(String serviceName, UUID serviceMemberId, String filter) {
        return listCredentialsWithServiceResponseAsync(serviceName, serviceMemberId, filter).map(new Func1<ServiceResponse<List<CredentialInner>>, List<CredentialInner>>() {
            @Override
            public List<CredentialInner> call(ServiceResponse<List<CredentialInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the credentials of the server which is needed by the agent to connect to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param filter The property filter to apply.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CredentialInner&gt; object
     */
    public Observable<ServiceResponse<List<CredentialInner>>> listCredentialsWithServiceResponseAsync(String serviceName, UUID serviceMemberId, String filter) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listCredentials(serviceName, serviceMemberId, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<CredentialInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<CredentialInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<CredentialInner>> result = listCredentialsDelegate(response);
                        List<CredentialInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<CredentialInner>> clientResponse = new ServiceResponse<List<CredentialInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl1<CredentialInner>> listCredentialsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl1<CredentialInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl1<CredentialInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes the data uploaded by the server to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteData(String serviceName, UUID serviceMemberId) {
        deleteDataWithServiceResponseAsync(serviceName, serviceMemberId).toBlocking().single().body();
    }

    /**
     * Deletes the data uploaded by the server to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteDataAsync(String serviceName, UUID serviceMemberId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteDataWithServiceResponseAsync(serviceName, serviceMemberId), serviceCallback);
    }

    /**
     * Deletes the data uploaded by the server to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteDataAsync(String serviceName, UUID serviceMemberId) {
        return deleteDataWithServiceResponseAsync(serviceName, serviceMemberId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the data uploaded by the server to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteDataWithServiceResponseAsync(String serviceName, UUID serviceMemberId) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteData(serviceName, serviceMemberId, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the last time when the server uploaded data to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ItemInner&gt; object if successful.
     */
    public List<ItemInner> listDataFreshness(String serviceName, UUID serviceMemberId) {
        return listDataFreshnessWithServiceResponseAsync(serviceName, serviceMemberId).toBlocking().single().body();
    }

    /**
     * Gets the last time when the server uploaded data to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ItemInner>> listDataFreshnessAsync(String serviceName, UUID serviceMemberId, final ServiceCallback<List<ItemInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listDataFreshnessWithServiceResponseAsync(serviceName, serviceMemberId), serviceCallback);
    }

    /**
     * Gets the last time when the server uploaded data to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ItemInner&gt; object
     */
    public Observable<List<ItemInner>> listDataFreshnessAsync(String serviceName, UUID serviceMemberId) {
        return listDataFreshnessWithServiceResponseAsync(serviceName, serviceMemberId).map(new Func1<ServiceResponse<List<ItemInner>>, List<ItemInner>>() {
            @Override
            public List<ItemInner> call(ServiceResponse<List<ItemInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the last time when the server uploaded data to Azure Active Directory Connect Health Service.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ItemInner&gt; object
     */
    public Observable<ServiceResponse<List<ItemInner>>> listDataFreshnessWithServiceResponseAsync(String serviceName, UUID serviceMemberId) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listDataFreshness(serviceName, serviceMemberId, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<ItemInner>> result = listDataFreshnessDelegate(response);
                        List<ItemInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<ItemInner>> clientResponse = new ServiceResponse<List<ItemInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl1<ItemInner>> listDataFreshnessDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl1<ItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl1<ItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the export status.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ExportStatusInner&gt; object if successful.
     */
    public PagedList<ExportStatusInner> listExportStatus(final String serviceName, final UUID serviceMemberId) {
        ServiceResponse<Page<ExportStatusInner>> response = listExportStatusSinglePageAsync(serviceName, serviceMemberId).toBlocking().single();
        return new PagedList<ExportStatusInner>(response.body()) {
            @Override
            public Page<ExportStatusInner> nextPage(String nextPageLink) {
                return listExportStatusNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the export status.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ExportStatusInner>> listExportStatusAsync(final String serviceName, final UUID serviceMemberId, final ListOperationCallback<ExportStatusInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listExportStatusSinglePageAsync(serviceName, serviceMemberId),
            new Func1<String, Observable<ServiceResponse<Page<ExportStatusInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ExportStatusInner>>> call(String nextPageLink) {
                    return listExportStatusNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the export status.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ExportStatusInner&gt; object
     */
    public Observable<Page<ExportStatusInner>> listExportStatusAsync(final String serviceName, final UUID serviceMemberId) {
        return listExportStatusWithServiceResponseAsync(serviceName, serviceMemberId)
            .map(new Func1<ServiceResponse<Page<ExportStatusInner>>, Page<ExportStatusInner>>() {
                @Override
                public Page<ExportStatusInner> call(ServiceResponse<Page<ExportStatusInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the export status.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ExportStatusInner&gt; object
     */
    public Observable<ServiceResponse<Page<ExportStatusInner>>> listExportStatusWithServiceResponseAsync(final String serviceName, final UUID serviceMemberId) {
        return listExportStatusSinglePageAsync(serviceName, serviceMemberId)
            .concatMap(new Func1<ServiceResponse<Page<ExportStatusInner>>, Observable<ServiceResponse<Page<ExportStatusInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ExportStatusInner>>> call(ServiceResponse<Page<ExportStatusInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listExportStatusNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the export status.
     *
    ServiceResponse<PageImpl<ExportStatusInner>> * @param serviceName The name of the service.
    ServiceResponse<PageImpl<ExportStatusInner>> * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ExportStatusInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ExportStatusInner>>> listExportStatusSinglePageAsync(final String serviceName, final UUID serviceMemberId) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listExportStatus(serviceName, serviceMemberId, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ExportStatusInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ExportStatusInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ExportStatusInner>> result = listExportStatusDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ExportStatusInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ExportStatusInner>> listExportStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ExportStatusInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ExportStatusInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the global configuration.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GlobalConfigurationInner&gt; object if successful.
     */
    public List<GlobalConfigurationInner> listGlobalConfiguration(String serviceName, String serviceMemberId) {
        return listGlobalConfigurationWithServiceResponseAsync(serviceName, serviceMemberId).toBlocking().single().body();
    }

    /**
     * Gets the global configuration.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GlobalConfigurationInner>> listGlobalConfigurationAsync(String serviceName, String serviceMemberId, final ServiceCallback<List<GlobalConfigurationInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listGlobalConfigurationWithServiceResponseAsync(serviceName, serviceMemberId), serviceCallback);
    }

    /**
     * Gets the global configuration.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GlobalConfigurationInner&gt; object
     */
    public Observable<List<GlobalConfigurationInner>> listGlobalConfigurationAsync(String serviceName, String serviceMemberId) {
        return listGlobalConfigurationWithServiceResponseAsync(serviceName, serviceMemberId).map(new Func1<ServiceResponse<List<GlobalConfigurationInner>>, List<GlobalConfigurationInner>>() {
            @Override
            public List<GlobalConfigurationInner> call(ServiceResponse<List<GlobalConfigurationInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the global configuration.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GlobalConfigurationInner&gt; object
     */
    public Observable<ServiceResponse<List<GlobalConfigurationInner>>> listGlobalConfigurationWithServiceResponseAsync(String serviceName, String serviceMemberId) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listGlobalConfiguration(serviceName, serviceMemberId, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GlobalConfigurationInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<GlobalConfigurationInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<GlobalConfigurationInner>> result = listGlobalConfigurationDelegate(response);
                        List<GlobalConfigurationInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<GlobalConfigurationInner>> clientResponse = new ServiceResponse<List<GlobalConfigurationInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl1<GlobalConfigurationInner>> listGlobalConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl1<GlobalConfigurationInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl1<GlobalConfigurationInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceMemberId The server id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MetricSetsInner object if successful.
     */
    public MetricSetsInner getMetrics(String serviceName, String metricName, String groupName, UUID serviceMemberId) {
        return getMetricsWithServiceResponseAsync(serviceName, metricName, groupName, serviceMemberId).toBlocking().single().body();
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceMemberId The server id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MetricSetsInner> getMetricsAsync(String serviceName, String metricName, String groupName, UUID serviceMemberId, final ServiceCallback<MetricSetsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMetricsWithServiceResponseAsync(serviceName, metricName, groupName, serviceMemberId), serviceCallback);
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceMemberId The server id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<MetricSetsInner> getMetricsAsync(String serviceName, String metricName, String groupName, UUID serviceMemberId) {
        return getMetricsWithServiceResponseAsync(serviceName, metricName, groupName, serviceMemberId).map(new Func1<ServiceResponse<MetricSetsInner>, MetricSetsInner>() {
            @Override
            public MetricSetsInner call(ServiceResponse<MetricSetsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceMemberId The server id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<ServiceResponse<MetricSetsInner>> getMetricsWithServiceResponseAsync(String serviceName, String metricName, String groupName, UUID serviceMemberId) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String groupKey = null;
        final DateTime fromDate = null;
        final DateTime toDate = null;
        return service.getMetrics(serviceName, metricName, groupName, serviceMemberId, groupKey, fromDate, toDate, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MetricSetsInner>>>() {
                @Override
                public Observable<ServiceResponse<MetricSetsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MetricSetsInner> clientResponse = getMetricsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceMemberId The server id.
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MetricSetsInner object if successful.
     */
    public MetricSetsInner getMetrics(String serviceName, String metricName, String groupName, UUID serviceMemberId, String groupKey, DateTime fromDate, DateTime toDate) {
        return getMetricsWithServiceResponseAsync(serviceName, metricName, groupName, serviceMemberId, groupKey, fromDate, toDate).toBlocking().single().body();
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceMemberId The server id.
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MetricSetsInner> getMetricsAsync(String serviceName, String metricName, String groupName, UUID serviceMemberId, String groupKey, DateTime fromDate, DateTime toDate, final ServiceCallback<MetricSetsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMetricsWithServiceResponseAsync(serviceName, metricName, groupName, serviceMemberId, groupKey, fromDate, toDate), serviceCallback);
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceMemberId The server id.
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<MetricSetsInner> getMetricsAsync(String serviceName, String metricName, String groupName, UUID serviceMemberId, String groupKey, DateTime fromDate, DateTime toDate) {
        return getMetricsWithServiceResponseAsync(serviceName, metricName, groupName, serviceMemberId, groupKey, fromDate, toDate).map(new Func1<ServiceResponse<MetricSetsInner>, MetricSetsInner>() {
            @Override
            public MetricSetsInner call(ServiceResponse<MetricSetsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceMemberId The server id.
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<ServiceResponse<MetricSetsInner>> getMetricsWithServiceResponseAsync(String serviceName, String metricName, String groupName, UUID serviceMemberId, String groupKey, DateTime fromDate, DateTime toDate) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getMetrics(serviceName, metricName, groupName, serviceMemberId, groupKey, fromDate, toDate, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MetricSetsInner>>>() {
                @Override
                public Observable<ServiceResponse<MetricSetsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MetricSetsInner> clientResponse = getMetricsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MetricSetsInner> getMetricsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MetricSetsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MetricSetsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the service configuration.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceConfigurationInner object if successful.
     */
    public ServiceConfigurationInner getServiceConfiguration(String serviceName, String serviceMemberId) {
        return getServiceConfigurationWithServiceResponseAsync(serviceName, serviceMemberId).toBlocking().single().body();
    }

    /**
     * Gets the service configuration.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceConfigurationInner> getServiceConfigurationAsync(String serviceName, String serviceMemberId, final ServiceCallback<ServiceConfigurationInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceConfigurationWithServiceResponseAsync(serviceName, serviceMemberId), serviceCallback);
    }

    /**
     * Gets the service configuration.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceConfigurationInner object
     */
    public Observable<ServiceConfigurationInner> getServiceConfigurationAsync(String serviceName, String serviceMemberId) {
        return getServiceConfigurationWithServiceResponseAsync(serviceName, serviceMemberId).map(new Func1<ServiceResponse<ServiceConfigurationInner>, ServiceConfigurationInner>() {
            @Override
            public ServiceConfigurationInner call(ServiceResponse<ServiceConfigurationInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the service configuration.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The server Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceConfigurationInner object
     */
    public Observable<ServiceResponse<ServiceConfigurationInner>> getServiceConfigurationWithServiceResponseAsync(String serviceName, String serviceMemberId) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getServiceConfiguration(serviceName, serviceMemberId, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceConfigurationInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceConfigurationInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceConfigurationInner> clientResponse = getServiceConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServiceConfigurationInner> getServiceConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ServiceConfigurationInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ServiceConfigurationInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the list of connectors and run profile names.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The service member id.
     * @param metricName The name of the metric.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ConnectorMetadataInner object if successful.
     */
    public ConnectorMetadataInner getConnectorMetadata(String serviceName, UUID serviceMemberId, String metricName) {
        return getConnectorMetadataWithServiceResponseAsync(serviceName, serviceMemberId, metricName).toBlocking().single().body();
    }

    /**
     * Gets the list of connectors and run profile names.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The service member id.
     * @param metricName The name of the metric.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ConnectorMetadataInner> getConnectorMetadataAsync(String serviceName, UUID serviceMemberId, String metricName, final ServiceCallback<ConnectorMetadataInner> serviceCallback) {
        return ServiceFuture.fromResponse(getConnectorMetadataWithServiceResponseAsync(serviceName, serviceMemberId, metricName), serviceCallback);
    }

    /**
     * Gets the list of connectors and run profile names.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The service member id.
     * @param metricName The name of the metric.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectorMetadataInner object
     */
    public Observable<ConnectorMetadataInner> getConnectorMetadataAsync(String serviceName, UUID serviceMemberId, String metricName) {
        return getConnectorMetadataWithServiceResponseAsync(serviceName, serviceMemberId, metricName).map(new Func1<ServiceResponse<ConnectorMetadataInner>, ConnectorMetadataInner>() {
            @Override
            public ConnectorMetadataInner call(ServiceResponse<ConnectorMetadataInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of connectors and run profile names.
     *
     * @param serviceName The name of the service.
     * @param serviceMemberId The service member id.
     * @param metricName The name of the metric.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectorMetadataInner object
     */
    public Observable<ServiceResponse<ConnectorMetadataInner>> getConnectorMetadataWithServiceResponseAsync(String serviceName, UUID serviceMemberId, String metricName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getConnectorMetadata(serviceName, serviceMemberId, metricName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectorMetadataInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectorMetadataInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectorMetadataInner> clientResponse = getConnectorMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectorMetadataInner> getConnectorMetadataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ConnectorMetadataInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ConnectorMetadataInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of the servers, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ServiceMemberInner&gt; object if successful.
     */
    public PagedList<ServiceMemberInner> listNext(final String nextPageLink) {
        ServiceResponse<Page<ServiceMemberInner>> response = listNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ServiceMemberInner>(response.body()) {
            @Override
            public Page<ServiceMemberInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of the servers, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServiceMemberInner>> listNextAsync(final String nextPageLink, final ServiceFuture<List<ServiceMemberInner>> serviceFuture, final ListOperationCallback<ServiceMemberInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ServiceMemberInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServiceMemberInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of the servers, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServiceMemberInner&gt; object
     */
    public Observable<Page<ServiceMemberInner>> listNextAsync(final String nextPageLink) {
        return listNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ServiceMemberInner>>, Page<ServiceMemberInner>>() {
                @Override
                public Page<ServiceMemberInner> call(ServiceResponse<Page<ServiceMemberInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of the servers, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServiceMemberInner&gt; object
     */
    public Observable<ServiceResponse<Page<ServiceMemberInner>>> listNextWithServiceResponseAsync(final String nextPageLink) {
        return listNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ServiceMemberInner>>, Observable<ServiceResponse<Page<ServiceMemberInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServiceMemberInner>>> call(ServiceResponse<Page<ServiceMemberInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of the servers, for a given service, that are onboarded to Azure Active Directory Connect Health Service.
     *
    ServiceResponse<PageImpl<ServiceMemberInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ServiceMemberInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ServiceMemberInner>>> listNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ServiceMemberInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServiceMemberInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServiceMemberInner>> result = listNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ServiceMemberInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ServiceMemberInner>> listNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ServiceMemberInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ServiceMemberInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of an alert for a given service and server combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;AlertInner&gt; object if successful.
     */
    public PagedList<AlertInner> listAlertsNext(final String nextPageLink) {
        ServiceResponse<Page<AlertInner>> response = listAlertsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<AlertInner>(response.body()) {
            @Override
            public Page<AlertInner> nextPage(String nextPageLink) {
                return listAlertsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of an alert for a given service and server combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AlertInner>> listAlertsNextAsync(final String nextPageLink, final ServiceFuture<List<AlertInner>> serviceFuture, final ListOperationCallback<AlertInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listAlertsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(String nextPageLink) {
                    return listAlertsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of an alert for a given service and server combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<Page<AlertInner>> listAlertsNextAsync(final String nextPageLink) {
        return listAlertsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<AlertInner>>, Page<AlertInner>>() {
                @Override
                public Page<AlertInner> call(ServiceResponse<Page<AlertInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of an alert for a given service and server combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listAlertsNextWithServiceResponseAsync(final String nextPageLink) {
        return listAlertsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<AlertInner>>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(ServiceResponse<Page<AlertInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listAlertsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of an alert for a given service and server combination.
     *
    ServiceResponse<PageImpl<AlertInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;AlertInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listAlertsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listAlertsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AlertInner>> result = listAlertsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AlertInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<AlertInner>> listAlertsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<AlertInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<AlertInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the export status.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ExportStatusInner&gt; object if successful.
     */
    public PagedList<ExportStatusInner> listExportStatusNext(final String nextPageLink) {
        ServiceResponse<Page<ExportStatusInner>> response = listExportStatusNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ExportStatusInner>(response.body()) {
            @Override
            public Page<ExportStatusInner> nextPage(String nextPageLink) {
                return listExportStatusNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the export status.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ExportStatusInner>> listExportStatusNextAsync(final String nextPageLink, final ServiceFuture<List<ExportStatusInner>> serviceFuture, final ListOperationCallback<ExportStatusInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listExportStatusNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ExportStatusInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ExportStatusInner>>> call(String nextPageLink) {
                    return listExportStatusNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the export status.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ExportStatusInner&gt; object
     */
    public Observable<Page<ExportStatusInner>> listExportStatusNextAsync(final String nextPageLink) {
        return listExportStatusNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ExportStatusInner>>, Page<ExportStatusInner>>() {
                @Override
                public Page<ExportStatusInner> call(ServiceResponse<Page<ExportStatusInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the export status.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ExportStatusInner&gt; object
     */
    public Observable<ServiceResponse<Page<ExportStatusInner>>> listExportStatusNextWithServiceResponseAsync(final String nextPageLink) {
        return listExportStatusNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ExportStatusInner>>, Observable<ServiceResponse<Page<ExportStatusInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ExportStatusInner>>> call(ServiceResponse<Page<ExportStatusInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listExportStatusNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the export status.
     *
    ServiceResponse<PageImpl<ExportStatusInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ExportStatusInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ExportStatusInner>>> listExportStatusNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listExportStatusNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ExportStatusInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ExportStatusInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ExportStatusInner>> result = listExportStatusNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ExportStatusInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ExportStatusInner>> listExportStatusNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ExportStatusInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ExportStatusInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
