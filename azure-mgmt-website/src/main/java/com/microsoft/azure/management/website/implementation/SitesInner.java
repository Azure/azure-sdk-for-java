/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.website.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceCall;
import com.microsoft.azure.AzureServiceResponseBuilder;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.website.CsmPublishingProfileOptions;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Streaming;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Sites.
 */
public final class SitesInner {
    /** The Retrofit service to perform REST calls. */
    private SitesService service;
    /** The service client containing this operation class. */
    private WebSiteManagementClientImpl client;

    /**
     * Initializes an instance of SitesInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public SitesInner(Retrofit retrofit, WebSiteManagementClientImpl client) {
        this.service = retrofit.create(SitesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Sites to be
     * used by Retrofit to perform actually REST calls.
     */
    interface SitesService {
        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> getSiteVNETConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteVNETConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteVNETConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> updateSiteVNETConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> getSiteVNETConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteVNETConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteVNETConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> updateSiteVNETConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkFeatures/{view}")
        Observable<Response<ResponseBody>> getSiteNetworkFeaturesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("view") String view, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkFeatures/{view}")
        Observable<Response<ResponseBody>> getSiteNetworkFeatures(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("view") String view, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/operationresults/{operationId}")
        Observable<Response<ResponseBody>> getSiteOperationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("operationId") String operationId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/operationresults/{operationId}")
        Observable<Response<ResponseBody>> getSiteOperation(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("operationId") String operationId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap")
        Observable<Response<ResponseBody>> swapSlotWithProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap")
        Observable<Response<ResponseBody>> beginSwapSlotWithProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap")
        Observable<Response<ResponseBody>> swapSlotsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap")
        Observable<Response<ResponseBody>> beginSwapSlotsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsdiffs")
        Observable<Response<ResponseBody>> getSlotsDifferencesFromProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsdiffs")
        Observable<Response<ResponseBody>> getSlotsDifferencesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/applySlotConfig")
        Observable<Response<ResponseBody>> applySlotConfigToProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/applySlotConfig")
        Observable<Response<ResponseBody>> applySlotConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resetSlotConfig")
        Observable<Response<ResponseBody>> resetProductionSlotConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resetSlotConfig")
        Observable<Response<ResponseBody>> resetSlotConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames")
        Observable<Response<ResponseBody>> getSlotConfigNames(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames")
        Observable<Response<ResponseBody>> updateSlotConfigNames(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SlotConfigNamesResourceInner slotConfigNames, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots")
        Observable<Response<ResponseBody>> getSiteSlots(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("propertiesToInclude") String propertiesToInclude, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites")
        Observable<Response<ResponseBody>> getSites(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Query("propertiesToInclude") String propertiesToInclude, @Query("includeSiteTypes") String includeSiteTypes, @Query("includeSlots") Boolean includeSlots, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> getSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("propertiesToInclude") String propertiesToInclude, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> createOrUpdateSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") String skipDnsRegistration, @Query("skipCustomDomainVerification") String skipCustomDomainVerification, @Query("forceDnsRegistration") String forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> beginCreateOrUpdateSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") String skipDnsRegistration, @Query("skipCustomDomainVerification") String skipCustomDomainVerification, @Query("forceDnsRegistration") String forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("deleteMetrics") String deleteMetrics, @Query("deleteEmptyServerFarm") String deleteEmptyServerFarm, @Query("skipDnsRegistration") String skipDnsRegistration, @Query("deleteAllSlots") String deleteAllSlots, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> getSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("propertiesToInclude") String propertiesToInclude, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> createOrUpdateSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") String skipDnsRegistration, @Query("skipCustomDomainVerification") String skipCustomDomainVerification, @Query("forceDnsRegistration") String forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> beginCreateOrUpdateSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") String skipDnsRegistration, @Query("skipCustomDomainVerification") String skipCustomDomainVerification, @Query("forceDnsRegistration") String forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("deleteMetrics") String deleteMetrics, @Query("deleteEmptyServerFarm") String deleteEmptyServerFarm, @Query("skipDnsRegistration") String skipDnsRegistration, @Query("deleteAllSlots") String deleteAllSlots, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/iscloneable")
        Observable<Response<ResponseBody>> isSiteCloneable(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/iscloneable")
        Observable<Response<ResponseBody>> isSiteCloneableSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/recover")
        Observable<Response<ResponseBody>> recoverSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/recover")
        Observable<Response<ResponseBody>> beginRecoverSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/recover")
        Observable<Response<ResponseBody>> recoverSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/recover")
        Observable<Response<ResponseBody>> beginRecoverSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshots")
        Observable<Response<ResponseBody>> getSiteSnapshots(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshots")
        Observable<Response<ResponseBody>> getSiteSnapshotsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/deletedSites")
        Observable<Response<ResponseBody>> getDeletedSites(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Query("propertiesToInclude") String propertiesToInclude, @Query("includeSiteTypes") String includeSiteTypes, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments")
        Observable<Response<ResponseBody>> getDeployments(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments")
        Observable<Response<ResponseBody>> getDeploymentsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments")
        Observable<Response<ResponseBody>> getInstanceDeployments(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments")
        Observable<Response<ResponseBody>> getInstanceDeploymentsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> getInstanceDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> createInstanceDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteInstanceDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}")
        Observable<Response<ResponseBody>> getDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}")
        Observable<Response<ResponseBody>> createDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}")
        Observable<Response<ResponseBody>> getDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}")
        Observable<Response<ResponseBody>> createDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> getInstanceDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> createInstanceDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteInstanceDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances")
        Observable<Response<ResponseBody>> getSiteInstanceIdentifiers(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances")
        Observable<Response<ResponseBody>> getSiteInstanceIdentifiersSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings")
        Observable<Response<ResponseBody>> getSiteHostNameBindings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings")
        Observable<Response<ResponseBody>> getSiteHostNameBindingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> getSiteHostNameBinding(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteHostNameBinding(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Body HostNameBindingInner hostNameBinding, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteHostNameBinding(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> getSiteHostNameBindingSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteHostNameBindingSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body HostNameBindingInner hostNameBinding, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteHostNameBindingSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web")
        Observable<Response<ResponseBody>> getSiteConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web")
        Observable<Response<ResponseBody>> createOrUpdateSiteConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteConfigInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web")
        Observable<Response<ResponseBody>> updateSiteConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteConfigInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web")
        Observable<Response<ResponseBody>> getSiteConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web")
        Observable<Response<ResponseBody>> createOrUpdateSiteConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteConfigInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web")
        Observable<Response<ResponseBody>> updateSiteConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteConfigInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> getSiteSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> createOrUpdateSiteSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> updateSiteSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> getSiteSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> createOrUpdateSiteSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> updateSiteSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings/list")
        Observable<Response<ResponseBody>> listSiteAppSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings/list")
        Observable<Response<ResponseBody>> listSiteAppSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings")
        Observable<Response<ResponseBody>> updateSiteAppSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner appSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings")
        Observable<Response<ResponseBody>> updateSiteAppSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner appSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings/list")
        Observable<Response<ResponseBody>> listSiteConnectionStrings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings/list")
        Observable<Response<ResponseBody>> listSiteConnectionStringsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings")
        Observable<Response<ResponseBody>> updateSiteConnectionStrings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body ConnectionStringDictionaryInner connectionStrings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings")
        Observable<Response<ResponseBody>> updateSiteConnectionStringsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body ConnectionStringDictionaryInner connectionStrings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings/list")
        Observable<Response<ResponseBody>> listSiteAuthSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings/list")
        Observable<Response<ResponseBody>> listSiteAuthSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings")
        Observable<Response<ResponseBody>> updateSiteAuthSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteAuthSettingsInner siteAuthSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings")
        Observable<Response<ResponseBody>> updateSiteAuthSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteAuthSettingsInner siteAuthSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> listSitePublishingCredentials(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> beginListSitePublishingCredentials(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> listSitePublishingCredentialsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> beginListSitePublishingCredentialsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata/list")
        Observable<Response<ResponseBody>> listSiteMetadata(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata/list")
        Observable<Response<ResponseBody>> listSiteMetadataSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata")
        Observable<Response<ResponseBody>> updateSiteMetadata(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner metadata, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata")
        Observable<Response<ResponseBody>> updateSiteMetadataSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner metadata, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs")
        Observable<Response<ResponseBody>> getSiteLogsConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs")
        Observable<Response<ResponseBody>> updateSiteLogsConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteLogsConfigInner siteLogsConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs")
        Observable<Response<ResponseBody>> getSiteLogsConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs")
        Observable<Response<ResponseBody>> updateSiteLogsConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteLogsConfigInner siteLogsConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons")
        Observable<Response<ResponseBody>> listSitePremierAddOns(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons")
        Observable<Response<ResponseBody>> listSitePremierAddOnsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> getSitePremierAddOn(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> addSitePremierAddOn(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("subscriptionId") String subscriptionId, @Body PremierAddOnRequestInner premierAddOn, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSitePremierAddOn(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> getSitePremierAddOnSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> addSitePremierAddOnSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body PremierAddOnRequestInner premierAddOn, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSitePremierAddOnSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup/list")
        Observable<Response<ResponseBody>> getSiteBackupConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup/list")
        Observable<Response<ResponseBody>> getSiteBackupConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup")
        Observable<Response<ResponseBody>> updateSiteBackupConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup")
        Observable<Response<ResponseBody>> updateSiteBackupConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backup")
        Observable<Response<ResponseBody>> backupSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backup")
        Observable<Response<ResponseBody>> backupSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/discover")
        Observable<Response<ResponseBody>> discoverSiteRestore(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/discover")
        Observable<Response<ResponseBody>> discoverSiteRestoreSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups")
        Observable<Response<ResponseBody>> listSiteBackups(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups")
        Observable<Response<ResponseBody>> listSiteBackupsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}")
        Observable<Response<ResponseBody>> getSiteBackupStatus(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackup(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}")
        Observable<Response<ResponseBody>> getSiteBackupStatusSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackupSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/list")
        Observable<Response<ResponseBody>> getSiteBackupStatusSecretsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/list")
        Observable<Response<ResponseBody>> getSiteBackupStatusSecrets(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> restoreSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> beginRestoreSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> restoreSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> beginRestoreSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/usages")
        Observable<Response<ResponseBody>> getSiteUsages(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/usages")
        Observable<Response<ResponseBody>> getSiteUsagesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metrics")
        Observable<Response<ResponseBody>> getSiteMetrics(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("details") Boolean details, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metrics")
        Observable<Response<ResponseBody>> getSiteMetricsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("details") Boolean details, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metricdefinitions")
        Observable<Response<ResponseBody>> getSiteMetricDefinitionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metricdefinitions")
        Observable<Response<ResponseBody>> getSiteMetricDefinitions(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publishxml")
        @Streaming
        Observable<Response<ResponseBody>> listSitePublishingProfileXml(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CsmPublishingProfileOptions options, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publishxml")
        @Streaming
        Observable<Response<ResponseBody>> listSitePublishingProfileXmlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CsmPublishingProfileOptions options, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restart")
        Observable<Response<ResponseBody>> restartSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("softRestart") Boolean softRestart, @Query("synchronous") Boolean synchronous, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restart")
        Observable<Response<ResponseBody>> restartSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("softRestart") Boolean softRestart, @Query("synchronous") Boolean synchronous, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/start")
        Observable<Response<ResponseBody>> startSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/start")
        Observable<Response<ResponseBody>> startSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stop")
        Observable<Response<ResponseBody>> stopSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stop")
        Observable<Response<ResponseBody>> stopSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sync")
        Observable<Response<ResponseBody>> syncSiteRepository(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sync")
        Observable<Response<ResponseBody>> syncSiteRepositorySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/newpassword")
        Observable<Response<ResponseBody>> generateNewSitePublishingPasswordSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/newpassword")
        Observable<Response<ResponseBody>> generateNewSitePublishingPassword(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> getSiteRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> updateSiteRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> getSiteRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> updateSiteRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection")
        Observable<Response<ResponseBody>> listSiteRelayServiceConnectionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection")
        Observable<Response<ResponseBody>> listSiteRelayServiceConnections(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> getSiteVnetGatewaySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteVNETConnectionGatewaySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> updateSiteVNETConnectionGatewaySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> getSiteVnetGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteVNETConnectionGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> updateSiteVNETConnectionGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections")
        Observable<Response<ResponseBody>> getSiteVNETConnections(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections")
        Observable<Response<ResponseBody>> getSiteVNETConnectionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("{nextLink}")
        Observable<Response<ResponseBody>> getSlotsDifferencesFromProductionNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("{nextLink}")
        Observable<Response<ResponseBody>> getSlotsDifferencesSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteSlotsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSitesNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getDeletedSitesNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getDeploymentsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getDeploymentsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getInstanceDeploymentsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getInstanceDeploymentsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteInstanceIdentifiersNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteInstanceIdentifiersSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteHostNameBindingsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteHostNameBindingsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listSiteBackupsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listSiteBackupsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteUsagesNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteUsagesSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteMetricsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteMetricsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteMetricDefinitionsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteMetricDefinitionsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner getSiteVNETConnectionSlot(String resourceGroupName, String name, String vnetName, String slot) {
        return getSiteVNETConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).toBlocking().single().getBody();
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> getSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(getSiteVNETConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot), serviceCallback);
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> getSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot) {
        return getSiteVNETConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> getSiteVNETConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteVNETConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = getSiteVNETConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> getSiteVNETConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner createOrUpdateSiteVNETConnectionSlot(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return createOrUpdateSiteVNETConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> createOrUpdateSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteVNETConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> createOrUpdateSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return createOrUpdateSiteVNETConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> createOrUpdateSiteVNETConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateSiteVNETConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = createOrUpdateSiteVNETConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> createOrUpdateSiteVNETConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @return the Object object if successful.
     */
    public Object deleteSiteVNETConnectionSlot(String resourceGroupName, String name, String vnetName, String slot) {
        return deleteSiteVNETConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).toBlocking().single().getBody();
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteVNETConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot), serviceCallback);
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot) {
        return deleteSiteVNETConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteVNETConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteVNETConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteVNETConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteVNETConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner updateSiteVNETConnectionSlot(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return updateSiteVNETConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> updateSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(updateSiteVNETConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> updateSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return updateSiteVNETConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> updateSiteVNETConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateSiteVNETConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = updateSiteVNETConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> updateSiteVNETConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner getSiteVNETConnection(String resourceGroupName, String name, String vnetName) {
        return getSiteVNETConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).toBlocking().single().getBody();
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> getSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(getSiteVNETConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName), serviceCallback);
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> getSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName) {
        return getSiteVNETConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> getSiteVNETConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteVNETConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = getSiteVNETConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> getSiteVNETConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner createOrUpdateSiteVNETConnection(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return createOrUpdateSiteVNETConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> createOrUpdateSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteVNETConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> createOrUpdateSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return createOrUpdateSiteVNETConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> createOrUpdateSiteVNETConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateSiteVNETConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = createOrUpdateSiteVNETConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> createOrUpdateSiteVNETConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @return the Object object if successful.
     */
    public Object deleteSiteVNETConnection(String resourceGroupName, String name, String vnetName) {
        return deleteSiteVNETConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).toBlocking().single().getBody();
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteVNETConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName), serviceCallback);
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName) {
        return deleteSiteVNETConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteVNETConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteVNETConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteVNETConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteVNETConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner updateSiteVNETConnection(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return updateSiteVNETConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> updateSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(updateSiteVNETConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> updateSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return updateSiteVNETConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> updateSiteVNETConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateSiteVNETConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = updateSiteVNETConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> updateSiteVNETConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot The name of the slot for this web app.
     * @return the NetworkFeaturesInner object if successful.
     */
    public NetworkFeaturesInner getSiteNetworkFeaturesSlot(String resourceGroupName, String name, String view, String slot) {
        return getSiteNetworkFeaturesSlotWithServiceResponseAsync(resourceGroupName, name, view, slot).toBlocking().single().getBody();
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<NetworkFeaturesInner> getSiteNetworkFeaturesSlotAsync(String resourceGroupName, String name, String view, String slot, final ServiceCallback<NetworkFeaturesInner> serviceCallback) {
        return ServiceCall.create(getSiteNetworkFeaturesSlotWithServiceResponseAsync(resourceGroupName, name, view, slot), serviceCallback);
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot The name of the slot for this web app.
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<NetworkFeaturesInner> getSiteNetworkFeaturesSlotAsync(String resourceGroupName, String name, String view, String slot) {
        return getSiteNetworkFeaturesSlotWithServiceResponseAsync(resourceGroupName, name, view, slot).map(new Func1<ServiceResponse<NetworkFeaturesInner>, NetworkFeaturesInner>() {
            @Override
            public NetworkFeaturesInner call(ServiceResponse<NetworkFeaturesInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot The name of the slot for this web app.
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<ServiceResponse<NetworkFeaturesInner>> getSiteNetworkFeaturesSlotWithServiceResponseAsync(String resourceGroupName, String name, String view, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (view == null) {
            throw new IllegalArgumentException("Parameter view is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteNetworkFeaturesSlot(resourceGroupName, name, view, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NetworkFeaturesInner>>>() {
                @Override
                public Observable<ServiceResponse<NetworkFeaturesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NetworkFeaturesInner> clientResponse = getSiteNetworkFeaturesSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NetworkFeaturesInner> getSiteNetworkFeaturesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<NetworkFeaturesInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<NetworkFeaturesInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @return the NetworkFeaturesInner object if successful.
     */
    public NetworkFeaturesInner getSiteNetworkFeatures(String resourceGroupName, String name, String view) {
        return getSiteNetworkFeaturesWithServiceResponseAsync(resourceGroupName, name, view).toBlocking().single().getBody();
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<NetworkFeaturesInner> getSiteNetworkFeaturesAsync(String resourceGroupName, String name, String view, final ServiceCallback<NetworkFeaturesInner> serviceCallback) {
        return ServiceCall.create(getSiteNetworkFeaturesWithServiceResponseAsync(resourceGroupName, name, view), serviceCallback);
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<NetworkFeaturesInner> getSiteNetworkFeaturesAsync(String resourceGroupName, String name, String view) {
        return getSiteNetworkFeaturesWithServiceResponseAsync(resourceGroupName, name, view).map(new Func1<ServiceResponse<NetworkFeaturesInner>, NetworkFeaturesInner>() {
            @Override
            public NetworkFeaturesInner call(ServiceResponse<NetworkFeaturesInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<ServiceResponse<NetworkFeaturesInner>> getSiteNetworkFeaturesWithServiceResponseAsync(String resourceGroupName, String name, String view) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (view == null) {
            throw new IllegalArgumentException("Parameter view is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteNetworkFeatures(resourceGroupName, name, view, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NetworkFeaturesInner>>>() {
                @Override
                public Observable<ServiceResponse<NetworkFeaturesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NetworkFeaturesInner> clientResponse = getSiteNetworkFeaturesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NetworkFeaturesInner> getSiteNetworkFeaturesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<NetworkFeaturesInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<NetworkFeaturesInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object getSiteOperationSlot(String resourceGroupName, String name, String operationId, String slot) {
        return getSiteOperationSlotWithServiceResponseAsync(resourceGroupName, name, operationId, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSiteOperationSlotAsync(String resourceGroupName, String name, String operationId, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSiteOperationSlotWithServiceResponseAsync(resourceGroupName, name, operationId, slot), serviceCallback);
    }

    /**
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> getSiteOperationSlotAsync(String resourceGroupName, String name, String operationId, String slot) {
        return getSiteOperationSlotWithServiceResponseAsync(resourceGroupName, name, operationId, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSiteOperationSlotWithServiceResponseAsync(String resourceGroupName, String name, String operationId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteOperationSlot(resourceGroupName, name, operationId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSiteOperationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSiteOperationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @return the Object object if successful.
     */
    public Object getSiteOperation(String resourceGroupName, String name, String operationId) {
        return getSiteOperationWithServiceResponseAsync(resourceGroupName, name, operationId).toBlocking().single().getBody();
    }

    /**
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSiteOperationAsync(String resourceGroupName, String name, String operationId, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSiteOperationWithServiceResponseAsync(resourceGroupName, name, operationId), serviceCallback);
    }

    /**
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @return the observable to the Object object
     */
    public Observable<Object> getSiteOperationAsync(String resourceGroupName, String name, String operationId) {
        return getSiteOperationWithServiceResponseAsync(resourceGroupName, name, operationId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSiteOperationWithServiceResponseAsync(String resourceGroupName, String name, String operationId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteOperation(resourceGroupName, name, operationId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSiteOperationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSiteOperationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the Object object if successful.
     */
    public Object swapSlotWithProduction(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        return swapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).toBlocking().last().getBody();
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> swapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(swapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable for the request
     */
    public Observable<Object> swapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        return swapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Object>> swapSlotWithProductionWithServiceResponseAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        Observable<Response<ResponseBody>> observable = service.swapSlotWithProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Object>() { }.getType());
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the Object object if successful.
     */
    public Object beginSwapSlotWithProduction(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        return beginSwapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).toBlocking().single().getBody();
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> beginSwapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(beginSwapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the Object object
     */
    public Observable<Object> beginSwapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        return beginSwapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> beginSwapSlotWithProductionWithServiceResponseAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.beginSwapSlotWithProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = beginSwapSlotWithProductionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> beginSwapSlotWithProductionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(202, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the Object object if successful.
     */
    public Object swapSlotsSlot(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        return swapSlotsSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().last().getBody();
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> swapSlotsSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(swapSlotsSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable for the request
     */
    public Observable<Object> swapSlotsSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        return swapSlotsSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Object>> swapSlotsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        Observable<Response<ResponseBody>> observable = service.swapSlotsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Object>() { }.getType());
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the Object object if successful.
     */
    public Object beginSwapSlotsSlot(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        return beginSwapSlotsSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().single().getBody();
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> beginSwapSlotsSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(beginSwapSlotsSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the Object object
     */
    public Observable<Object> beginSwapSlotsSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        return beginSwapSlotsSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> beginSwapSlotsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.beginSwapSlotsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = beginSwapSlotsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> beginSwapSlotsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(202, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> getSlotsDifferencesFromProduction(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity) {
        ServiceResponse<Page<SlotDifferenceInner>> response = getSlotsDifferencesFromProductionSinglePageAsync(resourceGroupName, name, slotSwapEntity).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.getBody()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SlotDifferenceInner>> getSlotsDifferencesFromProductionAsync(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSlotsDifferencesFromProductionSinglePageAsync(resourceGroupName, name, slotSwapEntity),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> getSlotsDifferencesFromProductionAsync(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity) {
        return getSlotsDifferencesFromProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesFromProductionWithServiceResponseAsync(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity) {
        return getSlotsDifferencesFromProductionSinglePageAsync(resourceGroupName, name, slotSwapEntity)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSlotsDifferencesFromProductionNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param name Name of web app
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param slotSwapEntity Request body that contains the target slot name
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesFromProductionSinglePageAsync(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.getSlotsDifferencesFromProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = getSlotsDifferencesFromProductionDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> getSlotsDifferencesFromProductionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SlotDifferenceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> getSlotsDifferencesSlot(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity) {
        ServiceResponse<Page<SlotDifferenceInner>> response = getSlotsDifferencesSlotSinglePageAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.getBody()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SlotDifferenceInner>> getSlotsDifferencesSlotAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSlotsDifferencesSlotSinglePageAsync(resourceGroupName, name, slot, slotSwapEntity),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> getSlotsDifferencesSlotAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity) {
        return getSlotsDifferencesSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity) {
        return getSlotsDifferencesSlotSinglePageAsync(resourceGroupName, name, slot, slotSwapEntity)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSlotsDifferencesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param name Name of web app
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param slot Name of the source slot
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param slotSwapEntity Request body that contains the target slot name
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.getSlotsDifferencesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = getSlotsDifferencesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> getSlotsDifferencesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SlotDifferenceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @return the Object object if successful.
     */
    public Object applySlotConfigToProduction(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        return applySlotConfigToProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).toBlocking().single().getBody();
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> applySlotConfigToProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(applySlotConfigToProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity), serviceCallback);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @return the observable to the Object object
     */
    public Observable<Object> applySlotConfigToProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        return applySlotConfigToProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> applySlotConfigToProductionWithServiceResponseAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.applySlotConfigToProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = applySlotConfigToProductionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> applySlotConfigToProductionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot. Settings from the target slot will be applied onto this slot
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @return the Object object if successful.
     */
    public Object applySlotConfigSlot(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        return applySlotConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().single().getBody();
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot. Settings from the target slot will be applied onto this slot
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> applySlotConfigSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(applySlotConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity), serviceCallback);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot. Settings from the target slot will be applied onto this slot
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @return the observable to the Object object
     */
    public Observable<Object> applySlotConfigSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        return applySlotConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot. Settings from the target slot will be applied onto this slot
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> applySlotConfigSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.applySlotConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = applySlotConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> applySlotConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object resetProductionSlotConfig(String resourceGroupName, String name) {
        return resetProductionSlotConfigWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> resetProductionSlotConfigAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(resetProductionSlotConfigWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> resetProductionSlotConfigAsync(String resourceGroupName, String name) {
        return resetProductionSlotConfigWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> resetProductionSlotConfigWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.resetProductionSlotConfig(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = resetProductionSlotConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> resetProductionSlotConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object resetSlotConfigSlot(String resourceGroupName, String name, String slot) {
        return resetSlotConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> resetSlotConfigSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(resetSlotConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> resetSlotConfigSlotAsync(String resourceGroupName, String name, String slot) {
        return resetSlotConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> resetSlotConfigSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.resetSlotConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = resetSlotConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> resetSlotConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the SlotConfigNamesResourceInner object if successful.
     */
    public SlotConfigNamesResourceInner getSlotConfigNames(String resourceGroupName, String name) {
        return getSlotConfigNamesWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SlotConfigNamesResourceInner> getSlotConfigNamesAsync(String resourceGroupName, String name, final ServiceCallback<SlotConfigNamesResourceInner> serviceCallback) {
        return ServiceCall.create(getSlotConfigNamesWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<SlotConfigNamesResourceInner> getSlotConfigNamesAsync(String resourceGroupName, String name) {
        return getSlotConfigNamesWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SlotConfigNamesResourceInner>, SlotConfigNamesResourceInner>() {
            @Override
            public SlotConfigNamesResourceInner call(ServiceResponse<SlotConfigNamesResourceInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<ServiceResponse<SlotConfigNamesResourceInner>> getSlotConfigNamesWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSlotConfigNames(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SlotConfigNamesResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SlotConfigNamesResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SlotConfigNamesResourceInner> clientResponse = getSlotConfigNamesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SlotConfigNamesResourceInner> getSlotConfigNamesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SlotConfigNamesResourceInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SlotConfigNamesResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotConfigNames Request body containing the names of application settings and connection strings
     * @return the SlotConfigNamesResourceInner object if successful.
     */
    public SlotConfigNamesResourceInner updateSlotConfigNames(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames) {
        return updateSlotConfigNamesWithServiceResponseAsync(resourceGroupName, name, slotConfigNames).toBlocking().single().getBody();
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotConfigNames Request body containing the names of application settings and connection strings
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SlotConfigNamesResourceInner> updateSlotConfigNamesAsync(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames, final ServiceCallback<SlotConfigNamesResourceInner> serviceCallback) {
        return ServiceCall.create(updateSlotConfigNamesWithServiceResponseAsync(resourceGroupName, name, slotConfigNames), serviceCallback);
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotConfigNames Request body containing the names of application settings and connection strings
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<SlotConfigNamesResourceInner> updateSlotConfigNamesAsync(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames) {
        return updateSlotConfigNamesWithServiceResponseAsync(resourceGroupName, name, slotConfigNames).map(new Func1<ServiceResponse<SlotConfigNamesResourceInner>, SlotConfigNamesResourceInner>() {
            @Override
            public SlotConfigNamesResourceInner call(ServiceResponse<SlotConfigNamesResourceInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotConfigNames Request body containing the names of application settings and connection strings
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<ServiceResponse<SlotConfigNamesResourceInner>> updateSlotConfigNamesWithServiceResponseAsync(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotConfigNames == null) {
            throw new IllegalArgumentException("Parameter slotConfigNames is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotConfigNames);
        return service.updateSlotConfigNames(resourceGroupName, name, this.client.subscriptionId(), slotConfigNames, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SlotConfigNamesResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SlotConfigNamesResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SlotConfigNamesResourceInner> clientResponse = updateSlotConfigNamesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SlotConfigNamesResourceInner> updateSlotConfigNamesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SlotConfigNamesResourceInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SlotConfigNamesResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> getSiteSlots(final String resourceGroupName, final String name) {
        ServiceResponse<Page<SiteInner>> response = getSiteSlotsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return getSiteSlotsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> getSiteSlotsAsync(final String resourceGroupName, final String name, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteSlotsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return getSiteSlotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> getSiteSlotsAsync(final String resourceGroupName, final String name) {
        return getSiteSlotsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSiteSlotsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return getSiteSlotsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteSlotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSiteSlotsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String propertiesToInclude = null;
        return service.getSiteSlots(resourceGroupName, name, this.client.subscriptionId(), propertiesToInclude, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = getSiteSlotsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude List of app properties to include in the response
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> getSiteSlots(final String resourceGroupName, final String name, final String propertiesToInclude) {
        ServiceResponse<Page<SiteInner>> response = getSiteSlotsSinglePageAsync(resourceGroupName, name, propertiesToInclude).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return getSiteSlotsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude List of app properties to include in the response
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> getSiteSlotsAsync(final String resourceGroupName, final String name, final String propertiesToInclude, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteSlotsSinglePageAsync(resourceGroupName, name, propertiesToInclude),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return getSiteSlotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude List of app properties to include in the response
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> getSiteSlotsAsync(final String resourceGroupName, final String name, final String propertiesToInclude) {
        return getSiteSlotsWithServiceResponseAsync(resourceGroupName, name, propertiesToInclude)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude List of app properties to include in the response
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSiteSlotsWithServiceResponseAsync(final String resourceGroupName, final String name, final String propertiesToInclude) {
        return getSiteSlotsSinglePageAsync(resourceGroupName, name, propertiesToInclude)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteSlotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SiteInner>> * @param name Name of web app
    ServiceResponse<PageImpl<SiteInner>> * @param propertiesToInclude List of app properties to include in the response
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSiteSlotsSinglePageAsync(final String resourceGroupName, final String name, final String propertiesToInclude) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteSlots(resourceGroupName, name, this.client.subscriptionId(), propertiesToInclude, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = getSiteSlotsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> getSiteSlotsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> getSites(final String resourceGroupName) {
        ServiceResponse<Page<SiteInner>> response = getSitesSinglePageAsync(resourceGroupName).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return getSitesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> getSitesAsync(final String resourceGroupName, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getSitesSinglePageAsync(resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return getSitesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> getSitesAsync(final String resourceGroupName) {
        return getSitesWithServiceResponseAsync(resourceGroupName)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSitesWithServiceResponseAsync(final String resourceGroupName) {
        return getSitesSinglePageAsync(resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSitesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSitesSinglePageAsync(final String resourceGroupName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String propertiesToInclude = null;
        final String includeSiteTypes = null;
        final Boolean includeSlots = null;
        return service.getSites(resourceGroupName, this.client.subscriptionId(), propertiesToInclude, includeSiteTypes, includeSlots, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = getSitesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSiteTypes Types of apps included in the response
     * @param includeSlots Whether or not to include deployments slots in results
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> getSites(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes, final Boolean includeSlots) {
        ServiceResponse<Page<SiteInner>> response = getSitesSinglePageAsync(resourceGroupName, propertiesToInclude, includeSiteTypes, includeSlots).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return getSitesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSiteTypes Types of apps included in the response
     * @param includeSlots Whether or not to include deployments slots in results
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> getSitesAsync(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes, final Boolean includeSlots, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getSitesSinglePageAsync(resourceGroupName, propertiesToInclude, includeSiteTypes, includeSlots),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return getSitesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSiteTypes Types of apps included in the response
     * @param includeSlots Whether or not to include deployments slots in results
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> getSitesAsync(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes, final Boolean includeSlots) {
        return getSitesWithServiceResponseAsync(resourceGroupName, propertiesToInclude, includeSiteTypes, includeSlots)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSiteTypes Types of apps included in the response
     * @param includeSlots Whether or not to include deployments slots in results
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSitesWithServiceResponseAsync(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes, final Boolean includeSlots) {
        return getSitesSinglePageAsync(resourceGroupName, propertiesToInclude, includeSiteTypes, includeSlots)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSitesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SiteInner>> * @param propertiesToInclude Additional web app properties included in the response
    ServiceResponse<PageImpl<SiteInner>> * @param includeSiteTypes Types of apps included in the response
    ServiceResponse<PageImpl<SiteInner>> * @param includeSlots Whether or not to include deployments slots in results
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSitesSinglePageAsync(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes, final Boolean includeSlots) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSites(resourceGroupName, this.client.subscriptionId(), propertiesToInclude, includeSiteTypes, includeSlots, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = getSitesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> getSitesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the SiteInner object if successful.
     */
    public SiteInner getSite(String resourceGroupName, String name) {
        return getSiteWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> getSiteAsync(String resourceGroupName, String name, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(getSiteWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> getSiteAsync(String resourceGroupName, String name) {
        return getSiteWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getSiteWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String propertiesToInclude = null;
        return service.getSite(resourceGroupName, name, this.client.subscriptionId(), propertiesToInclude, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the SiteInner object if successful.
     */
    public SiteInner getSite(String resourceGroupName, String name, String propertiesToInclude) {
        return getSiteWithServiceResponseAsync(resourceGroupName, name, propertiesToInclude).toBlocking().single().getBody();
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude Additional web app properties included in the response
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> getSiteAsync(String resourceGroupName, String name, String propertiesToInclude, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(getSiteWithServiceResponseAsync(resourceGroupName, name, propertiesToInclude), serviceCallback);
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> getSiteAsync(String resourceGroupName, String name, String propertiesToInclude) {
        return getSiteWithServiceResponseAsync(resourceGroupName, name, propertiesToInclude).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getSiteWithServiceResponseAsync(String resourceGroupName, String name, String propertiesToInclude) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSite(resourceGroupName, name, this.client.subscriptionId(), propertiesToInclude, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> getSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @return the SiteInner object  if successful.
     */
    public SiteInner createOrUpdateSite(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return createOrUpdateSiteWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).toBlocking().last().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> createOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteWithServiceResponseAsync(resourceGroupName, name, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable for the request
     */
    public Observable<SiteInner> createOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return createOrUpdateSiteWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateSiteWithServiceResponseAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String skipDnsRegistration = null;
        final String skipCustomDomainVerification = null;
        final String forceDnsRegistration = null;
        final String ttlInSeconds = null;
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSite(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }
    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the SiteInner object if successful.
     */
    public SiteInner createOrUpdateSite(String resourceGroupName, String name, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        return createOrUpdateSiteWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().last().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> createOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable for the request
     */
    public Observable<SiteInner> createOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        return createOrUpdateSiteWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateSiteWithServiceResponseAsync(String resourceGroupName, String name, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSite(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @return the SiteInner object if successful.
     */
    public SiteInner beginCreateOrUpdateSite(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return beginCreateOrUpdateSiteWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginCreateOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginCreateOrUpdateSiteWithServiceResponseAsync(resourceGroupName, name, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginCreateOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return beginCreateOrUpdateSiteWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateSiteWithServiceResponseAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String skipDnsRegistration = null;
        final String skipCustomDomainVerification = null;
        final String forceDnsRegistration = null;
        final String ttlInSeconds = null;
        return service.beginCreateOrUpdateSite(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the SiteInner object if successful.
     */
    public SiteInner beginCreateOrUpdateSite(String resourceGroupName, String name, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        return beginCreateOrUpdateSiteWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().single().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginCreateOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginCreateOrUpdateSiteWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginCreateOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        return beginCreateOrUpdateSiteWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateSiteWithServiceResponseAsync(String resourceGroupName, String name, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        return service.beginCreateOrUpdateSite(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> beginCreateOrUpdateSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object deleteSite(String resourceGroupName, String name) {
        return deleteSiteWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSiteAsync(String resourceGroupName, String name) {
        return deleteSiteWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String deleteMetrics = null;
        final String deleteEmptyServerFarm = null;
        final String skipDnsRegistration = null;
        final String deleteAllSlots = null;
        return service.deleteSite(resourceGroupName, name, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param deleteAllSlots If true, all slots associated with web app are also deleted
     * @return the Object object if successful.
     */
    public Object deleteSite(String resourceGroupName, String name, String deleteMetrics, String deleteEmptyServerFarm, String skipDnsRegistration, String deleteAllSlots) {
        return deleteSiteWithServiceResponseAsync(resourceGroupName, name, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots).toBlocking().single().getBody();
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param deleteAllSlots If true, all slots associated with web app are also deleted
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteAsync(String resourceGroupName, String name, String deleteMetrics, String deleteEmptyServerFarm, String skipDnsRegistration, String deleteAllSlots, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteWithServiceResponseAsync(resourceGroupName, name, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots), serviceCallback);
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param deleteAllSlots If true, all slots associated with web app are also deleted
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSiteAsync(String resourceGroupName, String name, String deleteMetrics, String deleteEmptyServerFarm, String skipDnsRegistration, String deleteAllSlots) {
        return deleteSiteWithServiceResponseAsync(resourceGroupName, name, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param deleteAllSlots If true, all slots associated with web app are also deleted
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteWithServiceResponseAsync(String resourceGroupName, String name, String deleteMetrics, String deleteEmptyServerFarm, String skipDnsRegistration, String deleteAllSlots) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSite(resourceGroupName, name, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the SiteInner object if successful.
     */
    public SiteInner getSiteSlot(String resourceGroupName, String name, String slot) {
        return getSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> getSiteSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(getSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> getSiteSlotAsync(String resourceGroupName, String name, String slot) {
        return getSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String propertiesToInclude = null;
        return service.getSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), propertiesToInclude, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the SiteInner object if successful.
     */
    public SiteInner getSiteSlot(String resourceGroupName, String name, String slot, String propertiesToInclude) {
        return getSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, propertiesToInclude).toBlocking().single().getBody();
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param propertiesToInclude Additional web app properties included in the response
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> getSiteSlotAsync(String resourceGroupName, String name, String slot, String propertiesToInclude, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(getSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, propertiesToInclude), serviceCallback);
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> getSiteSlotAsync(String resourceGroupName, String name, String slot, String propertiesToInclude) {
        return getSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, propertiesToInclude).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String propertiesToInclude) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), propertiesToInclude, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> getSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @return the SiteInner object  if successful.
     */
    public SiteInner createOrUpdateSiteSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return createOrUpdateSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).toBlocking().last().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> createOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable for the request
     */
    public Observable<SiteInner> createOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return createOrUpdateSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String skipDnsRegistration = null;
        final String skipCustomDomainVerification = null;
        final String forceDnsRegistration = null;
        final String ttlInSeconds = null;
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }
    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the SiteInner object if successful.
     */
    public SiteInner createOrUpdateSiteSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        return createOrUpdateSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().last().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> createOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable for the request
     */
    public Observable<SiteInner> createOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        return createOrUpdateSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @return the SiteInner object if successful.
     */
    public SiteInner beginCreateOrUpdateSiteSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return beginCreateOrUpdateSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginCreateOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginCreateOrUpdateSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginCreateOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return beginCreateOrUpdateSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String skipDnsRegistration = null;
        final String skipCustomDomainVerification = null;
        final String forceDnsRegistration = null;
        final String ttlInSeconds = null;
        return service.beginCreateOrUpdateSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the SiteInner object if successful.
     */
    public SiteInner beginCreateOrUpdateSiteSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        return beginCreateOrUpdateSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().single().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginCreateOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginCreateOrUpdateSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginCreateOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        return beginCreateOrUpdateSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        return service.beginCreateOrUpdateSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> beginCreateOrUpdateSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object deleteSiteSlot(String resourceGroupName, String name, String slot) {
        return deleteSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSiteSlotAsync(String resourceGroupName, String name, String slot) {
        return deleteSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String deleteMetrics = null;
        final String deleteEmptyServerFarm = null;
        final String skipDnsRegistration = null;
        final String deleteAllSlots = null;
        return service.deleteSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param deleteAllSlots If true, all slots associated with web app are also deleted
     * @return the Object object if successful.
     */
    public Object deleteSiteSlot(String resourceGroupName, String name, String slot, String deleteMetrics, String deleteEmptyServerFarm, String skipDnsRegistration, String deleteAllSlots) {
        return deleteSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots).toBlocking().single().getBody();
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param deleteAllSlots If true, all slots associated with web app are also deleted
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteSlotAsync(String resourceGroupName, String name, String slot, String deleteMetrics, String deleteEmptyServerFarm, String skipDnsRegistration, String deleteAllSlots, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots), serviceCallback);
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param deleteAllSlots If true, all slots associated with web app are also deleted
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSiteSlotAsync(String resourceGroupName, String name, String slot, String deleteMetrics, String deleteEmptyServerFarm, String skipDnsRegistration, String deleteAllSlots) {
        return deleteSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param deleteAllSlots If true, all slots associated with web app are also deleted
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String deleteMetrics, String deleteEmptyServerFarm, String skipDnsRegistration, String deleteAllSlots) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @return the SiteCloneabilityInner object if successful.
     */
    public SiteCloneabilityInner isSiteCloneable(String resourceGroupName, String name) {
        return isSiteCloneableWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteCloneabilityInner> isSiteCloneableAsync(String resourceGroupName, String name, final ServiceCallback<SiteCloneabilityInner> serviceCallback) {
        return ServiceCall.create(isSiteCloneableWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<SiteCloneabilityInner> isSiteCloneableAsync(String resourceGroupName, String name) {
        return isSiteCloneableWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteCloneabilityInner>, SiteCloneabilityInner>() {
            @Override
            public SiteCloneabilityInner call(ServiceResponse<SiteCloneabilityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<ServiceResponse<SiteCloneabilityInner>> isSiteCloneableWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.isSiteCloneable(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteCloneabilityInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteCloneabilityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteCloneabilityInner> clientResponse = isSiteCloneableDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteCloneabilityInner> isSiteCloneableDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteCloneabilityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteCloneabilityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the SiteCloneabilityInner object if successful.
     */
    public SiteCloneabilityInner isSiteCloneableSlot(String resourceGroupName, String name, String slot) {
        return isSiteCloneableSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteCloneabilityInner> isSiteCloneableSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteCloneabilityInner> serviceCallback) {
        return ServiceCall.create(isSiteCloneableSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<SiteCloneabilityInner> isSiteCloneableSlotAsync(String resourceGroupName, String name, String slot) {
        return isSiteCloneableSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteCloneabilityInner>, SiteCloneabilityInner>() {
            @Override
            public SiteCloneabilityInner call(ServiceResponse<SiteCloneabilityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<ServiceResponse<SiteCloneabilityInner>> isSiteCloneableSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.isSiteCloneableSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteCloneabilityInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteCloneabilityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteCloneabilityInner> clientResponse = isSiteCloneableSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteCloneabilityInner> isSiteCloneableSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteCloneabilityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteCloneabilityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the SiteInner object if successful.
     */
    public SiteInner recoverSite(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        return recoverSiteWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).toBlocking().last().getBody();
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> recoverSiteAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(recoverSiteWithServiceResponseAsync(resourceGroupName, name, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable for the request
     */
    public Observable<SiteInner> recoverSiteAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        return recoverSiteWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> recoverSiteWithServiceResponseAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        Observable<Response<ResponseBody>> observable = service.recoverSite(resourceGroupName, name, this.client.subscriptionId(), recoveryEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the SiteInner object if successful.
     */
    public SiteInner beginRecoverSite(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        return beginRecoverSiteWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).toBlocking().single().getBody();
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginRecoverSiteAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginRecoverSiteWithServiceResponseAsync(resourceGroupName, name, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginRecoverSiteAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        return beginRecoverSiteWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginRecoverSiteWithServiceResponseAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        return service.beginRecoverSite(resourceGroupName, name, this.client.subscriptionId(), recoveryEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginRecoverSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> beginRecoverSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the SiteInner object if successful.
     */
    public SiteInner recoverSiteSlot(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        return recoverSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).toBlocking().last().getBody();
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> recoverSiteSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(recoverSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable for the request
     */
    public Observable<SiteInner> recoverSiteSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        return recoverSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> recoverSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        Observable<Response<ResponseBody>> observable = service.recoverSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), recoveryEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the SiteInner object if successful.
     */
    public SiteInner beginRecoverSiteSlot(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        return beginRecoverSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).toBlocking().single().getBody();
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginRecoverSiteSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginRecoverSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginRecoverSiteSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        return beginRecoverSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginRecoverSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        return service.beginRecoverSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), recoveryEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginRecoverSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> beginRecoverSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Webspace
     * @param name Website Name
     * @return the Object object if successful.
     */
    public Object getSiteSnapshots(String resourceGroupName, String name) {
        return getSiteSnapshotsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Webspace
     * @param name Website Name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSiteSnapshotsAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSiteSnapshotsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Webspace
     * @param name Website Name
     * @return the observable to the Object object
     */
    public Observable<Object> getSiteSnapshotsAsync(String resourceGroupName, String name) {
        return getSiteSnapshotsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Webspace
     * @param name Website Name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSiteSnapshotsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteSnapshots(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSiteSnapshotsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSiteSnapshotsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Webspace
     * @param name Website Name
     * @param slot Website Slot
     * @return the Object object if successful.
     */
    public Object getSiteSnapshotsSlot(String resourceGroupName, String name, String slot) {
        return getSiteSnapshotsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Webspace
     * @param name Website Name
     * @param slot Website Slot
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSiteSnapshotsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSiteSnapshotsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Webspace
     * @param name Website Name
     * @param slot Website Slot
     * @return the observable to the Object object
     */
    public Observable<Object> getSiteSnapshotsSlotAsync(String resourceGroupName, String name, String slot) {
        return getSiteSnapshotsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Webspace
     * @param name Website Name
     * @param slot Website Slot
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSiteSnapshotsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteSnapshotsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSiteSnapshotsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSiteSnapshotsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @return the PagedList&lt;DeletedSiteInner&gt; object if successful.
     */
    public PagedList<DeletedSiteInner> getDeletedSites(final String resourceGroupName) {
        ServiceResponse<Page<DeletedSiteInner>> response = getDeletedSitesSinglePageAsync(resourceGroupName).toBlocking().single();
        return new PagedList<DeletedSiteInner>(response.getBody()) {
            @Override
            public Page<DeletedSiteInner> nextPage(String nextPageLink) {
                return getDeletedSitesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeletedSiteInner>> getDeletedSitesAsync(final String resourceGroupName, final ListOperationCallback<DeletedSiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getDeletedSitesSinglePageAsync(resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(String nextPageLink) {
                    return getDeletedSitesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @return the observable to the PagedList&lt;DeletedSiteInner&gt; object
     */
    public Observable<Page<DeletedSiteInner>> getDeletedSitesAsync(final String resourceGroupName) {
        return getDeletedSitesWithServiceResponseAsync(resourceGroupName)
            .map(new Func1<ServiceResponse<Page<DeletedSiteInner>>, Page<DeletedSiteInner>>() {
                @Override
                public Page<DeletedSiteInner> call(ServiceResponse<Page<DeletedSiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @return the observable to the PagedList&lt;DeletedSiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> getDeletedSitesWithServiceResponseAsync(final String resourceGroupName) {
        return getDeletedSitesSinglePageAsync(resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<DeletedSiteInner>>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(ServiceResponse<Page<DeletedSiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getDeletedSitesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @return the PagedList&lt;DeletedSiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> getDeletedSitesSinglePageAsync(final String resourceGroupName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String propertiesToInclude = null;
        final String includeSiteTypes = null;
        return service.getDeletedSites(resourceGroupName, this.client.subscriptionId(), propertiesToInclude, includeSiteTypes, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeletedSiteInner>> result = getDeletedSitesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeletedSiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSiteTypes Types of apps included in the response
     * @return the PagedList&lt;DeletedSiteInner&gt; object if successful.
     */
    public PagedList<DeletedSiteInner> getDeletedSites(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes) {
        ServiceResponse<Page<DeletedSiteInner>> response = getDeletedSitesSinglePageAsync(resourceGroupName, propertiesToInclude, includeSiteTypes).toBlocking().single();
        return new PagedList<DeletedSiteInner>(response.getBody()) {
            @Override
            public Page<DeletedSiteInner> nextPage(String nextPageLink) {
                return getDeletedSitesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSiteTypes Types of apps included in the response
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeletedSiteInner>> getDeletedSitesAsync(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes, final ListOperationCallback<DeletedSiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getDeletedSitesSinglePageAsync(resourceGroupName, propertiesToInclude, includeSiteTypes),
            new Func1<String, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(String nextPageLink) {
                    return getDeletedSitesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSiteTypes Types of apps included in the response
     * @return the observable to the PagedList&lt;DeletedSiteInner&gt; object
     */
    public Observable<Page<DeletedSiteInner>> getDeletedSitesAsync(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes) {
        return getDeletedSitesWithServiceResponseAsync(resourceGroupName, propertiesToInclude, includeSiteTypes)
            .map(new Func1<ServiceResponse<Page<DeletedSiteInner>>, Page<DeletedSiteInner>>() {
                @Override
                public Page<DeletedSiteInner> call(ServiceResponse<Page<DeletedSiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSiteTypes Types of apps included in the response
     * @return the observable to the PagedList&lt;DeletedSiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> getDeletedSitesWithServiceResponseAsync(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes) {
        return getDeletedSitesSinglePageAsync(resourceGroupName, propertiesToInclude, includeSiteTypes)
            .concatMap(new Func1<ServiceResponse<Page<DeletedSiteInner>>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(ServiceResponse<Page<DeletedSiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getDeletedSitesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     *
    ServiceResponse<PageImpl<DeletedSiteInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<DeletedSiteInner>> * @param propertiesToInclude Additional web app properties included in the response
    ServiceResponse<PageImpl<DeletedSiteInner>> * @param includeSiteTypes Types of apps included in the response
     * @return the PagedList&lt;DeletedSiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> getDeletedSitesSinglePageAsync(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDeletedSites(resourceGroupName, this.client.subscriptionId(), propertiesToInclude, includeSiteTypes, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeletedSiteInner>> result = getDeletedSitesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeletedSiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeletedSiteInner>> getDeletedSitesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeletedSiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeletedSiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> getDeployments(final String resourceGroupName, final String name) {
        ServiceResponse<Page<DeploymentInner>> response = getDeploymentsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return getDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getDeploymentsAsync(final String resourceGroupName, final String name, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getDeploymentsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> getDeploymentsAsync(final String resourceGroupName, final String name) {
        return getDeploymentsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return getDeploymentsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getDeploymentsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of web app
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDeployments(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getDeploymentsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getDeploymentsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> getDeploymentsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<DeploymentInner>> response = getDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return getDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> getDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return getDeploymentsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return getDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getDeploymentsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of web app
    ServiceResponse<PageImpl<DeploymentInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDeploymentsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getDeploymentsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getDeploymentsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param instanceId Id of web app instance
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> getInstanceDeployments(final String resourceGroupName, final String name, final String instanceId) {
        ServiceResponse<Page<DeploymentInner>> response = getInstanceDeploymentsSinglePageAsync(resourceGroupName, name, instanceId).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return getInstanceDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getInstanceDeploymentsAsync(final String resourceGroupName, final String name, final String instanceId, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getInstanceDeploymentsSinglePageAsync(resourceGroupName, name, instanceId),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getInstanceDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param instanceId Id of web app instance
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> getInstanceDeploymentsAsync(final String resourceGroupName, final String name, final String instanceId) {
        return getInstanceDeploymentsWithServiceResponseAsync(resourceGroupName, name, instanceId)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param instanceId Id of web app instance
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsWithServiceResponseAsync(final String resourceGroupName, final String name, final String instanceId) {
        return getInstanceDeploymentsSinglePageAsync(resourceGroupName, name, instanceId)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getInstanceDeploymentsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of web app
    ServiceResponse<PageImpl<DeploymentInner>> * @param instanceId Id of web app instance
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsSinglePageAsync(final String resourceGroupName, final String name, final String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceDeployments(resourceGroupName, name, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getInstanceDeploymentsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getInstanceDeploymentsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> getInstanceDeploymentsSlot(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        ServiceResponse<Page<DeploymentInner>> response = getInstanceDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot, instanceId).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getInstanceDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot, final String instanceId, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getInstanceDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot, instanceId),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> getInstanceDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        return getInstanceDeploymentsSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        return getInstanceDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot, instanceId)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getInstanceDeploymentsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of web app
    ServiceResponse<PageImpl<DeploymentInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
    ServiceResponse<PageImpl<DeploymentInner>> * @param instanceId Id of web app instance
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceDeploymentsSlot(resourceGroupName, name, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getInstanceDeploymentsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getInstanceDeploymentsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner getInstanceDeployment(String resourceGroupName, String name, String id, String instanceId) {
        return getInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId).toBlocking().single().getBody();
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> getInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(getInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId), serviceCallback);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> getInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId) {
        return getInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getInstanceDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceDeployment(resourceGroupName, name, id, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getInstanceDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getInstanceDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner createInstanceDeployment(String resourceGroupName, String name, String id, String instanceId, DeploymentInner deployment) {
        return createInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId, deployment).toBlocking().single().getBody();
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> createInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(createInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId, deployment), serviceCallback);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> createInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, DeploymentInner deployment) {
        return createInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId, deployment).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createInstanceDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id, String instanceId, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(deployment);
        return service.createInstanceDeployment(resourceGroupName, name, id, instanceId, this.client.subscriptionId(), deployment, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createInstanceDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createInstanceDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @return the Object object if successful.
     */
    public Object deleteInstanceDeployment(String resourceGroupName, String name, String id, String instanceId) {
        return deleteInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId).toBlocking().single().getBody();
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId), serviceCallback);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @return the observable to the Object object
     */
    public Observable<Object> deleteInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId) {
        return deleteInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteInstanceDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteInstanceDeployment(resourceGroupName, name, id, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteInstanceDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteInstanceDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner getDeployment(String resourceGroupName, String name, String id) {
        return getDeploymentWithServiceResponseAsync(resourceGroupName, name, id).toBlocking().single().getBody();
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> getDeploymentAsync(String resourceGroupName, String name, String id, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(getDeploymentWithServiceResponseAsync(resourceGroupName, name, id), serviceCallback);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> getDeploymentAsync(String resourceGroupName, String name, String id) {
        return getDeploymentWithServiceResponseAsync(resourceGroupName, name, id).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDeployment(resourceGroupName, name, id, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param deployment Details of deployment
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner createDeployment(String resourceGroupName, String name, String id, DeploymentInner deployment) {
        return createDeploymentWithServiceResponseAsync(resourceGroupName, name, id, deployment).toBlocking().single().getBody();
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param deployment Details of deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> createDeploymentAsync(String resourceGroupName, String name, String id, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(createDeploymentWithServiceResponseAsync(resourceGroupName, name, id, deployment), serviceCallback);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> createDeploymentAsync(String resourceGroupName, String name, String id, DeploymentInner deployment) {
        return createDeploymentWithServiceResponseAsync(resourceGroupName, name, id, deployment).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(deployment);
        return service.createDeployment(resourceGroupName, name, id, this.client.subscriptionId(), deployment, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @return the Object object if successful.
     */
    public Object deleteDeployment(String resourceGroupName, String name, String id) {
        return deleteDeploymentWithServiceResponseAsync(resourceGroupName, name, id).toBlocking().single().getBody();
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteDeploymentAsync(String resourceGroupName, String name, String id, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteDeploymentWithServiceResponseAsync(resourceGroupName, name, id), serviceCallback);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @return the observable to the Object object
     */
    public Observable<Object> deleteDeploymentAsync(String resourceGroupName, String name, String id) {
        return deleteDeploymentWithServiceResponseAsync(resourceGroupName, name, id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteDeployment(resourceGroupName, name, id, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner getDeploymentSlot(String resourceGroupName, String name, String id, String slot) {
        return getDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).toBlocking().single().getBody();
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> getDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(getDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot), serviceCallback);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> getDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot) {
        return getDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDeploymentSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deployment Details of deployment
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner createDeploymentSlot(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment) {
        return createDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, deployment).toBlocking().single().getBody();
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deployment Details of deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> createDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(createDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, deployment), serviceCallback);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> createDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment) {
        return createDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, deployment).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(deployment);
        return service.createDeploymentSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), deployment, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object deleteDeploymentSlot(String resourceGroupName, String name, String id, String slot) {
        return deleteDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).toBlocking().single().getBody();
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot), serviceCallback);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> deleteDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot) {
        return deleteDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteDeploymentSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner getInstanceDeploymentSlot(String resourceGroupName, String name, String id, String slot, String instanceId) {
        return getInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId).toBlocking().single().getBody();
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> getInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(getInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId), serviceCallback);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> getInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId) {
        return getInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getInstanceDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getInstanceDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getInstanceDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner createInstanceDeploymentSlot(String resourceGroupName, String name, String id, String slot, String instanceId, DeploymentInner deployment) {
        return createInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId, deployment).toBlocking().single().getBody();
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> createInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(createInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId, deployment), serviceCallback);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> createInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, DeploymentInner deployment) {
        return createInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId, deployment).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createInstanceDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot, String instanceId, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(deployment);
        return service.createInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, this.client.subscriptionId(), deployment, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createInstanceDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createInstanceDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the Object object if successful.
     */
    public Object deleteInstanceDeploymentSlot(String resourceGroupName, String name, String id, String slot, String instanceId) {
        return deleteInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId).toBlocking().single().getBody();
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId), serviceCallback);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the observable to the Object object
     */
    public Observable<Object> deleteInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId) {
        return deleteInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteInstanceDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteInstanceDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteInstanceDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> getSiteInstanceIdentifiers(final String resourceGroupName, final String name) {
        ServiceResponse<Page<SiteInstanceInner>> response = getSiteInstanceIdentifiersSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.getBody()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInstanceInner>> getSiteInstanceIdentifiersAsync(final String resourceGroupName, final String name, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteInstanceIdentifiersSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> getSiteInstanceIdentifiersAsync(final String resourceGroupName, final String name) {
        return getSiteInstanceIdentifiersWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return getSiteInstanceIdentifiersSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteInstanceIdentifiersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all instance of a web app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param name Name of web app
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteInstanceIdentifiers(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = getSiteInstanceIdentifiersDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> getSiteInstanceIdentifiersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInstanceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> getSiteInstanceIdentifiersSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<SiteInstanceInner>> response = getSiteInstanceIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.getBody()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInstanceInner>> getSiteInstanceIdentifiersSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteInstanceIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> getSiteInstanceIdentifiersSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return getSiteInstanceIdentifiersSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return getSiteInstanceIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteInstanceIdentifiersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all instance of a web app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param name Name of web app
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteInstanceIdentifiersSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = getSiteInstanceIdentifiersSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> getSiteInstanceIdentifiersSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInstanceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> getSiteHostNameBindings(final String resourceGroupName, final String name) {
        ServiceResponse<Page<HostNameBindingInner>> response = getSiteHostNameBindingsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.getBody()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return getSiteHostNameBindingsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<HostNameBindingInner>> getSiteHostNameBindingsAsync(final String resourceGroupName, final String name, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteHostNameBindingsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return getSiteHostNameBindingsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> getSiteHostNameBindingsAsync(final String resourceGroupName, final String name) {
        return getSiteHostNameBindingsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return getSiteHostNameBindingsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteHostNameBindingsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get web app hostname bindings.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param name Name of web app
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteHostNameBindings(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = getSiteHostNameBindingsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> getSiteHostNameBindingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<HostNameBindingInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> getSiteHostNameBindingsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<HostNameBindingInner>> response = getSiteHostNameBindingsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.getBody()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<HostNameBindingInner>> getSiteHostNameBindingsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteHostNameBindingsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> getSiteHostNameBindingsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return getSiteHostNameBindingsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return getSiteHostNameBindingsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteHostNameBindingsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get web app hostname bindings.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param name Name of web app
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteHostNameBindingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = getSiteHostNameBindingsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> getSiteHostNameBindingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<HostNameBindingInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner getSiteHostNameBinding(String resourceGroupName, String name, String hostName) {
        return getSiteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).toBlocking().single().getBody();
    }

    /**
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HostNameBindingInner> getSiteHostNameBindingAsync(String resourceGroupName, String name, String hostName, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceCall.create(getSiteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName), serviceCallback);
    }

    /**
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> getSiteHostNameBindingAsync(String resourceGroupName, String name, String hostName) {
        return getSiteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> getSiteHostNameBindingWithServiceResponseAsync(String resourceGroupName, String name, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteHostNameBinding(resourceGroupName, name, hostName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = getSiteHostNameBindingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> getSiteHostNameBindingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HostNameBindingInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param hostNameBinding Host name binding information
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner createOrUpdateSiteHostNameBinding(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding) {
        return createOrUpdateSiteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName, hostNameBinding).toBlocking().single().getBody();
    }

    /**
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param hostNameBinding Host name binding information
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HostNameBindingInner> createOrUpdateSiteHostNameBindingAsync(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName, hostNameBinding), serviceCallback);
    }

    /**
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param hostNameBinding Host name binding information
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> createOrUpdateSiteHostNameBindingAsync(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding) {
        return createOrUpdateSiteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName, hostNameBinding).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param hostNameBinding Host name binding information
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> createOrUpdateSiteHostNameBindingWithServiceResponseAsync(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (hostNameBinding == null) {
            throw new IllegalArgumentException("Parameter hostNameBinding is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(hostNameBinding);
        return service.createOrUpdateSiteHostNameBinding(resourceGroupName, name, hostName, this.client.subscriptionId(), hostNameBinding, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = createOrUpdateSiteHostNameBindingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> createOrUpdateSiteHostNameBindingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HostNameBindingInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @return the Object object if successful.
     */
    public Object deleteSiteHostNameBinding(String resourceGroupName, String name, String hostName) {
        return deleteSiteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).toBlocking().single().getBody();
    }

    /**
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteHostNameBindingAsync(String resourceGroupName, String name, String hostName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName), serviceCallback);
    }

    /**
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSiteHostNameBindingAsync(String resourceGroupName, String name, String hostName) {
        return deleteSiteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteHostNameBindingWithServiceResponseAsync(String resourceGroupName, String name, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteHostNameBinding(resourceGroupName, name, hostName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteHostNameBindingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteHostNameBindingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner getSiteHostNameBindingSlot(String resourceGroupName, String name, String slot, String hostName) {
        return getSiteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).toBlocking().single().getBody();
    }

    /**
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HostNameBindingInner> getSiteHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceCall.create(getSiteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName), serviceCallback);
    }

    /**
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> getSiteHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName) {
        return getSiteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> getSiteHostNameBindingSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteHostNameBindingSlot(resourceGroupName, name, slot, hostName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = getSiteHostNameBindingSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> getSiteHostNameBindingSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HostNameBindingInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostNameBinding Host name binding information
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner createOrUpdateSiteHostNameBindingSlot(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding) {
        return createOrUpdateSiteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, hostName, slot, hostNameBinding).toBlocking().single().getBody();
    }

    /**
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostNameBinding Host name binding information
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HostNameBindingInner> createOrUpdateSiteHostNameBindingSlotAsync(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, hostName, slot, hostNameBinding), serviceCallback);
    }

    /**
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostNameBinding Host name binding information
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> createOrUpdateSiteHostNameBindingSlotAsync(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding) {
        return createOrUpdateSiteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, hostName, slot, hostNameBinding).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostNameBinding Host name binding information
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> createOrUpdateSiteHostNameBindingSlotWithServiceResponseAsync(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (hostNameBinding == null) {
            throw new IllegalArgumentException("Parameter hostNameBinding is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(hostNameBinding);
        return service.createOrUpdateSiteHostNameBindingSlot(resourceGroupName, name, hostName, slot, this.client.subscriptionId(), hostNameBinding, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = createOrUpdateSiteHostNameBindingSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> createOrUpdateSiteHostNameBindingSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HostNameBindingInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @return the Object object if successful.
     */
    public Object deleteSiteHostNameBindingSlot(String resourceGroupName, String name, String slot, String hostName) {
        return deleteSiteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).toBlocking().single().getBody();
    }

    /**
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName), serviceCallback);
    }

    /**
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSiteHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName) {
        return deleteSiteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteHostNameBindingSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteHostNameBindingSlot(resourceGroupName, name, slot, hostName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteHostNameBindingSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteHostNameBindingSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the SiteConfigInner object if successful.
     */
    public SiteConfigInner getSiteConfig(String resourceGroupName, String name) {
        return getSiteConfigWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> getSiteConfigAsync(String resourceGroupName, String name, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(getSiteConfigWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<SiteConfigInner> getSiteConfigAsync(String resourceGroupName, String name) {
        return getSiteConfigWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteConfigInner>, SiteConfigInner>() {
            @Override
            public SiteConfigInner call(ServiceResponse<SiteConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> getSiteConfigWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteConfig(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = getSiteConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> getSiteConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the SiteConfigInner object if successful.
     */
    public SiteConfigInner createOrUpdateSiteConfig(String resourceGroupName, String name, SiteConfigInner siteConfig) {
        return createOrUpdateSiteConfigWithServiceResponseAsync(resourceGroupName, name, siteConfig).toBlocking().single().getBody();
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> createOrUpdateSiteConfigAsync(String resourceGroupName, String name, SiteConfigInner siteConfig, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteConfigWithServiceResponseAsync(resourceGroupName, name, siteConfig), serviceCallback);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<SiteConfigInner> createOrUpdateSiteConfigAsync(String resourceGroupName, String name, SiteConfigInner siteConfig) {
        return createOrUpdateSiteConfigWithServiceResponseAsync(resourceGroupName, name, siteConfig).map(new Func1<ServiceResponse<SiteConfigInner>, SiteConfigInner>() {
            @Override
            public SiteConfigInner call(ServiceResponse<SiteConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> createOrUpdateSiteConfigWithServiceResponseAsync(String resourceGroupName, String name, SiteConfigInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        return service.createOrUpdateSiteConfig(resourceGroupName, name, this.client.subscriptionId(), siteConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = createOrUpdateSiteConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> createOrUpdateSiteConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the SiteConfigInner object if successful.
     */
    public SiteConfigInner updateSiteConfig(String resourceGroupName, String name, SiteConfigInner siteConfig) {
        return updateSiteConfigWithServiceResponseAsync(resourceGroupName, name, siteConfig).toBlocking().single().getBody();
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> updateSiteConfigAsync(String resourceGroupName, String name, SiteConfigInner siteConfig, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(updateSiteConfigWithServiceResponseAsync(resourceGroupName, name, siteConfig), serviceCallback);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<SiteConfigInner> updateSiteConfigAsync(String resourceGroupName, String name, SiteConfigInner siteConfig) {
        return updateSiteConfigWithServiceResponseAsync(resourceGroupName, name, siteConfig).map(new Func1<ServiceResponse<SiteConfigInner>, SiteConfigInner>() {
            @Override
            public SiteConfigInner call(ServiceResponse<SiteConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> updateSiteConfigWithServiceResponseAsync(String resourceGroupName, String name, SiteConfigInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        return service.updateSiteConfig(resourceGroupName, name, this.client.subscriptionId(), siteConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = updateSiteConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> updateSiteConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the SiteConfigInner object if successful.
     */
    public SiteConfigInner getSiteConfigSlot(String resourceGroupName, String name, String slot) {
        return getSiteConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> getSiteConfigSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(getSiteConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteConfigInner object
     */
    public Observable<SiteConfigInner> getSiteConfigSlotAsync(String resourceGroupName, String name, String slot) {
        return getSiteConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteConfigInner>, SiteConfigInner>() {
            @Override
            public SiteConfigInner call(ServiceResponse<SiteConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> getSiteConfigSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = getSiteConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> getSiteConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the SiteConfigInner object if successful.
     */
    public SiteConfigInner createOrUpdateSiteConfigSlot(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) {
        return createOrUpdateSiteConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).toBlocking().single().getBody();
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> createOrUpdateSiteConfigSlotAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig), serviceCallback);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<SiteConfigInner> createOrUpdateSiteConfigSlotAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) {
        return createOrUpdateSiteConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).map(new Func1<ServiceResponse<SiteConfigInner>, SiteConfigInner>() {
            @Override
            public SiteConfigInner call(ServiceResponse<SiteConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> createOrUpdateSiteConfigSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        return service.createOrUpdateSiteConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = createOrUpdateSiteConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> createOrUpdateSiteConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the SiteConfigInner object if successful.
     */
    public SiteConfigInner updateSiteConfigSlot(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) {
        return updateSiteConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).toBlocking().single().getBody();
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> updateSiteConfigSlotAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(updateSiteConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig), serviceCallback);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<SiteConfigInner> updateSiteConfigSlotAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) {
        return updateSiteConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).map(new Func1<ServiceResponse<SiteConfigInner>, SiteConfigInner>() {
            @Override
            public SiteConfigInner call(ServiceResponse<SiteConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> updateSiteConfigSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        return service.updateSiteConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = updateSiteConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> updateSiteConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner getSiteSourceControl(String resourceGroupName, String name) {
        return getSiteSourceControlWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> getSiteSourceControlAsync(String resourceGroupName, String name, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(getSiteSourceControlWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> getSiteSourceControlAsync(String resourceGroupName, String name) {
        return getSiteSourceControlWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> getSiteSourceControlWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteSourceControl(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = getSiteSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> getSiteSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner createOrUpdateSiteSourceControl(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSiteSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).toBlocking().single().getBody();
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> createOrUpdateSiteSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl), serviceCallback);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> createOrUpdateSiteSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSiteSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> createOrUpdateSiteSourceControlWithServiceResponseAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        return service.createOrUpdateSiteSourceControl(resourceGroupName, name, this.client.subscriptionId(), siteSourceControl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = createOrUpdateSiteSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> createOrUpdateSiteSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object deleteSiteSourceControl(String resourceGroupName, String name) {
        return deleteSiteSourceControlWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteSourceControlAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteSourceControlWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSiteSourceControlAsync(String resourceGroupName, String name) {
        return deleteSiteSourceControlWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteSourceControlWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteSourceControl(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner updateSiteSourceControl(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return updateSiteSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).toBlocking().single().getBody();
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> updateSiteSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(updateSiteSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl), serviceCallback);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> updateSiteSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return updateSiteSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> updateSiteSourceControlWithServiceResponseAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        return service.updateSiteSourceControl(resourceGroupName, name, this.client.subscriptionId(), siteSourceControl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = updateSiteSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> updateSiteSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner getSiteSourceControlSlot(String resourceGroupName, String name, String slot) {
        return getSiteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> getSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(getSiteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> getSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot) {
        return getSiteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> getSiteSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = getSiteSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> getSiteSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner createOrUpdateSiteSourceControlSlot(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSiteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).toBlocking().single().getBody();
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> createOrUpdateSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl), serviceCallback);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> createOrUpdateSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSiteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> createOrUpdateSiteSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        return service.createOrUpdateSiteSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteSourceControl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = createOrUpdateSiteSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> createOrUpdateSiteSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object deleteSiteSourceControlSlot(String resourceGroupName, String name, String slot) {
        return deleteSiteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot) {
        return deleteSiteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner updateSiteSourceControlSlot(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return updateSiteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).toBlocking().single().getBody();
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> updateSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(updateSiteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl), serviceCallback);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> updateSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return updateSiteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> updateSiteSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        return service.updateSiteSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteSourceControl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = updateSiteSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> updateSiteSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listSiteAppSettingsSlot(String resourceGroupName, String name, String slot) {
        return listSiteAppSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> listSiteAppSettingsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listSiteAppSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listSiteAppSettingsSlotAsync(String resourceGroupName, String name, String slot) {
        return listSiteAppSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listSiteAppSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteAppSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listSiteAppSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listSiteAppSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listSiteAppSettings(String resourceGroupName, String name) {
        return listSiteAppSettingsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> listSiteAppSettingsAsync(String resourceGroupName, String name, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listSiteAppSettingsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listSiteAppSettingsAsync(String resourceGroupName, String name) {
        return listSiteAppSettingsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listSiteAppSettingsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteAppSettings(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listSiteAppSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listSiteAppSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param appSettings Application settings of web app
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateSiteAppSettings(String resourceGroupName, String name, StringDictionaryInner appSettings) {
        return updateSiteAppSettingsWithServiceResponseAsync(resourceGroupName, name, appSettings).toBlocking().single().getBody();
    }

    /**
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param appSettings Application settings of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> updateSiteAppSettingsAsync(String resourceGroupName, String name, StringDictionaryInner appSettings, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateSiteAppSettingsWithServiceResponseAsync(resourceGroupName, name, appSettings), serviceCallback);
    }

    /**
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param appSettings Application settings of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateSiteAppSettingsAsync(String resourceGroupName, String name, StringDictionaryInner appSettings) {
        return updateSiteAppSettingsWithServiceResponseAsync(resourceGroupName, name, appSettings).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param appSettings Application settings of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateSiteAppSettingsWithServiceResponseAsync(String resourceGroupName, String name, StringDictionaryInner appSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (appSettings == null) {
            throw new IllegalArgumentException("Parameter appSettings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(appSettings);
        return service.updateSiteAppSettings(resourceGroupName, name, this.client.subscriptionId(), appSettings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateSiteAppSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateSiteAppSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param appSettings Application settings of web app
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateSiteAppSettingsSlot(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings) {
        return updateSiteAppSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, appSettings).toBlocking().single().getBody();
    }

    /**
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param appSettings Application settings of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> updateSiteAppSettingsSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateSiteAppSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, appSettings), serviceCallback);
    }

    /**
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param appSettings Application settings of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateSiteAppSettingsSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings) {
        return updateSiteAppSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, appSettings).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param appSettings Application settings of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateSiteAppSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (appSettings == null) {
            throw new IllegalArgumentException("Parameter appSettings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(appSettings);
        return service.updateSiteAppSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), appSettings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateSiteAppSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateSiteAppSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner listSiteConnectionStrings(String resourceGroupName, String name) {
        return listSiteConnectionStringsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ConnectionStringDictionaryInner> listSiteConnectionStringsAsync(String resourceGroupName, String name, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listSiteConnectionStringsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> listSiteConnectionStringsAsync(String resourceGroupName, String name) {
        return listSiteConnectionStringsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> listSiteConnectionStringsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteConnectionStrings(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = listSiteConnectionStringsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> listSiteConnectionStringsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ConnectionStringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner listSiteConnectionStringsSlot(String resourceGroupName, String name, String slot) {
        return listSiteConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ConnectionStringDictionaryInner> listSiteConnectionStringsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listSiteConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> listSiteConnectionStringsSlotAsync(String resourceGroupName, String name, String slot) {
        return listSiteConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> listSiteConnectionStringsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteConnectionStringsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = listSiteConnectionStringsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> listSiteConnectionStringsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ConnectionStringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param connectionStrings Connection strings associated with web app
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner updateSiteConnectionStrings(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings) {
        return updateSiteConnectionStringsWithServiceResponseAsync(resourceGroupName, name, connectionStrings).toBlocking().single().getBody();
    }

    /**
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param connectionStrings Connection strings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ConnectionStringDictionaryInner> updateSiteConnectionStringsAsync(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateSiteConnectionStringsWithServiceResponseAsync(resourceGroupName, name, connectionStrings), serviceCallback);
    }

    /**
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param connectionStrings Connection strings associated with web app
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> updateSiteConnectionStringsAsync(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings) {
        return updateSiteConnectionStringsWithServiceResponseAsync(resourceGroupName, name, connectionStrings).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param connectionStrings Connection strings associated with web app
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> updateSiteConnectionStringsWithServiceResponseAsync(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionStrings == null) {
            throw new IllegalArgumentException("Parameter connectionStrings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionStrings);
        return service.updateSiteConnectionStrings(resourceGroupName, name, this.client.subscriptionId(), connectionStrings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = updateSiteConnectionStringsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> updateSiteConnectionStringsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ConnectionStringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param connectionStrings Connection strings associated with web app
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner updateSiteConnectionStringsSlot(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings) {
        return updateSiteConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot, connectionStrings).toBlocking().single().getBody();
    }

    /**
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param connectionStrings Connection strings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ConnectionStringDictionaryInner> updateSiteConnectionStringsSlotAsync(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateSiteConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot, connectionStrings), serviceCallback);
    }

    /**
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param connectionStrings Connection strings associated with web app
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> updateSiteConnectionStringsSlotAsync(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings) {
        return updateSiteConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot, connectionStrings).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param connectionStrings Connection strings associated with web app
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> updateSiteConnectionStringsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionStrings == null) {
            throw new IllegalArgumentException("Parameter connectionStrings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionStrings);
        return service.updateSiteConnectionStringsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), connectionStrings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = updateSiteConnectionStringsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> updateSiteConnectionStringsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ConnectionStringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner listSiteAuthSettings(String resourceGroupName, String name) {
        return listSiteAuthSettingsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteAuthSettingsInner> listSiteAuthSettingsAsync(String resourceGroupName, String name, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceCall.create(listSiteAuthSettingsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> listSiteAuthSettingsAsync(String resourceGroupName, String name) {
        return listSiteAuthSettingsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> listSiteAuthSettingsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteAuthSettings(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = listSiteAuthSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> listSiteAuthSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteAuthSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner listSiteAuthSettingsSlot(String resourceGroupName, String name, String slot) {
        return listSiteAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteAuthSettingsInner> listSiteAuthSettingsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceCall.create(listSiteAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> listSiteAuthSettingsSlotAsync(String resourceGroupName, String name, String slot) {
        return listSiteAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> listSiteAuthSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteAuthSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = listSiteAuthSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> listSiteAuthSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteAuthSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteAuthSettings Auth settings associated with web app
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner updateSiteAuthSettings(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings) {
        return updateSiteAuthSettingsWithServiceResponseAsync(resourceGroupName, name, siteAuthSettings).toBlocking().single().getBody();
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteAuthSettings Auth settings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteAuthSettingsInner> updateSiteAuthSettingsAsync(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceCall.create(updateSiteAuthSettingsWithServiceResponseAsync(resourceGroupName, name, siteAuthSettings), serviceCallback);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteAuthSettings Auth settings associated with web app
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> updateSiteAuthSettingsAsync(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings) {
        return updateSiteAuthSettingsWithServiceResponseAsync(resourceGroupName, name, siteAuthSettings).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteAuthSettings Auth settings associated with web app
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> updateSiteAuthSettingsWithServiceResponseAsync(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteAuthSettings == null) {
            throw new IllegalArgumentException("Parameter siteAuthSettings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteAuthSettings);
        return service.updateSiteAuthSettings(resourceGroupName, name, this.client.subscriptionId(), siteAuthSettings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = updateSiteAuthSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> updateSiteAuthSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteAuthSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner updateSiteAuthSettingsSlot(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings) {
        return updateSiteAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteAuthSettings).toBlocking().single().getBody();
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteAuthSettingsInner> updateSiteAuthSettingsSlotAsync(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceCall.create(updateSiteAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteAuthSettings), serviceCallback);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> updateSiteAuthSettingsSlotAsync(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings) {
        return updateSiteAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteAuthSettings).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> updateSiteAuthSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteAuthSettings == null) {
            throw new IllegalArgumentException("Parameter siteAuthSettings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteAuthSettings);
        return service.updateSiteAuthSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteAuthSettings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = updateSiteAuthSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> updateSiteAuthSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteAuthSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the UserInner object if successful.
     */
    public UserInner listSitePublishingCredentials(String resourceGroupName, String name) {
        return listSitePublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).toBlocking().last().getBody();
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<UserInner> listSitePublishingCredentialsAsync(String resourceGroupName, String name, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceCall.create(listSitePublishingCredentialsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable for the request
     */
    public Observable<UserInner> listSitePublishingCredentialsAsync(String resourceGroupName, String name) {
        return listSitePublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable for the request
     */
    public Observable<ServiceResponse<UserInner>> listSitePublishingCredentialsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.listSitePublishingCredentials(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<UserInner>() { }.getType());
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the UserInner object if successful.
     */
    public UserInner beginListSitePublishingCredentials(String resourceGroupName, String name) {
        return beginListSitePublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<UserInner> beginListSitePublishingCredentialsAsync(String resourceGroupName, String name, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceCall.create(beginListSitePublishingCredentialsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the UserInner object
     */
    public Observable<UserInner> beginListSitePublishingCredentialsAsync(String resourceGroupName, String name) {
        return beginListSitePublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the UserInner object
     */
    public Observable<ServiceResponse<UserInner>> beginListSitePublishingCredentialsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginListSitePublishingCredentials(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserInner>>>() {
                @Override
                public Observable<ServiceResponse<UserInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserInner> clientResponse = beginListSitePublishingCredentialsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserInner> beginListSitePublishingCredentialsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<UserInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<UserInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the UserInner object if successful.
     */
    public UserInner listSitePublishingCredentialsSlot(String resourceGroupName, String name, String slot) {
        return listSitePublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().last().getBody();
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<UserInner> listSitePublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceCall.create(listSitePublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable for the request
     */
    public Observable<UserInner> listSitePublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot) {
        return listSitePublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable for the request
     */
    public Observable<ServiceResponse<UserInner>> listSitePublishingCredentialsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.listSitePublishingCredentialsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<UserInner>() { }.getType());
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the UserInner object if successful.
     */
    public UserInner beginListSitePublishingCredentialsSlot(String resourceGroupName, String name, String slot) {
        return beginListSitePublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<UserInner> beginListSitePublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceCall.create(beginListSitePublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the UserInner object
     */
    public Observable<UserInner> beginListSitePublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot) {
        return beginListSitePublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the UserInner object
     */
    public Observable<ServiceResponse<UserInner>> beginListSitePublishingCredentialsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginListSitePublishingCredentialsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserInner>>>() {
                @Override
                public Observable<ServiceResponse<UserInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserInner> clientResponse = beginListSitePublishingCredentialsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserInner> beginListSitePublishingCredentialsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<UserInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<UserInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listSiteMetadata(String resourceGroupName, String name) {
        return listSiteMetadataWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> listSiteMetadataAsync(String resourceGroupName, String name, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listSiteMetadataWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listSiteMetadataAsync(String resourceGroupName, String name) {
        return listSiteMetadataWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listSiteMetadataWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteMetadata(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listSiteMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listSiteMetadataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listSiteMetadataSlot(String resourceGroupName, String name, String slot) {
        return listSiteMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> listSiteMetadataSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listSiteMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listSiteMetadataSlotAsync(String resourceGroupName, String name, String slot) {
        return listSiteMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listSiteMetadataSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteMetadataSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listSiteMetadataSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listSiteMetadataSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param metadata Meta data of web app
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateSiteMetadata(String resourceGroupName, String name, StringDictionaryInner metadata) {
        return updateSiteMetadataWithServiceResponseAsync(resourceGroupName, name, metadata).toBlocking().single().getBody();
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param metadata Meta data of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> updateSiteMetadataAsync(String resourceGroupName, String name, StringDictionaryInner metadata, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateSiteMetadataWithServiceResponseAsync(resourceGroupName, name, metadata), serviceCallback);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param metadata Meta data of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateSiteMetadataAsync(String resourceGroupName, String name, StringDictionaryInner metadata) {
        return updateSiteMetadataWithServiceResponseAsync(resourceGroupName, name, metadata).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param metadata Meta data of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateSiteMetadataWithServiceResponseAsync(String resourceGroupName, String name, StringDictionaryInner metadata) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (metadata == null) {
            throw new IllegalArgumentException("Parameter metadata is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(metadata);
        return service.updateSiteMetadata(resourceGroupName, name, this.client.subscriptionId(), metadata, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateSiteMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateSiteMetadataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param metadata Meta data of web app
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateSiteMetadataSlot(String resourceGroupName, String name, String slot, StringDictionaryInner metadata) {
        return updateSiteMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot, metadata).toBlocking().single().getBody();
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param metadata Meta data of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> updateSiteMetadataSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner metadata, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateSiteMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot, metadata), serviceCallback);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param metadata Meta data of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateSiteMetadataSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner metadata) {
        return updateSiteMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot, metadata).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param metadata Meta data of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateSiteMetadataSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, StringDictionaryInner metadata) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (metadata == null) {
            throw new IllegalArgumentException("Parameter metadata is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(metadata);
        return service.updateSiteMetadataSlot(resourceGroupName, name, slot, this.client.subscriptionId(), metadata, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateSiteMetadataSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateSiteMetadataSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner getSiteLogsConfig(String resourceGroupName, String name) {
        return getSiteLogsConfigWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteLogsConfigInner> getSiteLogsConfigAsync(String resourceGroupName, String name, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceCall.create(getSiteLogsConfigWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> getSiteLogsConfigAsync(String resourceGroupName, String name) {
        return getSiteLogsConfigWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> getSiteLogsConfigWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteLogsConfig(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = getSiteLogsConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> getSiteLogsConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteLogsConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteLogsConfig Site logs configuration
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner updateSiteLogsConfig(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig) {
        return updateSiteLogsConfigWithServiceResponseAsync(resourceGroupName, name, siteLogsConfig).toBlocking().single().getBody();
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteLogsConfig Site logs configuration
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteLogsConfigInner> updateSiteLogsConfigAsync(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceCall.create(updateSiteLogsConfigWithServiceResponseAsync(resourceGroupName, name, siteLogsConfig), serviceCallback);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteLogsConfig Site logs configuration
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> updateSiteLogsConfigAsync(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig) {
        return updateSiteLogsConfigWithServiceResponseAsync(resourceGroupName, name, siteLogsConfig).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteLogsConfig Site logs configuration
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> updateSiteLogsConfigWithServiceResponseAsync(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteLogsConfig == null) {
            throw new IllegalArgumentException("Parameter siteLogsConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteLogsConfig);
        return service.updateSiteLogsConfig(resourceGroupName, name, this.client.subscriptionId(), siteLogsConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = updateSiteLogsConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> updateSiteLogsConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteLogsConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner getSiteLogsConfigSlot(String resourceGroupName, String name, String slot) {
        return getSiteLogsConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteLogsConfigInner> getSiteLogsConfigSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceCall.create(getSiteLogsConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> getSiteLogsConfigSlotAsync(String resourceGroupName, String name, String slot) {
        return getSiteLogsConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> getSiteLogsConfigSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteLogsConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = getSiteLogsConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> getSiteLogsConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteLogsConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteLogsConfig Site logs configuration
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner updateSiteLogsConfigSlot(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig) {
        return updateSiteLogsConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteLogsConfig).toBlocking().single().getBody();
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteLogsConfig Site logs configuration
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteLogsConfigInner> updateSiteLogsConfigSlotAsync(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceCall.create(updateSiteLogsConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteLogsConfig), serviceCallback);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteLogsConfig Site logs configuration
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> updateSiteLogsConfigSlotAsync(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig) {
        return updateSiteLogsConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteLogsConfig).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteLogsConfig Site logs configuration
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> updateSiteLogsConfigSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteLogsConfig == null) {
            throw new IllegalArgumentException("Parameter siteLogsConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteLogsConfig);
        return service.updateSiteLogsConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteLogsConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = updateSiteLogsConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> updateSiteLogsConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteLogsConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @return the Object object if successful.
     */
    public Object listSitePremierAddOns(String resourceGroupName, String name) {
        return listSitePremierAddOnsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> listSitePremierAddOnsAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(listSitePremierAddOnsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @return the observable to the Object object
     */
    public Observable<Object> listSitePremierAddOnsAsync(String resourceGroupName, String name) {
        return listSitePremierAddOnsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> listSitePremierAddOnsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSitePremierAddOns(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = listSitePremierAddOnsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> listSitePremierAddOnsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param slot the String value
     * @return the Object object if successful.
     */
    public Object listSitePremierAddOnsSlot(String resourceGroupName, String name, String slot) {
        return listSitePremierAddOnsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param slot the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> listSitePremierAddOnsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(listSitePremierAddOnsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param slot the String value
     * @return the observable to the Object object
     */
    public Observable<Object> listSitePremierAddOnsSlotAsync(String resourceGroupName, String name, String slot) {
        return listSitePremierAddOnsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param slot the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> listSitePremierAddOnsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSitePremierAddOnsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = listSitePremierAddOnsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> listSitePremierAddOnsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @return the Object object if successful.
     */
    public Object getSitePremierAddOn(String resourceGroupName, String name, String premierAddOnName) {
        return getSitePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).toBlocking().single().getBody();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSitePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSitePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @return the observable to the Object object
     */
    public Observable<Object> getSitePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName) {
        return getSitePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSitePremierAddOnWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSitePremierAddOn(resourceGroupName, name, premierAddOnName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSitePremierAddOnDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSitePremierAddOnDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param premierAddOn the PremierAddOnRequestInner value
     * @return the Object object if successful.
     */
    public Object addSitePremierAddOn(String resourceGroupName, String name, String premierAddOnName, PremierAddOnRequestInner premierAddOn) {
        return addSitePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, premierAddOn).toBlocking().single().getBody();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param premierAddOn the PremierAddOnRequestInner value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> addSitePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, PremierAddOnRequestInner premierAddOn, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(addSitePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, premierAddOn), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param premierAddOn the PremierAddOnRequestInner value
     * @return the observable to the Object object
     */
    public Observable<Object> addSitePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, PremierAddOnRequestInner premierAddOn) {
        return addSitePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, premierAddOn).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param premierAddOn the PremierAddOnRequestInner value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> addSitePremierAddOnWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, PremierAddOnRequestInner premierAddOn) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (premierAddOn == null) {
            throw new IllegalArgumentException("Parameter premierAddOn is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(premierAddOn);
        return service.addSitePremierAddOn(resourceGroupName, name, premierAddOnName, this.client.subscriptionId(), premierAddOn, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = addSitePremierAddOnDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> addSitePremierAddOnDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @return the Object object if successful.
     */
    public Object deleteSitePremierAddOn(String resourceGroupName, String name, String premierAddOnName) {
        return deleteSitePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).toBlocking().single().getBody();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSitePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSitePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSitePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName) {
        return deleteSitePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSitePremierAddOnWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSitePremierAddOn(resourceGroupName, name, premierAddOnName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSitePremierAddOnDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSitePremierAddOnDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @return the Object object if successful.
     */
    public Object getSitePremierAddOnSlot(String resourceGroupName, String name, String premierAddOnName, String slot) {
        return getSitePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).toBlocking().single().getBody();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSitePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSitePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @return the observable to the Object object
     */
    public Observable<Object> getSitePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        return getSitePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSitePremierAddOnSlotWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSitePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSitePremierAddOnSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSitePremierAddOnSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @param premierAddOn the PremierAddOnRequestInner value
     * @return the Object object if successful.
     */
    public Object addSitePremierAddOnSlot(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnRequestInner premierAddOn) {
        return addSitePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot, premierAddOn).toBlocking().single().getBody();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @param premierAddOn the PremierAddOnRequestInner value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> addSitePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnRequestInner premierAddOn, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(addSitePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot, premierAddOn), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @param premierAddOn the PremierAddOnRequestInner value
     * @return the observable to the Object object
     */
    public Observable<Object> addSitePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnRequestInner premierAddOn) {
        return addSitePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot, premierAddOn).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @param premierAddOn the PremierAddOnRequestInner value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> addSitePremierAddOnSlotWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnRequestInner premierAddOn) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (premierAddOn == null) {
            throw new IllegalArgumentException("Parameter premierAddOn is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(premierAddOn);
        return service.addSitePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, this.client.subscriptionId(), premierAddOn, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = addSitePremierAddOnSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> addSitePremierAddOnSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @return the Object object if successful.
     */
    public Object deleteSitePremierAddOnSlot(String resourceGroupName, String name, String premierAddOnName, String slot) {
        return deleteSitePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).toBlocking().single().getBody();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSitePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSitePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSitePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        return deleteSitePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSitePremierAddOnSlotWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSitePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSitePremierAddOnSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSitePremierAddOnSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner getSiteBackupConfiguration(String resourceGroupName, String name) {
        return getSiteBackupConfigurationWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupRequestInner> getSiteBackupConfigurationAsync(String resourceGroupName, String name, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceCall.create(getSiteBackupConfigurationWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> getSiteBackupConfigurationAsync(String resourceGroupName, String name) {
        return getSiteBackupConfigurationWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> getSiteBackupConfigurationWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteBackupConfiguration(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = getSiteBackupConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> getSiteBackupConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner getSiteBackupConfigurationSlot(String resourceGroupName, String name, String slot) {
        return getSiteBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupRequestInner> getSiteBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceCall.create(getSiteBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> getSiteBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return getSiteBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> getSiteBackupConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteBackupConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = getSiteBackupConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> getSiteBackupConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner updateSiteBackupConfiguration(String resourceGroupName, String name, BackupRequestInner request) {
        return updateSiteBackupConfigurationWithServiceResponseAsync(resourceGroupName, name, request).toBlocking().single().getBody();
    }

    /**
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupRequestInner> updateSiteBackupConfigurationAsync(String resourceGroupName, String name, BackupRequestInner request, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceCall.create(updateSiteBackupConfigurationWithServiceResponseAsync(resourceGroupName, name, request), serviceCallback);
    }

    /**
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> updateSiteBackupConfigurationAsync(String resourceGroupName, String name, BackupRequestInner request) {
        return updateSiteBackupConfigurationWithServiceResponseAsync(resourceGroupName, name, request).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> updateSiteBackupConfigurationWithServiceResponseAsync(String resourceGroupName, String name, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.updateSiteBackupConfiguration(resourceGroupName, name, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = updateSiteBackupConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> updateSiteBackupConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner updateSiteBackupConfigurationSlot(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return updateSiteBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).toBlocking().single().getBody();
    }

    /**
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupRequestInner> updateSiteBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceCall.create(updateSiteBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, request), serviceCallback);
    }

    /**
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> updateSiteBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return updateSiteBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> updateSiteBackupConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.updateSiteBackupConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = updateSiteBackupConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> updateSiteBackupConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner backupSite(String resourceGroupName, String name, BackupRequestInner request) {
        return backupSiteWithServiceResponseAsync(resourceGroupName, name, request).toBlocking().single().getBody();
    }

    /**
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> backupSiteAsync(String resourceGroupName, String name, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(backupSiteWithServiceResponseAsync(resourceGroupName, name, request), serviceCallback);
    }

    /**
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> backupSiteAsync(String resourceGroupName, String name, BackupRequestInner request) {
        return backupSiteWithServiceResponseAsync(resourceGroupName, name, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> backupSiteWithServiceResponseAsync(String resourceGroupName, String name, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.backupSite(resourceGroupName, name, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = backupSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> backupSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner backupSiteSlot(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return backupSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).toBlocking().single().getBody();
    }

    /**
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> backupSiteSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(backupSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, request), serviceCallback);
    }

    /**
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> backupSiteSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return backupSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> backupSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.backupSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = backupSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> backupSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on restore request
     * @return the RestoreRequestInner object if successful.
     */
    public RestoreRequestInner discoverSiteRestore(String resourceGroupName, String name, RestoreRequestInner request) {
        return discoverSiteRestoreWithServiceResponseAsync(resourceGroupName, name, request).toBlocking().single().getBody();
    }

    /**
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreRequestInner> discoverSiteRestoreAsync(String resourceGroupName, String name, RestoreRequestInner request, final ServiceCallback<RestoreRequestInner> serviceCallback) {
        return ServiceCall.create(discoverSiteRestoreWithServiceResponseAsync(resourceGroupName, name, request), serviceCallback);
    }

    /**
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on restore request
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<RestoreRequestInner> discoverSiteRestoreAsync(String resourceGroupName, String name, RestoreRequestInner request) {
        return discoverSiteRestoreWithServiceResponseAsync(resourceGroupName, name, request).map(new Func1<ServiceResponse<RestoreRequestInner>, RestoreRequestInner>() {
            @Override
            public RestoreRequestInner call(ServiceResponse<RestoreRequestInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on restore request
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<ServiceResponse<RestoreRequestInner>> discoverSiteRestoreWithServiceResponseAsync(String resourceGroupName, String name, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.discoverSiteRestore(resourceGroupName, name, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreRequestInner> clientResponse = discoverSiteRestoreDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreRequestInner> discoverSiteRestoreDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RestoreRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RestoreRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the RestoreRequestInner object if successful.
     */
    public RestoreRequestInner discoverSiteRestoreSlot(String resourceGroupName, String name, String slot, RestoreRequestInner request) {
        return discoverSiteRestoreSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).toBlocking().single().getBody();
    }

    /**
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreRequestInner> discoverSiteRestoreSlotAsync(String resourceGroupName, String name, String slot, RestoreRequestInner request, final ServiceCallback<RestoreRequestInner> serviceCallback) {
        return ServiceCall.create(discoverSiteRestoreSlotWithServiceResponseAsync(resourceGroupName, name, slot, request), serviceCallback);
    }

    /**
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<RestoreRequestInner> discoverSiteRestoreSlotAsync(String resourceGroupName, String name, String slot, RestoreRequestInner request) {
        return discoverSiteRestoreSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).map(new Func1<ServiceResponse<RestoreRequestInner>, RestoreRequestInner>() {
            @Override
            public RestoreRequestInner call(ServiceResponse<RestoreRequestInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<ServiceResponse<RestoreRequestInner>> discoverSiteRestoreSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.discoverSiteRestoreSlot(resourceGroupName, name, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreRequestInner> clientResponse = discoverSiteRestoreSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreRequestInner> discoverSiteRestoreSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RestoreRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RestoreRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listSiteBackups(final String resourceGroupName, final String name) {
        ServiceResponse<Page<BackupItemInner>> response = listSiteBackupsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<BackupItemInner>(response.getBody()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listSiteBackupsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<BackupItemInner>> listSiteBackupsAsync(final String resourceGroupName, final String name, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceCall.create(
            listSiteBackupsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listSiteBackupsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listSiteBackupsAsync(final String resourceGroupName, final String name) {
        return listSiteBackupsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listSiteBackupsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSiteBackupsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all available backups for web app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<BackupItemInner>> * @param name Name of web app
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteBackups(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listSiteBackupsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listSiteBackupsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<BackupItemInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listSiteBackupsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<BackupItemInner>> response = listSiteBackupsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<BackupItemInner>(response.getBody()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listSiteBackupsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<BackupItemInner>> listSiteBackupsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceCall.create(
            listSiteBackupsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listSiteBackupsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listSiteBackupsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listSiteBackupsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listSiteBackupsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSiteBackupsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all available backups for web app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<BackupItemInner>> * @param name Name of web app
    ServiceResponse<PageImpl<BackupItemInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteBackupsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listSiteBackupsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listSiteBackupsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<BackupItemInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner getSiteBackupStatus(String resourceGroupName, String name, String backupId) {
        return getSiteBackupStatusWithServiceResponseAsync(resourceGroupName, name, backupId).toBlocking().single().getBody();
    }

    /**
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> getSiteBackupStatusAsync(String resourceGroupName, String name, String backupId, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(getSiteBackupStatusWithServiceResponseAsync(resourceGroupName, name, backupId), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> getSiteBackupStatusAsync(String resourceGroupName, String name, String backupId) {
        return getSiteBackupStatusWithServiceResponseAsync(resourceGroupName, name, backupId).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> getSiteBackupStatusWithServiceResponseAsync(String resourceGroupName, String name, String backupId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteBackupStatus(resourceGroupName, name, backupId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = getSiteBackupStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> getSiteBackupStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner deleteBackup(String resourceGroupName, String name, String backupId) {
        return deleteBackupWithServiceResponseAsync(resourceGroupName, name, backupId).toBlocking().single().getBody();
    }

    /**
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> deleteBackupAsync(String resourceGroupName, String name, String backupId, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(deleteBackupWithServiceResponseAsync(resourceGroupName, name, backupId), serviceCallback);
    }

    /**
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> deleteBackupAsync(String resourceGroupName, String name, String backupId) {
        return deleteBackupWithServiceResponseAsync(resourceGroupName, name, backupId).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> deleteBackupWithServiceResponseAsync(String resourceGroupName, String name, String backupId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteBackup(resourceGroupName, name, backupId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = deleteBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> deleteBackupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner getSiteBackupStatusSlot(String resourceGroupName, String name, String backupId, String slot) {
        return getSiteBackupStatusSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).toBlocking().single().getBody();
    }

    /**
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> getSiteBackupStatusSlotAsync(String resourceGroupName, String name, String backupId, String slot, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(getSiteBackupStatusSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> getSiteBackupStatusSlotAsync(String resourceGroupName, String name, String backupId, String slot) {
        return getSiteBackupStatusSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> getSiteBackupStatusSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteBackupStatusSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = getSiteBackupStatusSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> getSiteBackupStatusSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner deleteBackupSlot(String resourceGroupName, String name, String backupId, String slot) {
        return deleteBackupSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).toBlocking().single().getBody();
    }

    /**
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> deleteBackupSlotAsync(String resourceGroupName, String name, String backupId, String slot, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(deleteBackupSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot), serviceCallback);
    }

    /**
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> deleteBackupSlotAsync(String resourceGroupName, String name, String backupId, String slot) {
        return deleteBackupSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> deleteBackupSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteBackupSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = deleteBackupSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> deleteBackupSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner getSiteBackupStatusSecretsSlot(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request) {
        return getSiteBackupStatusSecretsSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).toBlocking().single().getBody();
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> getSiteBackupStatusSecretsSlotAsync(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(getSiteBackupStatusSecretsSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> getSiteBackupStatusSecretsSlotAsync(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request) {
        return getSiteBackupStatusSecretsSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> getSiteBackupStatusSecretsSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.getSiteBackupStatusSecretsSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = getSiteBackupStatusSecretsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> getSiteBackupStatusSecretsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param request Information on backup request
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner getSiteBackupStatusSecrets(String resourceGroupName, String name, String backupId, BackupRequestInner request) {
        return getSiteBackupStatusSecretsWithServiceResponseAsync(resourceGroupName, name, backupId, request).toBlocking().single().getBody();
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> getSiteBackupStatusSecretsAsync(String resourceGroupName, String name, String backupId, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(getSiteBackupStatusSecretsWithServiceResponseAsync(resourceGroupName, name, backupId, request), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> getSiteBackupStatusSecretsAsync(String resourceGroupName, String name, String backupId, BackupRequestInner request) {
        return getSiteBackupStatusSecretsWithServiceResponseAsync(resourceGroupName, name, backupId, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> getSiteBackupStatusSecretsWithServiceResponseAsync(String resourceGroupName, String name, String backupId, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.getSiteBackupStatusSecrets(resourceGroupName, name, backupId, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = getSiteBackupStatusSecretsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> getSiteBackupStatusSecretsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner restoreSite(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return restoreSiteWithServiceResponseAsync(resourceGroupName, name, backupId, request).toBlocking().last().getBody();
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreResponseInner> restoreSiteAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceCall.create(restoreSiteWithServiceResponseAsync(resourceGroupName, name, backupId, request), serviceCallback);
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @return the observable for the request
     */
    public Observable<RestoreResponseInner> restoreSiteAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return restoreSiteWithServiceResponseAsync(resourceGroupName, name, backupId, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @return the observable for the request
     */
    public Observable<ServiceResponse<RestoreResponseInner>> restoreSiteWithServiceResponseAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        Observable<Response<ResponseBody>> observable = service.restoreSite(resourceGroupName, name, backupId, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<RestoreResponseInner>() { }.getType());
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner beginRestoreSite(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return beginRestoreSiteWithServiceResponseAsync(resourceGroupName, name, backupId, request).toBlocking().single().getBody();
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreResponseInner> beginRestoreSiteAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceCall.create(beginRestoreSiteWithServiceResponseAsync(resourceGroupName, name, backupId, request), serviceCallback);
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<RestoreResponseInner> beginRestoreSiteAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return beginRestoreSiteWithServiceResponseAsync(resourceGroupName, name, backupId, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<ServiceResponse<RestoreResponseInner>> beginRestoreSiteWithServiceResponseAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.beginRestoreSite(resourceGroupName, name, backupId, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreResponseInner> clientResponse = beginRestoreSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreResponseInner> beginRestoreSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RestoreResponseInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RestoreResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner restoreSiteSlot(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return restoreSiteSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).toBlocking().last().getBody();
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreResponseInner> restoreSiteSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceCall.create(restoreSiteSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request), serviceCallback);
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the observable for the request
     */
    public Observable<RestoreResponseInner> restoreSiteSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return restoreSiteSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the observable for the request
     */
    public Observable<ServiceResponse<RestoreResponseInner>> restoreSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        Observable<Response<ResponseBody>> observable = service.restoreSiteSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<RestoreResponseInner>() { }.getType());
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner beginRestoreSiteSlot(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return beginRestoreSiteSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).toBlocking().single().getBody();
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreResponseInner> beginRestoreSiteSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceCall.create(beginRestoreSiteSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request), serviceCallback);
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<RestoreResponseInner> beginRestoreSiteSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return beginRestoreSiteSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<ServiceResponse<RestoreResponseInner>> beginRestoreSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.beginRestoreSiteSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreResponseInner> clientResponse = beginRestoreSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreResponseInner> beginRestoreSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RestoreResponseInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RestoreResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> getSiteUsages(final String resourceGroupName, final String name) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = getSiteUsagesSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return getSiteUsagesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> getSiteUsagesAsync(final String resourceGroupName, final String name, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteUsagesSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return getSiteUsagesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> getSiteUsagesAsync(final String resourceGroupName, final String name) {
        return getSiteUsagesWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return getSiteUsagesSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteUsagesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        return service.getSiteUsages(resourceGroupName, name, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = getSiteUsagesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> getSiteUsages(final String resourceGroupName, final String name, final String filter) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = getSiteUsagesSinglePageAsync(resourceGroupName, name, filter).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return getSiteUsagesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> getSiteUsagesAsync(final String resourceGroupName, final String name, final String filter, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteUsagesSinglePageAsync(resourceGroupName, name, filter),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return getSiteUsagesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> getSiteUsagesAsync(final String resourceGroupName, final String name, final String filter) {
        return getSiteUsagesWithServiceResponseAsync(resourceGroupName, name, filter)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesWithServiceResponseAsync(final String resourceGroupName, final String name, final String filter) {
        return getSiteUsagesSinglePageAsync(resourceGroupName, name, filter)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteUsagesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param name Name of web app
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSinglePageAsync(final String resourceGroupName, final String name, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteUsages(resourceGroupName, name, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = getSiteUsagesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> getSiteUsagesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CsmUsageQuotaInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> getSiteUsagesSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = getSiteUsagesSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return getSiteUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> getSiteUsagesSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteUsagesSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return getSiteUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> getSiteUsagesSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return getSiteUsagesSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return getSiteUsagesSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteUsagesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        return service.getSiteUsagesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = getSiteUsagesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> getSiteUsagesSlot(final String resourceGroupName, final String name, final String slot, final String filter) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = getSiteUsagesSlotSinglePageAsync(resourceGroupName, name, slot, filter).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return getSiteUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> getSiteUsagesSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteUsagesSlotSinglePageAsync(resourceGroupName, name, slot, filter),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return getSiteUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> getSiteUsagesSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        return getSiteUsagesSlotWithServiceResponseAsync(resourceGroupName, name, slot, filter)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        return getSiteUsagesSlotSinglePageAsync(resourceGroupName, name, slot, filter)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteUsagesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param name Name of web app
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteUsagesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = getSiteUsagesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> getSiteUsagesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CsmUsageQuotaInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> getSiteMetrics(final String resourceGroupName, final String name) {
        ServiceResponse<Page<ResourceMetricInner>> response = getSiteMetricsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return getSiteMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> getSiteMetricsAsync(final String resourceGroupName, final String name, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return getSiteMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> getSiteMetricsAsync(final String resourceGroupName, final String name) {
        return getSiteMetricsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return getSiteMetricsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean details = null;
        final String filter = null;
        return service.getSiteMetrics(resourceGroupName, name, this.client.subscriptionId(), details, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = getSiteMetricsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> getSiteMetrics(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        ServiceResponse<Page<ResourceMetricInner>> response = getSiteMetricsSinglePageAsync(resourceGroupName, name, details, filter).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return getSiteMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> getSiteMetricsAsync(final String resourceGroupName, final String name, final Boolean details, final String filter, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricsSinglePageAsync(resourceGroupName, name, details, filter),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return getSiteMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> getSiteMetricsAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        return getSiteMetricsWithServiceResponseAsync(resourceGroupName, name, details, filter)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsWithServiceResponseAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        return getSiteMetricsSinglePageAsync(resourceGroupName, name, details, filter)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param name Name of web app
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param details If true, metric details are included in response
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSinglePageAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteMetrics(resourceGroupName, name, this.client.subscriptionId(), details, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = getSiteMetricsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> getSiteMetricsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<ResourceMetricInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> getSiteMetricsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<ResourceMetricInner>> response = getSiteMetricsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return getSiteMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> getSiteMetricsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return getSiteMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> getSiteMetricsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return getSiteMetricsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return getSiteMetricsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteMetricsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean details = null;
        final String filter = null;
        return service.getSiteMetricsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), details, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = getSiteMetricsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> getSiteMetricsSlot(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        ServiceResponse<Page<ResourceMetricInner>> response = getSiteMetricsSlotSinglePageAsync(resourceGroupName, name, slot, details, filter).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return getSiteMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> getSiteMetricsSlotAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricsSlotSinglePageAsync(resourceGroupName, name, slot, details, filter),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return getSiteMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> getSiteMetricsSlotAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        return getSiteMetricsSlotWithServiceResponseAsync(resourceGroupName, name, slot, details, filter)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        return getSiteMetricsSlotSinglePageAsync(resourceGroupName, name, slot, details, filter)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteMetricsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param name Name of web app
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param details If true, metric details are included in response
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteMetricsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), details, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = getSiteMetricsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> getSiteMetricsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<ResourceMetricInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;MetricDefinitionInner&gt; object if successful.
     */
    public PagedList<MetricDefinitionInner> getSiteMetricDefinitionsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<MetricDefinitionInner>> response = getSiteMetricDefinitionsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<MetricDefinitionInner>(response.getBody()) {
            @Override
            public Page<MetricDefinitionInner> nextPage(String nextPageLink) {
                return getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<MetricDefinitionInner>> getSiteMetricDefinitionsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<MetricDefinitionInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricDefinitionsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(String nextPageLink) {
                    return getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<Page<MetricDefinitionInner>> getSiteMetricDefinitionsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return getSiteMetricDefinitionsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Page<MetricDefinitionInner>>() {
                @Override
                public Page<MetricDefinitionInner> call(ServiceResponse<Page<MetricDefinitionInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return getSiteMetricDefinitionsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(ServiceResponse<Page<MetricDefinitionInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteMetricDefinitionsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     *
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param name Name of web app
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteMetricDefinitionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricDefinitionInner>> result = getSiteMetricDefinitionsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricDefinitionInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricDefinitionInner>> getSiteMetricDefinitionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<MetricDefinitionInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<MetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;MetricDefinitionInner&gt; object if successful.
     */
    public PagedList<MetricDefinitionInner> getSiteMetricDefinitions(final String resourceGroupName, final String name) {
        ServiceResponse<Page<MetricDefinitionInner>> response = getSiteMetricDefinitionsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<MetricDefinitionInner>(response.getBody()) {
            @Override
            public Page<MetricDefinitionInner> nextPage(String nextPageLink) {
                return getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<MetricDefinitionInner>> getSiteMetricDefinitionsAsync(final String resourceGroupName, final String name, final ListOperationCallback<MetricDefinitionInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricDefinitionsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(String nextPageLink) {
                    return getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<Page<MetricDefinitionInner>> getSiteMetricDefinitionsAsync(final String resourceGroupName, final String name) {
        return getSiteMetricDefinitionsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Page<MetricDefinitionInner>>() {
                @Override
                public Page<MetricDefinitionInner> call(ServiceResponse<Page<MetricDefinitionInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return getSiteMetricDefinitionsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(ServiceResponse<Page<MetricDefinitionInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteMetricDefinitionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     *
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param name Name of web app
     * @return the PagedList&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteMetricDefinitions(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricDefinitionInner>> result = getSiteMetricDefinitionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricDefinitionInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricDefinitionInner>> getSiteMetricDefinitionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<MetricDefinitionInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<MetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the InputStream object if successful.
     */
    public InputStream listSitePublishingProfileXml(String resourceGroupName, String name) {
        return listSitePublishingProfileXmlWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<InputStream> listSitePublishingProfileXmlAsync(String resourceGroupName, String name, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceCall.create(listSitePublishingProfileXmlWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listSitePublishingProfileXmlAsync(String resourceGroupName, String name) {
        return listSitePublishingProfileXmlWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listSitePublishingProfileXmlWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String format = null;
        CsmPublishingProfileOptions options = new CsmPublishingProfileOptions();
        options.withFormat(null);
        return service.listSitePublishingProfileXml(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), options, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listSitePublishingProfileXmlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @return the InputStream object if successful.
     */
    public InputStream listSitePublishingProfileXml(String resourceGroupName, String name, String format) {
        return listSitePublishingProfileXmlWithServiceResponseAsync(resourceGroupName, name, format).toBlocking().single().getBody();
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<InputStream> listSitePublishingProfileXmlAsync(String resourceGroupName, String name, String format, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceCall.create(listSitePublishingProfileXmlWithServiceResponseAsync(resourceGroupName, name, format), serviceCallback);
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listSitePublishingProfileXmlAsync(String resourceGroupName, String name, String format) {
        return listSitePublishingProfileXmlWithServiceResponseAsync(resourceGroupName, name, format).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listSitePublishingProfileXmlWithServiceResponseAsync(String resourceGroupName, String name, String format) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        CsmPublishingProfileOptions options = new CsmPublishingProfileOptions();
        options.withFormat(format);
        return service.listSitePublishingProfileXml(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), options, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listSitePublishingProfileXmlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> listSitePublishingProfileXmlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<InputStream, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the InputStream object if successful.
     */
    public InputStream listSitePublishingProfileXmlSlot(String resourceGroupName, String name, String slot) {
        return listSitePublishingProfileXmlSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<InputStream> listSitePublishingProfileXmlSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceCall.create(listSitePublishingProfileXmlSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listSitePublishingProfileXmlSlotAsync(String resourceGroupName, String name, String slot) {
        return listSitePublishingProfileXmlSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listSitePublishingProfileXmlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String format = null;
        CsmPublishingProfileOptions options = new CsmPublishingProfileOptions();
        options.withFormat(null);
        return service.listSitePublishingProfileXmlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), options, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listSitePublishingProfileXmlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @return the InputStream object if successful.
     */
    public InputStream listSitePublishingProfileXmlSlot(String resourceGroupName, String name, String slot, String format) {
        return listSitePublishingProfileXmlSlotWithServiceResponseAsync(resourceGroupName, name, slot, format).toBlocking().single().getBody();
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<InputStream> listSitePublishingProfileXmlSlotAsync(String resourceGroupName, String name, String slot, String format, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceCall.create(listSitePublishingProfileXmlSlotWithServiceResponseAsync(resourceGroupName, name, slot, format), serviceCallback);
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listSitePublishingProfileXmlSlotAsync(String resourceGroupName, String name, String slot, String format) {
        return listSitePublishingProfileXmlSlotWithServiceResponseAsync(resourceGroupName, name, slot, format).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listSitePublishingProfileXmlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String format) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        CsmPublishingProfileOptions options = new CsmPublishingProfileOptions();
        options.withFormat(format);
        return service.listSitePublishingProfileXmlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), options, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listSitePublishingProfileXmlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> listSitePublishingProfileXmlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<InputStream, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object restartSiteSlot(String resourceGroupName, String name, String slot) {
        return restartSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> restartSiteSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(restartSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> restartSiteSlotAsync(String resourceGroupName, String name, String slot) {
        return restartSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> restartSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean softRestart = null;
        final Boolean synchronous = null;
        return service.restartSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), softRestart, synchronous, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = restartSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @return the Object object if successful.
     */
    public Object restartSiteSlot(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous) {
        return restartSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, softRestart, synchronous).toBlocking().single().getBody();
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> restartSiteSlotAsync(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(restartSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, softRestart, synchronous), serviceCallback);
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @return the observable to the Object object
     */
    public Observable<Object> restartSiteSlotAsync(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous) {
        return restartSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot, softRestart, synchronous).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> restartSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.restartSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), softRestart, synchronous, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = restartSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> restartSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object restartSite(String resourceGroupName, String name) {
        return restartSiteWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> restartSiteAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(restartSiteWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> restartSiteAsync(String resourceGroupName, String name) {
        return restartSiteWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> restartSiteWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean softRestart = null;
        final Boolean synchronous = null;
        return service.restartSite(resourceGroupName, name, this.client.subscriptionId(), softRestart, synchronous, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = restartSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @return the Object object if successful.
     */
    public Object restartSite(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous) {
        return restartSiteWithServiceResponseAsync(resourceGroupName, name, softRestart, synchronous).toBlocking().single().getBody();
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> restartSiteAsync(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(restartSiteWithServiceResponseAsync(resourceGroupName, name, softRestart, synchronous), serviceCallback);
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @return the observable to the Object object
     */
    public Observable<Object> restartSiteAsync(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous) {
        return restartSiteWithServiceResponseAsync(resourceGroupName, name, softRestart, synchronous).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> restartSiteWithServiceResponseAsync(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.restartSite(resourceGroupName, name, this.client.subscriptionId(), softRestart, synchronous, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = restartSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> restartSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object startSite(String resourceGroupName, String name) {
        return startSiteWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> startSiteAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(startSiteWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> startSiteAsync(String resourceGroupName, String name) {
        return startSiteWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> startSiteWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.startSite(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = startSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> startSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object startSiteSlot(String resourceGroupName, String name, String slot) {
        return startSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> startSiteSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(startSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> startSiteSlotAsync(String resourceGroupName, String name, String slot) {
        return startSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> startSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.startSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = startSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> startSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object stopSite(String resourceGroupName, String name) {
        return stopSiteWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> stopSiteAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(stopSiteWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> stopSiteAsync(String resourceGroupName, String name) {
        return stopSiteWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> stopSiteWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.stopSite(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = stopSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> stopSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object stopSiteSlot(String resourceGroupName, String name, String slot) {
        return stopSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> stopSiteSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(stopSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> stopSiteSlotAsync(String resourceGroupName, String name, String slot) {
        return stopSiteSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> stopSiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.stopSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = stopSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> stopSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @return the Object object if successful.
     */
    public Object syncSiteRepository(String resourceGroupName, String name) {
        return syncSiteRepositoryWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> syncSiteRepositoryAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(syncSiteRepositoryWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @return the observable to the Object object
     */
    public Observable<Object> syncSiteRepositoryAsync(String resourceGroupName, String name) {
        return syncSiteRepositoryWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> syncSiteRepositoryWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.syncSiteRepository(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = syncSiteRepositoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> syncSiteRepositoryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param slot the String value
     * @return the Object object if successful.
     */
    public Object syncSiteRepositorySlot(String resourceGroupName, String name, String slot) {
        return syncSiteRepositorySlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param slot the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> syncSiteRepositorySlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(syncSiteRepositorySlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param slot the String value
     * @return the observable to the Object object
     */
    public Observable<Object> syncSiteRepositorySlotAsync(String resourceGroupName, String name, String slot) {
        return syncSiteRepositorySlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param slot the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> syncSiteRepositorySlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.syncSiteRepositorySlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = syncSiteRepositorySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> syncSiteRepositorySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object generateNewSitePublishingPasswordSlot(String resourceGroupName, String name, String slot) {
        return generateNewSitePublishingPasswordSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> generateNewSitePublishingPasswordSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(generateNewSitePublishingPasswordSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> generateNewSitePublishingPasswordSlotAsync(String resourceGroupName, String name, String slot) {
        return generateNewSitePublishingPasswordSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> generateNewSitePublishingPasswordSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = generateNewSitePublishingPasswordSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> generateNewSitePublishingPasswordSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object generateNewSitePublishingPassword(String resourceGroupName, String name) {
        return generateNewSitePublishingPasswordWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> generateNewSitePublishingPasswordAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(generateNewSitePublishingPasswordWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> generateNewSitePublishingPasswordAsync(String resourceGroupName, String name) {
        return generateNewSitePublishingPasswordWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> generateNewSitePublishingPasswordWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.generateNewSitePublishingPassword(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = generateNewSitePublishingPasswordDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> generateNewSitePublishingPasswordDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner getSiteRelayServiceConnection(String resourceGroupName, String name, String entityName) {
        return getSiteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).toBlocking().single().getBody();
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> getSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(getSiteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName), serviceCallback);
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> getSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName) {
        return getSiteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> getSiteRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = getSiteRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> getSiteRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner createOrUpdateSiteRelayServiceConnection(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateSiteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> createOrUpdateSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> createOrUpdateSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateSiteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> createOrUpdateSiteRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateSiteRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = createOrUpdateSiteRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> createOrUpdateSiteRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @return the Object object if successful.
     */
    public Object deleteSiteRelayServiceConnection(String resourceGroupName, String name, String entityName) {
        return deleteSiteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).toBlocking().single().getBody();
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName), serviceCallback);
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName) {
        return deleteSiteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner updateSiteRelayServiceConnection(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateSiteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> updateSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(updateSiteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> updateSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateSiteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> updateSiteRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateSiteRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = updateSiteRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> updateSiteRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner getSiteRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot) {
        return getSiteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).toBlocking().single().getBody();
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> getSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(getSiteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot), serviceCallback);
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> getSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot) {
        return getSiteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> getSiteRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = getSiteRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> getSiteRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner createOrUpdateSiteRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateSiteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> createOrUpdateSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> createOrUpdateSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateSiteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> createOrUpdateSiteRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateSiteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = createOrUpdateSiteRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> createOrUpdateSiteRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @return the Object object if successful.
     */
    public Object deleteSiteRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot) {
        return deleteSiteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).toBlocking().single().getBody();
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot), serviceCallback);
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot) {
        return deleteSiteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner updateSiteRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateSiteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> updateSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(updateSiteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> updateSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateSiteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> updateSiteRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateSiteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = updateSiteRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> updateSiteRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner listSiteRelayServiceConnectionsSlot(String resourceGroupName, String name, String slot) {
        return listSiteRelayServiceConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> listSiteRelayServiceConnectionsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(listSiteRelayServiceConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> listSiteRelayServiceConnectionsSlotAsync(String resourceGroupName, String name, String slot) {
        return listSiteRelayServiceConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> listSiteRelayServiceConnectionsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteRelayServiceConnectionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = listSiteRelayServiceConnectionsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> listSiteRelayServiceConnectionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner listSiteRelayServiceConnections(String resourceGroupName, String name) {
        return listSiteRelayServiceConnectionsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> listSiteRelayServiceConnectionsAsync(String resourceGroupName, String name, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(listSiteRelayServiceConnectionsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> listSiteRelayServiceConnectionsAsync(String resourceGroupName, String name) {
        return listSiteRelayServiceConnectionsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> listSiteRelayServiceConnectionsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteRelayServiceConnections(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = listSiteRelayServiceConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> listSiteRelayServiceConnectionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @return the Object object if successful.
     */
    public Object getSiteVnetGatewaySlot(String resourceGroupName, String name, String vnetName, String gatewayName, String slot) {
        return getSiteVnetGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot).toBlocking().single().getBody();
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSiteVnetGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSiteVnetGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot), serviceCallback);
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @return the observable to the Object object
     */
    public Observable<Object> getSiteVnetGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot) {
        return getSiteVnetGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSiteVnetGatewaySlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteVnetGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSiteVnetGatewaySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSiteVnetGatewaySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner createOrUpdateSiteVNETConnectionGatewaySlot(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateSiteVNETConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetGatewayInner> createOrUpdateSiteVNETConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteVNETConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> createOrUpdateSiteVNETConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateSiteVNETConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> createOrUpdateSiteVNETConnectionGatewaySlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateSiteVNETConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = createOrUpdateSiteVNETConnectionGatewaySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> createOrUpdateSiteVNETConnectionGatewaySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetGatewayInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner updateSiteVNETConnectionGatewaySlot(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return updateSiteVNETConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetGatewayInner> updateSiteVNETConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceCall.create(updateSiteVNETConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> updateSiteVNETConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return updateSiteVNETConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> updateSiteVNETConnectionGatewaySlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateSiteVNETConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = updateSiteVNETConnectionGatewaySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> updateSiteVNETConnectionGatewaySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetGatewayInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @return the Object object if successful.
     */
    public Object getSiteVnetGateway(String resourceGroupName, String name, String vnetName, String gatewayName) {
        return getSiteVnetGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName).toBlocking().single().getBody();
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSiteVnetGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSiteVnetGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName), serviceCallback);
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @return the observable to the Object object
     */
    public Observable<Object> getSiteVnetGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName) {
        return getSiteVnetGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSiteVnetGatewayWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteVnetGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSiteVnetGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSiteVnetGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner createOrUpdateSiteVNETConnectionGateway(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateSiteVNETConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetGatewayInner> createOrUpdateSiteVNETConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteVNETConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> createOrUpdateSiteVNETConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateSiteVNETConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> createOrUpdateSiteVNETConnectionGatewayWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateSiteVNETConnectionGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = createOrUpdateSiteVNETConnectionGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> createOrUpdateSiteVNETConnectionGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetGatewayInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner updateSiteVNETConnectionGateway(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return updateSiteVNETConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetGatewayInner> updateSiteVNETConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceCall.create(updateSiteVNETConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> updateSiteVNETConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return updateSiteVNETConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> updateSiteVNETConnectionGatewayWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateSiteVNETConnectionGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = updateSiteVNETConnectionGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> updateSiteVNETConnectionGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetGatewayInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the List&lt;VnetInfoInner&gt; object if successful.
     */
    public List<VnetInfoInner> getSiteVNETConnections(String resourceGroupName, String name) {
        return getSiteVNETConnectionsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<VnetInfoInner>> getSiteVNETConnectionsAsync(String resourceGroupName, String name, final ServiceCallback<List<VnetInfoInner>> serviceCallback) {
        return ServiceCall.create(getSiteVNETConnectionsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<List<VnetInfoInner>> getSiteVNETConnectionsAsync(String resourceGroupName, String name) {
        return getSiteVNETConnectionsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<List<VnetInfoInner>>, List<VnetInfoInner>>() {
            @Override
            public List<VnetInfoInner> call(ServiceResponse<List<VnetInfoInner>> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<VnetInfoInner>>> getSiteVNETConnectionsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteVNETConnections(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<VnetInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<VnetInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<VnetInfoInner>> clientResponse = getSiteVNETConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<VnetInfoInner>> getSiteVNETConnectionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<List<VnetInfoInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<VnetInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @return the List&lt;VnetInfoInner&gt; object if successful.
     */
    public List<VnetInfoInner> getSiteVNETConnectionsSlot(String resourceGroupName, String name, String slot) {
        return getSiteVNETConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<VnetInfoInner>> getSiteVNETConnectionsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<List<VnetInfoInner>> serviceCallback) {
        return ServiceCall.create(getSiteVNETConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<List<VnetInfoInner>> getSiteVNETConnectionsSlotAsync(String resourceGroupName, String name, String slot) {
        return getSiteVNETConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<List<VnetInfoInner>>, List<VnetInfoInner>>() {
            @Override
            public List<VnetInfoInner> call(ServiceResponse<List<VnetInfoInner>> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<VnetInfoInner>>> getSiteVNETConnectionsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteVNETConnectionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<VnetInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<VnetInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<VnetInfoInner>> clientResponse = getSiteVNETConnectionsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<VnetInfoInner>> getSiteVNETConnectionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<List<VnetInfoInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<VnetInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> getSlotsDifferencesFromProductionNext(final String nextPageLink) {
        ServiceResponse<Page<SlotDifferenceInner>> response = getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.getBody()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SlotDifferenceInner>> getSlotsDifferencesFromProductionNextAsync(final String nextPageLink, final ServiceCall<List<SlotDifferenceInner>> serviceCall, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> getSlotsDifferencesFromProductionNextAsync(final String nextPageLink) {
        return getSlotsDifferencesFromProductionNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesFromProductionNextWithServiceResponseAsync(final String nextPageLink) {
        return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSlotsDifferencesFromProductionNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesFromProductionNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSlotsDifferencesFromProductionNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = getSlotsDifferencesFromProductionNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> getSlotsDifferencesFromProductionNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SlotDifferenceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> getSlotsDifferencesSlotNext(final String nextPageLink) {
        ServiceResponse<Page<SlotDifferenceInner>> response = getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.getBody()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SlotDifferenceInner>> getSlotsDifferencesSlotNextAsync(final String nextPageLink, final ServiceCall<List<SlotDifferenceInner>> serviceCall, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> getSlotsDifferencesSlotNextAsync(final String nextPageLink) {
        return getSlotsDifferencesSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSlotsDifferencesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSlotsDifferencesSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = getSlotsDifferencesSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> getSlotsDifferencesSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SlotDifferenceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> getSiteSlotsNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInner>> response = getSiteSlotsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return getSiteSlotsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> getSiteSlotsNextAsync(final String nextPageLink, final ServiceCall<List<SiteInner>> serviceCall, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteSlotsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return getSiteSlotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> getSiteSlotsNextAsync(final String nextPageLink) {
        return getSiteSlotsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSiteSlotsNextWithServiceResponseAsync(final String nextPageLink) {
        return getSiteSlotsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteSlotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSiteSlotsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteSlotsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = getSiteSlotsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> getSiteSlotsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> getSitesNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInner>> response = getSitesNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return getSitesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> getSitesNextAsync(final String nextPageLink, final ServiceCall<List<SiteInner>> serviceCall, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getSitesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return getSitesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> getSitesNextAsync(final String nextPageLink) {
        return getSitesNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSitesNextWithServiceResponseAsync(final String nextPageLink) {
        return getSitesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSitesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSitesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSitesNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = getSitesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> getSitesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeletedSiteInner&gt; object if successful.
     */
    public PagedList<DeletedSiteInner> getDeletedSitesNext(final String nextPageLink) {
        ServiceResponse<Page<DeletedSiteInner>> response = getDeletedSitesNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeletedSiteInner>(response.getBody()) {
            @Override
            public Page<DeletedSiteInner> nextPage(String nextPageLink) {
                return getDeletedSitesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeletedSiteInner>> getDeletedSitesNextAsync(final String nextPageLink, final ServiceCall<List<DeletedSiteInner>> serviceCall, final ListOperationCallback<DeletedSiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getDeletedSitesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(String nextPageLink) {
                    return getDeletedSitesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeletedSiteInner&gt; object
     */
    public Observable<Page<DeletedSiteInner>> getDeletedSitesNextAsync(final String nextPageLink) {
        return getDeletedSitesNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeletedSiteInner>>, Page<DeletedSiteInner>>() {
                @Override
                public Page<DeletedSiteInner> call(ServiceResponse<Page<DeletedSiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeletedSiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> getDeletedSitesNextWithServiceResponseAsync(final String nextPageLink) {
        return getDeletedSitesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeletedSiteInner>>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(ServiceResponse<Page<DeletedSiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getDeletedSitesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     *
    ServiceResponse<PageImpl<DeletedSiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeletedSiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> getDeletedSitesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getDeletedSitesNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeletedSiteInner>> result = getDeletedSitesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeletedSiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeletedSiteInner>> getDeletedSitesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeletedSiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeletedSiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> getDeploymentsNext(final String nextPageLink) {
        ServiceResponse<Page<DeploymentInner>> response = getDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return getDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getDeploymentsNextAsync(final String nextPageLink, final ServiceCall<List<DeploymentInner>> serviceCall, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getDeploymentsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> getDeploymentsNextAsync(final String nextPageLink) {
        return getDeploymentsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsNextWithServiceResponseAsync(final String nextPageLink) {
        return getDeploymentsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getDeploymentsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getDeploymentsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getDeploymentsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getDeploymentsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> getDeploymentsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<DeploymentInner>> response = getDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return getDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getDeploymentsSlotNextAsync(final String nextPageLink, final ServiceCall<List<DeploymentInner>> serviceCall, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getDeploymentsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> getDeploymentsSlotNextAsync(final String nextPageLink) {
        return getDeploymentsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return getDeploymentsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getDeploymentsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getDeploymentsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getDeploymentsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getDeploymentsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> getInstanceDeploymentsNext(final String nextPageLink) {
        ServiceResponse<Page<DeploymentInner>> response = getInstanceDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return getInstanceDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getInstanceDeploymentsNextAsync(final String nextPageLink, final ServiceCall<List<DeploymentInner>> serviceCall, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getInstanceDeploymentsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getInstanceDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> getInstanceDeploymentsNextAsync(final String nextPageLink) {
        return getInstanceDeploymentsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsNextWithServiceResponseAsync(final String nextPageLink) {
        return getInstanceDeploymentsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getInstanceDeploymentsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getInstanceDeploymentsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getInstanceDeploymentsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getInstanceDeploymentsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> getInstanceDeploymentsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<DeploymentInner>> response = getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getInstanceDeploymentsSlotNextAsync(final String nextPageLink, final ServiceCall<List<DeploymentInner>> serviceCall, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> getInstanceDeploymentsSlotNextAsync(final String nextPageLink) {
        return getInstanceDeploymentsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getInstanceDeploymentsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getInstanceDeploymentsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getInstanceDeploymentsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getInstanceDeploymentsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> getSiteInstanceIdentifiersNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInstanceInner>> response = getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.getBody()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInstanceInner>> getSiteInstanceIdentifiersNextAsync(final String nextPageLink, final ServiceCall<List<SiteInstanceInner>> serviceCall, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> getSiteInstanceIdentifiersNextAsync(final String nextPageLink) {
        return getSiteInstanceIdentifiersNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersNextWithServiceResponseAsync(final String nextPageLink) {
        return getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteInstanceIdentifiersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all instance of a web app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteInstanceIdentifiersNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = getSiteInstanceIdentifiersNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> getSiteInstanceIdentifiersNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInstanceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> getSiteInstanceIdentifiersSlotNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInstanceInner>> response = getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.getBody()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInstanceInner>> getSiteInstanceIdentifiersSlotNextAsync(final String nextPageLink, final ServiceCall<List<SiteInstanceInner>> serviceCall, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> getSiteInstanceIdentifiersSlotNextAsync(final String nextPageLink) {
        return getSiteInstanceIdentifiersSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteInstanceIdentifiersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all instance of a web app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteInstanceIdentifiersSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = getSiteInstanceIdentifiersSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> getSiteInstanceIdentifiersSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInstanceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> getSiteHostNameBindingsNext(final String nextPageLink) {
        ServiceResponse<Page<HostNameBindingInner>> response = getSiteHostNameBindingsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.getBody()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return getSiteHostNameBindingsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<HostNameBindingInner>> getSiteHostNameBindingsNextAsync(final String nextPageLink, final ServiceCall<List<HostNameBindingInner>> serviceCall, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteHostNameBindingsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return getSiteHostNameBindingsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> getSiteHostNameBindingsNextAsync(final String nextPageLink) {
        return getSiteHostNameBindingsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsNextWithServiceResponseAsync(final String nextPageLink) {
        return getSiteHostNameBindingsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteHostNameBindingsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get web app hostname bindings.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteHostNameBindingsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = getSiteHostNameBindingsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> getSiteHostNameBindingsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<HostNameBindingInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> getSiteHostNameBindingsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<HostNameBindingInner>> response = getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.getBody()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<HostNameBindingInner>> getSiteHostNameBindingsSlotNextAsync(final String nextPageLink, final ServiceCall<List<HostNameBindingInner>> serviceCall, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> getSiteHostNameBindingsSlotNextAsync(final String nextPageLink) {
        return getSiteHostNameBindingsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteHostNameBindingsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get web app hostname bindings.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteHostNameBindingsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = getSiteHostNameBindingsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> getSiteHostNameBindingsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<HostNameBindingInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listSiteBackupsNext(final String nextPageLink) {
        ServiceResponse<Page<BackupItemInner>> response = listSiteBackupsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<BackupItemInner>(response.getBody()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listSiteBackupsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<BackupItemInner>> listSiteBackupsNextAsync(final String nextPageLink, final ServiceCall<List<BackupItemInner>> serviceCall, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceCall.create(
            listSiteBackupsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listSiteBackupsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listSiteBackupsNextAsync(final String nextPageLink) {
        return listSiteBackupsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsNextWithServiceResponseAsync(final String nextPageLink) {
        return listSiteBackupsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSiteBackupsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all available backups for web app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listSiteBackupsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listSiteBackupsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listSiteBackupsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<BackupItemInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listSiteBackupsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<BackupItemInner>> response = listSiteBackupsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<BackupItemInner>(response.getBody()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listSiteBackupsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<BackupItemInner>> listSiteBackupsSlotNextAsync(final String nextPageLink, final ServiceCall<List<BackupItemInner>> serviceCall, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceCall.create(
            listSiteBackupsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listSiteBackupsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listSiteBackupsSlotNextAsync(final String nextPageLink) {
        return listSiteBackupsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listSiteBackupsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSiteBackupsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all available backups for web app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listSiteBackupsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listSiteBackupsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listSiteBackupsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<BackupItemInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> getSiteUsagesNext(final String nextPageLink) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = getSiteUsagesNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return getSiteUsagesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> getSiteUsagesNextAsync(final String nextPageLink, final ServiceCall<List<CsmUsageQuotaInner>> serviceCall, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteUsagesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return getSiteUsagesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> getSiteUsagesNextAsync(final String nextPageLink) {
        return getSiteUsagesNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesNextWithServiceResponseAsync(final String nextPageLink) {
        return getSiteUsagesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteUsagesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteUsagesNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = getSiteUsagesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> getSiteUsagesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CsmUsageQuotaInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> getSiteUsagesSlotNext(final String nextPageLink) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = getSiteUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return getSiteUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> getSiteUsagesSlotNextAsync(final String nextPageLink, final ServiceCall<List<CsmUsageQuotaInner>> serviceCall, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteUsagesSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return getSiteUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> getSiteUsagesSlotNextAsync(final String nextPageLink) {
        return getSiteUsagesSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return getSiteUsagesSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteUsagesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteUsagesSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = getSiteUsagesSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> getSiteUsagesSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CsmUsageQuotaInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> getSiteMetricsNext(final String nextPageLink) {
        ServiceResponse<Page<ResourceMetricInner>> response = getSiteMetricsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return getSiteMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> getSiteMetricsNextAsync(final String nextPageLink, final ServiceCall<List<ResourceMetricInner>> serviceCall, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return getSiteMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> getSiteMetricsNextAsync(final String nextPageLink) {
        return getSiteMetricsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsNextWithServiceResponseAsync(final String nextPageLink) {
        return getSiteMetricsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteMetricsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = getSiteMetricsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> getSiteMetricsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<ResourceMetricInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> getSiteMetricsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<ResourceMetricInner>> response = getSiteMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return getSiteMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> getSiteMetricsSlotNextAsync(final String nextPageLink, final ServiceCall<List<ResourceMetricInner>> serviceCall, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return getSiteMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> getSiteMetricsSlotNextAsync(final String nextPageLink) {
        return getSiteMetricsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return getSiteMetricsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteMetricsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteMetricsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = getSiteMetricsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> getSiteMetricsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<ResourceMetricInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;MetricDefinitionInner&gt; object if successful.
     */
    public PagedList<MetricDefinitionInner> getSiteMetricDefinitionsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<MetricDefinitionInner>> response = getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<MetricDefinitionInner>(response.getBody()) {
            @Override
            public Page<MetricDefinitionInner> nextPage(String nextPageLink) {
                return getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<MetricDefinitionInner>> getSiteMetricDefinitionsSlotNextAsync(final String nextPageLink, final ServiceCall<List<MetricDefinitionInner>> serviceCall, final ListOperationCallback<MetricDefinitionInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(String nextPageLink) {
                    return getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<Page<MetricDefinitionInner>> getSiteMetricDefinitionsSlotNextAsync(final String nextPageLink) {
        return getSiteMetricDefinitionsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Page<MetricDefinitionInner>>() {
                @Override
                public Page<MetricDefinitionInner> call(ServiceResponse<Page<MetricDefinitionInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(ServiceResponse<Page<MetricDefinitionInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteMetricDefinitionsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     *
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteMetricDefinitionsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricDefinitionInner>> result = getSiteMetricDefinitionsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricDefinitionInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricDefinitionInner>> getSiteMetricDefinitionsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<MetricDefinitionInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<MetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;MetricDefinitionInner&gt; object if successful.
     */
    public PagedList<MetricDefinitionInner> getSiteMetricDefinitionsNext(final String nextPageLink) {
        ServiceResponse<Page<MetricDefinitionInner>> response = getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<MetricDefinitionInner>(response.getBody()) {
            @Override
            public Page<MetricDefinitionInner> nextPage(String nextPageLink) {
                return getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<MetricDefinitionInner>> getSiteMetricDefinitionsNextAsync(final String nextPageLink, final ServiceCall<List<MetricDefinitionInner>> serviceCall, final ListOperationCallback<MetricDefinitionInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(String nextPageLink) {
                    return getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<Page<MetricDefinitionInner>> getSiteMetricDefinitionsNextAsync(final String nextPageLink) {
        return getSiteMetricDefinitionsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Page<MetricDefinitionInner>>() {
                @Override
                public Page<MetricDefinitionInner> call(ServiceResponse<Page<MetricDefinitionInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsNextWithServiceResponseAsync(final String nextPageLink) {
        return getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(ServiceResponse<Page<MetricDefinitionInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSiteMetricDefinitionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     *
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteMetricDefinitionsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricDefinitionInner>> result = getSiteMetricDefinitionsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricDefinitionInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricDefinitionInner>> getSiteMetricDefinitionsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<MetricDefinitionInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<MetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
