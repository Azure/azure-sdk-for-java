/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.website.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceCall;
import com.microsoft.azure.AzureServiceResponseBuilder;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.website.CsmPublishingProfileOptions;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Streaming;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Sites.
 */
public final class SitesInner {
    /** The Retrofit service to perform REST calls. */
    private SitesService service;
    /** The service client containing this operation class. */
    private WebSiteManagementClientImpl client;

    /**
     * Initializes an instance of SitesInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public SitesInner(Retrofit retrofit, WebSiteManagementClientImpl client) {
        this.service = retrofit.create(SitesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Sites to be
     * used by Retrofit to perform actually REST calls.
     */
    interface SitesService {
        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> getSiteVNETConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteVNETConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteVNETConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> updateSiteVNETConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> getSiteVNETConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteVNETConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteVNETConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> updateSiteVNETConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkFeatures/{view}")
        Observable<Response<ResponseBody>> getSiteNetworkFeaturesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("view") String view, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkFeatures/{view}")
        Observable<Response<ResponseBody>> getSiteNetworkFeatures(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("view") String view, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/operationresults/{operationId}")
        Observable<Response<ResponseBody>> getSiteOperationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("operationId") String operationId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/operationresults/{operationId}")
        Observable<Response<ResponseBody>> getSiteOperation(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("operationId") String operationId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap")
        Observable<Response<ResponseBody>> swapSlotWithProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap")
        Observable<Response<ResponseBody>> beginSwapSlotWithProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap")
        Observable<Response<ResponseBody>> swapSlotsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap")
        Observable<Response<ResponseBody>> beginSwapSlotsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsdiffs")
        Observable<Response<ResponseBody>> getSlotsDifferencesFromProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsdiffs")
        Observable<Response<ResponseBody>> getSlotsDifferencesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/applySlotConfig")
        Observable<Response<ResponseBody>> applySlotConfigToProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/applySlotConfig")
        Observable<Response<ResponseBody>> applySlotConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resetSlotConfig")
        Observable<Response<ResponseBody>> resetProductionSlotConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resetSlotConfig")
        Observable<Response<ResponseBody>> resetSlotConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames")
        Observable<Response<ResponseBody>> getSlotConfigNames(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames")
        Observable<Response<ResponseBody>> updateSlotConfigNames(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SlotConfigNamesResourceInner slotConfigNames, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots")
        Observable<Response<ResponseBody>> getSiteSlots(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("propertiesToInclude") String propertiesToInclude, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites")
        Observable<Response<ResponseBody>> getSites(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Query("propertiesToInclude") String propertiesToInclude, @Query("includeSiteTypes") String includeSiteTypes, @Query("includeSlots") Boolean includeSlots, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> getSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("propertiesToInclude") String propertiesToInclude, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> createOrUpdateSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") String skipDnsRegistration, @Query("skipCustomDomainVerification") String skipCustomDomainVerification, @Query("forceDnsRegistration") String forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> beginCreateOrUpdateSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") String skipDnsRegistration, @Query("skipCustomDomainVerification") String skipCustomDomainVerification, @Query("forceDnsRegistration") String forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("deleteMetrics") String deleteMetrics, @Query("deleteEmptyServerFarm") String deleteEmptyServerFarm, @Query("skipDnsRegistration") String skipDnsRegistration, @Query("deleteAllSlots") String deleteAllSlots, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> getSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("propertiesToInclude") String propertiesToInclude, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> createOrUpdateSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") String skipDnsRegistration, @Query("skipCustomDomainVerification") String skipCustomDomainVerification, @Query("forceDnsRegistration") String forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> beginCreateOrUpdateSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") String skipDnsRegistration, @Query("skipCustomDomainVerification") String skipCustomDomainVerification, @Query("forceDnsRegistration") String forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("deleteMetrics") String deleteMetrics, @Query("deleteEmptyServerFarm") String deleteEmptyServerFarm, @Query("skipDnsRegistration") String skipDnsRegistration, @Query("deleteAllSlots") String deleteAllSlots, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/iscloneable")
        Observable<Response<ResponseBody>> isSiteCloneable(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/iscloneable")
        Observable<Response<ResponseBody>> isSiteCloneableSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/recover")
        Observable<Response<ResponseBody>> recoverSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/recover")
        Observable<Response<ResponseBody>> beginRecoverSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/recover")
        Observable<Response<ResponseBody>> recoverSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/recover")
        Observable<Response<ResponseBody>> beginRecoverSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshots")
        Observable<Response<ResponseBody>> getSiteSnapshots(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshots")
        Observable<Response<ResponseBody>> getSiteSnapshotsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/deletedSites")
        Observable<Response<ResponseBody>> getDeletedSites(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Query("propertiesToInclude") String propertiesToInclude, @Query("includeSiteTypes") String includeSiteTypes, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments")
        Observable<Response<ResponseBody>> getDeployments(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments")
        Observable<Response<ResponseBody>> getDeploymentsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments")
        Observable<Response<ResponseBody>> getInstanceDeployments(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments")
        Observable<Response<ResponseBody>> getInstanceDeploymentsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> getInstanceDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> createInstanceDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteInstanceDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}")
        Observable<Response<ResponseBody>> getDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}")
        Observable<Response<ResponseBody>> createDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}")
        Observable<Response<ResponseBody>> getDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}")
        Observable<Response<ResponseBody>> createDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> getInstanceDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> createInstanceDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteInstanceDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances")
        Observable<Response<ResponseBody>> getSiteInstanceIdentifiers(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances")
        Observable<Response<ResponseBody>> getSiteInstanceIdentifiersSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings")
        Observable<Response<ResponseBody>> getSiteHostNameBindings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings")
        Observable<Response<ResponseBody>> getSiteHostNameBindingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> getSiteHostNameBinding(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteHostNameBinding(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Body HostNameBindingInner hostNameBinding, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteHostNameBinding(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> getSiteHostNameBindingSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteHostNameBindingSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body HostNameBindingInner hostNameBinding, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteHostNameBindingSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web")
        Observable<Response<ResponseBody>> getSiteConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web")
        Observable<Response<ResponseBody>> createOrUpdateSiteConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteConfigInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web")
        Observable<Response<ResponseBody>> updateSiteConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteConfigInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web")
        Observable<Response<ResponseBody>> getSiteConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web")
        Observable<Response<ResponseBody>> createOrUpdateSiteConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteConfigInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web")
        Observable<Response<ResponseBody>> updateSiteConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteConfigInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> getSiteSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> createOrUpdateSiteSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> updateSiteSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> getSiteSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> createOrUpdateSiteSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> updateSiteSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings/list")
        Observable<Response<ResponseBody>> listSiteAppSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings/list")
        Observable<Response<ResponseBody>> listSiteAppSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings")
        Observable<Response<ResponseBody>> updateSiteAppSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner appSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings")
        Observable<Response<ResponseBody>> updateSiteAppSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner appSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings/list")
        Observable<Response<ResponseBody>> listSiteConnectionStrings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings/list")
        Observable<Response<ResponseBody>> listSiteConnectionStringsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings")
        Observable<Response<ResponseBody>> updateSiteConnectionStrings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body ConnectionStringDictionaryInner connectionStrings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings")
        Observable<Response<ResponseBody>> updateSiteConnectionStringsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body ConnectionStringDictionaryInner connectionStrings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings/list")
        Observable<Response<ResponseBody>> listSiteAuthSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings/list")
        Observable<Response<ResponseBody>> listSiteAuthSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings")
        Observable<Response<ResponseBody>> updateSiteAuthSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteAuthSettingsInner siteAuthSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings")
        Observable<Response<ResponseBody>> updateSiteAuthSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteAuthSettingsInner siteAuthSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> listSitePublishingCredentials(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> beginListSitePublishingCredentials(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> listSitePublishingCredentialsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> beginListSitePublishingCredentialsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata/list")
        Observable<Response<ResponseBody>> listSiteMetadata(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata/list")
        Observable<Response<ResponseBody>> listSiteMetadataSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata")
        Observable<Response<ResponseBody>> updateSiteMetadata(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner metadata, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata")
        Observable<Response<ResponseBody>> updateSiteMetadataSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner metadata, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs")
        Observable<Response<ResponseBody>> getSiteLogsConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs")
        Observable<Response<ResponseBody>> updateSiteLogsConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteLogsConfigInner siteLogsConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs")
        Observable<Response<ResponseBody>> getSiteLogsConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs")
        Observable<Response<ResponseBody>> updateSiteLogsConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteLogsConfigInner siteLogsConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons")
        Observable<Response<ResponseBody>> listSitePremierAddOns(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons")
        Observable<Response<ResponseBody>> listSitePremierAddOnsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> getSitePremierAddOn(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> addSitePremierAddOn(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("subscriptionId") String subscriptionId, @Body PremierAddOnRequestInner premierAddOn, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSitePremierAddOn(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> getSitePremierAddOnSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> addSitePremierAddOnSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body PremierAddOnRequestInner premierAddOn, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSitePremierAddOnSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup/list")
        Observable<Response<ResponseBody>> getSiteBackupConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup/list")
        Observable<Response<ResponseBody>> getSiteBackupConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup")
        Observable<Response<ResponseBody>> updateSiteBackupConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup")
        Observable<Response<ResponseBody>> updateSiteBackupConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backup")
        Observable<Response<ResponseBody>> backupSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backup")
        Observable<Response<ResponseBody>> backupSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/discover")
        Observable<Response<ResponseBody>> discoverSiteRestore(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/discover")
        Observable<Response<ResponseBody>> discoverSiteRestoreSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups")
        Observable<Response<ResponseBody>> listSiteBackups(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups")
        Observable<Response<ResponseBody>> listSiteBackupsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}")
        Observable<Response<ResponseBody>> getSiteBackupStatus(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackup(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}")
        Observable<Response<ResponseBody>> getSiteBackupStatusSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackupSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/list")
        Observable<Response<ResponseBody>> getSiteBackupStatusSecretsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/list")
        Observable<Response<ResponseBody>> getSiteBackupStatusSecrets(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> restoreSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> beginRestoreSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> restoreSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> beginRestoreSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/usages")
        Observable<Response<ResponseBody>> getSiteUsages(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/usages")
        Observable<Response<ResponseBody>> getSiteUsagesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metrics")
        Observable<Response<ResponseBody>> getSiteMetrics(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("details") Boolean details, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metrics")
        Observable<Response<ResponseBody>> getSiteMetricsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("details") Boolean details, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metricdefinitions")
        Observable<Response<ResponseBody>> getSiteMetricDefinitionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metricdefinitions")
        Observable<Response<ResponseBody>> getSiteMetricDefinitions(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publishxml")
        @Streaming
        Observable<Response<ResponseBody>> listSitePublishingProfileXml(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CsmPublishingProfileOptions options, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publishxml")
        @Streaming
        Observable<Response<ResponseBody>> listSitePublishingProfileXmlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CsmPublishingProfileOptions options, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restart")
        Observable<Response<ResponseBody>> restartSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("softRestart") Boolean softRestart, @Query("synchronous") Boolean synchronous, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restart")
        Observable<Response<ResponseBody>> restartSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("softRestart") Boolean softRestart, @Query("synchronous") Boolean synchronous, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/start")
        Observable<Response<ResponseBody>> startSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/start")
        Observable<Response<ResponseBody>> startSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stop")
        Observable<Response<ResponseBody>> stopSite(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stop")
        Observable<Response<ResponseBody>> stopSiteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sync")
        Observable<Response<ResponseBody>> syncSiteRepository(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sync")
        Observable<Response<ResponseBody>> syncSiteRepositorySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/newpassword")
        Observable<Response<ResponseBody>> generateNewSitePublishingPasswordSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/newpassword")
        Observable<Response<ResponseBody>> generateNewSitePublishingPassword(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> getSiteRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> updateSiteRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> getSiteRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> updateSiteRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection")
        Observable<Response<ResponseBody>> listSiteRelayServiceConnectionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection")
        Observable<Response<ResponseBody>> listSiteRelayServiceConnections(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> getSiteVnetGatewaySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteVNETConnectionGatewaySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> updateSiteVNETConnectionGatewaySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> getSiteVnetGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> createOrUpdateSiteVNETConnectionGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> updateSiteVNETConnectionGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections")
        Observable<Response<ResponseBody>> getSiteVNETConnections(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections")
        Observable<Response<ResponseBody>> getSiteVNETConnectionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("{nextLink}")
        Observable<Response<ResponseBody>> getSlotsDifferencesFromProductionNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("{nextLink}")
        Observable<Response<ResponseBody>> getSlotsDifferencesSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteSlotsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSitesNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getDeletedSitesNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getDeploymentsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getDeploymentsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getInstanceDeploymentsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getInstanceDeploymentsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteInstanceIdentifiersNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteInstanceIdentifiersSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteHostNameBindingsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteHostNameBindingsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listSiteBackupsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listSiteBackupsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteUsagesNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteUsagesSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteMetricsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteMetricsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteMetricDefinitionsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getSiteMetricDefinitionsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the VnetInfoInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<VnetInfoInner> getSiteVNETConnectionSlot(String resourceGroupName, String name, String vnetName, String slot) throws CloudException, IOException, IllegalArgumentException {
        return getSiteVNETConnectionSlotAsync(resourceGroupName, name, vnetName, slot).toBlocking().single();
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> getSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(getSiteVNETConnectionSlotAsync(resourceGroupName, name, vnetName, slot), serviceCallback);
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> getSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteVNETConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = getSiteVNETConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> getSiteVNETConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the VnetInfoInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<VnetInfoInner> createOrUpdateSiteVNETConnectionSlot(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) throws CloudException, IOException, IllegalArgumentException {
        return createOrUpdateSiteVNETConnectionSlotAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).toBlocking().single();
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> createOrUpdateSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteVNETConnectionSlotAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> createOrUpdateSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateSiteVNETConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = createOrUpdateSiteVNETConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> createOrUpdateSiteVNETConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteSiteVNETConnectionSlot(String resourceGroupName, String name, String vnetName, String slot) throws CloudException, IOException, IllegalArgumentException {
        return deleteSiteVNETConnectionSlotAsync(resourceGroupName, name, vnetName, slot).toBlocking().single();
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteVNETConnectionSlotAsync(resourceGroupName, name, vnetName, slot), serviceCallback);
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteVNETConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteVNETConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteVNETConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the VnetInfoInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<VnetInfoInner> updateSiteVNETConnectionSlot(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteVNETConnectionSlotAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).toBlocking().single();
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> updateSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(updateSiteVNETConnectionSlotAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> updateSiteVNETConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateSiteVNETConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = updateSiteVNETConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> updateSiteVNETConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the VnetInfoInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<VnetInfoInner> getSiteVNETConnection(String resourceGroupName, String name, String vnetName) throws CloudException, IOException, IllegalArgumentException {
        return getSiteVNETConnectionAsync(resourceGroupName, name, vnetName).toBlocking().single();
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> getSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(getSiteVNETConnectionAsync(resourceGroupName, name, vnetName), serviceCallback);
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> getSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteVNETConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = getSiteVNETConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> getSiteVNETConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the VnetInfoInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<VnetInfoInner> createOrUpdateSiteVNETConnection(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) throws CloudException, IOException, IllegalArgumentException {
        return createOrUpdateSiteVNETConnectionAsync(resourceGroupName, name, vnetName, connectionEnvelope).toBlocking().single();
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> createOrUpdateSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteVNETConnectionAsync(resourceGroupName, name, vnetName, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> createOrUpdateSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateSiteVNETConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = createOrUpdateSiteVNETConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> createOrUpdateSiteVNETConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteSiteVNETConnection(String resourceGroupName, String name, String vnetName) throws CloudException, IOException, IllegalArgumentException {
        return deleteSiteVNETConnectionAsync(resourceGroupName, name, vnetName).toBlocking().single();
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteVNETConnectionAsync(resourceGroupName, name, vnetName), serviceCallback);
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteVNETConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteVNETConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteVNETConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the VnetInfoInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<VnetInfoInner> updateSiteVNETConnection(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteVNETConnectionAsync(resourceGroupName, name, vnetName, connectionEnvelope).toBlocking().single();
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> updateSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(updateSiteVNETConnectionAsync(resourceGroupName, name, vnetName, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> updateSiteVNETConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateSiteVNETConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = updateSiteVNETConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> updateSiteVNETConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot The name of the slot for this web app.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the NetworkFeaturesInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<NetworkFeaturesInner> getSiteNetworkFeaturesSlot(String resourceGroupName, String name, String view, String slot) throws CloudException, IOException, IllegalArgumentException {
        return getSiteNetworkFeaturesSlotAsync(resourceGroupName, name, view, slot).toBlocking().single();
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<NetworkFeaturesInner> getSiteNetworkFeaturesSlotAsync(String resourceGroupName, String name, String view, String slot, final ServiceCallback<NetworkFeaturesInner> serviceCallback) {
        return ServiceCall.create(getSiteNetworkFeaturesSlotAsync(resourceGroupName, name, view, slot), serviceCallback);
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot The name of the slot for this web app.
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<ServiceResponse<NetworkFeaturesInner>> getSiteNetworkFeaturesSlotAsync(String resourceGroupName, String name, String view, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (view == null) {
            throw new IllegalArgumentException("Parameter view is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteNetworkFeaturesSlot(resourceGroupName, name, view, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NetworkFeaturesInner>>>() {
                @Override
                public Observable<ServiceResponse<NetworkFeaturesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NetworkFeaturesInner> clientResponse = getSiteNetworkFeaturesSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NetworkFeaturesInner> getSiteNetworkFeaturesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<NetworkFeaturesInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<NetworkFeaturesInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the NetworkFeaturesInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<NetworkFeaturesInner> getSiteNetworkFeatures(String resourceGroupName, String name, String view) throws CloudException, IOException, IllegalArgumentException {
        return getSiteNetworkFeaturesAsync(resourceGroupName, name, view).toBlocking().single();
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<NetworkFeaturesInner> getSiteNetworkFeaturesAsync(String resourceGroupName, String name, String view, final ServiceCallback<NetworkFeaturesInner> serviceCallback) {
        return ServiceCall.create(getSiteNetworkFeaturesAsync(resourceGroupName, name, view), serviceCallback);
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<ServiceResponse<NetworkFeaturesInner>> getSiteNetworkFeaturesAsync(String resourceGroupName, String name, String view) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (view == null) {
            throw new IllegalArgumentException("Parameter view is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteNetworkFeatures(resourceGroupName, name, view, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NetworkFeaturesInner>>>() {
                @Override
                public Observable<ServiceResponse<NetworkFeaturesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NetworkFeaturesInner> clientResponse = getSiteNetworkFeaturesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NetworkFeaturesInner> getSiteNetworkFeaturesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<NetworkFeaturesInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<NetworkFeaturesInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> getSiteOperationSlot(String resourceGroupName, String name, String operationId, String slot) throws CloudException, IOException, IllegalArgumentException {
        return getSiteOperationSlotAsync(resourceGroupName, name, operationId, slot).toBlocking().single();
    }

    /**
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSiteOperationSlotAsync(String resourceGroupName, String name, String operationId, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSiteOperationSlotAsync(resourceGroupName, name, operationId, slot), serviceCallback);
    }

    /**
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSiteOperationSlotAsync(String resourceGroupName, String name, String operationId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteOperationSlot(resourceGroupName, name, operationId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSiteOperationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSiteOperationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> getSiteOperation(String resourceGroupName, String name, String operationId) throws CloudException, IOException, IllegalArgumentException {
        return getSiteOperationAsync(resourceGroupName, name, operationId).toBlocking().single();
    }

    /**
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSiteOperationAsync(String resourceGroupName, String name, String operationId, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSiteOperationAsync(resourceGroupName, name, operationId), serviceCallback);
    }

    /**
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSiteOperationAsync(String resourceGroupName, String name, String operationId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteOperation(resourceGroupName, name, operationId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSiteOperationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSiteOperationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @throws InterruptedException exception thrown when long running operation is interrupted
     * @return the Object object wrapped in ServiceResponse if successful.
     */
    public ServiceResponse<Object> swapSlotWithProduction(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) throws CloudException, IOException, IllegalArgumentException, InterruptedException {
        return swapSlotWithProductionAsync(resourceGroupName, name, slotSwapEntity).toBlocking().last();
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> swapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(swapSlotWithProductionAsync(resourceGroupName, name, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Object>> swapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        Observable<Response<ResponseBody>> observable = service.swapSlotWithProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Object>() { }.getType());
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> beginSwapSlotWithProduction(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) throws CloudException, IOException, IllegalArgumentException {
        return beginSwapSlotWithProductionAsync(resourceGroupName, name, slotSwapEntity).toBlocking().single();
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> beginSwapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(beginSwapSlotWithProductionAsync(resourceGroupName, name, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> beginSwapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.beginSwapSlotWithProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = beginSwapSlotWithProductionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> beginSwapSlotWithProductionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(202, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @throws InterruptedException exception thrown when long running operation is interrupted
     * @return the Object object wrapped in ServiceResponse if successful.
     */
    public ServiceResponse<Object> swapSlotsSlot(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) throws CloudException, IOException, IllegalArgumentException, InterruptedException {
        return swapSlotsSlotAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().last();
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> swapSlotsSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(swapSlotsSlotAsync(resourceGroupName, name, slot, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Object>> swapSlotsSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        Observable<Response<ResponseBody>> observable = service.swapSlotsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Object>() { }.getType());
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> beginSwapSlotsSlot(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) throws CloudException, IOException, IllegalArgumentException {
        return beginSwapSlotsSlotAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().single();
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> beginSwapSlotsSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(beginSwapSlotsSlotAsync(resourceGroupName, name, slot, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> beginSwapSlotsSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.beginSwapSlotsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = beginSwapSlotsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> beginSwapSlotsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(202, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SlotDifferenceInner>> getSlotsDifferencesFromProduction(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<SlotDifferenceInner>> response = getSlotsDifferencesFromProductionSinglePageAsync(resourceGroupName, name, slotSwapEntity).toBlocking().single();
        PagedList<SlotDifferenceInner> pagedList = new PagedList<SlotDifferenceInner>(response.getBody()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<SlotDifferenceInner>>(pagedList, response.getResponse());
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SlotDifferenceInner>> getSlotsDifferencesFromProductionAsync(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSlotsDifferencesFromProductionSinglePageAsync(resourceGroupName, name, slotSwapEntity),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the List&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesFromProductionAsync(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity) {
        return getSlotsDifferencesFromProductionSinglePageAsync(resourceGroupName, name, slotSwapEntity)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param name Name of web app
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param slotSwapEntity Request body that contains the target slot name
     * @return the List&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesFromProductionSinglePageAsync(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.getSlotsDifferencesFromProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = getSlotsDifferencesFromProductionDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> getSlotsDifferencesFromProductionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SlotDifferenceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot
     * @param slotSwapEntity Request body that contains the target slot name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SlotDifferenceInner>> getSlotsDifferencesSlot(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<SlotDifferenceInner>> response = getSlotsDifferencesSlotSinglePageAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().single();
        PagedList<SlotDifferenceInner> pagedList = new PagedList<SlotDifferenceInner>(response.getBody()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<SlotDifferenceInner>>(pagedList, response.getResponse());
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SlotDifferenceInner>> getSlotsDifferencesSlotAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSlotsDifferencesSlotSinglePageAsync(resourceGroupName, name, slot, slotSwapEntity),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the List&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesSlotAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity) {
        return getSlotsDifferencesSlotSinglePageAsync(resourceGroupName, name, slot, slotSwapEntity)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param name Name of web app
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param slot Name of the source slot
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param slotSwapEntity Request body that contains the target slot name
     * @return the List&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.getSlotsDifferencesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = getSlotsDifferencesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> getSlotsDifferencesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SlotDifferenceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> applySlotConfigToProduction(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) throws CloudException, IOException, IllegalArgumentException {
        return applySlotConfigToProductionAsync(resourceGroupName, name, slotSwapEntity).toBlocking().single();
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> applySlotConfigToProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(applySlotConfigToProductionAsync(resourceGroupName, name, slotSwapEntity), serviceCallback);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> applySlotConfigToProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.applySlotConfigToProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = applySlotConfigToProductionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> applySlotConfigToProductionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot. Settings from the target slot will be applied onto this slot
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> applySlotConfigSlot(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) throws CloudException, IOException, IllegalArgumentException {
        return applySlotConfigSlotAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().single();
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot. Settings from the target slot will be applied onto this slot
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> applySlotConfigSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(applySlotConfigSlotAsync(resourceGroupName, name, slot, slotSwapEntity), serviceCallback);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot. Settings from the target slot will be applied onto this slot
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> applySlotConfigSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.applySlotConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = applySlotConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> applySlotConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> resetProductionSlotConfig(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return resetProductionSlotConfigAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> resetProductionSlotConfigAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(resetProductionSlotConfigAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> resetProductionSlotConfigAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.resetProductionSlotConfig(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = resetProductionSlotConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> resetProductionSlotConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> resetSlotConfigSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return resetSlotConfigSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> resetSlotConfigSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(resetSlotConfigSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> resetSlotConfigSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.resetSlotConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = resetSlotConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> resetSlotConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SlotConfigNamesResourceInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SlotConfigNamesResourceInner> getSlotConfigNames(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return getSlotConfigNamesAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Gets the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SlotConfigNamesResourceInner> getSlotConfigNamesAsync(String resourceGroupName, String name, final ServiceCallback<SlotConfigNamesResourceInner> serviceCallback) {
        return ServiceCall.create(getSlotConfigNamesAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<ServiceResponse<SlotConfigNamesResourceInner>> getSlotConfigNamesAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSlotConfigNames(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SlotConfigNamesResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SlotConfigNamesResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SlotConfigNamesResourceInner> clientResponse = getSlotConfigNamesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SlotConfigNamesResourceInner> getSlotConfigNamesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SlotConfigNamesResourceInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SlotConfigNamesResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotConfigNames Request body containing the names of application settings and connection strings
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SlotConfigNamesResourceInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SlotConfigNamesResourceInner> updateSlotConfigNames(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames) throws CloudException, IOException, IllegalArgumentException {
        return updateSlotConfigNamesAsync(resourceGroupName, name, slotConfigNames).toBlocking().single();
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotConfigNames Request body containing the names of application settings and connection strings
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SlotConfigNamesResourceInner> updateSlotConfigNamesAsync(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames, final ServiceCallback<SlotConfigNamesResourceInner> serviceCallback) {
        return ServiceCall.create(updateSlotConfigNamesAsync(resourceGroupName, name, slotConfigNames), serviceCallback);
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotConfigNames Request body containing the names of application settings and connection strings
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<ServiceResponse<SlotConfigNamesResourceInner>> updateSlotConfigNamesAsync(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotConfigNames == null) {
            throw new IllegalArgumentException("Parameter slotConfigNames is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotConfigNames);
        return service.updateSlotConfigNames(resourceGroupName, name, this.client.subscriptionId(), slotConfigNames, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SlotConfigNamesResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SlotConfigNamesResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SlotConfigNamesResourceInner> clientResponse = updateSlotConfigNamesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SlotConfigNamesResourceInner> updateSlotConfigNamesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SlotConfigNamesResourceInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SlotConfigNamesResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SiteInner>> getSiteSlots(final String resourceGroupName, final String name) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<SiteInner>> response = getSiteSlotsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        PagedList<SiteInner> pagedList = new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteSlotsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<SiteInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> getSiteSlotsAsync(final String resourceGroupName, final String name, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteSlotsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return getSiteSlotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the List&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSiteSlotsAsync(final String resourceGroupName, final String name) {
        return getSiteSlotsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteSlotsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the List&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSiteSlotsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String propertiesToInclude = null;
        return service.getSiteSlots(resourceGroupName, name, this.client.subscriptionId(), propertiesToInclude, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = getSiteSlotsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude List of app properties to include in the response
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SiteInner>> getSiteSlots(final String resourceGroupName, final String name, final String propertiesToInclude) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<SiteInner>> response = getSiteSlotsSinglePageAsync(resourceGroupName, name, propertiesToInclude).toBlocking().single();
        PagedList<SiteInner> pagedList = new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteSlotsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<SiteInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude List of app properties to include in the response
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> getSiteSlotsAsync(final String resourceGroupName, final String name, final String propertiesToInclude, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteSlotsSinglePageAsync(resourceGroupName, name, propertiesToInclude),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return getSiteSlotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude List of app properties to include in the response
     * @return the observable to the List&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSiteSlotsAsync(final String resourceGroupName, final String name, final String propertiesToInclude) {
        return getSiteSlotsSinglePageAsync(resourceGroupName, name, propertiesToInclude)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteSlotsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SiteInner>> * @param name Name of web app
    ServiceResponse<PageImpl<SiteInner>> * @param propertiesToInclude List of app properties to include in the response
     * @return the List&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSiteSlotsSinglePageAsync(final String resourceGroupName, final String name, final String propertiesToInclude) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteSlots(resourceGroupName, name, this.client.subscriptionId(), propertiesToInclude, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = getSiteSlotsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> getSiteSlotsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SiteInner>> getSites(final String resourceGroupName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<SiteInner>> response = getSitesSinglePageAsync(resourceGroupName).toBlocking().single();
        PagedList<SiteInner> pagedList = new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSitesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<SiteInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> getSitesAsync(final String resourceGroupName, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getSitesSinglePageAsync(resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return getSitesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @return the observable to the List&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSitesAsync(final String resourceGroupName) {
        return getSitesSinglePageAsync(resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSitesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @return the List&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSitesSinglePageAsync(final String resourceGroupName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String propertiesToInclude = null;
        final String includeSiteTypes = null;
        final Boolean includeSlots = null;
        return service.getSites(resourceGroupName, this.client.subscriptionId(), propertiesToInclude, includeSiteTypes, includeSlots, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = getSitesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSiteTypes Types of apps included in the response
     * @param includeSlots Whether or not to include deployments slots in results
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SiteInner>> getSites(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes, final Boolean includeSlots) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<SiteInner>> response = getSitesSinglePageAsync(resourceGroupName, propertiesToInclude, includeSiteTypes, includeSlots).toBlocking().single();
        PagedList<SiteInner> pagedList = new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSitesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<SiteInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSiteTypes Types of apps included in the response
     * @param includeSlots Whether or not to include deployments slots in results
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> getSitesAsync(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes, final Boolean includeSlots, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getSitesSinglePageAsync(resourceGroupName, propertiesToInclude, includeSiteTypes, includeSlots),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return getSitesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSiteTypes Types of apps included in the response
     * @param includeSlots Whether or not to include deployments slots in results
     * @return the observable to the List&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSitesAsync(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes, final Boolean includeSlots) {
        return getSitesSinglePageAsync(resourceGroupName, propertiesToInclude, includeSiteTypes, includeSlots)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSitesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SiteInner>> * @param propertiesToInclude Additional web app properties included in the response
    ServiceResponse<PageImpl<SiteInner>> * @param includeSiteTypes Types of apps included in the response
    ServiceResponse<PageImpl<SiteInner>> * @param includeSlots Whether or not to include deployments slots in results
     * @return the List&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSitesSinglePageAsync(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes, final Boolean includeSlots) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSites(resourceGroupName, this.client.subscriptionId(), propertiesToInclude, includeSiteTypes, includeSlots, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = getSitesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> getSitesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteInner> getSite(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return getSiteAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> getSiteAsync(String resourceGroupName, String name, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(getSiteAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getSiteAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String propertiesToInclude = null;
        return service.getSite(resourceGroupName, name, this.client.subscriptionId(), propertiesToInclude, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude Additional web app properties included in the response
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteInner> getSite(String resourceGroupName, String name, String propertiesToInclude) throws CloudException, IOException, IllegalArgumentException {
        return getSiteAsync(resourceGroupName, name, propertiesToInclude).toBlocking().single();
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude Additional web app properties included in the response
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> getSiteAsync(String resourceGroupName, String name, String propertiesToInclude, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(getSiteAsync(resourceGroupName, name, propertiesToInclude), serviceCallback);
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getSiteAsync(String resourceGroupName, String name, String propertiesToInclude) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSite(resourceGroupName, name, this.client.subscriptionId(), propertiesToInclude, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> getSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @throws InterruptedException exception thrown when long running operation is interrupted
     * @return the SiteInner object wrapped in ServiceResponse if successful.
     */
    public ServiceResponse<SiteInner> createOrUpdateSite(String resourceGroupName, String name, SiteInner siteEnvelope) throws CloudException, IOException, IllegalArgumentException, InterruptedException {
        return createOrUpdateSiteAsync(resourceGroupName, name, siteEnvelope).toBlocking().last();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> createOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteAsync(resourceGroupName, name, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String skipDnsRegistration = null;
        final String skipCustomDomainVerification = null;
        final String forceDnsRegistration = null;
        final String ttlInSeconds = null;
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSite(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }
    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @throws InterruptedException exception thrown when long running operation is interrupted
     * @return the SiteInner object wrapped in ServiceResponse if successful.
     */
    public ServiceResponse<SiteInner> createOrUpdateSite(String resourceGroupName, String name, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) throws CloudException, IOException, IllegalArgumentException, InterruptedException {
        return createOrUpdateSiteAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().last();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> createOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSite(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteInner> beginCreateOrUpdateSite(String resourceGroupName, String name, SiteInner siteEnvelope) throws CloudException, IOException, IllegalArgumentException {
        return beginCreateOrUpdateSiteAsync(resourceGroupName, name, siteEnvelope).toBlocking().single();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginCreateOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginCreateOrUpdateSiteAsync(resourceGroupName, name, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String skipDnsRegistration = null;
        final String skipCustomDomainVerification = null;
        final String forceDnsRegistration = null;
        final String ttlInSeconds = null;
        return service.beginCreateOrUpdateSite(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteInner> beginCreateOrUpdateSite(String resourceGroupName, String name, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) throws CloudException, IOException, IllegalArgumentException {
        return beginCreateOrUpdateSiteAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().single();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginCreateOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginCreateOrUpdateSiteAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateSiteAsync(String resourceGroupName, String name, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        return service.beginCreateOrUpdateSite(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> beginCreateOrUpdateSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteSite(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return deleteSiteAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String deleteMetrics = null;
        final String deleteEmptyServerFarm = null;
        final String skipDnsRegistration = null;
        final String deleteAllSlots = null;
        return service.deleteSite(resourceGroupName, name, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param deleteAllSlots If true, all slots associated with web app are also deleted
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteSite(String resourceGroupName, String name, String deleteMetrics, String deleteEmptyServerFarm, String skipDnsRegistration, String deleteAllSlots) throws CloudException, IOException, IllegalArgumentException {
        return deleteSiteAsync(resourceGroupName, name, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots).toBlocking().single();
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param deleteAllSlots If true, all slots associated with web app are also deleted
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteAsync(String resourceGroupName, String name, String deleteMetrics, String deleteEmptyServerFarm, String skipDnsRegistration, String deleteAllSlots, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteAsync(resourceGroupName, name, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots), serviceCallback);
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param deleteAllSlots If true, all slots associated with web app are also deleted
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteAsync(String resourceGroupName, String name, String deleteMetrics, String deleteEmptyServerFarm, String skipDnsRegistration, String deleteAllSlots) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSite(resourceGroupName, name, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteInner> getSiteSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return getSiteSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> getSiteSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(getSiteSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getSiteSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String propertiesToInclude = null;
        return service.getSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), propertiesToInclude, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param propertiesToInclude Additional web app properties included in the response
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteInner> getSiteSlot(String resourceGroupName, String name, String slot, String propertiesToInclude) throws CloudException, IOException, IllegalArgumentException {
        return getSiteSlotAsync(resourceGroupName, name, slot, propertiesToInclude).toBlocking().single();
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param propertiesToInclude Additional web app properties included in the response
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> getSiteSlotAsync(String resourceGroupName, String name, String slot, String propertiesToInclude, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(getSiteSlotAsync(resourceGroupName, name, slot, propertiesToInclude), serviceCallback);
    }

    /**
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getSiteSlotAsync(String resourceGroupName, String name, String slot, String propertiesToInclude) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), propertiesToInclude, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> getSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @throws InterruptedException exception thrown when long running operation is interrupted
     * @return the SiteInner object wrapped in ServiceResponse if successful.
     */
    public ServiceResponse<SiteInner> createOrUpdateSiteSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) throws CloudException, IOException, IllegalArgumentException, InterruptedException {
        return createOrUpdateSiteSlotAsync(resourceGroupName, name, slot, siteEnvelope).toBlocking().last();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> createOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteSlotAsync(resourceGroupName, name, slot, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String skipDnsRegistration = null;
        final String skipCustomDomainVerification = null;
        final String forceDnsRegistration = null;
        final String ttlInSeconds = null;
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }
    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @throws InterruptedException exception thrown when long running operation is interrupted
     * @return the SiteInner object wrapped in ServiceResponse if successful.
     */
    public ServiceResponse<SiteInner> createOrUpdateSiteSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) throws CloudException, IOException, IllegalArgumentException, InterruptedException {
        return createOrUpdateSiteSlotAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().last();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> createOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteSlotAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteInner> beginCreateOrUpdateSiteSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) throws CloudException, IOException, IllegalArgumentException {
        return beginCreateOrUpdateSiteSlotAsync(resourceGroupName, name, slot, siteEnvelope).toBlocking().single();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginCreateOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginCreateOrUpdateSiteSlotAsync(resourceGroupName, name, slot, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String skipDnsRegistration = null;
        final String skipCustomDomainVerification = null;
        final String forceDnsRegistration = null;
        final String ttlInSeconds = null;
        return service.beginCreateOrUpdateSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteInner> beginCreateOrUpdateSiteSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) throws CloudException, IOException, IllegalArgumentException {
        return beginCreateOrUpdateSiteSlotAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().single();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginCreateOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginCreateOrUpdateSiteSlotAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateSiteSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, String skipDnsRegistration, String skipCustomDomainVerification, String forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        return service.beginCreateOrUpdateSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> beginCreateOrUpdateSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteSiteSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return deleteSiteSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String deleteMetrics = null;
        final String deleteEmptyServerFarm = null;
        final String skipDnsRegistration = null;
        final String deleteAllSlots = null;
        return service.deleteSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param deleteAllSlots If true, all slots associated with web app are also deleted
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteSiteSlot(String resourceGroupName, String name, String slot, String deleteMetrics, String deleteEmptyServerFarm, String skipDnsRegistration, String deleteAllSlots) throws CloudException, IOException, IllegalArgumentException {
        return deleteSiteSlotAsync(resourceGroupName, name, slot, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots).toBlocking().single();
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param deleteAllSlots If true, all slots associated with web app are also deleted
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteSlotAsync(String resourceGroupName, String name, String slot, String deleteMetrics, String deleteEmptyServerFarm, String skipDnsRegistration, String deleteAllSlots, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteSlotAsync(resourceGroupName, name, slot, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots), serviceCallback);
    }

    /**
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param deleteAllSlots If true, all slots associated with web app are also deleted
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteSlotAsync(String resourceGroupName, String name, String slot, String deleteMetrics, String deleteEmptyServerFarm, String skipDnsRegistration, String deleteAllSlots) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, deleteAllSlots, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteCloneabilityInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteCloneabilityInner> isSiteCloneable(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return isSiteCloneableAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteCloneabilityInner> isSiteCloneableAsync(String resourceGroupName, String name, final ServiceCallback<SiteCloneabilityInner> serviceCallback) {
        return ServiceCall.create(isSiteCloneableAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<ServiceResponse<SiteCloneabilityInner>> isSiteCloneableAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.isSiteCloneable(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteCloneabilityInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteCloneabilityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteCloneabilityInner> clientResponse = isSiteCloneableDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteCloneabilityInner> isSiteCloneableDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteCloneabilityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteCloneabilityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteCloneabilityInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteCloneabilityInner> isSiteCloneableSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return isSiteCloneableSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteCloneabilityInner> isSiteCloneableSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteCloneabilityInner> serviceCallback) {
        return ServiceCall.create(isSiteCloneableSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<ServiceResponse<SiteCloneabilityInner>> isSiteCloneableSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.isSiteCloneableSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteCloneabilityInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteCloneabilityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteCloneabilityInner> clientResponse = isSiteCloneableSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteCloneabilityInner> isSiteCloneableSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteCloneabilityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteCloneabilityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @throws InterruptedException exception thrown when long running operation is interrupted
     * @return the SiteInner object wrapped in ServiceResponse if successful.
     */
    public ServiceResponse<SiteInner> recoverSite(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) throws CloudException, IOException, IllegalArgumentException, InterruptedException {
        return recoverSiteAsync(resourceGroupName, name, recoveryEntity).toBlocking().last();
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> recoverSiteAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(recoverSiteAsync(resourceGroupName, name, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> recoverSiteAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        Observable<Response<ResponseBody>> observable = service.recoverSite(resourceGroupName, name, this.client.subscriptionId(), recoveryEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteInner> beginRecoverSite(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) throws CloudException, IOException, IllegalArgumentException {
        return beginRecoverSiteAsync(resourceGroupName, name, recoveryEntity).toBlocking().single();
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginRecoverSiteAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginRecoverSiteAsync(resourceGroupName, name, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginRecoverSiteAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        return service.beginRecoverSite(resourceGroupName, name, this.client.subscriptionId(), recoveryEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginRecoverSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> beginRecoverSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @throws InterruptedException exception thrown when long running operation is interrupted
     * @return the SiteInner object wrapped in ServiceResponse if successful.
     */
    public ServiceResponse<SiteInner> recoverSiteSlot(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) throws CloudException, IOException, IllegalArgumentException, InterruptedException {
        return recoverSiteSlotAsync(resourceGroupName, name, slot, recoveryEntity).toBlocking().last();
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> recoverSiteSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(recoverSiteSlotAsync(resourceGroupName, name, slot, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> recoverSiteSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        Observable<Response<ResponseBody>> observable = service.recoverSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), recoveryEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteInner> beginRecoverSiteSlot(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) throws CloudException, IOException, IllegalArgumentException {
        return beginRecoverSiteSlotAsync(resourceGroupName, name, slot, recoveryEntity).toBlocking().single();
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginRecoverSiteSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginRecoverSiteSlotAsync(resourceGroupName, name, slot, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginRecoverSiteSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        return service.beginRecoverSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), recoveryEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginRecoverSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> beginRecoverSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Webspace
     * @param name Website Name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> getSiteSnapshots(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return getSiteSnapshotsAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Webspace
     * @param name Website Name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSiteSnapshotsAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSiteSnapshotsAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Webspace
     * @param name Website Name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSiteSnapshotsAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteSnapshots(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSiteSnapshotsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSiteSnapshotsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Webspace
     * @param name Website Name
     * @param slot Website Slot
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> getSiteSnapshotsSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return getSiteSnapshotsSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Webspace
     * @param name Website Name
     * @param slot Website Slot
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSiteSnapshotsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSiteSnapshotsSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Webspace
     * @param name Website Name
     * @param slot Website Slot
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSiteSnapshotsSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteSnapshotsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSiteSnapshotsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSiteSnapshotsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;DeletedSiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<DeletedSiteInner>> getDeletedSites(final String resourceGroupName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<DeletedSiteInner>> response = getDeletedSitesSinglePageAsync(resourceGroupName).toBlocking().single();
        PagedList<DeletedSiteInner> pagedList = new PagedList<DeletedSiteInner>(response.getBody()) {
            @Override
            public Page<DeletedSiteInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getDeletedSitesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<DeletedSiteInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeletedSiteInner>> getDeletedSitesAsync(final String resourceGroupName, final ListOperationCallback<DeletedSiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getDeletedSitesSinglePageAsync(resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(String nextPageLink) {
                    return getDeletedSitesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @return the observable to the List&lt;DeletedSiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> getDeletedSitesAsync(final String resourceGroupName) {
        return getDeletedSitesSinglePageAsync(resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<DeletedSiteInner>>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(ServiceResponse<Page<DeletedSiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getDeletedSitesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @return the List&lt;DeletedSiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> getDeletedSitesSinglePageAsync(final String resourceGroupName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String propertiesToInclude = null;
        final String includeSiteTypes = null;
        return service.getDeletedSites(resourceGroupName, this.client.subscriptionId(), propertiesToInclude, includeSiteTypes, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeletedSiteInner>> result = getDeletedSitesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeletedSiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSiteTypes Types of apps included in the response
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;DeletedSiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<DeletedSiteInner>> getDeletedSites(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<DeletedSiteInner>> response = getDeletedSitesSinglePageAsync(resourceGroupName, propertiesToInclude, includeSiteTypes).toBlocking().single();
        PagedList<DeletedSiteInner> pagedList = new PagedList<DeletedSiteInner>(response.getBody()) {
            @Override
            public Page<DeletedSiteInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getDeletedSitesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<DeletedSiteInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSiteTypes Types of apps included in the response
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeletedSiteInner>> getDeletedSitesAsync(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes, final ListOperationCallback<DeletedSiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getDeletedSitesSinglePageAsync(resourceGroupName, propertiesToInclude, includeSiteTypes),
            new Func1<String, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(String nextPageLink) {
                    return getDeletedSitesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSiteTypes Types of apps included in the response
     * @return the observable to the List&lt;DeletedSiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> getDeletedSitesAsync(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes) {
        return getDeletedSitesSinglePageAsync(resourceGroupName, propertiesToInclude, includeSiteTypes)
            .concatMap(new Func1<ServiceResponse<Page<DeletedSiteInner>>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(ServiceResponse<Page<DeletedSiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getDeletedSitesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     *
    ServiceResponse<PageImpl<DeletedSiteInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<DeletedSiteInner>> * @param propertiesToInclude Additional web app properties included in the response
    ServiceResponse<PageImpl<DeletedSiteInner>> * @param includeSiteTypes Types of apps included in the response
     * @return the List&lt;DeletedSiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> getDeletedSitesSinglePageAsync(final String resourceGroupName, final String propertiesToInclude, final String includeSiteTypes) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDeletedSites(resourceGroupName, this.client.subscriptionId(), propertiesToInclude, includeSiteTypes, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeletedSiteInner>> result = getDeletedSitesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeletedSiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeletedSiteInner>> getDeletedSitesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeletedSiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeletedSiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<DeploymentInner>> getDeployments(final String resourceGroupName, final String name) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<DeploymentInner>> response = getDeploymentsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        PagedList<DeploymentInner> pagedList = new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<DeploymentInner>>(pagedList, response.getResponse());
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getDeploymentsAsync(final String resourceGroupName, final String name, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getDeploymentsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the List&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsAsync(final String resourceGroupName, final String name) {
        return getDeploymentsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getDeploymentsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of web app
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDeployments(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getDeploymentsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getDeploymentsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<DeploymentInner>> getDeploymentsSlot(final String resourceGroupName, final String name, final String slot) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<DeploymentInner>> response = getDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        PagedList<DeploymentInner> pagedList = new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<DeploymentInner>>(pagedList, response.getResponse());
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the List&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return getDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of web app
    ServiceResponse<PageImpl<DeploymentInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDeploymentsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getDeploymentsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getDeploymentsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param instanceId Id of web app instance
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<DeploymentInner>> getInstanceDeployments(final String resourceGroupName, final String name, final String instanceId) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<DeploymentInner>> response = getInstanceDeploymentsSinglePageAsync(resourceGroupName, name, instanceId).toBlocking().single();
        PagedList<DeploymentInner> pagedList = new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getInstanceDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<DeploymentInner>>(pagedList, response.getResponse());
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getInstanceDeploymentsAsync(final String resourceGroupName, final String name, final String instanceId, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getInstanceDeploymentsSinglePageAsync(resourceGroupName, name, instanceId),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getInstanceDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param instanceId Id of web app instance
     * @return the observable to the List&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsAsync(final String resourceGroupName, final String name, final String instanceId) {
        return getInstanceDeploymentsSinglePageAsync(resourceGroupName, name, instanceId)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getInstanceDeploymentsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of web app
    ServiceResponse<PageImpl<DeploymentInner>> * @param instanceId Id of web app instance
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsSinglePageAsync(final String resourceGroupName, final String name, final String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceDeployments(resourceGroupName, name, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getInstanceDeploymentsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getInstanceDeploymentsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<DeploymentInner>> getInstanceDeploymentsSlot(final String resourceGroupName, final String name, final String slot, final String instanceId) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<DeploymentInner>> response = getInstanceDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot, instanceId).toBlocking().single();
        PagedList<DeploymentInner> pagedList = new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<DeploymentInner>>(pagedList, response.getResponse());
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getInstanceDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot, final String instanceId, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getInstanceDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot, instanceId),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the observable to the List&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        return getInstanceDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot, instanceId)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of web app
    ServiceResponse<PageImpl<DeploymentInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
    ServiceResponse<PageImpl<DeploymentInner>> * @param instanceId Id of web app instance
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceDeploymentsSlot(resourceGroupName, name, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getInstanceDeploymentsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getInstanceDeploymentsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the DeploymentInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<DeploymentInner> getInstanceDeployment(String resourceGroupName, String name, String id, String instanceId) throws CloudException, IOException, IllegalArgumentException {
        return getInstanceDeploymentAsync(resourceGroupName, name, id, instanceId).toBlocking().single();
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> getInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(getInstanceDeploymentAsync(resourceGroupName, name, id, instanceId), serviceCallback);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceDeployment(resourceGroupName, name, id, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getInstanceDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getInstanceDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the DeploymentInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<DeploymentInner> createInstanceDeployment(String resourceGroupName, String name, String id, String instanceId, DeploymentInner deployment) throws CloudException, IOException, IllegalArgumentException {
        return createInstanceDeploymentAsync(resourceGroupName, name, id, instanceId, deployment).toBlocking().single();
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> createInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(createInstanceDeploymentAsync(resourceGroupName, name, id, instanceId, deployment), serviceCallback);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(deployment);
        return service.createInstanceDeployment(resourceGroupName, name, id, instanceId, this.client.subscriptionId(), deployment, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createInstanceDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createInstanceDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteInstanceDeployment(String resourceGroupName, String name, String id, String instanceId) throws CloudException, IOException, IllegalArgumentException {
        return deleteInstanceDeploymentAsync(resourceGroupName, name, id, instanceId).toBlocking().single();
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteInstanceDeploymentAsync(resourceGroupName, name, id, instanceId), serviceCallback);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteInstanceDeployment(resourceGroupName, name, id, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteInstanceDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteInstanceDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the DeploymentInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<DeploymentInner> getDeployment(String resourceGroupName, String name, String id) throws CloudException, IOException, IllegalArgumentException {
        return getDeploymentAsync(resourceGroupName, name, id).toBlocking().single();
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> getDeploymentAsync(String resourceGroupName, String name, String id, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(getDeploymentAsync(resourceGroupName, name, id), serviceCallback);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getDeploymentAsync(String resourceGroupName, String name, String id) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDeployment(resourceGroupName, name, id, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param deployment Details of deployment
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the DeploymentInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<DeploymentInner> createDeployment(String resourceGroupName, String name, String id, DeploymentInner deployment) throws CloudException, IOException, IllegalArgumentException {
        return createDeploymentAsync(resourceGroupName, name, id, deployment).toBlocking().single();
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param deployment Details of deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> createDeploymentAsync(String resourceGroupName, String name, String id, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(createDeploymentAsync(resourceGroupName, name, id, deployment), serviceCallback);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createDeploymentAsync(String resourceGroupName, String name, String id, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(deployment);
        return service.createDeployment(resourceGroupName, name, id, this.client.subscriptionId(), deployment, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteDeployment(String resourceGroupName, String name, String id) throws CloudException, IOException, IllegalArgumentException {
        return deleteDeploymentAsync(resourceGroupName, name, id).toBlocking().single();
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteDeploymentAsync(String resourceGroupName, String name, String id, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteDeploymentAsync(resourceGroupName, name, id), serviceCallback);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteDeploymentAsync(String resourceGroupName, String name, String id) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteDeployment(resourceGroupName, name, id, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the DeploymentInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<DeploymentInner> getDeploymentSlot(String resourceGroupName, String name, String id, String slot) throws CloudException, IOException, IllegalArgumentException {
        return getDeploymentSlotAsync(resourceGroupName, name, id, slot).toBlocking().single();
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> getDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(getDeploymentSlotAsync(resourceGroupName, name, id, slot), serviceCallback);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDeploymentSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deployment Details of deployment
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the DeploymentInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<DeploymentInner> createDeploymentSlot(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment) throws CloudException, IOException, IllegalArgumentException {
        return createDeploymentSlotAsync(resourceGroupName, name, id, slot, deployment).toBlocking().single();
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deployment Details of deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> createDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(createDeploymentSlotAsync(resourceGroupName, name, id, slot, deployment), serviceCallback);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(deployment);
        return service.createDeploymentSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), deployment, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteDeploymentSlot(String resourceGroupName, String name, String id, String slot) throws CloudException, IOException, IllegalArgumentException {
        return deleteDeploymentSlotAsync(resourceGroupName, name, id, slot).toBlocking().single();
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteDeploymentSlotAsync(resourceGroupName, name, id, slot), serviceCallback);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteDeploymentSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the DeploymentInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<DeploymentInner> getInstanceDeploymentSlot(String resourceGroupName, String name, String id, String slot, String instanceId) throws CloudException, IOException, IllegalArgumentException {
        return getInstanceDeploymentSlotAsync(resourceGroupName, name, id, slot, instanceId).toBlocking().single();
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> getInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(getInstanceDeploymentSlotAsync(resourceGroupName, name, id, slot, instanceId), serviceCallback);
    }

    /**
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getInstanceDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getInstanceDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the DeploymentInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<DeploymentInner> createInstanceDeploymentSlot(String resourceGroupName, String name, String id, String slot, String instanceId, DeploymentInner deployment) throws CloudException, IOException, IllegalArgumentException {
        return createInstanceDeploymentSlotAsync(resourceGroupName, name, id, slot, instanceId, deployment).toBlocking().single();
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> createInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(createInstanceDeploymentSlotAsync(resourceGroupName, name, id, slot, instanceId, deployment), serviceCallback);
    }

    /**
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(deployment);
        return service.createInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, this.client.subscriptionId(), deployment, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createInstanceDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createInstanceDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteInstanceDeploymentSlot(String resourceGroupName, String name, String id, String slot, String instanceId) throws CloudException, IOException, IllegalArgumentException {
        return deleteInstanceDeploymentSlotAsync(resourceGroupName, name, id, slot, instanceId).toBlocking().single();
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteInstanceDeploymentSlotAsync(resourceGroupName, name, id, slot, instanceId), serviceCallback);
    }

    /**
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteInstanceDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteInstanceDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SiteInstanceInner>> getSiteInstanceIdentifiers(final String resourceGroupName, final String name) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<SiteInstanceInner>> response = getSiteInstanceIdentifiersSinglePageAsync(resourceGroupName, name).toBlocking().single();
        PagedList<SiteInstanceInner> pagedList = new PagedList<SiteInstanceInner>(response.getBody()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<SiteInstanceInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInstanceInner>> getSiteInstanceIdentifiersAsync(final String resourceGroupName, final String name, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteInstanceIdentifiersSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the List&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersAsync(final String resourceGroupName, final String name) {
        return getSiteInstanceIdentifiersSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets all instance of a web app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param name Name of web app
     * @return the List&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteInstanceIdentifiers(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = getSiteInstanceIdentifiersDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> getSiteInstanceIdentifiersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInstanceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SiteInstanceInner>> getSiteInstanceIdentifiersSlot(final String resourceGroupName, final String name, final String slot) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<SiteInstanceInner>> response = getSiteInstanceIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        PagedList<SiteInstanceInner> pagedList = new PagedList<SiteInstanceInner>(response.getBody()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<SiteInstanceInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInstanceInner>> getSiteInstanceIdentifiersSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteInstanceIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the List&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return getSiteInstanceIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets all instance of a web app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param name Name of web app
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the List&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteInstanceIdentifiersSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = getSiteInstanceIdentifiersSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> getSiteInstanceIdentifiersSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInstanceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<HostNameBindingInner>> getSiteHostNameBindings(final String resourceGroupName, final String name) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<HostNameBindingInner>> response = getSiteHostNameBindingsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        PagedList<HostNameBindingInner> pagedList = new PagedList<HostNameBindingInner>(response.getBody()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteHostNameBindingsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<HostNameBindingInner>>(pagedList, response.getResponse());
    }

    /**
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<HostNameBindingInner>> getSiteHostNameBindingsAsync(final String resourceGroupName, final String name, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteHostNameBindingsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return getSiteHostNameBindingsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the List&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsAsync(final String resourceGroupName, final String name) {
        return getSiteHostNameBindingsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteHostNameBindingsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Get web app hostname bindings.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param name Name of web app
     * @return the List&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteHostNameBindings(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = getSiteHostNameBindingsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> getSiteHostNameBindingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<HostNameBindingInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<HostNameBindingInner>> getSiteHostNameBindingsSlot(final String resourceGroupName, final String name, final String slot) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<HostNameBindingInner>> response = getSiteHostNameBindingsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        PagedList<HostNameBindingInner> pagedList = new PagedList<HostNameBindingInner>(response.getBody()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<HostNameBindingInner>>(pagedList, response.getResponse());
    }

    /**
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<HostNameBindingInner>> getSiteHostNameBindingsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteHostNameBindingsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the List&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return getSiteHostNameBindingsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Get web app hostname bindings.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param name Name of web app
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the List&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteHostNameBindingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = getSiteHostNameBindingsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> getSiteHostNameBindingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<HostNameBindingInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the HostNameBindingInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<HostNameBindingInner> getSiteHostNameBinding(String resourceGroupName, String name, String hostName) throws CloudException, IOException, IllegalArgumentException {
        return getSiteHostNameBindingAsync(resourceGroupName, name, hostName).toBlocking().single();
    }

    /**
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HostNameBindingInner> getSiteHostNameBindingAsync(String resourceGroupName, String name, String hostName, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceCall.create(getSiteHostNameBindingAsync(resourceGroupName, name, hostName), serviceCallback);
    }

    /**
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> getSiteHostNameBindingAsync(String resourceGroupName, String name, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteHostNameBinding(resourceGroupName, name, hostName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = getSiteHostNameBindingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> getSiteHostNameBindingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HostNameBindingInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param hostNameBinding Host name binding information
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the HostNameBindingInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<HostNameBindingInner> createOrUpdateSiteHostNameBinding(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding) throws CloudException, IOException, IllegalArgumentException {
        return createOrUpdateSiteHostNameBindingAsync(resourceGroupName, name, hostName, hostNameBinding).toBlocking().single();
    }

    /**
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param hostNameBinding Host name binding information
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HostNameBindingInner> createOrUpdateSiteHostNameBindingAsync(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteHostNameBindingAsync(resourceGroupName, name, hostName, hostNameBinding), serviceCallback);
    }

    /**
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param hostNameBinding Host name binding information
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> createOrUpdateSiteHostNameBindingAsync(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (hostNameBinding == null) {
            throw new IllegalArgumentException("Parameter hostNameBinding is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(hostNameBinding);
        return service.createOrUpdateSiteHostNameBinding(resourceGroupName, name, hostName, this.client.subscriptionId(), hostNameBinding, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = createOrUpdateSiteHostNameBindingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> createOrUpdateSiteHostNameBindingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HostNameBindingInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteSiteHostNameBinding(String resourceGroupName, String name, String hostName) throws CloudException, IOException, IllegalArgumentException {
        return deleteSiteHostNameBindingAsync(resourceGroupName, name, hostName).toBlocking().single();
    }

    /**
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteHostNameBindingAsync(String resourceGroupName, String name, String hostName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteHostNameBindingAsync(resourceGroupName, name, hostName), serviceCallback);
    }

    /**
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteHostNameBindingAsync(String resourceGroupName, String name, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteHostNameBinding(resourceGroupName, name, hostName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteHostNameBindingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteHostNameBindingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the HostNameBindingInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<HostNameBindingInner> getSiteHostNameBindingSlot(String resourceGroupName, String name, String slot, String hostName) throws CloudException, IOException, IllegalArgumentException {
        return getSiteHostNameBindingSlotAsync(resourceGroupName, name, slot, hostName).toBlocking().single();
    }

    /**
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HostNameBindingInner> getSiteHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceCall.create(getSiteHostNameBindingSlotAsync(resourceGroupName, name, slot, hostName), serviceCallback);
    }

    /**
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> getSiteHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteHostNameBindingSlot(resourceGroupName, name, slot, hostName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = getSiteHostNameBindingSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> getSiteHostNameBindingSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HostNameBindingInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostNameBinding Host name binding information
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the HostNameBindingInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<HostNameBindingInner> createOrUpdateSiteHostNameBindingSlot(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding) throws CloudException, IOException, IllegalArgumentException {
        return createOrUpdateSiteHostNameBindingSlotAsync(resourceGroupName, name, hostName, slot, hostNameBinding).toBlocking().single();
    }

    /**
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostNameBinding Host name binding information
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HostNameBindingInner> createOrUpdateSiteHostNameBindingSlotAsync(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteHostNameBindingSlotAsync(resourceGroupName, name, hostName, slot, hostNameBinding), serviceCallback);
    }

    /**
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostNameBinding Host name binding information
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> createOrUpdateSiteHostNameBindingSlotAsync(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (hostNameBinding == null) {
            throw new IllegalArgumentException("Parameter hostNameBinding is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(hostNameBinding);
        return service.createOrUpdateSiteHostNameBindingSlot(resourceGroupName, name, hostName, slot, this.client.subscriptionId(), hostNameBinding, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = createOrUpdateSiteHostNameBindingSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> createOrUpdateSiteHostNameBindingSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HostNameBindingInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteSiteHostNameBindingSlot(String resourceGroupName, String name, String slot, String hostName) throws CloudException, IOException, IllegalArgumentException {
        return deleteSiteHostNameBindingSlotAsync(resourceGroupName, name, slot, hostName).toBlocking().single();
    }

    /**
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteHostNameBindingSlotAsync(resourceGroupName, name, slot, hostName), serviceCallback);
    }

    /**
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteHostNameBindingSlot(resourceGroupName, name, slot, hostName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteHostNameBindingSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteHostNameBindingSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteConfigInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteConfigInner> getSiteConfig(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return getSiteConfigAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> getSiteConfigAsync(String resourceGroupName, String name, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(getSiteConfigAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> getSiteConfigAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteConfig(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = getSiteConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> getSiteConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteConfigInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteConfigInner> createOrUpdateSiteConfig(String resourceGroupName, String name, SiteConfigInner siteConfig) throws CloudException, IOException, IllegalArgumentException {
        return createOrUpdateSiteConfigAsync(resourceGroupName, name, siteConfig).toBlocking().single();
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> createOrUpdateSiteConfigAsync(String resourceGroupName, String name, SiteConfigInner siteConfig, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteConfigAsync(resourceGroupName, name, siteConfig), serviceCallback);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> createOrUpdateSiteConfigAsync(String resourceGroupName, String name, SiteConfigInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        return service.createOrUpdateSiteConfig(resourceGroupName, name, this.client.subscriptionId(), siteConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = createOrUpdateSiteConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> createOrUpdateSiteConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteConfigInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteConfigInner> updateSiteConfig(String resourceGroupName, String name, SiteConfigInner siteConfig) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteConfigAsync(resourceGroupName, name, siteConfig).toBlocking().single();
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> updateSiteConfigAsync(String resourceGroupName, String name, SiteConfigInner siteConfig, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(updateSiteConfigAsync(resourceGroupName, name, siteConfig), serviceCallback);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> updateSiteConfigAsync(String resourceGroupName, String name, SiteConfigInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        return service.updateSiteConfig(resourceGroupName, name, this.client.subscriptionId(), siteConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = updateSiteConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> updateSiteConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteConfigInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteConfigInner> getSiteConfigSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return getSiteConfigSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> getSiteConfigSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(getSiteConfigSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> getSiteConfigSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = getSiteConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> getSiteConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteConfigInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteConfigInner> createOrUpdateSiteConfigSlot(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) throws CloudException, IOException, IllegalArgumentException {
        return createOrUpdateSiteConfigSlotAsync(resourceGroupName, name, slot, siteConfig).toBlocking().single();
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> createOrUpdateSiteConfigSlotAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteConfigSlotAsync(resourceGroupName, name, slot, siteConfig), serviceCallback);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> createOrUpdateSiteConfigSlotAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        return service.createOrUpdateSiteConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = createOrUpdateSiteConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> createOrUpdateSiteConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteConfigInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteConfigInner> updateSiteConfigSlot(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteConfigSlotAsync(resourceGroupName, name, slot, siteConfig).toBlocking().single();
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> updateSiteConfigSlotAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(updateSiteConfigSlotAsync(resourceGroupName, name, slot, siteConfig), serviceCallback);
    }

    /**
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> updateSiteConfigSlotAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        return service.updateSiteConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = updateSiteConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> updateSiteConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteSourceControlInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteSourceControlInner> getSiteSourceControl(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return getSiteSourceControlAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> getSiteSourceControlAsync(String resourceGroupName, String name, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(getSiteSourceControlAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> getSiteSourceControlAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteSourceControl(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = getSiteSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> getSiteSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteSourceControlInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteSourceControlInner> createOrUpdateSiteSourceControl(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) throws CloudException, IOException, IllegalArgumentException {
        return createOrUpdateSiteSourceControlAsync(resourceGroupName, name, siteSourceControl).toBlocking().single();
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> createOrUpdateSiteSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteSourceControlAsync(resourceGroupName, name, siteSourceControl), serviceCallback);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> createOrUpdateSiteSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        return service.createOrUpdateSiteSourceControl(resourceGroupName, name, this.client.subscriptionId(), siteSourceControl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = createOrUpdateSiteSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> createOrUpdateSiteSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteSiteSourceControl(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return deleteSiteSourceControlAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteSourceControlAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteSourceControlAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteSourceControlAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteSourceControl(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteSourceControlInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteSourceControlInner> updateSiteSourceControl(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteSourceControlAsync(resourceGroupName, name, siteSourceControl).toBlocking().single();
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> updateSiteSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(updateSiteSourceControlAsync(resourceGroupName, name, siteSourceControl), serviceCallback);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> updateSiteSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        return service.updateSiteSourceControl(resourceGroupName, name, this.client.subscriptionId(), siteSourceControl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = updateSiteSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> updateSiteSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteSourceControlInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteSourceControlInner> getSiteSourceControlSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return getSiteSourceControlSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> getSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(getSiteSourceControlSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> getSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = getSiteSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> getSiteSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteSourceControlInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteSourceControlInner> createOrUpdateSiteSourceControlSlot(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) throws CloudException, IOException, IllegalArgumentException {
        return createOrUpdateSiteSourceControlSlotAsync(resourceGroupName, name, slot, siteSourceControl).toBlocking().single();
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> createOrUpdateSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteSourceControlSlotAsync(resourceGroupName, name, slot, siteSourceControl), serviceCallback);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> createOrUpdateSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        return service.createOrUpdateSiteSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteSourceControl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = createOrUpdateSiteSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> createOrUpdateSiteSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteSiteSourceControlSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return deleteSiteSourceControlSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteSourceControlSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteSourceControlInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteSourceControlInner> updateSiteSourceControlSlot(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteSourceControlSlotAsync(resourceGroupName, name, slot, siteSourceControl).toBlocking().single();
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> updateSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(updateSiteSourceControlSlotAsync(resourceGroupName, name, slot, siteSourceControl), serviceCallback);
    }

    /**
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> updateSiteSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        return service.updateSiteSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteSourceControl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = updateSiteSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> updateSiteSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the StringDictionaryInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<StringDictionaryInner> listSiteAppSettingsSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return listSiteAppSettingsSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> listSiteAppSettingsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listSiteAppSettingsSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listSiteAppSettingsSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteAppSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listSiteAppSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listSiteAppSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the StringDictionaryInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<StringDictionaryInner> listSiteAppSettings(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return listSiteAppSettingsAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> listSiteAppSettingsAsync(String resourceGroupName, String name, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listSiteAppSettingsAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listSiteAppSettingsAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteAppSettings(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listSiteAppSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listSiteAppSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param appSettings Application settings of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the StringDictionaryInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<StringDictionaryInner> updateSiteAppSettings(String resourceGroupName, String name, StringDictionaryInner appSettings) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteAppSettingsAsync(resourceGroupName, name, appSettings).toBlocking().single();
    }

    /**
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param appSettings Application settings of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> updateSiteAppSettingsAsync(String resourceGroupName, String name, StringDictionaryInner appSettings, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateSiteAppSettingsAsync(resourceGroupName, name, appSettings), serviceCallback);
    }

    /**
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param appSettings Application settings of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateSiteAppSettingsAsync(String resourceGroupName, String name, StringDictionaryInner appSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (appSettings == null) {
            throw new IllegalArgumentException("Parameter appSettings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(appSettings);
        return service.updateSiteAppSettings(resourceGroupName, name, this.client.subscriptionId(), appSettings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateSiteAppSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateSiteAppSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param appSettings Application settings of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the StringDictionaryInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<StringDictionaryInner> updateSiteAppSettingsSlot(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteAppSettingsSlotAsync(resourceGroupName, name, slot, appSettings).toBlocking().single();
    }

    /**
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param appSettings Application settings of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> updateSiteAppSettingsSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateSiteAppSettingsSlotAsync(resourceGroupName, name, slot, appSettings), serviceCallback);
    }

    /**
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param appSettings Application settings of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateSiteAppSettingsSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (appSettings == null) {
            throw new IllegalArgumentException("Parameter appSettings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(appSettings);
        return service.updateSiteAppSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), appSettings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateSiteAppSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateSiteAppSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the ConnectionStringDictionaryInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<ConnectionStringDictionaryInner> listSiteConnectionStrings(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return listSiteConnectionStringsAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ConnectionStringDictionaryInner> listSiteConnectionStringsAsync(String resourceGroupName, String name, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listSiteConnectionStringsAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> listSiteConnectionStringsAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteConnectionStrings(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = listSiteConnectionStringsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> listSiteConnectionStringsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ConnectionStringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the ConnectionStringDictionaryInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<ConnectionStringDictionaryInner> listSiteConnectionStringsSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return listSiteConnectionStringsSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ConnectionStringDictionaryInner> listSiteConnectionStringsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listSiteConnectionStringsSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> listSiteConnectionStringsSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteConnectionStringsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = listSiteConnectionStringsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> listSiteConnectionStringsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ConnectionStringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param connectionStrings Connection strings associated with web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the ConnectionStringDictionaryInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<ConnectionStringDictionaryInner> updateSiteConnectionStrings(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteConnectionStringsAsync(resourceGroupName, name, connectionStrings).toBlocking().single();
    }

    /**
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param connectionStrings Connection strings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ConnectionStringDictionaryInner> updateSiteConnectionStringsAsync(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateSiteConnectionStringsAsync(resourceGroupName, name, connectionStrings), serviceCallback);
    }

    /**
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param connectionStrings Connection strings associated with web app
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> updateSiteConnectionStringsAsync(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionStrings == null) {
            throw new IllegalArgumentException("Parameter connectionStrings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionStrings);
        return service.updateSiteConnectionStrings(resourceGroupName, name, this.client.subscriptionId(), connectionStrings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = updateSiteConnectionStringsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> updateSiteConnectionStringsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ConnectionStringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param connectionStrings Connection strings associated with web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the ConnectionStringDictionaryInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<ConnectionStringDictionaryInner> updateSiteConnectionStringsSlot(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteConnectionStringsSlotAsync(resourceGroupName, name, slot, connectionStrings).toBlocking().single();
    }

    /**
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param connectionStrings Connection strings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ConnectionStringDictionaryInner> updateSiteConnectionStringsSlotAsync(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateSiteConnectionStringsSlotAsync(resourceGroupName, name, slot, connectionStrings), serviceCallback);
    }

    /**
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param connectionStrings Connection strings associated with web app
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> updateSiteConnectionStringsSlotAsync(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionStrings == null) {
            throw new IllegalArgumentException("Parameter connectionStrings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionStrings);
        return service.updateSiteConnectionStringsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), connectionStrings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = updateSiteConnectionStringsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> updateSiteConnectionStringsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ConnectionStringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteAuthSettingsInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteAuthSettingsInner> listSiteAuthSettings(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return listSiteAuthSettingsAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteAuthSettingsInner> listSiteAuthSettingsAsync(String resourceGroupName, String name, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceCall.create(listSiteAuthSettingsAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> listSiteAuthSettingsAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteAuthSettings(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = listSiteAuthSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> listSiteAuthSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteAuthSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteAuthSettingsInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteAuthSettingsInner> listSiteAuthSettingsSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return listSiteAuthSettingsSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteAuthSettingsInner> listSiteAuthSettingsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceCall.create(listSiteAuthSettingsSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> listSiteAuthSettingsSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteAuthSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = listSiteAuthSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> listSiteAuthSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteAuthSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteAuthSettings Auth settings associated with web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteAuthSettingsInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteAuthSettingsInner> updateSiteAuthSettings(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteAuthSettingsAsync(resourceGroupName, name, siteAuthSettings).toBlocking().single();
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteAuthSettings Auth settings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteAuthSettingsInner> updateSiteAuthSettingsAsync(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceCall.create(updateSiteAuthSettingsAsync(resourceGroupName, name, siteAuthSettings), serviceCallback);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteAuthSettings Auth settings associated with web app
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> updateSiteAuthSettingsAsync(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteAuthSettings == null) {
            throw new IllegalArgumentException("Parameter siteAuthSettings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteAuthSettings);
        return service.updateSiteAuthSettings(resourceGroupName, name, this.client.subscriptionId(), siteAuthSettings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = updateSiteAuthSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> updateSiteAuthSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteAuthSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteAuthSettingsInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteAuthSettingsInner> updateSiteAuthSettingsSlot(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteAuthSettingsSlotAsync(resourceGroupName, name, slot, siteAuthSettings).toBlocking().single();
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteAuthSettingsInner> updateSiteAuthSettingsSlotAsync(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceCall.create(updateSiteAuthSettingsSlotAsync(resourceGroupName, name, slot, siteAuthSettings), serviceCallback);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> updateSiteAuthSettingsSlotAsync(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteAuthSettings == null) {
            throw new IllegalArgumentException("Parameter siteAuthSettings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteAuthSettings);
        return service.updateSiteAuthSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteAuthSettings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = updateSiteAuthSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> updateSiteAuthSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteAuthSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @throws InterruptedException exception thrown when long running operation is interrupted
     * @return the UserInner object wrapped in ServiceResponse if successful.
     */
    public ServiceResponse<UserInner> listSitePublishingCredentials(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException, InterruptedException {
        return listSitePublishingCredentialsAsync(resourceGroupName, name).toBlocking().last();
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<UserInner> listSitePublishingCredentialsAsync(String resourceGroupName, String name, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceCall.create(listSitePublishingCredentialsAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable for the request
     */
    public Observable<ServiceResponse<UserInner>> listSitePublishingCredentialsAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.listSitePublishingCredentials(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<UserInner>() { }.getType());
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the UserInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<UserInner> beginListSitePublishingCredentials(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return beginListSitePublishingCredentialsAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<UserInner> beginListSitePublishingCredentialsAsync(String resourceGroupName, String name, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceCall.create(beginListSitePublishingCredentialsAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the UserInner object
     */
    public Observable<ServiceResponse<UserInner>> beginListSitePublishingCredentialsAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginListSitePublishingCredentials(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserInner>>>() {
                @Override
                public Observable<ServiceResponse<UserInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserInner> clientResponse = beginListSitePublishingCredentialsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserInner> beginListSitePublishingCredentialsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<UserInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<UserInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @throws InterruptedException exception thrown when long running operation is interrupted
     * @return the UserInner object wrapped in ServiceResponse if successful.
     */
    public ServiceResponse<UserInner> listSitePublishingCredentialsSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException, InterruptedException {
        return listSitePublishingCredentialsSlotAsync(resourceGroupName, name, slot).toBlocking().last();
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<UserInner> listSitePublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceCall.create(listSitePublishingCredentialsSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable for the request
     */
    public Observable<ServiceResponse<UserInner>> listSitePublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.listSitePublishingCredentialsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<UserInner>() { }.getType());
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the UserInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<UserInner> beginListSitePublishingCredentialsSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return beginListSitePublishingCredentialsSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<UserInner> beginListSitePublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceCall.create(beginListSitePublishingCredentialsSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the UserInner object
     */
    public Observable<ServiceResponse<UserInner>> beginListSitePublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginListSitePublishingCredentialsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserInner>>>() {
                @Override
                public Observable<ServiceResponse<UserInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserInner> clientResponse = beginListSitePublishingCredentialsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserInner> beginListSitePublishingCredentialsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<UserInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<UserInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the StringDictionaryInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<StringDictionaryInner> listSiteMetadata(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return listSiteMetadataAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> listSiteMetadataAsync(String resourceGroupName, String name, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listSiteMetadataAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listSiteMetadataAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteMetadata(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listSiteMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listSiteMetadataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the StringDictionaryInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<StringDictionaryInner> listSiteMetadataSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return listSiteMetadataSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> listSiteMetadataSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listSiteMetadataSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listSiteMetadataSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteMetadataSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listSiteMetadataSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listSiteMetadataSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param metadata Meta data of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the StringDictionaryInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<StringDictionaryInner> updateSiteMetadata(String resourceGroupName, String name, StringDictionaryInner metadata) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteMetadataAsync(resourceGroupName, name, metadata).toBlocking().single();
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param metadata Meta data of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> updateSiteMetadataAsync(String resourceGroupName, String name, StringDictionaryInner metadata, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateSiteMetadataAsync(resourceGroupName, name, metadata), serviceCallback);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param metadata Meta data of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateSiteMetadataAsync(String resourceGroupName, String name, StringDictionaryInner metadata) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (metadata == null) {
            throw new IllegalArgumentException("Parameter metadata is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(metadata);
        return service.updateSiteMetadata(resourceGroupName, name, this.client.subscriptionId(), metadata, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateSiteMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateSiteMetadataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param metadata Meta data of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the StringDictionaryInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<StringDictionaryInner> updateSiteMetadataSlot(String resourceGroupName, String name, String slot, StringDictionaryInner metadata) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteMetadataSlotAsync(resourceGroupName, name, slot, metadata).toBlocking().single();
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param metadata Meta data of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> updateSiteMetadataSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner metadata, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateSiteMetadataSlotAsync(resourceGroupName, name, slot, metadata), serviceCallback);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param metadata Meta data of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateSiteMetadataSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner metadata) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (metadata == null) {
            throw new IllegalArgumentException("Parameter metadata is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(metadata);
        return service.updateSiteMetadataSlot(resourceGroupName, name, slot, this.client.subscriptionId(), metadata, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateSiteMetadataSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateSiteMetadataSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteLogsConfigInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteLogsConfigInner> getSiteLogsConfig(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return getSiteLogsConfigAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteLogsConfigInner> getSiteLogsConfigAsync(String resourceGroupName, String name, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceCall.create(getSiteLogsConfigAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> getSiteLogsConfigAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteLogsConfig(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = getSiteLogsConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> getSiteLogsConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteLogsConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteLogsConfig Site logs configuration
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteLogsConfigInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteLogsConfigInner> updateSiteLogsConfig(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteLogsConfigAsync(resourceGroupName, name, siteLogsConfig).toBlocking().single();
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteLogsConfig Site logs configuration
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteLogsConfigInner> updateSiteLogsConfigAsync(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceCall.create(updateSiteLogsConfigAsync(resourceGroupName, name, siteLogsConfig), serviceCallback);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteLogsConfig Site logs configuration
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> updateSiteLogsConfigAsync(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteLogsConfig == null) {
            throw new IllegalArgumentException("Parameter siteLogsConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteLogsConfig);
        return service.updateSiteLogsConfig(resourceGroupName, name, this.client.subscriptionId(), siteLogsConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = updateSiteLogsConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> updateSiteLogsConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteLogsConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteLogsConfigInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteLogsConfigInner> getSiteLogsConfigSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return getSiteLogsConfigSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteLogsConfigInner> getSiteLogsConfigSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceCall.create(getSiteLogsConfigSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> getSiteLogsConfigSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteLogsConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = getSiteLogsConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> getSiteLogsConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteLogsConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteLogsConfig Site logs configuration
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SiteLogsConfigInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SiteLogsConfigInner> updateSiteLogsConfigSlot(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteLogsConfigSlotAsync(resourceGroupName, name, slot, siteLogsConfig).toBlocking().single();
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteLogsConfig Site logs configuration
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteLogsConfigInner> updateSiteLogsConfigSlotAsync(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceCall.create(updateSiteLogsConfigSlotAsync(resourceGroupName, name, slot, siteLogsConfig), serviceCallback);
    }

    /**
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteLogsConfig Site logs configuration
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> updateSiteLogsConfigSlotAsync(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteLogsConfig == null) {
            throw new IllegalArgumentException("Parameter siteLogsConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteLogsConfig);
        return service.updateSiteLogsConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteLogsConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = updateSiteLogsConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> updateSiteLogsConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteLogsConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> listSitePremierAddOns(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return listSitePremierAddOnsAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> listSitePremierAddOnsAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(listSitePremierAddOnsAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> listSitePremierAddOnsAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSitePremierAddOns(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = listSitePremierAddOnsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> listSitePremierAddOnsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param slot the String value
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> listSitePremierAddOnsSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return listSitePremierAddOnsSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param slot the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> listSitePremierAddOnsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(listSitePremierAddOnsSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param slot the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> listSitePremierAddOnsSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSitePremierAddOnsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = listSitePremierAddOnsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> listSitePremierAddOnsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> getSitePremierAddOn(String resourceGroupName, String name, String premierAddOnName) throws CloudException, IOException, IllegalArgumentException {
        return getSitePremierAddOnAsync(resourceGroupName, name, premierAddOnName).toBlocking().single();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSitePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSitePremierAddOnAsync(resourceGroupName, name, premierAddOnName), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSitePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSitePremierAddOn(resourceGroupName, name, premierAddOnName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSitePremierAddOnDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSitePremierAddOnDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param premierAddOn the PremierAddOnRequestInner value
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> addSitePremierAddOn(String resourceGroupName, String name, String premierAddOnName, PremierAddOnRequestInner premierAddOn) throws CloudException, IOException, IllegalArgumentException {
        return addSitePremierAddOnAsync(resourceGroupName, name, premierAddOnName, premierAddOn).toBlocking().single();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param premierAddOn the PremierAddOnRequestInner value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> addSitePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, PremierAddOnRequestInner premierAddOn, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(addSitePremierAddOnAsync(resourceGroupName, name, premierAddOnName, premierAddOn), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param premierAddOn the PremierAddOnRequestInner value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> addSitePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, PremierAddOnRequestInner premierAddOn) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (premierAddOn == null) {
            throw new IllegalArgumentException("Parameter premierAddOn is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(premierAddOn);
        return service.addSitePremierAddOn(resourceGroupName, name, premierAddOnName, this.client.subscriptionId(), premierAddOn, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = addSitePremierAddOnDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> addSitePremierAddOnDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteSitePremierAddOn(String resourceGroupName, String name, String premierAddOnName) throws CloudException, IOException, IllegalArgumentException {
        return deleteSitePremierAddOnAsync(resourceGroupName, name, premierAddOnName).toBlocking().single();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSitePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSitePremierAddOnAsync(resourceGroupName, name, premierAddOnName), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSitePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSitePremierAddOn(resourceGroupName, name, premierAddOnName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSitePremierAddOnDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSitePremierAddOnDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> getSitePremierAddOnSlot(String resourceGroupName, String name, String premierAddOnName, String slot) throws CloudException, IOException, IllegalArgumentException {
        return getSitePremierAddOnSlotAsync(resourceGroupName, name, premierAddOnName, slot).toBlocking().single();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSitePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSitePremierAddOnSlotAsync(resourceGroupName, name, premierAddOnName, slot), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSitePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSitePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSitePremierAddOnSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSitePremierAddOnSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @param premierAddOn the PremierAddOnRequestInner value
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> addSitePremierAddOnSlot(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnRequestInner premierAddOn) throws CloudException, IOException, IllegalArgumentException {
        return addSitePremierAddOnSlotAsync(resourceGroupName, name, premierAddOnName, slot, premierAddOn).toBlocking().single();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @param premierAddOn the PremierAddOnRequestInner value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> addSitePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnRequestInner premierAddOn, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(addSitePremierAddOnSlotAsync(resourceGroupName, name, premierAddOnName, slot, premierAddOn), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @param premierAddOn the PremierAddOnRequestInner value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> addSitePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnRequestInner premierAddOn) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (premierAddOn == null) {
            throw new IllegalArgumentException("Parameter premierAddOn is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(premierAddOn);
        return service.addSitePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, this.client.subscriptionId(), premierAddOn, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = addSitePremierAddOnSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> addSitePremierAddOnSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteSitePremierAddOnSlot(String resourceGroupName, String name, String premierAddOnName, String slot) throws CloudException, IOException, IllegalArgumentException {
        return deleteSitePremierAddOnSlotAsync(resourceGroupName, name, premierAddOnName, slot).toBlocking().single();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSitePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSitePremierAddOnSlotAsync(resourceGroupName, name, premierAddOnName, slot), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param premierAddOnName the String value
     * @param slot the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSitePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSitePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSitePremierAddOnSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSitePremierAddOnSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the BackupRequestInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<BackupRequestInner> getSiteBackupConfiguration(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return getSiteBackupConfigurationAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupRequestInner> getSiteBackupConfigurationAsync(String resourceGroupName, String name, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceCall.create(getSiteBackupConfigurationAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> getSiteBackupConfigurationAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteBackupConfiguration(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = getSiteBackupConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> getSiteBackupConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the BackupRequestInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<BackupRequestInner> getSiteBackupConfigurationSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return getSiteBackupConfigurationSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupRequestInner> getSiteBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceCall.create(getSiteBackupConfigurationSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> getSiteBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteBackupConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = getSiteBackupConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> getSiteBackupConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the BackupRequestInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<BackupRequestInner> updateSiteBackupConfiguration(String resourceGroupName, String name, BackupRequestInner request) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteBackupConfigurationAsync(resourceGroupName, name, request).toBlocking().single();
    }

    /**
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupRequestInner> updateSiteBackupConfigurationAsync(String resourceGroupName, String name, BackupRequestInner request, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceCall.create(updateSiteBackupConfigurationAsync(resourceGroupName, name, request), serviceCallback);
    }

    /**
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> updateSiteBackupConfigurationAsync(String resourceGroupName, String name, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.updateSiteBackupConfiguration(resourceGroupName, name, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = updateSiteBackupConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> updateSiteBackupConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the BackupRequestInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<BackupRequestInner> updateSiteBackupConfigurationSlot(String resourceGroupName, String name, String slot, BackupRequestInner request) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteBackupConfigurationSlotAsync(resourceGroupName, name, slot, request).toBlocking().single();
    }

    /**
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupRequestInner> updateSiteBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceCall.create(updateSiteBackupConfigurationSlotAsync(resourceGroupName, name, slot, request), serviceCallback);
    }

    /**
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> updateSiteBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.updateSiteBackupConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = updateSiteBackupConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> updateSiteBackupConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the BackupItemInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<BackupItemInner> backupSite(String resourceGroupName, String name, BackupRequestInner request) throws CloudException, IOException, IllegalArgumentException {
        return backupSiteAsync(resourceGroupName, name, request).toBlocking().single();
    }

    /**
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> backupSiteAsync(String resourceGroupName, String name, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(backupSiteAsync(resourceGroupName, name, request), serviceCallback);
    }

    /**
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> backupSiteAsync(String resourceGroupName, String name, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.backupSite(resourceGroupName, name, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = backupSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> backupSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the BackupItemInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<BackupItemInner> backupSiteSlot(String resourceGroupName, String name, String slot, BackupRequestInner request) throws CloudException, IOException, IllegalArgumentException {
        return backupSiteSlotAsync(resourceGroupName, name, slot, request).toBlocking().single();
    }

    /**
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> backupSiteSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(backupSiteSlotAsync(resourceGroupName, name, slot, request), serviceCallback);
    }

    /**
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> backupSiteSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.backupSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = backupSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> backupSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on restore request
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the RestoreRequestInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<RestoreRequestInner> discoverSiteRestore(String resourceGroupName, String name, RestoreRequestInner request) throws CloudException, IOException, IllegalArgumentException {
        return discoverSiteRestoreAsync(resourceGroupName, name, request).toBlocking().single();
    }

    /**
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreRequestInner> discoverSiteRestoreAsync(String resourceGroupName, String name, RestoreRequestInner request, final ServiceCallback<RestoreRequestInner> serviceCallback) {
        return ServiceCall.create(discoverSiteRestoreAsync(resourceGroupName, name, request), serviceCallback);
    }

    /**
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on restore request
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<ServiceResponse<RestoreRequestInner>> discoverSiteRestoreAsync(String resourceGroupName, String name, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.discoverSiteRestore(resourceGroupName, name, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreRequestInner> clientResponse = discoverSiteRestoreDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreRequestInner> discoverSiteRestoreDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RestoreRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RestoreRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the RestoreRequestInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<RestoreRequestInner> discoverSiteRestoreSlot(String resourceGroupName, String name, String slot, RestoreRequestInner request) throws CloudException, IOException, IllegalArgumentException {
        return discoverSiteRestoreSlotAsync(resourceGroupName, name, slot, request).toBlocking().single();
    }

    /**
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreRequestInner> discoverSiteRestoreSlotAsync(String resourceGroupName, String name, String slot, RestoreRequestInner request, final ServiceCallback<RestoreRequestInner> serviceCallback) {
        return ServiceCall.create(discoverSiteRestoreSlotAsync(resourceGroupName, name, slot, request), serviceCallback);
    }

    /**
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<ServiceResponse<RestoreRequestInner>> discoverSiteRestoreSlotAsync(String resourceGroupName, String name, String slot, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.discoverSiteRestoreSlot(resourceGroupName, name, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreRequestInner> clientResponse = discoverSiteRestoreSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreRequestInner> discoverSiteRestoreSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RestoreRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RestoreRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<BackupItemInner>> listSiteBackups(final String resourceGroupName, final String name) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<BackupItemInner>> response = listSiteBackupsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        PagedList<BackupItemInner> pagedList = new PagedList<BackupItemInner>(response.getBody()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) throws RestException, IOException {
                return listSiteBackupsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<BackupItemInner>>(pagedList, response.getResponse());
    }

    /**
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<BackupItemInner>> listSiteBackupsAsync(final String resourceGroupName, final String name, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceCall.create(
            listSiteBackupsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listSiteBackupsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the List&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsAsync(final String resourceGroupName, final String name) {
        return listSiteBackupsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listSiteBackupsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Lists all available backups for web app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<BackupItemInner>> * @param name Name of web app
     * @return the List&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteBackups(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listSiteBackupsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listSiteBackupsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<BackupItemInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<BackupItemInner>> listSiteBackupsSlot(final String resourceGroupName, final String name, final String slot) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<BackupItemInner>> response = listSiteBackupsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        PagedList<BackupItemInner> pagedList = new PagedList<BackupItemInner>(response.getBody()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) throws RestException, IOException {
                return listSiteBackupsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<BackupItemInner>>(pagedList, response.getResponse());
    }

    /**
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<BackupItemInner>> listSiteBackupsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceCall.create(
            listSiteBackupsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listSiteBackupsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the List&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listSiteBackupsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listSiteBackupsSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Lists all available backups for web app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<BackupItemInner>> * @param name Name of web app
    ServiceResponse<PageImpl<BackupItemInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the List&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteBackupsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listSiteBackupsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listSiteBackupsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<BackupItemInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the BackupItemInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<BackupItemInner> getSiteBackupStatus(String resourceGroupName, String name, String backupId) throws CloudException, IOException, IllegalArgumentException {
        return getSiteBackupStatusAsync(resourceGroupName, name, backupId).toBlocking().single();
    }

    /**
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> getSiteBackupStatusAsync(String resourceGroupName, String name, String backupId, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(getSiteBackupStatusAsync(resourceGroupName, name, backupId), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> getSiteBackupStatusAsync(String resourceGroupName, String name, String backupId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteBackupStatus(resourceGroupName, name, backupId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = getSiteBackupStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> getSiteBackupStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the BackupItemInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<BackupItemInner> deleteBackup(String resourceGroupName, String name, String backupId) throws CloudException, IOException, IllegalArgumentException {
        return deleteBackupAsync(resourceGroupName, name, backupId).toBlocking().single();
    }

    /**
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> deleteBackupAsync(String resourceGroupName, String name, String backupId, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(deleteBackupAsync(resourceGroupName, name, backupId), serviceCallback);
    }

    /**
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> deleteBackupAsync(String resourceGroupName, String name, String backupId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteBackup(resourceGroupName, name, backupId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = deleteBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> deleteBackupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the BackupItemInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<BackupItemInner> getSiteBackupStatusSlot(String resourceGroupName, String name, String backupId, String slot) throws CloudException, IOException, IllegalArgumentException {
        return getSiteBackupStatusSlotAsync(resourceGroupName, name, backupId, slot).toBlocking().single();
    }

    /**
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> getSiteBackupStatusSlotAsync(String resourceGroupName, String name, String backupId, String slot, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(getSiteBackupStatusSlotAsync(resourceGroupName, name, backupId, slot), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> getSiteBackupStatusSlotAsync(String resourceGroupName, String name, String backupId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteBackupStatusSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = getSiteBackupStatusSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> getSiteBackupStatusSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the BackupItemInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<BackupItemInner> deleteBackupSlot(String resourceGroupName, String name, String backupId, String slot) throws CloudException, IOException, IllegalArgumentException {
        return deleteBackupSlotAsync(resourceGroupName, name, backupId, slot).toBlocking().single();
    }

    /**
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> deleteBackupSlotAsync(String resourceGroupName, String name, String backupId, String slot, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(deleteBackupSlotAsync(resourceGroupName, name, backupId, slot), serviceCallback);
    }

    /**
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> deleteBackupSlotAsync(String resourceGroupName, String name, String backupId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteBackupSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = deleteBackupSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> deleteBackupSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the BackupItemInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<BackupItemInner> getSiteBackupStatusSecretsSlot(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request) throws CloudException, IOException, IllegalArgumentException {
        return getSiteBackupStatusSecretsSlotAsync(resourceGroupName, name, backupId, slot, request).toBlocking().single();
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> getSiteBackupStatusSecretsSlotAsync(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(getSiteBackupStatusSecretsSlotAsync(resourceGroupName, name, backupId, slot, request), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> getSiteBackupStatusSecretsSlotAsync(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.getSiteBackupStatusSecretsSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = getSiteBackupStatusSecretsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> getSiteBackupStatusSecretsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param request Information on backup request
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the BackupItemInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<BackupItemInner> getSiteBackupStatusSecrets(String resourceGroupName, String name, String backupId, BackupRequestInner request) throws CloudException, IOException, IllegalArgumentException {
        return getSiteBackupStatusSecretsAsync(resourceGroupName, name, backupId, request).toBlocking().single();
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> getSiteBackupStatusSecretsAsync(String resourceGroupName, String name, String backupId, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(getSiteBackupStatusSecretsAsync(resourceGroupName, name, backupId, request), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> getSiteBackupStatusSecretsAsync(String resourceGroupName, String name, String backupId, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.getSiteBackupStatusSecrets(resourceGroupName, name, backupId, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = getSiteBackupStatusSecretsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> getSiteBackupStatusSecretsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @throws InterruptedException exception thrown when long running operation is interrupted
     * @return the RestoreResponseInner object wrapped in ServiceResponse if successful.
     */
    public ServiceResponse<RestoreResponseInner> restoreSite(String resourceGroupName, String name, String backupId, RestoreRequestInner request) throws CloudException, IOException, IllegalArgumentException, InterruptedException {
        return restoreSiteAsync(resourceGroupName, name, backupId, request).toBlocking().last();
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreResponseInner> restoreSiteAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceCall.create(restoreSiteAsync(resourceGroupName, name, backupId, request), serviceCallback);
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @return the observable for the request
     */
    public Observable<ServiceResponse<RestoreResponseInner>> restoreSiteAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        Observable<Response<ResponseBody>> observable = service.restoreSite(resourceGroupName, name, backupId, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<RestoreResponseInner>() { }.getType());
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the RestoreResponseInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<RestoreResponseInner> beginRestoreSite(String resourceGroupName, String name, String backupId, RestoreRequestInner request) throws CloudException, IOException, IllegalArgumentException {
        return beginRestoreSiteAsync(resourceGroupName, name, backupId, request).toBlocking().single();
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreResponseInner> beginRestoreSiteAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceCall.create(beginRestoreSiteAsync(resourceGroupName, name, backupId, request), serviceCallback);
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<ServiceResponse<RestoreResponseInner>> beginRestoreSiteAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.beginRestoreSite(resourceGroupName, name, backupId, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreResponseInner> clientResponse = beginRestoreSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreResponseInner> beginRestoreSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RestoreResponseInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RestoreResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @throws InterruptedException exception thrown when long running operation is interrupted
     * @return the RestoreResponseInner object wrapped in ServiceResponse if successful.
     */
    public ServiceResponse<RestoreResponseInner> restoreSiteSlot(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) throws CloudException, IOException, IllegalArgumentException, InterruptedException {
        return restoreSiteSlotAsync(resourceGroupName, name, backupId, slot, request).toBlocking().last();
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreResponseInner> restoreSiteSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceCall.create(restoreSiteSlotAsync(resourceGroupName, name, backupId, slot, request), serviceCallback);
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the observable for the request
     */
    public Observable<ServiceResponse<RestoreResponseInner>> restoreSiteSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        Observable<Response<ResponseBody>> observable = service.restoreSiteSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<RestoreResponseInner>() { }.getType());
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the RestoreResponseInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<RestoreResponseInner> beginRestoreSiteSlot(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) throws CloudException, IOException, IllegalArgumentException {
        return beginRestoreSiteSlotAsync(resourceGroupName, name, backupId, slot, request).toBlocking().single();
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreResponseInner> beginRestoreSiteSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceCall.create(beginRestoreSiteSlotAsync(resourceGroupName, name, backupId, slot, request), serviceCallback);
    }

    /**
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<ServiceResponse<RestoreResponseInner>> beginRestoreSiteSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.beginRestoreSiteSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreResponseInner> clientResponse = beginRestoreSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreResponseInner> beginRestoreSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RestoreResponseInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RestoreResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CsmUsageQuotaInner>> getSiteUsages(final String resourceGroupName, final String name) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = getSiteUsagesSinglePageAsync(resourceGroupName, name).toBlocking().single();
        PagedList<CsmUsageQuotaInner> pagedList = new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteUsagesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<CsmUsageQuotaInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> getSiteUsagesAsync(final String resourceGroupName, final String name, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteUsagesSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return getSiteUsagesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the List&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesAsync(final String resourceGroupName, final String name) {
        return getSiteUsagesSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteUsagesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the List&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        return service.getSiteUsages(resourceGroupName, name, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = getSiteUsagesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CsmUsageQuotaInner>> getSiteUsages(final String resourceGroupName, final String name, final String filter) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = getSiteUsagesSinglePageAsync(resourceGroupName, name, filter).toBlocking().single();
        PagedList<CsmUsageQuotaInner> pagedList = new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteUsagesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<CsmUsageQuotaInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> getSiteUsagesAsync(final String resourceGroupName, final String name, final String filter, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteUsagesSinglePageAsync(resourceGroupName, name, filter),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return getSiteUsagesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the List&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesAsync(final String resourceGroupName, final String name, final String filter) {
        return getSiteUsagesSinglePageAsync(resourceGroupName, name, filter)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteUsagesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param name Name of web app
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the List&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSinglePageAsync(final String resourceGroupName, final String name, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteUsages(resourceGroupName, name, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = getSiteUsagesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> getSiteUsagesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CsmUsageQuotaInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CsmUsageQuotaInner>> getSiteUsagesSlot(final String resourceGroupName, final String name, final String slot) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = getSiteUsagesSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        PagedList<CsmUsageQuotaInner> pagedList = new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<CsmUsageQuotaInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> getSiteUsagesSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteUsagesSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return getSiteUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the List&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return getSiteUsagesSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the List&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        return service.getSiteUsagesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = getSiteUsagesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CsmUsageQuotaInner>> getSiteUsagesSlot(final String resourceGroupName, final String name, final String slot, final String filter) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = getSiteUsagesSlotSinglePageAsync(resourceGroupName, name, slot, filter).toBlocking().single();
        PagedList<CsmUsageQuotaInner> pagedList = new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<CsmUsageQuotaInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> getSiteUsagesSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteUsagesSlotSinglePageAsync(resourceGroupName, name, slot, filter),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return getSiteUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the List&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        return getSiteUsagesSlotSinglePageAsync(resourceGroupName, name, slot, filter)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param name Name of web app
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the List&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteUsagesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = getSiteUsagesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> getSiteUsagesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CsmUsageQuotaInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<ResourceMetricInner>> getSiteMetrics(final String resourceGroupName, final String name) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<ResourceMetricInner>> response = getSiteMetricsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        PagedList<ResourceMetricInner> pagedList = new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<ResourceMetricInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> getSiteMetricsAsync(final String resourceGroupName, final String name, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return getSiteMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the List&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsAsync(final String resourceGroupName, final String name) {
        return getSiteMetricsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteMetricsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the List&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean details = null;
        final String filter = null;
        return service.getSiteMetrics(resourceGroupName, name, this.client.subscriptionId(), details, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = getSiteMetricsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<ResourceMetricInner>> getSiteMetrics(final String resourceGroupName, final String name, final Boolean details, final String filter) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<ResourceMetricInner>> response = getSiteMetricsSinglePageAsync(resourceGroupName, name, details, filter).toBlocking().single();
        PagedList<ResourceMetricInner> pagedList = new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<ResourceMetricInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> getSiteMetricsAsync(final String resourceGroupName, final String name, final Boolean details, final String filter, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricsSinglePageAsync(resourceGroupName, name, details, filter),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return getSiteMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the List&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        return getSiteMetricsSinglePageAsync(resourceGroupName, name, details, filter)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteMetricsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param name Name of web app
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param details If true, metric details are included in response
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the List&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSinglePageAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteMetrics(resourceGroupName, name, this.client.subscriptionId(), details, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = getSiteMetricsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> getSiteMetricsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<ResourceMetricInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<ResourceMetricInner>> getSiteMetricsSlot(final String resourceGroupName, final String name, final String slot) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<ResourceMetricInner>> response = getSiteMetricsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        PagedList<ResourceMetricInner> pagedList = new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<ResourceMetricInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> getSiteMetricsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return getSiteMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the List&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return getSiteMetricsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the List&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean details = null;
        final String filter = null;
        return service.getSiteMetricsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), details, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = getSiteMetricsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<ResourceMetricInner>> getSiteMetricsSlot(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<ResourceMetricInner>> response = getSiteMetricsSlotSinglePageAsync(resourceGroupName, name, slot, details, filter).toBlocking().single();
        PagedList<ResourceMetricInner> pagedList = new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<ResourceMetricInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> getSiteMetricsSlotAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricsSlotSinglePageAsync(resourceGroupName, name, slot, details, filter),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return getSiteMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the List&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSlotAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        return getSiteMetricsSlotSinglePageAsync(resourceGroupName, name, slot, details, filter)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param name Name of web app
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param details If true, metric details are included in response
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the List&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteMetricsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), details, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = getSiteMetricsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> getSiteMetricsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<ResourceMetricInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<MetricDefinitionInner>> getSiteMetricDefinitionsSlot(final String resourceGroupName, final String name, final String slot) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<MetricDefinitionInner>> response = getSiteMetricDefinitionsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        PagedList<MetricDefinitionInner> pagedList = new PagedList<MetricDefinitionInner>(response.getBody()) {
            @Override
            public Page<MetricDefinitionInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<MetricDefinitionInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<MetricDefinitionInner>> getSiteMetricDefinitionsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<MetricDefinitionInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricDefinitionsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(String nextPageLink) {
                    return getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the List&lt;MetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return getSiteMetricDefinitionsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(ServiceResponse<Page<MetricDefinitionInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     *
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param name Name of web app
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the List&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteMetricDefinitionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricDefinitionInner>> result = getSiteMetricDefinitionsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricDefinitionInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricDefinitionInner>> getSiteMetricDefinitionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<MetricDefinitionInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<MetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<MetricDefinitionInner>> getSiteMetricDefinitions(final String resourceGroupName, final String name) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<MetricDefinitionInner>> response = getSiteMetricDefinitionsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        PagedList<MetricDefinitionInner> pagedList = new PagedList<MetricDefinitionInner>(response.getBody()) {
            @Override
            public Page<MetricDefinitionInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<MetricDefinitionInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<MetricDefinitionInner>> getSiteMetricDefinitionsAsync(final String resourceGroupName, final String name, final ListOperationCallback<MetricDefinitionInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricDefinitionsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(String nextPageLink) {
                    return getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the List&lt;MetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsAsync(final String resourceGroupName, final String name) {
        return getSiteMetricDefinitionsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(ServiceResponse<Page<MetricDefinitionInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     *
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param name Name of web app
     * @return the List&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteMetricDefinitions(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricDefinitionInner>> result = getSiteMetricDefinitionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricDefinitionInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricDefinitionInner>> getSiteMetricDefinitionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<MetricDefinitionInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<MetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the InputStream object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<InputStream> listSitePublishingProfileXml(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return listSitePublishingProfileXmlAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<InputStream> listSitePublishingProfileXmlAsync(String resourceGroupName, String name, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceCall.create(listSitePublishingProfileXmlAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listSitePublishingProfileXmlAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String format = null;
        CsmPublishingProfileOptions options = new CsmPublishingProfileOptions();
        options.withFormat(null);
        return service.listSitePublishingProfileXml(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), options, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listSitePublishingProfileXmlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the InputStream object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<InputStream> listSitePublishingProfileXml(String resourceGroupName, String name, String format) throws CloudException, IOException, IllegalArgumentException {
        return listSitePublishingProfileXmlAsync(resourceGroupName, name, format).toBlocking().single();
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<InputStream> listSitePublishingProfileXmlAsync(String resourceGroupName, String name, String format, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceCall.create(listSitePublishingProfileXmlAsync(resourceGroupName, name, format), serviceCallback);
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listSitePublishingProfileXmlAsync(String resourceGroupName, String name, String format) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        CsmPublishingProfileOptions options = new CsmPublishingProfileOptions();
        options.withFormat(format);
        return service.listSitePublishingProfileXml(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), options, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listSitePublishingProfileXmlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> listSitePublishingProfileXmlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<InputStream, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the InputStream object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<InputStream> listSitePublishingProfileXmlSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return listSitePublishingProfileXmlSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<InputStream> listSitePublishingProfileXmlSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceCall.create(listSitePublishingProfileXmlSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listSitePublishingProfileXmlSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String format = null;
        CsmPublishingProfileOptions options = new CsmPublishingProfileOptions();
        options.withFormat(null);
        return service.listSitePublishingProfileXmlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), options, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listSitePublishingProfileXmlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the InputStream object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<InputStream> listSitePublishingProfileXmlSlot(String resourceGroupName, String name, String slot, String format) throws CloudException, IOException, IllegalArgumentException {
        return listSitePublishingProfileXmlSlotAsync(resourceGroupName, name, slot, format).toBlocking().single();
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<InputStream> listSitePublishingProfileXmlSlotAsync(String resourceGroupName, String name, String slot, String format, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceCall.create(listSitePublishingProfileXmlSlotAsync(resourceGroupName, name, slot, format), serviceCallback);
    }

    /**
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listSitePublishingProfileXmlSlotAsync(String resourceGroupName, String name, String slot, String format) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        CsmPublishingProfileOptions options = new CsmPublishingProfileOptions();
        options.withFormat(format);
        return service.listSitePublishingProfileXmlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), options, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listSitePublishingProfileXmlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> listSitePublishingProfileXmlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<InputStream, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> restartSiteSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return restartSiteSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> restartSiteSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(restartSiteSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> restartSiteSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean softRestart = null;
        final Boolean synchronous = null;
        return service.restartSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), softRestart, synchronous, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = restartSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> restartSiteSlot(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous) throws CloudException, IOException, IllegalArgumentException {
        return restartSiteSlotAsync(resourceGroupName, name, slot, softRestart, synchronous).toBlocking().single();
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> restartSiteSlotAsync(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(restartSiteSlotAsync(resourceGroupName, name, slot, softRestart, synchronous), serviceCallback);
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> restartSiteSlotAsync(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.restartSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), softRestart, synchronous, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = restartSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> restartSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> restartSite(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return restartSiteAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> restartSiteAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(restartSiteAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> restartSiteAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean softRestart = null;
        final Boolean synchronous = null;
        return service.restartSite(resourceGroupName, name, this.client.subscriptionId(), softRestart, synchronous, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = restartSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> restartSite(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous) throws CloudException, IOException, IllegalArgumentException {
        return restartSiteAsync(resourceGroupName, name, softRestart, synchronous).toBlocking().single();
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> restartSiteAsync(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(restartSiteAsync(resourceGroupName, name, softRestart, synchronous), serviceCallback);
    }

    /**
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> restartSiteAsync(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.restartSite(resourceGroupName, name, this.client.subscriptionId(), softRestart, synchronous, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = restartSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> restartSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> startSite(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return startSiteAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> startSiteAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(startSiteAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> startSiteAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.startSite(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = startSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> startSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> startSiteSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return startSiteSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> startSiteSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(startSiteSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> startSiteSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.startSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = startSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> startSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> stopSite(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return stopSiteAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> stopSiteAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(stopSiteAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> stopSiteAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.stopSite(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = stopSiteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> stopSiteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> stopSiteSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return stopSiteSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> stopSiteSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(stopSiteSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> stopSiteSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.stopSiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = stopSiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> stopSiteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> syncSiteRepository(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return syncSiteRepositoryAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> syncSiteRepositoryAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(syncSiteRepositoryAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> syncSiteRepositoryAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.syncSiteRepository(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = syncSiteRepositoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> syncSiteRepositoryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param slot the String value
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> syncSiteRepositorySlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return syncSiteRepositorySlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param slot the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> syncSiteRepositorySlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(syncSiteRepositorySlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     *
     * @param resourceGroupName the String value
     * @param name the String value
     * @param slot the String value
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> syncSiteRepositorySlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.syncSiteRepositorySlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = syncSiteRepositorySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> syncSiteRepositorySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> generateNewSitePublishingPasswordSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return generateNewSitePublishingPasswordSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> generateNewSitePublishingPasswordSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(generateNewSitePublishingPasswordSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> generateNewSitePublishingPasswordSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = generateNewSitePublishingPasswordSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> generateNewSitePublishingPasswordSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> generateNewSitePublishingPassword(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return generateNewSitePublishingPasswordAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> generateNewSitePublishingPasswordAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(generateNewSitePublishingPasswordAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> generateNewSitePublishingPasswordAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.generateNewSitePublishingPassword(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = generateNewSitePublishingPasswordDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> generateNewSitePublishingPasswordDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the RelayServiceConnectionEntityInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<RelayServiceConnectionEntityInner> getSiteRelayServiceConnection(String resourceGroupName, String name, String entityName) throws CloudException, IOException, IllegalArgumentException {
        return getSiteRelayServiceConnectionAsync(resourceGroupName, name, entityName).toBlocking().single();
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> getSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(getSiteRelayServiceConnectionAsync(resourceGroupName, name, entityName), serviceCallback);
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> getSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = getSiteRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> getSiteRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the RelayServiceConnectionEntityInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<RelayServiceConnectionEntityInner> createOrUpdateSiteRelayServiceConnection(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) throws CloudException, IOException, IllegalArgumentException {
        return createOrUpdateSiteRelayServiceConnectionAsync(resourceGroupName, name, entityName, connectionEnvelope).toBlocking().single();
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> createOrUpdateSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteRelayServiceConnectionAsync(resourceGroupName, name, entityName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> createOrUpdateSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateSiteRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = createOrUpdateSiteRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> createOrUpdateSiteRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteSiteRelayServiceConnection(String resourceGroupName, String name, String entityName) throws CloudException, IOException, IllegalArgumentException {
        return deleteSiteRelayServiceConnectionAsync(resourceGroupName, name, entityName).toBlocking().single();
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteRelayServiceConnectionAsync(resourceGroupName, name, entityName), serviceCallback);
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the RelayServiceConnectionEntityInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<RelayServiceConnectionEntityInner> updateSiteRelayServiceConnection(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteRelayServiceConnectionAsync(resourceGroupName, name, entityName, connectionEnvelope).toBlocking().single();
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> updateSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(updateSiteRelayServiceConnectionAsync(resourceGroupName, name, entityName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> updateSiteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateSiteRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = updateSiteRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> updateSiteRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the RelayServiceConnectionEntityInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<RelayServiceConnectionEntityInner> getSiteRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot) throws CloudException, IOException, IllegalArgumentException {
        return getSiteRelayServiceConnectionSlotAsync(resourceGroupName, name, entityName, slot).toBlocking().single();
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> getSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(getSiteRelayServiceConnectionSlotAsync(resourceGroupName, name, entityName, slot), serviceCallback);
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> getSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = getSiteRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> getSiteRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the RelayServiceConnectionEntityInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<RelayServiceConnectionEntityInner> createOrUpdateSiteRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) throws CloudException, IOException, IllegalArgumentException {
        return createOrUpdateSiteRelayServiceConnectionSlotAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).toBlocking().single();
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> createOrUpdateSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteRelayServiceConnectionSlotAsync(resourceGroupName, name, entityName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> createOrUpdateSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateSiteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = createOrUpdateSiteRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> createOrUpdateSiteRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> deleteSiteRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot) throws CloudException, IOException, IllegalArgumentException {
        return deleteSiteRelayServiceConnectionSlotAsync(resourceGroupName, name, entityName, slot).toBlocking().single();
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSiteRelayServiceConnectionSlotAsync(resourceGroupName, name, entityName, slot), serviceCallback);
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSiteRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSiteRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the RelayServiceConnectionEntityInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<RelayServiceConnectionEntityInner> updateSiteRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteRelayServiceConnectionSlotAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).toBlocking().single();
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> updateSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(updateSiteRelayServiceConnectionSlotAsync(resourceGroupName, name, entityName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> updateSiteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateSiteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = updateSiteRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> updateSiteRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the RelayServiceConnectionEntityInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<RelayServiceConnectionEntityInner> listSiteRelayServiceConnectionsSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return listSiteRelayServiceConnectionsSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> listSiteRelayServiceConnectionsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(listSiteRelayServiceConnectionsSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> listSiteRelayServiceConnectionsSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteRelayServiceConnectionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = listSiteRelayServiceConnectionsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> listSiteRelayServiceConnectionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the RelayServiceConnectionEntityInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<RelayServiceConnectionEntityInner> listSiteRelayServiceConnections(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return listSiteRelayServiceConnectionsAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> listSiteRelayServiceConnectionsAsync(String resourceGroupName, String name, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(listSiteRelayServiceConnectionsAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> listSiteRelayServiceConnectionsAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteRelayServiceConnections(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = listSiteRelayServiceConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> listSiteRelayServiceConnectionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> getSiteVnetGatewaySlot(String resourceGroupName, String name, String vnetName, String gatewayName, String slot) throws CloudException, IOException, IllegalArgumentException {
        return getSiteVnetGatewaySlotAsync(resourceGroupName, name, vnetName, gatewayName, slot).toBlocking().single();
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSiteVnetGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSiteVnetGatewaySlotAsync(resourceGroupName, name, vnetName, gatewayName, slot), serviceCallback);
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSiteVnetGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteVnetGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSiteVnetGatewaySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSiteVnetGatewaySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the VnetGatewayInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<VnetGatewayInner> createOrUpdateSiteVNETConnectionGatewaySlot(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) throws CloudException, IOException, IllegalArgumentException {
        return createOrUpdateSiteVNETConnectionGatewaySlotAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).toBlocking().single();
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetGatewayInner> createOrUpdateSiteVNETConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteVNETConnectionGatewaySlotAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> createOrUpdateSiteVNETConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateSiteVNETConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = createOrUpdateSiteVNETConnectionGatewaySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> createOrUpdateSiteVNETConnectionGatewaySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetGatewayInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the VnetGatewayInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<VnetGatewayInner> updateSiteVNETConnectionGatewaySlot(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteVNETConnectionGatewaySlotAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).toBlocking().single();
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetGatewayInner> updateSiteVNETConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceCall.create(updateSiteVNETConnectionGatewaySlotAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> updateSiteVNETConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateSiteVNETConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = updateSiteVNETConnectionGatewaySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> updateSiteVNETConnectionGatewaySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetGatewayInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<Object> getSiteVnetGateway(String resourceGroupName, String name, String vnetName, String gatewayName) throws CloudException, IOException, IllegalArgumentException {
        return getSiteVnetGatewayAsync(resourceGroupName, name, vnetName, gatewayName).toBlocking().single();
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getSiteVnetGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getSiteVnetGatewayAsync(resourceGroupName, name, vnetName, gatewayName), serviceCallback);
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSiteVnetGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteVnetGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSiteVnetGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSiteVnetGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the VnetGatewayInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<VnetGatewayInner> createOrUpdateSiteVNETConnectionGateway(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) throws CloudException, IOException, IllegalArgumentException {
        return createOrUpdateSiteVNETConnectionGatewayAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).toBlocking().single();
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetGatewayInner> createOrUpdateSiteVNETConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSiteVNETConnectionGatewayAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> createOrUpdateSiteVNETConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateSiteVNETConnectionGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = createOrUpdateSiteVNETConnectionGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> createOrUpdateSiteVNETConnectionGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetGatewayInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the VnetGatewayInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<VnetGatewayInner> updateSiteVNETConnectionGateway(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) throws CloudException, IOException, IllegalArgumentException {
        return updateSiteVNETConnectionGatewayAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).toBlocking().single();
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetGatewayInner> updateSiteVNETConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceCall.create(updateSiteVNETConnectionGatewayAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> updateSiteVNETConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateSiteVNETConnectionGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = updateSiteVNETConnectionGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> updateSiteVNETConnectionGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetGatewayInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;VnetInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<VnetInfoInner>> getSiteVNETConnections(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return getSiteVNETConnectionsAsync(resourceGroupName, name).toBlocking().single();
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<VnetInfoInner>> getSiteVNETConnectionsAsync(String resourceGroupName, String name, final ServiceCallback<List<VnetInfoInner>> serviceCallback) {
        return ServiceCall.create(getSiteVNETConnectionsAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<VnetInfoInner>>> getSiteVNETConnectionsAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteVNETConnections(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<VnetInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<VnetInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<VnetInfoInner>> clientResponse = getSiteVNETConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<VnetInfoInner>> getSiteVNETConnectionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<List<VnetInfoInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<VnetInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;VnetInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<VnetInfoInner>> getSiteVNETConnectionsSlot(String resourceGroupName, String name, String slot) throws CloudException, IOException, IllegalArgumentException {
        return getSiteVNETConnectionsSlotAsync(resourceGroupName, name, slot).toBlocking().single();
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<VnetInfoInner>> getSiteVNETConnectionsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<List<VnetInfoInner>> serviceCallback) {
        return ServiceCall.create(getSiteVNETConnectionsSlotAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<VnetInfoInner>>> getSiteVNETConnectionsSlotAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteVNETConnectionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<VnetInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<VnetInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<VnetInfoInner>> clientResponse = getSiteVNETConnectionsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<VnetInfoInner>> getSiteVNETConnectionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<List<VnetInfoInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<VnetInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SlotDifferenceInner>> getSlotsDifferencesFromProductionNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<SlotDifferenceInner>> response = getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<SlotDifferenceInner> pagedList = new PagedList<SlotDifferenceInner>(response.getBody()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<SlotDifferenceInner>>(pagedList, response.getResponse());
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SlotDifferenceInner>> getSlotsDifferencesFromProductionNextAsync(final String nextPageLink, final ServiceCall<List<SlotDifferenceInner>> serviceCall, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesFromProductionNextAsync(final String nextPageLink) {
        return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesFromProductionNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSlotsDifferencesFromProductionNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = getSlotsDifferencesFromProductionNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> getSlotsDifferencesFromProductionNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SlotDifferenceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SlotDifferenceInner>> getSlotsDifferencesSlotNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<SlotDifferenceInner>> response = getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<SlotDifferenceInner> pagedList = new PagedList<SlotDifferenceInner>(response.getBody()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<SlotDifferenceInner>>(pagedList, response.getResponse());
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SlotDifferenceInner>> getSlotsDifferencesSlotNextAsync(final String nextPageLink, final ServiceCall<List<SlotDifferenceInner>> serviceCall, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesSlotNextAsync(final String nextPageLink) {
        return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSlotsDifferencesSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = getSlotsDifferencesSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> getSlotsDifferencesSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SlotDifferenceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SiteInner>> getSiteSlotsNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<SiteInner>> response = getSiteSlotsNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<SiteInner> pagedList = new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteSlotsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<SiteInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> getSiteSlotsNextAsync(final String nextPageLink, final ServiceCall<List<SiteInner>> serviceCall, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteSlotsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return getSiteSlotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all the slots for a web apps.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSiteSlotsNextAsync(final String nextPageLink) {
        return getSiteSlotsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteSlotsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSiteSlotsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteSlotsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = getSiteSlotsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> getSiteSlotsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SiteInner>> getSitesNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<SiteInner>> response = getSitesNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<SiteInner> pagedList = new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSitesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<SiteInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> getSitesNextAsync(final String nextPageLink, final ServiceCall<List<SiteInner>> serviceCall, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getSitesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return getSitesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSitesNextAsync(final String nextPageLink) {
        return getSitesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSitesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> getSitesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSitesNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = getSitesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> getSitesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;DeletedSiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<DeletedSiteInner>> getDeletedSitesNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<DeletedSiteInner>> response = getDeletedSitesNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<DeletedSiteInner> pagedList = new PagedList<DeletedSiteInner>(response.getBody()) {
            @Override
            public Page<DeletedSiteInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getDeletedSitesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<DeletedSiteInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeletedSiteInner>> getDeletedSitesNextAsync(final String nextPageLink, final ServiceCall<List<DeletedSiteInner>> serviceCall, final ListOperationCallback<DeletedSiteInner> serviceCallback) {
        return AzureServiceCall.create(
            getDeletedSitesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(String nextPageLink) {
                    return getDeletedSitesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets deleted web apps in subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;DeletedSiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> getDeletedSitesNextAsync(final String nextPageLink) {
        return getDeletedSitesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeletedSiteInner>>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(ServiceResponse<Page<DeletedSiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getDeletedSitesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     *
    ServiceResponse<PageImpl<DeletedSiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;DeletedSiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> getDeletedSitesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getDeletedSitesNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeletedSiteInner>> result = getDeletedSitesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeletedSiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeletedSiteInner>> getDeletedSitesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeletedSiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeletedSiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<DeploymentInner>> getDeploymentsNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<DeploymentInner>> response = getDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<DeploymentInner> pagedList = new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<DeploymentInner>>(pagedList, response.getResponse());
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getDeploymentsNextAsync(final String nextPageLink, final ServiceCall<List<DeploymentInner>> serviceCall, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getDeploymentsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsNextAsync(final String nextPageLink) {
        return getDeploymentsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getDeploymentsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getDeploymentsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getDeploymentsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getDeploymentsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<DeploymentInner>> getDeploymentsSlotNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<DeploymentInner>> response = getDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<DeploymentInner> pagedList = new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<DeploymentInner>>(pagedList, response.getResponse());
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getDeploymentsSlotNextAsync(final String nextPageLink, final ServiceCall<List<DeploymentInner>> serviceCall, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getDeploymentsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsSlotNextAsync(final String nextPageLink) {
        return getDeploymentsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getDeploymentsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getDeploymentsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getDeploymentsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getDeploymentsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<DeploymentInner>> getInstanceDeploymentsNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<DeploymentInner>> response = getInstanceDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<DeploymentInner> pagedList = new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getInstanceDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<DeploymentInner>>(pagedList, response.getResponse());
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getInstanceDeploymentsNextAsync(final String nextPageLink, final ServiceCall<List<DeploymentInner>> serviceCall, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getInstanceDeploymentsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getInstanceDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsNextAsync(final String nextPageLink) {
        return getInstanceDeploymentsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getInstanceDeploymentsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getInstanceDeploymentsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getInstanceDeploymentsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getInstanceDeploymentsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<DeploymentInner>> getInstanceDeploymentsSlotNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<DeploymentInner>> response = getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<DeploymentInner> pagedList = new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<DeploymentInner>>(pagedList, response.getResponse());
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> getInstanceDeploymentsSlotNextAsync(final String nextPageLink, final ServiceCall<List<DeploymentInner>> serviceCall, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsSlotNextAsync(final String nextPageLink) {
        return getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> getInstanceDeploymentsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getInstanceDeploymentsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = getInstanceDeploymentsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> getInstanceDeploymentsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SiteInstanceInner>> getSiteInstanceIdentifiersNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<SiteInstanceInner>> response = getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<SiteInstanceInner> pagedList = new PagedList<SiteInstanceInner>(response.getBody()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<SiteInstanceInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInstanceInner>> getSiteInstanceIdentifiersNextAsync(final String nextPageLink, final ServiceCall<List<SiteInstanceInner>> serviceCall, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersNextAsync(final String nextPageLink) {
        return getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteInstanceIdentifiersNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets all instance of a web app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteInstanceIdentifiersNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = getSiteInstanceIdentifiersNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> getSiteInstanceIdentifiersNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInstanceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SiteInstanceInner>> getSiteInstanceIdentifiersSlotNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<SiteInstanceInner>> response = getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<SiteInstanceInner> pagedList = new PagedList<SiteInstanceInner>(response.getBody()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<SiteInstanceInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInstanceInner>> getSiteInstanceIdentifiersSlotNextAsync(final String nextPageLink, final ServiceCall<List<SiteInstanceInner>> serviceCall, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersSlotNextAsync(final String nextPageLink) {
        return getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets all instance of a web app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> getSiteInstanceIdentifiersSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteInstanceIdentifiersSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = getSiteInstanceIdentifiersSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> getSiteInstanceIdentifiersSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInstanceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<HostNameBindingInner>> getSiteHostNameBindingsNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<HostNameBindingInner>> response = getSiteHostNameBindingsNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<HostNameBindingInner> pagedList = new PagedList<HostNameBindingInner>(response.getBody()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteHostNameBindingsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<HostNameBindingInner>>(pagedList, response.getResponse());
    }

    /**
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<HostNameBindingInner>> getSiteHostNameBindingsNextAsync(final String nextPageLink, final ServiceCall<List<HostNameBindingInner>> serviceCall, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteHostNameBindingsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return getSiteHostNameBindingsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsNextAsync(final String nextPageLink) {
        return getSiteHostNameBindingsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteHostNameBindingsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Get web app hostname bindings.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteHostNameBindingsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = getSiteHostNameBindingsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> getSiteHostNameBindingsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<HostNameBindingInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<HostNameBindingInner>> getSiteHostNameBindingsSlotNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<HostNameBindingInner>> response = getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<HostNameBindingInner> pagedList = new PagedList<HostNameBindingInner>(response.getBody()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<HostNameBindingInner>>(pagedList, response.getResponse());
    }

    /**
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<HostNameBindingInner>> getSiteHostNameBindingsSlotNextAsync(final String nextPageLink, final ServiceCall<List<HostNameBindingInner>> serviceCall, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsSlotNextAsync(final String nextPageLink) {
        return getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteHostNameBindingsSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Get web app hostname bindings.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> getSiteHostNameBindingsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteHostNameBindingsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = getSiteHostNameBindingsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> getSiteHostNameBindingsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<HostNameBindingInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<BackupItemInner>> listSiteBackupsNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<BackupItemInner>> response = listSiteBackupsNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<BackupItemInner> pagedList = new PagedList<BackupItemInner>(response.getBody()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) throws RestException, IOException {
                return listSiteBackupsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<BackupItemInner>>(pagedList, response.getResponse());
    }

    /**
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<BackupItemInner>> listSiteBackupsNextAsync(final String nextPageLink, final ServiceCall<List<BackupItemInner>> serviceCall, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceCall.create(
            listSiteBackupsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listSiteBackupsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsNextAsync(final String nextPageLink) {
        return listSiteBackupsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listSiteBackupsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Lists all available backups for web app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listSiteBackupsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listSiteBackupsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listSiteBackupsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<BackupItemInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<BackupItemInner>> listSiteBackupsSlotNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<BackupItemInner>> response = listSiteBackupsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<BackupItemInner> pagedList = new PagedList<BackupItemInner>(response.getBody()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) throws RestException, IOException {
                return listSiteBackupsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<BackupItemInner>>(pagedList, response.getResponse());
    }

    /**
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<BackupItemInner>> listSiteBackupsSlotNextAsync(final String nextPageLink, final ServiceCall<List<BackupItemInner>> serviceCall, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceCall.create(
            listSiteBackupsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listSiteBackupsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsSlotNextAsync(final String nextPageLink) {
        return listSiteBackupsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return listSiteBackupsSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Lists all available backups for web app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listSiteBackupsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listSiteBackupsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listSiteBackupsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listSiteBackupsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<BackupItemInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CsmUsageQuotaInner>> getSiteUsagesNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = getSiteUsagesNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<CsmUsageQuotaInner> pagedList = new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteUsagesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<CsmUsageQuotaInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> getSiteUsagesNextAsync(final String nextPageLink, final ServiceCall<List<CsmUsageQuotaInner>> serviceCall, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteUsagesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return getSiteUsagesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesNextAsync(final String nextPageLink) {
        return getSiteUsagesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteUsagesNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteUsagesNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = getSiteUsagesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> getSiteUsagesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CsmUsageQuotaInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CsmUsageQuotaInner>> getSiteUsagesSlotNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = getSiteUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<CsmUsageQuotaInner> pagedList = new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<CsmUsageQuotaInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> getSiteUsagesSlotNextAsync(final String nextPageLink, final ServiceCall<List<CsmUsageQuotaInner>> serviceCall, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteUsagesSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return getSiteUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSlotNextAsync(final String nextPageLink) {
        return getSiteUsagesSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> getSiteUsagesSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteUsagesSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = getSiteUsagesSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> getSiteUsagesSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CsmUsageQuotaInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<ResourceMetricInner>> getSiteMetricsNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<ResourceMetricInner>> response = getSiteMetricsNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<ResourceMetricInner> pagedList = new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<ResourceMetricInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> getSiteMetricsNextAsync(final String nextPageLink, final ServiceCall<List<ResourceMetricInner>> serviceCall, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return getSiteMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsNextAsync(final String nextPageLink) {
        return getSiteMetricsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteMetricsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteMetricsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = getSiteMetricsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> getSiteMetricsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<ResourceMetricInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<ResourceMetricInner>> getSiteMetricsSlotNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<ResourceMetricInner>> response = getSiteMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<ResourceMetricInner> pagedList = new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<ResourceMetricInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> getSiteMetricsSlotNextAsync(final String nextPageLink, final ServiceCall<List<ResourceMetricInner>> serviceCall, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return getSiteMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSlotNextAsync(final String nextPageLink) {
        return getSiteMetricsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets metrics for web app.
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> getSiteMetricsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteMetricsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = getSiteMetricsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> getSiteMetricsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<ResourceMetricInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<MetricDefinitionInner>> getSiteMetricDefinitionsSlotNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<MetricDefinitionInner>> response = getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<MetricDefinitionInner> pagedList = new PagedList<MetricDefinitionInner>(response.getBody()) {
            @Override
            public Page<MetricDefinitionInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<MetricDefinitionInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<MetricDefinitionInner>> getSiteMetricDefinitionsSlotNextAsync(final String nextPageLink, final ServiceCall<List<MetricDefinitionInner>> serviceCall, final ListOperationCallback<MetricDefinitionInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(String nextPageLink) {
                    return getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;MetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsSlotNextAsync(final String nextPageLink) {
        return getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(ServiceResponse<Page<MetricDefinitionInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteMetricDefinitionsSlotNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     *
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteMetricDefinitionsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricDefinitionInner>> result = getSiteMetricDefinitionsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricDefinitionInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricDefinitionInner>> getSiteMetricDefinitionsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<MetricDefinitionInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<MetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<MetricDefinitionInner>> getSiteMetricDefinitionsNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<MetricDefinitionInner>> response = getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink).toBlocking().single();
        PagedList<MetricDefinitionInner> pagedList = new PagedList<MetricDefinitionInner>(response.getBody()) {
            @Override
            public Page<MetricDefinitionInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
        return new ServiceResponse<PagedList<MetricDefinitionInner>>(pagedList, response.getResponse());
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<MetricDefinitionInner>> getSiteMetricDefinitionsNextAsync(final String nextPageLink, final ServiceCall<List<MetricDefinitionInner>> serviceCall, final ListOperationCallback<MetricDefinitionInner> serviceCallback) {
        return AzureServiceCall.create(
            getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(String nextPageLink) {
                    return getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the List&lt;MetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsNextAsync(final String nextPageLink) {
        return getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(ServiceResponse<Page<MetricDefinitionInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    return getSiteMetricDefinitionsNextSinglePageAsync(nextPageLink);
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     *
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the List&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> getSiteMetricDefinitionsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSiteMetricDefinitionsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricDefinitionInner>> result = getSiteMetricDefinitionsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricDefinitionInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricDefinitionInner>> getSiteMetricDefinitionsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<MetricDefinitionInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<MetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
