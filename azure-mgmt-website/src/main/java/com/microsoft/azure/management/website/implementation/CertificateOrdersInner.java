/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.website.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceCall;
import com.microsoft.azure.AzureServiceResponseBuilder;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in CertificateOrders.
 */
public final class CertificateOrdersInner {
    /** The Retrofit service to perform REST calls. */
    private CertificateOrdersService service;
    /** The service client containing this operation class. */
    private WebSiteManagementClientImpl client;

    /**
     * Initializes an instance of CertificateOrdersInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public CertificateOrdersInner(Retrofit retrofit, WebSiteManagementClientImpl client) {
        this.service = retrofit.create(CertificateOrdersService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for CertificateOrders to be
     * used by Retrofit to perform actually REST calls.
     */
    interface CertificateOrdersService {
        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/certificates/{name}")
        Observable<Response<ResponseBody>> getCertificate(@Path("resourceGroupName") String resourceGroupName, @Path("certificateOrderName") String certificateOrderName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/certificates/{name}")
        Observable<Response<ResponseBody>> createOrUpdateCertificate(@Path("resourceGroupName") String resourceGroupName, @Path("certificateOrderName") String certificateOrderName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CertificateOrderCertificateInner keyVaultCertificate, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/certificates/{name}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteCertificate(@Path("resourceGroupName") String resourceGroupName, @Path("certificateOrderName") String certificateOrderName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/certificates/{name}")
        Observable<Response<ResponseBody>> updateCertificate(@Path("resourceGroupName") String resourceGroupName, @Path("certificateOrderName") String certificateOrderName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CertificateOrderCertificateInner keyVaultCertificate, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{name}")
        Observable<Response<ResponseBody>> getCertificateOrder(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{name}")
        Observable<Response<ResponseBody>> createOrUpdateCertificateOrder(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CertificateOrderInner certificateDistinguishedName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{name}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteCertificateOrder(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{name}")
        Observable<Response<ResponseBody>> updateCertificateOrder(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CertificateOrderInner certificateDistinguishedName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders")
        Observable<Response<ResponseBody>> getCertificateOrders(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/certificates")
        Observable<Response<ResponseBody>> getCertificates(@Path("resourceGroupName") String resourceGroupName, @Path("certificateOrderName") String certificateOrderName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{name}/reissue")
        Observable<Response<ResponseBody>> reissueCertificateOrder(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body ReissueCertificateOrderRequestInner reissueCertificateOrderRequest, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{name}/renew")
        Observable<Response<ResponseBody>> renewCertificateOrder(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body RenewCertificateOrderRequestInner renewCertificateOrderRequest, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{name}/retrieveCertificateActions")
        Observable<Response<ResponseBody>> retrieveCertificateActions(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{name}/retrieveEmailHistory")
        Observable<Response<ResponseBody>> retrieveCertificateEmailHistory(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{name}/resendEmail")
        Observable<Response<ResponseBody>> resendCertificateEmail(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{name}/verifyDomainOwnership")
        Observable<Response<ResponseBody>> verifyDomainOwnership(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getCertificateOrdersNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> getCertificatesNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Get certificate associated with the certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOrderCertificateInner object if successful.
     */
    public CertificateOrderCertificateInner getCertificate(String resourceGroupName, String certificateOrderName, String name) throws CloudException, IOException, IllegalArgumentException {
        return getCertificateWithServiceResponseAsync(resourceGroupName, certificateOrderName, name).toBlocking().single().getBody();
    }

    /**
     * Get certificate associated with the certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<CertificateOrderCertificateInner> getCertificateAsync(String resourceGroupName, String certificateOrderName, String name, final ServiceCallback<CertificateOrderCertificateInner> serviceCallback) {
        return ServiceCall.create(getCertificateWithServiceResponseAsync(resourceGroupName, certificateOrderName, name), serviceCallback);
    }

    /**
     * Get certificate associated with the certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @return the observable to the CertificateOrderCertificateInner object
     */
    public Observable<CertificateOrderCertificateInner> getCertificateAsync(String resourceGroupName, String certificateOrderName, String name) {
        return getCertificateWithServiceResponseAsync(resourceGroupName, certificateOrderName, name).map(new Func1<ServiceResponse<CertificateOrderCertificateInner>, CertificateOrderCertificateInner>() {
            @Override
            public CertificateOrderCertificateInner call(ServiceResponse<CertificateOrderCertificateInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get certificate associated with the certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @return the observable to the CertificateOrderCertificateInner object
     */
    public Observable<ServiceResponse<CertificateOrderCertificateInner>> getCertificateWithServiceResponseAsync(String resourceGroupName, String certificateOrderName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (certificateOrderName == null) {
            throw new IllegalArgumentException("Parameter certificateOrderName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getCertificate(resourceGroupName, certificateOrderName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateOrderCertificateInner>>>() {
                @Override
                public Observable<ServiceResponse<CertificateOrderCertificateInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateOrderCertificateInner> clientResponse = getCertificateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CertificateOrderCertificateInner> getCertificateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateOrderCertificateInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<CertificateOrderCertificateInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Associates a Key Vault secret to a certificate store that will be used for storing the certificate once it's ready.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @param keyVaultCertificate Key Vault secret csm Id
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOrderCertificateInner object if successful.
     */
    public CertificateOrderCertificateInner createOrUpdateCertificate(String resourceGroupName, String certificateOrderName, String name, CertificateOrderCertificateInner keyVaultCertificate) throws CloudException, IOException, IllegalArgumentException {
        return createOrUpdateCertificateWithServiceResponseAsync(resourceGroupName, certificateOrderName, name, keyVaultCertificate).toBlocking().single().getBody();
    }

    /**
     * Associates a Key Vault secret to a certificate store that will be used for storing the certificate once it's ready.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @param keyVaultCertificate Key Vault secret csm Id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<CertificateOrderCertificateInner> createOrUpdateCertificateAsync(String resourceGroupName, String certificateOrderName, String name, CertificateOrderCertificateInner keyVaultCertificate, final ServiceCallback<CertificateOrderCertificateInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateCertificateWithServiceResponseAsync(resourceGroupName, certificateOrderName, name, keyVaultCertificate), serviceCallback);
    }

    /**
     * Associates a Key Vault secret to a certificate store that will be used for storing the certificate once it's ready.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @param keyVaultCertificate Key Vault secret csm Id
     * @return the observable to the CertificateOrderCertificateInner object
     */
    public Observable<CertificateOrderCertificateInner> createOrUpdateCertificateAsync(String resourceGroupName, String certificateOrderName, String name, CertificateOrderCertificateInner keyVaultCertificate) {
        return createOrUpdateCertificateWithServiceResponseAsync(resourceGroupName, certificateOrderName, name, keyVaultCertificate).map(new Func1<ServiceResponse<CertificateOrderCertificateInner>, CertificateOrderCertificateInner>() {
            @Override
            public CertificateOrderCertificateInner call(ServiceResponse<CertificateOrderCertificateInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Associates a Key Vault secret to a certificate store that will be used for storing the certificate once it's ready.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @param keyVaultCertificate Key Vault secret csm Id
     * @return the observable to the CertificateOrderCertificateInner object
     */
    public Observable<ServiceResponse<CertificateOrderCertificateInner>> createOrUpdateCertificateWithServiceResponseAsync(String resourceGroupName, String certificateOrderName, String name, CertificateOrderCertificateInner keyVaultCertificate) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (certificateOrderName == null) {
            throw new IllegalArgumentException("Parameter certificateOrderName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (keyVaultCertificate == null) {
            throw new IllegalArgumentException("Parameter keyVaultCertificate is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(keyVaultCertificate);
        return service.createOrUpdateCertificate(resourceGroupName, certificateOrderName, name, this.client.subscriptionId(), keyVaultCertificate, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateOrderCertificateInner>>>() {
                @Override
                public Observable<ServiceResponse<CertificateOrderCertificateInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateOrderCertificateInner> clientResponse = createOrUpdateCertificateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CertificateOrderCertificateInner> createOrUpdateCertificateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateOrderCertificateInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<CertificateOrderCertificateInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes the certificate associated with the certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object if successful.
     */
    public Object deleteCertificate(String resourceGroupName, String certificateOrderName, String name) throws CloudException, IOException, IllegalArgumentException {
        return deleteCertificateWithServiceResponseAsync(resourceGroupName, certificateOrderName, name).toBlocking().single().getBody();
    }

    /**
     * Deletes the certificate associated with the certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteCertificateAsync(String resourceGroupName, String certificateOrderName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteCertificateWithServiceResponseAsync(resourceGroupName, certificateOrderName, name), serviceCallback);
    }

    /**
     * Deletes the certificate associated with the certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @return the observable to the Object object
     */
    public Observable<Object> deleteCertificateAsync(String resourceGroupName, String certificateOrderName, String name) {
        return deleteCertificateWithServiceResponseAsync(resourceGroupName, certificateOrderName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes the certificate associated with the certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteCertificateWithServiceResponseAsync(String resourceGroupName, String certificateOrderName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (certificateOrderName == null) {
            throw new IllegalArgumentException("Parameter certificateOrderName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteCertificate(resourceGroupName, certificateOrderName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteCertificateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteCertificateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Associates a Key Vault secret to a certificate store that will be used for storing the certificate once it's ready.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @param keyVaultCertificate Key Vault secret csm Id
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOrderCertificateInner object if successful.
     */
    public CertificateOrderCertificateInner updateCertificate(String resourceGroupName, String certificateOrderName, String name, CertificateOrderCertificateInner keyVaultCertificate) throws CloudException, IOException, IllegalArgumentException {
        return updateCertificateWithServiceResponseAsync(resourceGroupName, certificateOrderName, name, keyVaultCertificate).toBlocking().single().getBody();
    }

    /**
     * Associates a Key Vault secret to a certificate store that will be used for storing the certificate once it's ready.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @param keyVaultCertificate Key Vault secret csm Id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<CertificateOrderCertificateInner> updateCertificateAsync(String resourceGroupName, String certificateOrderName, String name, CertificateOrderCertificateInner keyVaultCertificate, final ServiceCallback<CertificateOrderCertificateInner> serviceCallback) {
        return ServiceCall.create(updateCertificateWithServiceResponseAsync(resourceGroupName, certificateOrderName, name, keyVaultCertificate), serviceCallback);
    }

    /**
     * Associates a Key Vault secret to a certificate store that will be used for storing the certificate once it's ready.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @param keyVaultCertificate Key Vault secret csm Id
     * @return the observable to the CertificateOrderCertificateInner object
     */
    public Observable<CertificateOrderCertificateInner> updateCertificateAsync(String resourceGroupName, String certificateOrderName, String name, CertificateOrderCertificateInner keyVaultCertificate) {
        return updateCertificateWithServiceResponseAsync(resourceGroupName, certificateOrderName, name, keyVaultCertificate).map(new Func1<ServiceResponse<CertificateOrderCertificateInner>, CertificateOrderCertificateInner>() {
            @Override
            public CertificateOrderCertificateInner call(ServiceResponse<CertificateOrderCertificateInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Associates a Key Vault secret to a certificate store that will be used for storing the certificate once it's ready.
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param name Certificate name
     * @param keyVaultCertificate Key Vault secret csm Id
     * @return the observable to the CertificateOrderCertificateInner object
     */
    public Observable<ServiceResponse<CertificateOrderCertificateInner>> updateCertificateWithServiceResponseAsync(String resourceGroupName, String certificateOrderName, String name, CertificateOrderCertificateInner keyVaultCertificate) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (certificateOrderName == null) {
            throw new IllegalArgumentException("Parameter certificateOrderName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (keyVaultCertificate == null) {
            throw new IllegalArgumentException("Parameter keyVaultCertificate is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(keyVaultCertificate);
        return service.updateCertificate(resourceGroupName, certificateOrderName, name, this.client.subscriptionId(), keyVaultCertificate, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateOrderCertificateInner>>>() {
                @Override
                public Observable<ServiceResponse<CertificateOrderCertificateInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateOrderCertificateInner> clientResponse = updateCertificateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CertificateOrderCertificateInner> updateCertificateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateOrderCertificateInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<CertificateOrderCertificateInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get a certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOrderInner object if successful.
     */
    public CertificateOrderInner getCertificateOrder(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return getCertificateOrderWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Get a certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<CertificateOrderInner> getCertificateOrderAsync(String resourceGroupName, String name, final ServiceCallback<CertificateOrderInner> serviceCallback) {
        return ServiceCall.create(getCertificateOrderWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Get a certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @return the observable to the CertificateOrderInner object
     */
    public Observable<CertificateOrderInner> getCertificateOrderAsync(String resourceGroupName, String name) {
        return getCertificateOrderWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<CertificateOrderInner>, CertificateOrderInner>() {
            @Override
            public CertificateOrderInner call(ServiceResponse<CertificateOrderInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get a certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @return the observable to the CertificateOrderInner object
     */
    public Observable<ServiceResponse<CertificateOrderInner>> getCertificateOrderWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getCertificateOrder(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateOrderInner>>>() {
                @Override
                public Observable<ServiceResponse<CertificateOrderInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateOrderInner> clientResponse = getCertificateOrderDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CertificateOrderInner> getCertificateOrderDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateOrderInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<CertificateOrderInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create or update a certificate purchase order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param certificateDistinguishedName Distinguished name to be used for purchasing certificate
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOrderInner object if successful.
     */
    public CertificateOrderInner createOrUpdateCertificateOrder(String resourceGroupName, String name, CertificateOrderInner certificateDistinguishedName) throws CloudException, IOException, IllegalArgumentException {
        return createOrUpdateCertificateOrderWithServiceResponseAsync(resourceGroupName, name, certificateDistinguishedName).toBlocking().single().getBody();
    }

    /**
     * Create or update a certificate purchase order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param certificateDistinguishedName Distinguished name to be used for purchasing certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<CertificateOrderInner> createOrUpdateCertificateOrderAsync(String resourceGroupName, String name, CertificateOrderInner certificateDistinguishedName, final ServiceCallback<CertificateOrderInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateCertificateOrderWithServiceResponseAsync(resourceGroupName, name, certificateDistinguishedName), serviceCallback);
    }

    /**
     * Create or update a certificate purchase order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param certificateDistinguishedName Distinguished name to be used for purchasing certificate
     * @return the observable to the CertificateOrderInner object
     */
    public Observable<CertificateOrderInner> createOrUpdateCertificateOrderAsync(String resourceGroupName, String name, CertificateOrderInner certificateDistinguishedName) {
        return createOrUpdateCertificateOrderWithServiceResponseAsync(resourceGroupName, name, certificateDistinguishedName).map(new Func1<ServiceResponse<CertificateOrderInner>, CertificateOrderInner>() {
            @Override
            public CertificateOrderInner call(ServiceResponse<CertificateOrderInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Create or update a certificate purchase order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param certificateDistinguishedName Distinguished name to be used for purchasing certificate
     * @return the observable to the CertificateOrderInner object
     */
    public Observable<ServiceResponse<CertificateOrderInner>> createOrUpdateCertificateOrderWithServiceResponseAsync(String resourceGroupName, String name, CertificateOrderInner certificateDistinguishedName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (certificateDistinguishedName == null) {
            throw new IllegalArgumentException("Parameter certificateDistinguishedName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(certificateDistinguishedName);
        return service.createOrUpdateCertificateOrder(resourceGroupName, name, this.client.subscriptionId(), certificateDistinguishedName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateOrderInner>>>() {
                @Override
                public Observable<ServiceResponse<CertificateOrderInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateOrderInner> clientResponse = createOrUpdateCertificateOrderDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CertificateOrderInner> createOrUpdateCertificateOrderDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateOrderInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<CertificateOrderInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete an existing certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object if successful.
     */
    public Object deleteCertificateOrder(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return deleteCertificateOrderWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Delete an existing certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteCertificateOrderAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteCertificateOrderWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Delete an existing certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @return the observable to the Object object
     */
    public Observable<Object> deleteCertificateOrderAsync(String resourceGroupName, String name) {
        return deleteCertificateOrderWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Delete an existing certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteCertificateOrderWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteCertificateOrder(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteCertificateOrderDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteCertificateOrderDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create or update a certificate purchase order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param certificateDistinguishedName Distinguished name to be used for purchasing certificate
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOrderInner object if successful.
     */
    public CertificateOrderInner updateCertificateOrder(String resourceGroupName, String name, CertificateOrderInner certificateDistinguishedName) throws CloudException, IOException, IllegalArgumentException {
        return updateCertificateOrderWithServiceResponseAsync(resourceGroupName, name, certificateDistinguishedName).toBlocking().single().getBody();
    }

    /**
     * Create or update a certificate purchase order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param certificateDistinguishedName Distinguished name to be used for purchasing certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<CertificateOrderInner> updateCertificateOrderAsync(String resourceGroupName, String name, CertificateOrderInner certificateDistinguishedName, final ServiceCallback<CertificateOrderInner> serviceCallback) {
        return ServiceCall.create(updateCertificateOrderWithServiceResponseAsync(resourceGroupName, name, certificateDistinguishedName), serviceCallback);
    }

    /**
     * Create or update a certificate purchase order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param certificateDistinguishedName Distinguished name to be used for purchasing certificate
     * @return the observable to the CertificateOrderInner object
     */
    public Observable<CertificateOrderInner> updateCertificateOrderAsync(String resourceGroupName, String name, CertificateOrderInner certificateDistinguishedName) {
        return updateCertificateOrderWithServiceResponseAsync(resourceGroupName, name, certificateDistinguishedName).map(new Func1<ServiceResponse<CertificateOrderInner>, CertificateOrderInner>() {
            @Override
            public CertificateOrderInner call(ServiceResponse<CertificateOrderInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Create or update a certificate purchase order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param certificateDistinguishedName Distinguished name to be used for purchasing certificate
     * @return the observable to the CertificateOrderInner object
     */
    public Observable<ServiceResponse<CertificateOrderInner>> updateCertificateOrderWithServiceResponseAsync(String resourceGroupName, String name, CertificateOrderInner certificateDistinguishedName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (certificateDistinguishedName == null) {
            throw new IllegalArgumentException("Parameter certificateDistinguishedName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(certificateDistinguishedName);
        return service.updateCertificateOrder(resourceGroupName, name, this.client.subscriptionId(), certificateDistinguishedName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateOrderInner>>>() {
                @Override
                public Observable<ServiceResponse<CertificateOrderInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateOrderInner> clientResponse = updateCertificateOrderDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CertificateOrderInner> updateCertificateOrderDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateOrderInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<CertificateOrderInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get certificate orders in a resource group.
     *
     * @param resourceGroupName Azure resource group name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the PagedList&lt;CertificateOrderInner&gt; object if successful.
     */
    public PagedList<CertificateOrderInner> getCertificateOrders(final String resourceGroupName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<CertificateOrderInner>> response = getCertificateOrdersSinglePageAsync(resourceGroupName).toBlocking().single();
        return new PagedList<CertificateOrderInner>(response.getBody()) {
            @Override
            public Page<CertificateOrderInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getCertificateOrdersNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get certificate orders in a resource group.
     *
     * @param resourceGroupName Azure resource group name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CertificateOrderInner>> getCertificateOrdersAsync(final String resourceGroupName, final ListOperationCallback<CertificateOrderInner> serviceCallback) {
        return AzureServiceCall.create(
            getCertificateOrdersSinglePageAsync(resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<CertificateOrderInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CertificateOrderInner>>> call(String nextPageLink) {
                    return getCertificateOrdersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get certificate orders in a resource group.
     *
     * @param resourceGroupName Azure resource group name
     * @return the observable to the PagedList&lt;CertificateOrderInner&gt; object
     */
    public Observable<Page<CertificateOrderInner>> getCertificateOrdersAsync(final String resourceGroupName) {
        return getCertificateOrdersWithServiceResponseAsync(resourceGroupName)
            .map(new Func1<ServiceResponse<Page<CertificateOrderInner>>, Page<CertificateOrderInner>>() {
                @Override
                public Page<CertificateOrderInner> call(ServiceResponse<Page<CertificateOrderInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get certificate orders in a resource group.
     *
     * @param resourceGroupName Azure resource group name
     * @return the observable to the PagedList&lt;CertificateOrderInner&gt; object
     */
    public Observable<ServiceResponse<Page<CertificateOrderInner>>> getCertificateOrdersWithServiceResponseAsync(final String resourceGroupName) {
        return getCertificateOrdersSinglePageAsync(resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<CertificateOrderInner>>, Observable<ServiceResponse<Page<CertificateOrderInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CertificateOrderInner>>> call(ServiceResponse<Page<CertificateOrderInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getCertificateOrdersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get certificate orders in a resource group.
     *
    ServiceResponse<PageImpl<CertificateOrderInner>> * @param resourceGroupName Azure resource group name
     * @return the PagedList&lt;CertificateOrderInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CertificateOrderInner>>> getCertificateOrdersSinglePageAsync(final String resourceGroupName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getCertificateOrders(resourceGroupName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CertificateOrderInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CertificateOrderInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CertificateOrderInner>> result = getCertificateOrdersDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CertificateOrderInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CertificateOrderInner>> getCertificateOrdersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateOrderInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateOrderInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List all certificates associated with a certificate order (only one certificate can be associated with an order at a time).
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the PagedList&lt;CertificateOrderCertificateInner&gt; object if successful.
     */
    public PagedList<CertificateOrderCertificateInner> getCertificates(final String resourceGroupName, final String certificateOrderName) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<CertificateOrderCertificateInner>> response = getCertificatesSinglePageAsync(resourceGroupName, certificateOrderName).toBlocking().single();
        return new PagedList<CertificateOrderCertificateInner>(response.getBody()) {
            @Override
            public Page<CertificateOrderCertificateInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getCertificatesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List all certificates associated with a certificate order (only one certificate can be associated with an order at a time).
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CertificateOrderCertificateInner>> getCertificatesAsync(final String resourceGroupName, final String certificateOrderName, final ListOperationCallback<CertificateOrderCertificateInner> serviceCallback) {
        return AzureServiceCall.create(
            getCertificatesSinglePageAsync(resourceGroupName, certificateOrderName),
            new Func1<String, Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>> call(String nextPageLink) {
                    return getCertificatesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List all certificates associated with a certificate order (only one certificate can be associated with an order at a time).
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @return the observable to the PagedList&lt;CertificateOrderCertificateInner&gt; object
     */
    public Observable<Page<CertificateOrderCertificateInner>> getCertificatesAsync(final String resourceGroupName, final String certificateOrderName) {
        return getCertificatesWithServiceResponseAsync(resourceGroupName, certificateOrderName)
            .map(new Func1<ServiceResponse<Page<CertificateOrderCertificateInner>>, Page<CertificateOrderCertificateInner>>() {
                @Override
                public Page<CertificateOrderCertificateInner> call(ServiceResponse<Page<CertificateOrderCertificateInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List all certificates associated with a certificate order (only one certificate can be associated with an order at a time).
     *
     * @param resourceGroupName Azure resource group name
     * @param certificateOrderName Certificate name
     * @return the observable to the PagedList&lt;CertificateOrderCertificateInner&gt; object
     */
    public Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>> getCertificatesWithServiceResponseAsync(final String resourceGroupName, final String certificateOrderName) {
        return getCertificatesSinglePageAsync(resourceGroupName, certificateOrderName)
            .concatMap(new Func1<ServiceResponse<Page<CertificateOrderCertificateInner>>, Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>> call(ServiceResponse<Page<CertificateOrderCertificateInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getCertificatesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List all certificates associated with a certificate order (only one certificate can be associated with an order at a time).
     *
    ServiceResponse<PageImpl<CertificateOrderCertificateInner>> * @param resourceGroupName Azure resource group name
    ServiceResponse<PageImpl<CertificateOrderCertificateInner>> * @param certificateOrderName Certificate name
     * @return the PagedList&lt;CertificateOrderCertificateInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>> getCertificatesSinglePageAsync(final String resourceGroupName, final String certificateOrderName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (certificateOrderName == null) {
            throw new IllegalArgumentException("Parameter certificateOrderName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getCertificates(resourceGroupName, certificateOrderName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CertificateOrderCertificateInner>> result = getCertificatesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CertificateOrderCertificateInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CertificateOrderCertificateInner>> getCertificatesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateOrderCertificateInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateOrderCertificateInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Reissue an existing certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param reissueCertificateOrderRequest Reissue parameters
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object if successful.
     */
    public Object reissueCertificateOrder(String resourceGroupName, String name, ReissueCertificateOrderRequestInner reissueCertificateOrderRequest) throws CloudException, IOException, IllegalArgumentException {
        return reissueCertificateOrderWithServiceResponseAsync(resourceGroupName, name, reissueCertificateOrderRequest).toBlocking().single().getBody();
    }

    /**
     * Reissue an existing certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param reissueCertificateOrderRequest Reissue parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> reissueCertificateOrderAsync(String resourceGroupName, String name, ReissueCertificateOrderRequestInner reissueCertificateOrderRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(reissueCertificateOrderWithServiceResponseAsync(resourceGroupName, name, reissueCertificateOrderRequest), serviceCallback);
    }

    /**
     * Reissue an existing certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param reissueCertificateOrderRequest Reissue parameters
     * @return the observable to the Object object
     */
    public Observable<Object> reissueCertificateOrderAsync(String resourceGroupName, String name, ReissueCertificateOrderRequestInner reissueCertificateOrderRequest) {
        return reissueCertificateOrderWithServiceResponseAsync(resourceGroupName, name, reissueCertificateOrderRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Reissue an existing certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param reissueCertificateOrderRequest Reissue parameters
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> reissueCertificateOrderWithServiceResponseAsync(String resourceGroupName, String name, ReissueCertificateOrderRequestInner reissueCertificateOrderRequest) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (reissueCertificateOrderRequest == null) {
            throw new IllegalArgumentException("Parameter reissueCertificateOrderRequest is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(reissueCertificateOrderRequest);
        return service.reissueCertificateOrder(resourceGroupName, name, this.client.subscriptionId(), reissueCertificateOrderRequest, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = reissueCertificateOrderDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> reissueCertificateOrderDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Renew an existing certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param renewCertificateOrderRequest Renew parameters
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object if successful.
     */
    public Object renewCertificateOrder(String resourceGroupName, String name, RenewCertificateOrderRequestInner renewCertificateOrderRequest) throws CloudException, IOException, IllegalArgumentException {
        return renewCertificateOrderWithServiceResponseAsync(resourceGroupName, name, renewCertificateOrderRequest).toBlocking().single().getBody();
    }

    /**
     * Renew an existing certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param renewCertificateOrderRequest Renew parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> renewCertificateOrderAsync(String resourceGroupName, String name, RenewCertificateOrderRequestInner renewCertificateOrderRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(renewCertificateOrderWithServiceResponseAsync(resourceGroupName, name, renewCertificateOrderRequest), serviceCallback);
    }

    /**
     * Renew an existing certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param renewCertificateOrderRequest Renew parameters
     * @return the observable to the Object object
     */
    public Observable<Object> renewCertificateOrderAsync(String resourceGroupName, String name, RenewCertificateOrderRequestInner renewCertificateOrderRequest) {
        return renewCertificateOrderWithServiceResponseAsync(resourceGroupName, name, renewCertificateOrderRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Renew an existing certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate name
     * @param renewCertificateOrderRequest Renew parameters
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> renewCertificateOrderWithServiceResponseAsync(String resourceGroupName, String name, RenewCertificateOrderRequestInner renewCertificateOrderRequest) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (renewCertificateOrderRequest == null) {
            throw new IllegalArgumentException("Parameter renewCertificateOrderRequest is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(renewCertificateOrderRequest);
        return service.renewCertificateOrder(resourceGroupName, name, this.client.subscriptionId(), renewCertificateOrderRequest, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = renewCertificateOrderDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> renewCertificateOrderDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieve the list of certificate actions.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateOrderActionInner&gt; object if successful.
     */
    public List<CertificateOrderActionInner> retrieveCertificateActions(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return retrieveCertificateActionsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Retrieve the list of certificate actions.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CertificateOrderActionInner>> retrieveCertificateActionsAsync(String resourceGroupName, String name, final ServiceCallback<List<CertificateOrderActionInner>> serviceCallback) {
        return ServiceCall.create(retrieveCertificateActionsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Retrieve the list of certificate actions.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @return the observable to the List&lt;CertificateOrderActionInner&gt; object
     */
    public Observable<List<CertificateOrderActionInner>> retrieveCertificateActionsAsync(String resourceGroupName, String name) {
        return retrieveCertificateActionsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<List<CertificateOrderActionInner>>, List<CertificateOrderActionInner>>() {
            @Override
            public List<CertificateOrderActionInner> call(ServiceResponse<List<CertificateOrderActionInner>> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieve the list of certificate actions.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @return the observable to the List&lt;CertificateOrderActionInner&gt; object
     */
    public Observable<ServiceResponse<List<CertificateOrderActionInner>>> retrieveCertificateActionsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.retrieveCertificateActions(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<CertificateOrderActionInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<CertificateOrderActionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<CertificateOrderActionInner>> clientResponse = retrieveCertificateActionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<CertificateOrderActionInner>> retrieveCertificateActionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<List<CertificateOrderActionInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<CertificateOrderActionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrive email history.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateEmailInner&gt; object if successful.
     */
    public List<CertificateEmailInner> retrieveCertificateEmailHistory(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return retrieveCertificateEmailHistoryWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Retrive email history.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CertificateEmailInner>> retrieveCertificateEmailHistoryAsync(String resourceGroupName, String name, final ServiceCallback<List<CertificateEmailInner>> serviceCallback) {
        return ServiceCall.create(retrieveCertificateEmailHistoryWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Retrive email history.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @return the observable to the List&lt;CertificateEmailInner&gt; object
     */
    public Observable<List<CertificateEmailInner>> retrieveCertificateEmailHistoryAsync(String resourceGroupName, String name) {
        return retrieveCertificateEmailHistoryWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<List<CertificateEmailInner>>, List<CertificateEmailInner>>() {
            @Override
            public List<CertificateEmailInner> call(ServiceResponse<List<CertificateEmailInner>> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrive email history.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @return the observable to the List&lt;CertificateEmailInner&gt; object
     */
    public Observable<ServiceResponse<List<CertificateEmailInner>>> retrieveCertificateEmailHistoryWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.retrieveCertificateEmailHistory(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<CertificateEmailInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<CertificateEmailInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<CertificateEmailInner>> clientResponse = retrieveCertificateEmailHistoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<CertificateEmailInner>> retrieveCertificateEmailHistoryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<List<CertificateEmailInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<CertificateEmailInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Resend certificate email.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object if successful.
     */
    public Object resendCertificateEmail(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return resendCertificateEmailWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Resend certificate email.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> resendCertificateEmailAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(resendCertificateEmailWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Resend certificate email.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @return the observable to the Object object
     */
    public Observable<Object> resendCertificateEmailAsync(String resourceGroupName, String name) {
        return resendCertificateEmailWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Resend certificate email.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> resendCertificateEmailWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.resendCertificateEmail(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = resendCertificateEmailDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> resendCertificateEmailDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Verify domain ownership for this certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the Object object if successful.
     */
    public Object verifyDomainOwnership(String resourceGroupName, String name) throws CloudException, IOException, IllegalArgumentException {
        return verifyDomainOwnershipWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Verify domain ownership for this certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> verifyDomainOwnershipAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(verifyDomainOwnershipWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Verify domain ownership for this certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @return the observable to the Object object
     */
    public Observable<Object> verifyDomainOwnershipAsync(String resourceGroupName, String name) {
        return verifyDomainOwnershipWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Verify domain ownership for this certificate order.
     *
     * @param resourceGroupName Azure resource group name
     * @param name Certificate order name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> verifyDomainOwnershipWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.verifyDomainOwnership(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = verifyDomainOwnershipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> verifyDomainOwnershipDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get certificate orders in a resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the PagedList&lt;CertificateOrderInner&gt; object if successful.
     */
    public PagedList<CertificateOrderInner> getCertificateOrdersNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<CertificateOrderInner>> response = getCertificateOrdersNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<CertificateOrderInner>(response.getBody()) {
            @Override
            public Page<CertificateOrderInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getCertificateOrdersNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get certificate orders in a resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CertificateOrderInner>> getCertificateOrdersNextAsync(final String nextPageLink, final ServiceCall<List<CertificateOrderInner>> serviceCall, final ListOperationCallback<CertificateOrderInner> serviceCallback) {
        return AzureServiceCall.create(
            getCertificateOrdersNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<CertificateOrderInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CertificateOrderInner>>> call(String nextPageLink) {
                    return getCertificateOrdersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get certificate orders in a resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;CertificateOrderInner&gt; object
     */
    public Observable<Page<CertificateOrderInner>> getCertificateOrdersNextAsync(final String nextPageLink) {
        return getCertificateOrdersNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<CertificateOrderInner>>, Page<CertificateOrderInner>>() {
                @Override
                public Page<CertificateOrderInner> call(ServiceResponse<Page<CertificateOrderInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get certificate orders in a resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;CertificateOrderInner&gt; object
     */
    public Observable<ServiceResponse<Page<CertificateOrderInner>>> getCertificateOrdersNextWithServiceResponseAsync(final String nextPageLink) {
        return getCertificateOrdersNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<CertificateOrderInner>>, Observable<ServiceResponse<Page<CertificateOrderInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CertificateOrderInner>>> call(ServiceResponse<Page<CertificateOrderInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getCertificateOrdersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get certificate orders in a resource group.
     *
    ServiceResponse<PageImpl<CertificateOrderInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;CertificateOrderInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CertificateOrderInner>>> getCertificateOrdersNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getCertificateOrdersNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CertificateOrderInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CertificateOrderInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CertificateOrderInner>> result = getCertificateOrdersNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CertificateOrderInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CertificateOrderInner>> getCertificateOrdersNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateOrderInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateOrderInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List all certificates associated with a certificate order (only one certificate can be associated with an order at a time).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws CloudException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the PagedList&lt;CertificateOrderCertificateInner&gt; object if successful.
     */
    public PagedList<CertificateOrderCertificateInner> getCertificatesNext(final String nextPageLink) throws CloudException, IOException, IllegalArgumentException {
        ServiceResponse<Page<CertificateOrderCertificateInner>> response = getCertificatesNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<CertificateOrderCertificateInner>(response.getBody()) {
            @Override
            public Page<CertificateOrderCertificateInner> nextPage(String nextPageLink) throws RestException, IOException {
                return getCertificatesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List all certificates associated with a certificate order (only one certificate can be associated with an order at a time).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CertificateOrderCertificateInner>> getCertificatesNextAsync(final String nextPageLink, final ServiceCall<List<CertificateOrderCertificateInner>> serviceCall, final ListOperationCallback<CertificateOrderCertificateInner> serviceCallback) {
        return AzureServiceCall.create(
            getCertificatesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>> call(String nextPageLink) {
                    return getCertificatesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List all certificates associated with a certificate order (only one certificate can be associated with an order at a time).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;CertificateOrderCertificateInner&gt; object
     */
    public Observable<Page<CertificateOrderCertificateInner>> getCertificatesNextAsync(final String nextPageLink) {
        return getCertificatesNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<CertificateOrderCertificateInner>>, Page<CertificateOrderCertificateInner>>() {
                @Override
                public Page<CertificateOrderCertificateInner> call(ServiceResponse<Page<CertificateOrderCertificateInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List all certificates associated with a certificate order (only one certificate can be associated with an order at a time).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;CertificateOrderCertificateInner&gt; object
     */
    public Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>> getCertificatesNextWithServiceResponseAsync(final String nextPageLink) {
        return getCertificatesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<CertificateOrderCertificateInner>>, Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>> call(ServiceResponse<Page<CertificateOrderCertificateInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getCertificatesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List all certificates associated with a certificate order (only one certificate can be associated with an order at a time).
     *
    ServiceResponse<PageImpl<CertificateOrderCertificateInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;CertificateOrderCertificateInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>> getCertificatesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getCertificatesNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CertificateOrderCertificateInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CertificateOrderCertificateInner>> result = getCertificatesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CertificateOrderCertificateInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CertificateOrderCertificateInner>> getCertificatesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateOrderCertificateInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateOrderCertificateInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
