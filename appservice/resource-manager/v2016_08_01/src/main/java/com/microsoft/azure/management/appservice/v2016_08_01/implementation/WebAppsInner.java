/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.appservice.v2016_08_01.implementation;

import com.microsoft.azure.arm.collection.InnerSupportsGet;
import com.microsoft.azure.arm.collection.InnerSupportsDelete;
import com.microsoft.azure.arm.collection.InnerSupportsListing;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.appservice.v2016_08_01.CsmPublishingProfileOptions;
import com.microsoft.azure.management.appservice.v2016_08_01.CsmSlotEntity;
import com.microsoft.azure.management.appservice.v2016_08_01.MigrateMySqlRequest;
import com.microsoft.azure.management.appservice.v2016_08_01.MSDeploy;
import com.microsoft.azure.management.appservice.v2016_08_01.PublishingProfileFormat;
import com.microsoft.azure.management.appservice.v2016_08_01.SitePatchResource;
import com.microsoft.azure.management.appservice.v2016_08_01.SnapshotRecoveryRequest;
import com.microsoft.azure.management.appservice.v2016_08_01.StorageMigrationOptions;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Streaming;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in WebApps.
 */
public class WebAppsInner implements InnerSupportsGet<SiteInner>, InnerSupportsDelete<Void>, InnerSupportsListing<SiteInner> {
    /** The Retrofit service to perform REST calls. */
    private WebAppsService service;
    /** The service client containing this operation class. */
    private WebSiteManagementClientImpl client;

    /**
     * Initializes an instance of WebAppsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public WebAppsInner(Retrofit retrofit, WebSiteManagementClientImpl client) {
        this.service = retrofit.create(WebAppsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for WebApps to be
     * used by Retrofit to perform actually REST calls.
     */
    interface WebAppsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps list" })
        @GET("subscriptions/{subscriptionId}/providers/Microsoft.Web/sites")
        Observable<Response<ResponseBody>> list(@Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listByResourceGroup" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites")
        Observable<Response<ResponseBody>> listByResourceGroup(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Query("includeSlots") Boolean includeSlots, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getByResourceGroup" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> getByResourceGroup(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> createOrUpdate(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginCreateOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> beginCreateOrUpdate(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("deleteMetrics") Boolean deleteMetrics, @Query("deleteEmptyServerFarm") Boolean deleteEmptyServerFarm, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps update" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> update(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SitePatchResource siteEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps analyzeCustomHostname" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/analyzeCustomHostname")
        Observable<Response<ResponseBody>> analyzeCustomHostname(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("hostName") String hostName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps applySlotConfigToProduction" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/applySlotConfig")
        Observable<Response<ResponseBody>> applySlotConfigToProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntity slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps backup" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backup")
        Observable<Response<ResponseBody>> backup(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listBackups" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups")
        Observable<Response<ResponseBody>> listBackups(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps discoverRestore" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/discover")
        Observable<Response<ResponseBody>> discoverRestore(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getBackupStatus" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}")
        Observable<Response<ResponseBody>> getBackupStatus(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteBackup" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackup(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listBackupStatusSecrets" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/list")
        Observable<Response<ResponseBody>> listBackupStatusSecrets(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps restore" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> restore(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginRestore" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> beginRestore(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listConfigurations" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config")
        Observable<Response<ResponseBody>> listConfigurations(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateApplicationSettings" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings")
        Observable<Response<ResponseBody>> updateApplicationSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner appSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listApplicationSettings" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings/list")
        Observable<Response<ResponseBody>> listApplicationSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateAuthSettings" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings")
        Observable<Response<ResponseBody>> updateAuthSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteAuthSettingsInner siteAuthSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getAuthSettings" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings/list")
        Observable<Response<ResponseBody>> getAuthSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateBackupConfiguration" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup")
        Observable<Response<ResponseBody>> updateBackupConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteBackupConfiguration" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackupConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getBackupConfiguration" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup/list")
        Observable<Response<ResponseBody>> getBackupConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateConnectionStrings" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings")
        Observable<Response<ResponseBody>> updateConnectionStrings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body ConnectionStringDictionaryInner connectionStrings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listConnectionStrings" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings/list")
        Observable<Response<ResponseBody>> listConnectionStrings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getDiagnosticLogsConfiguration" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs")
        Observable<Response<ResponseBody>> getDiagnosticLogsConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateDiagnosticLogsConfig" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs")
        Observable<Response<ResponseBody>> updateDiagnosticLogsConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteLogsConfigInner siteLogsConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateMetadata" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata")
        Observable<Response<ResponseBody>> updateMetadata(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner metadata, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listMetadata" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata/list")
        Observable<Response<ResponseBody>> listMetadata(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listPublishingCredentials" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> listPublishingCredentials(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginListPublishingCredentials" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> beginListPublishingCredentials(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateSitePushSettings" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings")
        Observable<Response<ResponseBody>> updateSitePushSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body PushSettingsInner pushSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSitePushSettings" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings/list")
        Observable<Response<ResponseBody>> listSitePushSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSlotConfigurationNames" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames")
        Observable<Response<ResponseBody>> listSlotConfigurationNames(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateSlotConfigurationNames" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames")
        Observable<Response<ResponseBody>> updateSlotConfigurationNames(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SlotConfigNamesResourceInner slotConfigNames, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getConfiguration" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web")
        Observable<Response<ResponseBody>> getConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateConfiguration" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web")
        Observable<Response<ResponseBody>> createOrUpdateConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteConfigResourceInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateConfiguration" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web")
        Observable<Response<ResponseBody>> updateConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteConfigResourceInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listConfigurationSnapshotInfo" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots")
        Observable<Response<ResponseBody>> listConfigurationSnapshotInfo(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getConfigurationSnapshot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}")
        Observable<Response<ResponseBody>> getConfigurationSnapshot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("snapshotId") String snapshotId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps recoverSiteConfigurationSnapshot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}/recover")
        Observable<Response<ResponseBody>> recoverSiteConfigurationSnapshot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("snapshotId") String snapshotId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getWebSiteContainerLogs" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs")
        @Streaming
        Observable<Response<ResponseBody>> getWebSiteContainerLogs(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getWebSiteContainerLogsZip" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs/zip/download")
        @Streaming
        Observable<Response<ResponseBody>> getWebSiteContainerLogsZip(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listContinuousWebJobs" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs")
        Observable<Response<ResponseBody>> listContinuousWebJobs(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getContinuousWebJob" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}")
        Observable<Response<ResponseBody>> getContinuousWebJob(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteContinuousWebJob" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteContinuousWebJob(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps startContinuousWebJob" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/start")
        Observable<Response<ResponseBody>> startContinuousWebJob(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps stopContinuousWebJob" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/stop")
        Observable<Response<ResponseBody>> stopContinuousWebJob(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listDeployments" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments")
        Observable<Response<ResponseBody>> listDeployments(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getDeployment" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}")
        Observable<Response<ResponseBody>> getDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createDeployment" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}")
        Observable<Response<ResponseBody>> createDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteDeployment" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listDeploymentLog" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}/log")
        Observable<Response<ResponseBody>> listDeploymentLog(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listDomainOwnershipIdentifiers" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers")
        Observable<Response<ResponseBody>> listDomainOwnershipIdentifiers(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getDomainOwnershipIdentifier" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}")
        Observable<Response<ResponseBody>> getDomainOwnershipIdentifier(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateDomainOwnershipIdentifier" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}")
        Observable<Response<ResponseBody>> createOrUpdateDomainOwnershipIdentifier(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("subscriptionId") String subscriptionId, @Body IdentifierInner domainOwnershipIdentifier, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteDomainOwnershipIdentifier" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDomainOwnershipIdentifier(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateDomainOwnershipIdentifier" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}")
        Observable<Response<ResponseBody>> updateDomainOwnershipIdentifier(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("subscriptionId") String subscriptionId, @Body IdentifierInner domainOwnershipIdentifier, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getMSDeployStatus" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy")
        Observable<Response<ResponseBody>> getMSDeployStatus(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createMSDeployOperation" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy")
        Observable<Response<ResponseBody>> createMSDeployOperation(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body MSDeploy mSDeploy, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginCreateMSDeployOperation" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy")
        Observable<Response<ResponseBody>> beginCreateMSDeployOperation(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body MSDeploy mSDeploy, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getMSDeployLog" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy/log")
        Observable<Response<ResponseBody>> getMSDeployLog(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listFunctions" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions")
        Observable<Response<ResponseBody>> listFunctions(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getFunctionsAdminToken" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/admin/token")
        Observable<Response<ResponseBody>> getFunctionsAdminToken(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getFunction" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}")
        Observable<Response<ResponseBody>> getFunction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("functionName") String functionName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createFunction" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}")
        Observable<Response<ResponseBody>> createFunction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("functionName") String functionName, @Path("subscriptionId") String subscriptionId, @Body FunctionEnvelopeInner functionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginCreateFunction" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}")
        Observable<Response<ResponseBody>> beginCreateFunction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("functionName") String functionName, @Path("subscriptionId") String subscriptionId, @Body FunctionEnvelopeInner functionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteFunction" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteFunction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("functionName") String functionName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listFunctionSecrets" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/listsecrets")
        Observable<Response<ResponseBody>> listFunctionSecrets(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("functionName") String functionName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listHostNameBindings" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings")
        Observable<Response<ResponseBody>> listHostNameBindings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getHostNameBinding" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> getHostNameBinding(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateHostNameBinding" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> createOrUpdateHostNameBinding(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Body HostNameBindingInner hostNameBinding, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteHostNameBinding" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHostNameBinding(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getHybridConnection" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> getHybridConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateHybridConnection" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> createOrUpdateHybridConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Body HybridConnectionInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteHybridConnection" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHybridConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateHybridConnection" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> updateHybridConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Body HybridConnectionInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listHybridConnectionKeys" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys")
        Observable<Response<ResponseBody>> listHybridConnectionKeys(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listHybridConnections" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionRelays")
        Observable<Response<ResponseBody>> listHybridConnections(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listRelayServiceConnections" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection")
        Observable<Response<ResponseBody>> listRelayServiceConnections(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getRelayServiceConnection" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> getRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateRelayServiceConnection" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> createOrUpdateRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteRelayServiceConnection" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateRelayServiceConnection" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> updateRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceIdentifiers" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances")
        Observable<Response<ResponseBody>> listInstanceIdentifiers(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getInstanceMsDeployStatus" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy")
        Observable<Response<ResponseBody>> getInstanceMsDeployStatus(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createInstanceMSDeployOperation" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy")
        Observable<Response<ResponseBody>> createInstanceMSDeployOperation(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Body MSDeploy mSDeploy, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginCreateInstanceMSDeployOperation" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy")
        Observable<Response<ResponseBody>> beginCreateInstanceMSDeployOperation(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Body MSDeploy mSDeploy, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getInstanceMSDeployLog" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy/log")
        Observable<Response<ResponseBody>> getInstanceMSDeployLog(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceProcesses" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes")
        Observable<Response<ResponseBody>> listInstanceProcesses(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getInstanceProcess" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}")
        Observable<Response<ResponseBody>> getInstanceProcess(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteInstanceProcess" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteInstanceProcess(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getInstanceProcessDump" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/dump")
        @Streaming
        Observable<Response<ResponseBody>> getInstanceProcessDump(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceProcessModules" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules")
        Observable<Response<ResponseBody>> listInstanceProcessModules(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getInstanceProcessModule" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}")
        Observable<Response<ResponseBody>> getInstanceProcessModule(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("baseAddress") String baseAddress, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceProcessThreads" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/threads")
        Observable<Response<ResponseBody>> listInstanceProcessThreads(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getInstanceProcessThread" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/threads/{threadId}")
        Observable<Response<ResponseBody>> getInstanceProcessThread(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("threadId") String threadId, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps isCloneable" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/iscloneable")
        Observable<Response<ResponseBody>> isCloneable(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSyncFunctionTriggers" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/listsyncfunctiontriggerstatus")
        Observable<Response<ResponseBody>> listSyncFunctionTriggers(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listMetricDefinitions" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metricdefinitions")
        Observable<Response<ResponseBody>> listMetricDefinitions(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listMetrics" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metrics")
        Observable<Response<ResponseBody>> listMetrics(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("details") Boolean details, @Query(value = "$filter", encoded = true) String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps migrateStorage" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migrate")
        Observable<Response<ResponseBody>> migrateStorage(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("subscriptionName") String subscriptionName, @Body StorageMigrationOptions migrationOptions, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginMigrateStorage" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migrate")
        Observable<Response<ResponseBody>> beginMigrateStorage(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("subscriptionName") String subscriptionName, @Body StorageMigrationOptions migrationOptions, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps migrateMySql" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql")
        Observable<Response<ResponseBody>> migrateMySql(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body MigrateMySqlRequest migrationRequestEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginMigrateMySql" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql")
        Observable<Response<ResponseBody>> beginMigrateMySql(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body MigrateMySqlRequest migrationRequestEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getMigrateMySqlStatus" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql/status")
        Observable<Response<ResponseBody>> getMigrateMySqlStatus(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listNetworkFeatures" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkFeatures/{view}")
        Observable<Response<ResponseBody>> listNetworkFeatures(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("view") String view, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps startWebSiteNetworkTrace" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/start")
        Observable<Response<ResponseBody>> startWebSiteNetworkTrace(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("durationInSeconds") Integer durationInSeconds, @Query("maxFrameLength") Integer maxFrameLength, @Query("sasUrl") String sasUrl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps stopWebSiteNetworkTrace" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/stop")
        Observable<Response<ResponseBody>> stopWebSiteNetworkTrace(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps generateNewSitePublishingPassword" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/newpassword")
        Observable<Response<ResponseBody>> generateNewSitePublishingPassword(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listPerfMonCounters" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/perfcounters")
        Observable<Response<ResponseBody>> listPerfMonCounters(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query(value = "$filter", encoded = true) String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getSitePhpErrorLogFlag" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/phplogging")
        Observable<Response<ResponseBody>> getSitePhpErrorLogFlag(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listPremierAddOns" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons")
        Observable<Response<ResponseBody>> listPremierAddOns(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getPremierAddOn" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> getPremierAddOn(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps addPremierAddOn" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> addPremierAddOn(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("subscriptionId") String subscriptionId, @Body PremierAddOnInner premierAddOn, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deletePremierAddOn" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deletePremierAddOn(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listProcesses" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes")
        Observable<Response<ResponseBody>> listProcesses(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getProcess" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}")
        Observable<Response<ResponseBody>> getProcess(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteProcess" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteProcess(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getProcessDump" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/dump")
        @Streaming
        Observable<Response<ResponseBody>> getProcessDump(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listProcessModules" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules")
        Observable<Response<ResponseBody>> listProcessModules(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getProcessModule" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules/{baseAddress}")
        Observable<Response<ResponseBody>> getProcessModule(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("baseAddress") String baseAddress, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listProcessThreads" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/threads")
        Observable<Response<ResponseBody>> listProcessThreads(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getProcessThread" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/threads/{threadId}")
        Observable<Response<ResponseBody>> getProcessThread(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("threadId") String threadId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listPublicCertificates" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates")
        Observable<Response<ResponseBody>> listPublicCertificates(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getPublicCertificate" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}")
        Observable<Response<ResponseBody>> getPublicCertificate(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("publicCertificateName") String publicCertificateName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdatePublicCertificate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}")
        Observable<Response<ResponseBody>> createOrUpdatePublicCertificate(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("publicCertificateName") String publicCertificateName, @Path("subscriptionId") String subscriptionId, @Body PublicCertificateInner publicCertificate, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deletePublicCertificate" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deletePublicCertificate(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("publicCertificateName") String publicCertificateName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listPublishingProfileXmlWithSecrets" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publishxml")
        @Streaming
        Observable<Response<ResponseBody>> listPublishingProfileXmlWithSecrets(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CsmPublishingProfileOptions publishingProfileOptions, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps recover" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/recover")
        Observable<Response<ResponseBody>> recover(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SnapshotRecoveryRequest recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginRecover" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/recover")
        Observable<Response<ResponseBody>> beginRecover(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SnapshotRecoveryRequest recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps resetProductionSlotConfig" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resetSlotConfig")
        Observable<Response<ResponseBody>> resetProductionSlotConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps restart" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restart")
        Observable<Response<ResponseBody>> restart(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("softRestart") Boolean softRestart, @Query("synchronous") Boolean synchronous, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSiteExtensions" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions")
        Observable<Response<ResponseBody>> listSiteExtensions(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getSiteExtension" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}")
        Observable<Response<ResponseBody>> getSiteExtension(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("siteExtensionId") String siteExtensionId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps installSiteExtension" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}")
        Observable<Response<ResponseBody>> installSiteExtension(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("siteExtensionId") String siteExtensionId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginInstallSiteExtension" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}")
        Observable<Response<ResponseBody>> beginInstallSiteExtension(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("siteExtensionId") String siteExtensionId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteSiteExtension" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteExtension(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("siteExtensionId") String siteExtensionId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSlots" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots")
        Observable<Response<ResponseBody>> listSlots(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> getSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> createOrUpdateSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("skipCustomDomainVerification") Boolean skipCustomDomainVerification, @Query("forceDnsRegistration") Boolean forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginCreateOrUpdateSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> beginCreateOrUpdateSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("skipCustomDomainVerification") Boolean skipCustomDomainVerification, @Query("forceDnsRegistration") Boolean forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("deleteMetrics") Boolean deleteMetrics, @Query("deleteEmptyServerFarm") Boolean deleteEmptyServerFarm, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateSlot" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> updateSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SitePatchResource siteEnvelope, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("skipCustomDomainVerification") Boolean skipCustomDomainVerification, @Query("forceDnsRegistration") Boolean forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps analyzeCustomHostnameSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/analyzeCustomHostname")
        Observable<Response<ResponseBody>> analyzeCustomHostnameSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("hostName") String hostName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps applySlotConfigurationSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/applySlotConfig")
        Observable<Response<ResponseBody>> applySlotConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntity slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps backupSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backup")
        Observable<Response<ResponseBody>> backupSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listBackupsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups")
        Observable<Response<ResponseBody>> listBackupsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps discoverRestoreSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/discover")
        Observable<Response<ResponseBody>> discoverRestoreSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getBackupStatusSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}")
        Observable<Response<ResponseBody>> getBackupStatusSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteBackupSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackupSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listBackupStatusSecretsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/list")
        Observable<Response<ResponseBody>> listBackupStatusSecretsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps restoreSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> restoreSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginRestoreSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> beginRestoreSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listConfigurationsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config")
        Observable<Response<ResponseBody>> listConfigurationsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateApplicationSettingsSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings")
        Observable<Response<ResponseBody>> updateApplicationSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner appSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listApplicationSettingsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings/list")
        Observable<Response<ResponseBody>> listApplicationSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateAuthSettingsSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings")
        Observable<Response<ResponseBody>> updateAuthSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteAuthSettingsInner siteAuthSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getAuthSettingsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings/list")
        Observable<Response<ResponseBody>> getAuthSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateBackupConfigurationSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup")
        Observable<Response<ResponseBody>> updateBackupConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteBackupConfigurationSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackupConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getBackupConfigurationSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup/list")
        Observable<Response<ResponseBody>> getBackupConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateConnectionStringsSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings")
        Observable<Response<ResponseBody>> updateConnectionStringsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body ConnectionStringDictionaryInner connectionStrings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listConnectionStringsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings/list")
        Observable<Response<ResponseBody>> listConnectionStringsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getDiagnosticLogsConfigurationSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs")
        Observable<Response<ResponseBody>> getDiagnosticLogsConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateDiagnosticLogsConfigSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs")
        Observable<Response<ResponseBody>> updateDiagnosticLogsConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteLogsConfigInner siteLogsConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateMetadataSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata")
        Observable<Response<ResponseBody>> updateMetadataSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner metadata, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listMetadataSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata/list")
        Observable<Response<ResponseBody>> listMetadataSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listPublishingCredentialsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> listPublishingCredentialsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginListPublishingCredentialsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> beginListPublishingCredentialsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateSitePushSettingsSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings")
        Observable<Response<ResponseBody>> updateSitePushSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body PushSettingsInner pushSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSitePushSettingsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings/list")
        Observable<Response<ResponseBody>> listSitePushSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getConfigurationSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web")
        Observable<Response<ResponseBody>> getConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateConfigurationSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web")
        Observable<Response<ResponseBody>> createOrUpdateConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteConfigResourceInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateConfigurationSlot" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web")
        Observable<Response<ResponseBody>> updateConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteConfigResourceInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listConfigurationSnapshotInfoSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots")
        Observable<Response<ResponseBody>> listConfigurationSnapshotInfoSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getConfigurationSnapshotSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}")
        Observable<Response<ResponseBody>> getConfigurationSnapshotSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("snapshotId") String snapshotId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps recoverSiteConfigurationSnapshotSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}/recover")
        Observable<Response<ResponseBody>> recoverSiteConfigurationSnapshotSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("snapshotId") String snapshotId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getWebSiteContainerLogsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs")
        @Streaming
        Observable<Response<ResponseBody>> getWebSiteContainerLogsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getWebSiteContainerLogsZipSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs/zip/download")
        @Streaming
        Observable<Response<ResponseBody>> getWebSiteContainerLogsZipSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listContinuousWebJobsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs")
        Observable<Response<ResponseBody>> listContinuousWebJobsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getContinuousWebJobSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}")
        Observable<Response<ResponseBody>> getContinuousWebJobSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteContinuousWebJobSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteContinuousWebJobSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps startContinuousWebJobSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/start")
        Observable<Response<ResponseBody>> startContinuousWebJobSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps stopContinuousWebJobSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/stop")
        Observable<Response<ResponseBody>> stopContinuousWebJobSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listDeploymentsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments")
        Observable<Response<ResponseBody>> listDeploymentsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getDeploymentSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}")
        Observable<Response<ResponseBody>> getDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createDeploymentSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}")
        Observable<Response<ResponseBody>> createDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteDeploymentSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listDeploymentLogSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}/log")
        Observable<Response<ResponseBody>> listDeploymentLogSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listDomainOwnershipIdentifiersSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers")
        Observable<Response<ResponseBody>> listDomainOwnershipIdentifiersSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getDomainOwnershipIdentifierSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}")
        Observable<Response<ResponseBody>> getDomainOwnershipIdentifierSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateDomainOwnershipIdentifierSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}")
        Observable<Response<ResponseBody>> createOrUpdateDomainOwnershipIdentifierSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body IdentifierInner domainOwnershipIdentifier, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteDomainOwnershipIdentifierSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDomainOwnershipIdentifierSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateDomainOwnershipIdentifierSlot" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}")
        Observable<Response<ResponseBody>> updateDomainOwnershipIdentifierSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body IdentifierInner domainOwnershipIdentifier, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getMSDeployStatusSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy")
        Observable<Response<ResponseBody>> getMSDeployStatusSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createMSDeployOperationSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy")
        Observable<Response<ResponseBody>> createMSDeployOperationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body MSDeploy mSDeploy, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginCreateMSDeployOperationSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy")
        Observable<Response<ResponseBody>> beginCreateMSDeployOperationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body MSDeploy mSDeploy, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getMSDeployLogSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy/log")
        Observable<Response<ResponseBody>> getMSDeployLogSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceFunctionsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions")
        Observable<Response<ResponseBody>> listInstanceFunctionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getFunctionsAdminTokenSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/admin/token")
        Observable<Response<ResponseBody>> getFunctionsAdminTokenSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getInstanceFunctionSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}")
        Observable<Response<ResponseBody>> getInstanceFunctionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("functionName") String functionName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createInstanceFunctionSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}")
        Observable<Response<ResponseBody>> createInstanceFunctionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("functionName") String functionName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body FunctionEnvelopeInner functionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginCreateInstanceFunctionSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}")
        Observable<Response<ResponseBody>> beginCreateInstanceFunctionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("functionName") String functionName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body FunctionEnvelopeInner functionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteInstanceFunctionSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteInstanceFunctionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("functionName") String functionName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listFunctionSecretsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/listsecrets")
        Observable<Response<ResponseBody>> listFunctionSecretsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("functionName") String functionName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listHostNameBindingsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings")
        Observable<Response<ResponseBody>> listHostNameBindingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getHostNameBindingSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> getHostNameBindingSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateHostNameBindingSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> createOrUpdateHostNameBindingSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body HostNameBindingInner hostNameBinding, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteHostNameBindingSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHostNameBindingSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getHybridConnectionSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> getHybridConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateHybridConnectionSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> createOrUpdateHybridConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body HybridConnectionInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteHybridConnectionSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHybridConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateHybridConnectionSlot" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> updateHybridConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body HybridConnectionInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listHybridConnectionKeysSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys")
        Observable<Response<ResponseBody>> listHybridConnectionKeysSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listHybridConnectionsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionRelays")
        Observable<Response<ResponseBody>> listHybridConnectionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listRelayServiceConnectionsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection")
        Observable<Response<ResponseBody>> listRelayServiceConnectionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getRelayServiceConnectionSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> getRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateRelayServiceConnectionSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> createOrUpdateRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteRelayServiceConnectionSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateRelayServiceConnectionSlot" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> updateRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceIdentifiersSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances")
        Observable<Response<ResponseBody>> listInstanceIdentifiersSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getInstanceMsDeployStatusSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy")
        Observable<Response<ResponseBody>> getInstanceMsDeployStatusSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createInstanceMSDeployOperationSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy")
        Observable<Response<ResponseBody>> createInstanceMSDeployOperationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Body MSDeploy mSDeploy, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginCreateInstanceMSDeployOperationSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy")
        Observable<Response<ResponseBody>> beginCreateInstanceMSDeployOperationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Body MSDeploy mSDeploy, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getInstanceMSDeployLogSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy/log")
        Observable<Response<ResponseBody>> getInstanceMSDeployLogSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceProcessesSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes")
        Observable<Response<ResponseBody>> listInstanceProcessesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getInstanceProcessSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}")
        Observable<Response<ResponseBody>> getInstanceProcessSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteInstanceProcessSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteInstanceProcessSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getInstanceProcessDumpSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/dump")
        @Streaming
        Observable<Response<ResponseBody>> getInstanceProcessDumpSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceProcessModulesSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules")
        Observable<Response<ResponseBody>> listInstanceProcessModulesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getInstanceProcessModuleSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}")
        Observable<Response<ResponseBody>> getInstanceProcessModuleSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("baseAddress") String baseAddress, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceProcessThreadsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/threads")
        Observable<Response<ResponseBody>> listInstanceProcessThreadsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getInstanceProcessThreadSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/threads/{threadId}")
        Observable<Response<ResponseBody>> getInstanceProcessThreadSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("threadId") String threadId, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps isCloneableSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/iscloneable")
        Observable<Response<ResponseBody>> isCloneableSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSyncFunctionTriggersSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/listsyncfunctiontriggerstatus")
        Observable<Response<ResponseBody>> listSyncFunctionTriggersSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listMetricDefinitionsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metricdefinitions")
        Observable<Response<ResponseBody>> listMetricDefinitionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listMetricsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metrics")
        Observable<Response<ResponseBody>> listMetricsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("details") Boolean details, @Query(value = "$filter", encoded = true) String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getMigrateMySqlStatusSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/migratemysql/status")
        Observable<Response<ResponseBody>> getMigrateMySqlStatusSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listNetworkFeaturesSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkFeatures/{view}")
        Observable<Response<ResponseBody>> listNetworkFeaturesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("view") String view, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps startWebSiteNetworkTraceSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/start")
        Observable<Response<ResponseBody>> startWebSiteNetworkTraceSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("durationInSeconds") Integer durationInSeconds, @Query("maxFrameLength") Integer maxFrameLength, @Query("sasUrl") String sasUrl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps stopWebSiteNetworkTraceSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/stop")
        Observable<Response<ResponseBody>> stopWebSiteNetworkTraceSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps generateNewSitePublishingPasswordSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/newpassword")
        Observable<Response<ResponseBody>> generateNewSitePublishingPasswordSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listPerfMonCountersSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/perfcounters")
        Observable<Response<ResponseBody>> listPerfMonCountersSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query(value = "$filter", encoded = true) String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getSitePhpErrorLogFlagSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/phplogging")
        Observable<Response<ResponseBody>> getSitePhpErrorLogFlagSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listPremierAddOnsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons")
        Observable<Response<ResponseBody>> listPremierAddOnsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getPremierAddOnSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> getPremierAddOnSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps addPremierAddOnSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> addPremierAddOnSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body PremierAddOnInner premierAddOn, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deletePremierAddOnSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deletePremierAddOnSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listProcessesSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes")
        Observable<Response<ResponseBody>> listProcessesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getProcessSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}")
        Observable<Response<ResponseBody>> getProcessSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteProcessSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteProcessSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getProcessDumpSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/dump")
        @Streaming
        Observable<Response<ResponseBody>> getProcessDumpSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listProcessModulesSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules")
        Observable<Response<ResponseBody>> listProcessModulesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getProcessModuleSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules/{baseAddress}")
        Observable<Response<ResponseBody>> getProcessModuleSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("baseAddress") String baseAddress, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listProcessThreadsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/threads")
        Observable<Response<ResponseBody>> listProcessThreadsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getProcessThreadSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/threads/{threadId}")
        Observable<Response<ResponseBody>> getProcessThreadSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("processId") String processId, @Path("threadId") String threadId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listPublicCertificatesSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates")
        Observable<Response<ResponseBody>> listPublicCertificatesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getPublicCertificateSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}")
        Observable<Response<ResponseBody>> getPublicCertificateSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("publicCertificateName") String publicCertificateName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdatePublicCertificateSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}")
        Observable<Response<ResponseBody>> createOrUpdatePublicCertificateSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("publicCertificateName") String publicCertificateName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body PublicCertificateInner publicCertificate, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deletePublicCertificateSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deletePublicCertificateSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("publicCertificateName") String publicCertificateName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listPublishingProfileXmlWithSecretsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publishxml")
        @Streaming
        Observable<Response<ResponseBody>> listPublishingProfileXmlWithSecretsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CsmPublishingProfileOptions publishingProfileOptions, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps recoverSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/recover")
        Observable<Response<ResponseBody>> recoverSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SnapshotRecoveryRequest recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginRecoverSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/recover")
        Observable<Response<ResponseBody>> beginRecoverSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SnapshotRecoveryRequest recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps resetSlotConfigurationSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resetSlotConfig")
        Observable<Response<ResponseBody>> resetSlotConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps restartSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restart")
        Observable<Response<ResponseBody>> restartSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("softRestart") Boolean softRestart, @Query("synchronous") Boolean synchronous, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSiteExtensionsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions")
        Observable<Response<ResponseBody>> listSiteExtensionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getSiteExtensionSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}")
        Observable<Response<ResponseBody>> getSiteExtensionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("siteExtensionId") String siteExtensionId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps installSiteExtensionSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}")
        Observable<Response<ResponseBody>> installSiteExtensionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("siteExtensionId") String siteExtensionId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginInstallSiteExtensionSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}")
        Observable<Response<ResponseBody>> beginInstallSiteExtensionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("siteExtensionId") String siteExtensionId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteSiteExtensionSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSiteExtensionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("siteExtensionId") String siteExtensionId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSlotDifferencesSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsdiffs")
        Observable<Response<ResponseBody>> listSlotDifferencesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntity slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps swapSlotSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap")
        Observable<Response<ResponseBody>> swapSlotSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntity slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginSwapSlotSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap")
        Observable<Response<ResponseBody>> beginSwapSlotSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntity slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSnapshotsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshots")
        Observable<Response<ResponseBody>> listSnapshotsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getSourceControlSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> getSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateSourceControlSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> createOrUpdateSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginCreateOrUpdateSourceControlSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> beginCreateOrUpdateSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteSourceControlSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateSourceControlSlot" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> updateSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps startSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/start")
        Observable<Response<ResponseBody>> startSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps stopSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stop")
        Observable<Response<ResponseBody>> stopSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps syncRepositorySlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sync")
        Observable<Response<ResponseBody>> syncRepositorySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps syncFunctionTriggersSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/syncfunctiontriggers")
        Observable<Response<ResponseBody>> syncFunctionTriggersSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listTriggeredWebJobsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs")
        Observable<Response<ResponseBody>> listTriggeredWebJobsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getTriggeredWebJobSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}")
        Observable<Response<ResponseBody>> getTriggeredWebJobSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteTriggeredWebJobSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteTriggeredWebJobSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listTriggeredWebJobHistorySlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history")
        Observable<Response<ResponseBody>> listTriggeredWebJobHistorySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getTriggeredWebJobHistorySlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history/{id}")
        Observable<Response<ResponseBody>> getTriggeredWebJobHistorySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps runTriggeredWebJobSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/run")
        Observable<Response<ResponseBody>> runTriggeredWebJobSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listUsagesSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/usages")
        Observable<Response<ResponseBody>> listUsagesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query(value = "$filter", encoded = true) String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listVnetConnectionsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections")
        Observable<Response<ResponseBody>> listVnetConnectionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getVnetConnectionSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> getVnetConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateVnetConnectionSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> createOrUpdateVnetConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteVnetConnectionSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteVnetConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateVnetConnectionSlot" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> updateVnetConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getVnetConnectionGatewaySlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> getVnetConnectionGatewaySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateVnetConnectionGatewaySlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> createOrUpdateVnetConnectionGatewaySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateVnetConnectionGatewaySlot" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> updateVnetConnectionGatewaySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listWebJobsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs")
        Observable<Response<ResponseBody>> listWebJobsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getWebJobSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs/{webJobName}")
        Observable<Response<ResponseBody>> getWebJobSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSlotDifferencesFromProduction" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsdiffs")
        Observable<Response<ResponseBody>> listSlotDifferencesFromProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntity slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps swapSlotWithProduction" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap")
        Observable<Response<ResponseBody>> swapSlotWithProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntity slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginSwapSlotWithProduction" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap")
        Observable<Response<ResponseBody>> beginSwapSlotWithProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntity slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSnapshots" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshots")
        Observable<Response<ResponseBody>> listSnapshots(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getSourceControl" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> getSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateSourceControl" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> createOrUpdateSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps beginCreateOrUpdateSourceControl" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> beginCreateOrUpdateSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteSourceControl" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateSourceControl" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> updateSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps start" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/start")
        Observable<Response<ResponseBody>> start(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps stop" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stop")
        Observable<Response<ResponseBody>> stop(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps syncRepository" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sync")
        Observable<Response<ResponseBody>> syncRepository(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps syncFunctionTriggers" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/syncfunctiontriggers")
        Observable<Response<ResponseBody>> syncFunctionTriggers(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listTriggeredWebJobs" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs")
        Observable<Response<ResponseBody>> listTriggeredWebJobs(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getTriggeredWebJob" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}")
        Observable<Response<ResponseBody>> getTriggeredWebJob(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteTriggeredWebJob" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteTriggeredWebJob(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listTriggeredWebJobHistory" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history")
        Observable<Response<ResponseBody>> listTriggeredWebJobHistory(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getTriggeredWebJobHistory" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history/{id}")
        Observable<Response<ResponseBody>> getTriggeredWebJobHistory(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps runTriggeredWebJob" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/run")
        Observable<Response<ResponseBody>> runTriggeredWebJob(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listUsages" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/usages")
        Observable<Response<ResponseBody>> listUsages(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query(value = "$filter", encoded = true) String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listVnetConnections" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections")
        Observable<Response<ResponseBody>> listVnetConnections(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getVnetConnection" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> getVnetConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateVnetConnection" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> createOrUpdateVnetConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps deleteVnetConnection" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteVnetConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateVnetConnection" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> updateVnetConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getVnetConnectionGateway" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> getVnetConnectionGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps createOrUpdateVnetConnectionGateway" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> createOrUpdateVnetConnectionGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps updateVnetConnectionGateway" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> updateVnetConnectionGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listWebJobs" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs")
        Observable<Response<ResponseBody>> listWebJobs(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps getWebJob" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs/{webJobName}")
        Observable<Response<ResponseBody>> getWebJob(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("webJobName") String webJobName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listNext" })
        @GET
        Observable<Response<ResponseBody>> listNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listByResourceGroupNext" })
        @GET
        Observable<Response<ResponseBody>> listByResourceGroupNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listBackupsNext" })
        @GET
        Observable<Response<ResponseBody>> listBackupsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listConfigurationsNext" })
        @GET
        Observable<Response<ResponseBody>> listConfigurationsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listConfigurationSnapshotInfoNext" })
        @GET
        Observable<Response<ResponseBody>> listConfigurationSnapshotInfoNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listContinuousWebJobsNext" })
        @GET
        Observable<Response<ResponseBody>> listContinuousWebJobsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listDeploymentsNext" })
        @GET
        Observable<Response<ResponseBody>> listDeploymentsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listDomainOwnershipIdentifiersNext" })
        @GET
        Observable<Response<ResponseBody>> listDomainOwnershipIdentifiersNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listFunctionsNext" })
        @GET
        Observable<Response<ResponseBody>> listFunctionsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listHostNameBindingsNext" })
        @GET
        Observable<Response<ResponseBody>> listHostNameBindingsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceIdentifiersNext" })
        @GET
        Observable<Response<ResponseBody>> listInstanceIdentifiersNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceProcessesNext" })
        @GET
        Observable<Response<ResponseBody>> listInstanceProcessesNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceProcessModulesNext" })
        @GET
        Observable<Response<ResponseBody>> listInstanceProcessModulesNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceProcessThreadsNext" })
        @GET
        Observable<Response<ResponseBody>> listInstanceProcessThreadsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listMetricDefinitionsNext" })
        @GET
        Observable<Response<ResponseBody>> listMetricDefinitionsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listMetricsNext" })
        @GET
        Observable<Response<ResponseBody>> listMetricsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listPerfMonCountersNext" })
        @GET
        Observable<Response<ResponseBody>> listPerfMonCountersNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listProcessesNext" })
        @GET
        Observable<Response<ResponseBody>> listProcessesNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listProcessModulesNext" })
        @GET
        Observable<Response<ResponseBody>> listProcessModulesNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listProcessThreadsNext" })
        @GET
        Observable<Response<ResponseBody>> listProcessThreadsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listPublicCertificatesNext" })
        @GET
        Observable<Response<ResponseBody>> listPublicCertificatesNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSiteExtensionsNext" })
        @GET
        Observable<Response<ResponseBody>> listSiteExtensionsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSlotsNext" })
        @GET
        Observable<Response<ResponseBody>> listSlotsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listBackupsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listBackupsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listConfigurationsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listConfigurationsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listConfigurationSnapshotInfoSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listConfigurationSnapshotInfoSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listContinuousWebJobsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listContinuousWebJobsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listDeploymentsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listDeploymentsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listDomainOwnershipIdentifiersSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listDomainOwnershipIdentifiersSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceFunctionsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listInstanceFunctionsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listHostNameBindingsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listHostNameBindingsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceIdentifiersSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listInstanceIdentifiersSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceProcessesSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listInstanceProcessesSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceProcessModulesSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listInstanceProcessModulesSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listInstanceProcessThreadsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listInstanceProcessThreadsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listMetricDefinitionsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listMetricDefinitionsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listMetricsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listMetricsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listPerfMonCountersSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listPerfMonCountersSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listProcessesSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listProcessesSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listProcessModulesSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listProcessModulesSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listProcessThreadsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listProcessThreadsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listPublicCertificatesSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listPublicCertificatesSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSiteExtensionsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listSiteExtensionsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSlotDifferencesSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listSlotDifferencesSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSnapshotsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listSnapshotsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listTriggeredWebJobsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listTriggeredWebJobsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listTriggeredWebJobHistorySlotNext" })
        @GET
        Observable<Response<ResponseBody>> listTriggeredWebJobHistorySlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listUsagesSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listUsagesSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listWebJobsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listWebJobsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSlotDifferencesFromProductionNext" })
        @GET
        Observable<Response<ResponseBody>> listSlotDifferencesFromProductionNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listSnapshotsNext" })
        @GET
        Observable<Response<ResponseBody>> listSnapshotsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listTriggeredWebJobsNext" })
        @GET
        Observable<Response<ResponseBody>> listTriggeredWebJobsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listTriggeredWebJobHistoryNext" })
        @GET
        Observable<Response<ResponseBody>> listTriggeredWebJobHistoryNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listUsagesNext" })
        @GET
        Observable<Response<ResponseBody>> listUsagesNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.v2016_08_01.WebApps listWebJobsNext" })
        @GET
        Observable<Response<ResponseBody>> listWebJobsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> list() {
        ServiceResponse<Page<SiteInner>> response = listSinglePageAsync().toBlocking().single();
        return new PagedList<SiteInner>(response.body()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInner>> listAsync(final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listAsync() {
        return listWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listWithServiceResponseAsync() {
        return listSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSinglePageAsync() {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.list(this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listByResourceGroup(final String resourceGroupName) {
        ServiceResponse<Page<SiteInner>> response = listByResourceGroupSinglePageAsync(resourceGroupName).toBlocking().single();
        return new PagedList<SiteInner>(response.body()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInner>> listByResourceGroupAsync(final String resourceGroupName, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupSinglePageAsync(resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listByResourceGroupAsync(final String resourceGroupName) {
        return listByResourceGroupWithServiceResponseAsync(resourceGroupName)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupWithServiceResponseAsync(final String resourceGroupName) {
        return listByResourceGroupSinglePageAsync(resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupSinglePageAsync(final String resourceGroupName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean includeSlots = null;
        return service.listByResourceGroup(resourceGroupName, this.client.subscriptionId(), includeSlots, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listByResourceGroupDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param includeSlots Specify &lt;strong&gt;true&lt;/strong&gt; to include deployment slots in results. The default is false, which only gives you the production slot of all apps.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listByResourceGroup(final String resourceGroupName, final Boolean includeSlots) {
        ServiceResponse<Page<SiteInner>> response = listByResourceGroupSinglePageAsync(resourceGroupName, includeSlots).toBlocking().single();
        return new PagedList<SiteInner>(response.body()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param includeSlots Specify &lt;strong&gt;true&lt;/strong&gt; to include deployment slots in results. The default is false, which only gives you the production slot of all apps.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInner>> listByResourceGroupAsync(final String resourceGroupName, final Boolean includeSlots, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupSinglePageAsync(resourceGroupName, includeSlots),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param includeSlots Specify &lt;strong&gt;true&lt;/strong&gt; to include deployment slots in results. The default is false, which only gives you the production slot of all apps.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listByResourceGroupAsync(final String resourceGroupName, final Boolean includeSlots) {
        return listByResourceGroupWithServiceResponseAsync(resourceGroupName, includeSlots)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param includeSlots Specify &lt;strong&gt;true&lt;/strong&gt; to include deployment slots in results. The default is false, which only gives you the production slot of all apps.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupWithServiceResponseAsync(final String resourceGroupName, final Boolean includeSlots) {
        return listByResourceGroupSinglePageAsync(resourceGroupName, includeSlots)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SiteInner>> * @param includeSlots Specify &lt;strong&gt;true&lt;/strong&gt; to include deployment slots in results. The default is false, which only gives you the production slot of all apps.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupSinglePageAsync(final String resourceGroupName, final Boolean includeSlots) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByResourceGroup(resourceGroupName, this.client.subscriptionId(), includeSlots, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listByResourceGroupDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner getByResourceGroup(String resourceGroupName, String name) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> getByResourceGroupAsync(String resourceGroupName, String name, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByResourceGroupWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> getByResourceGroupAsync(String resourceGroupName, String name) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getByResourceGroupWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getByResourceGroup(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getByResourceGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> getByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner createOrUpdate(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).toBlocking().last().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> createOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SiteInner> createOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        Observable<Response<ResponseBody>> observable = service.createOrUpdate(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner beginCreateOrUpdate(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> beginCreateOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginCreateOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateWithServiceResponseAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        return service.beginCreateOrUpdate(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> beginCreateOrUpdateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String resourceGroupName, String name) {
        deleteWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String resourceGroupName, String name) {
        return deleteWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean deleteMetrics = null;
        final Boolean deleteEmptyServerFarm = null;
        return service.delete(resourceGroupName, name, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param deleteMetrics If true, web app metrics are also deleted.
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String resourceGroupName, String name, Boolean deleteMetrics, Boolean deleteEmptyServerFarm) {
        deleteWithServiceResponseAsync(resourceGroupName, name, deleteMetrics, deleteEmptyServerFarm).toBlocking().single().body();
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param deleteMetrics If true, web app metrics are also deleted.
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String name, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, name, deleteMetrics, deleteEmptyServerFarm), serviceCallback);
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param deleteMetrics If true, web app metrics are also deleted.
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String resourceGroupName, String name, Boolean deleteMetrics, Boolean deleteEmptyServerFarm) {
        return deleteWithServiceResponseAsync(resourceGroupName, name, deleteMetrics, deleteEmptyServerFarm).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param deleteMetrics If true, web app metrics are also deleted.
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String name, Boolean deleteMetrics, Boolean deleteEmptyServerFarm) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.delete(resourceGroupName, name, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner update(String resourceGroupName, String name, SitePatchResource siteEnvelope) {
        return updateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> updateAsync(String resourceGroupName, String name, SitePatchResource siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> updateAsync(String resourceGroupName, String name, SitePatchResource siteEnvelope) {
        return updateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> updateWithServiceResponseAsync(String resourceGroupName, String name, SitePatchResource siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        return service.update(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> updateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CustomHostnameAnalysisResultInner object if successful.
     */
    public CustomHostnameAnalysisResultInner analyzeCustomHostname(String resourceGroupName, String name) {
        return analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CustomHostnameAnalysisResultInner> analyzeCustomHostnameAsync(String resourceGroupName, String name, final ServiceCallback<CustomHostnameAnalysisResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<CustomHostnameAnalysisResultInner> analyzeCustomHostnameAsync(String resourceGroupName, String name) {
        return analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<CustomHostnameAnalysisResultInner>, CustomHostnameAnalysisResultInner>() {
            @Override
            public CustomHostnameAnalysisResultInner call(ServiceResponse<CustomHostnameAnalysisResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> analyzeCustomHostnameWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String hostName = null;
        return service.analyzeCustomHostname(resourceGroupName, name, this.client.subscriptionId(), hostName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CustomHostnameAnalysisResultInner>>>() {
                @Override
                public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CustomHostnameAnalysisResultInner> clientResponse = analyzeCustomHostnameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param hostName Custom hostname.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CustomHostnameAnalysisResultInner object if successful.
     */
    public CustomHostnameAnalysisResultInner analyzeCustomHostname(String resourceGroupName, String name, String hostName) {
        return analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name, hostName).toBlocking().single().body();
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param hostName Custom hostname.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CustomHostnameAnalysisResultInner> analyzeCustomHostnameAsync(String resourceGroupName, String name, String hostName, final ServiceCallback<CustomHostnameAnalysisResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name, hostName), serviceCallback);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param hostName Custom hostname.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<CustomHostnameAnalysisResultInner> analyzeCustomHostnameAsync(String resourceGroupName, String name, String hostName) {
        return analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name, hostName).map(new Func1<ServiceResponse<CustomHostnameAnalysisResultInner>, CustomHostnameAnalysisResultInner>() {
            @Override
            public CustomHostnameAnalysisResultInner call(ServiceResponse<CustomHostnameAnalysisResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param hostName Custom hostname.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> analyzeCustomHostnameWithServiceResponseAsync(String resourceGroupName, String name, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.analyzeCustomHostname(resourceGroupName, name, this.client.subscriptionId(), hostName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CustomHostnameAnalysisResultInner>>>() {
                @Override
                public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CustomHostnameAnalysisResultInner> clientResponse = analyzeCustomHostnameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CustomHostnameAnalysisResultInner> analyzeCustomHostnameDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<CustomHostnameAnalysisResultInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<CustomHostnameAnalysisResultInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void applySlotConfigToProduction(String resourceGroupName, String name, CsmSlotEntity slotSwapEntity) {
        applySlotConfigToProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).toBlocking().single().body();
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> applySlotConfigToProductionAsync(String resourceGroupName, String name, CsmSlotEntity slotSwapEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(applySlotConfigToProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity), serviceCallback);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> applySlotConfigToProductionAsync(String resourceGroupName, String name, CsmSlotEntity slotSwapEntity) {
        return applySlotConfigToProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> applySlotConfigToProductionWithServiceResponseAsync(String resourceGroupName, String name, CsmSlotEntity slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.applySlotConfigToProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = applySlotConfigToProductionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> applySlotConfigToProductionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner backup(String resourceGroupName, String name, BackupRequestInner request) {
        return backupWithServiceResponseAsync(resourceGroupName, name, request).toBlocking().single().body();
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupItemInner> backupAsync(String resourceGroupName, String name, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceFuture.fromResponse(backupWithServiceResponseAsync(resourceGroupName, name, request), serviceCallback);
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> backupAsync(String resourceGroupName, String name, BackupRequestInner request) {
        return backupWithServiceResponseAsync(resourceGroupName, name, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> backupWithServiceResponseAsync(String resourceGroupName, String name, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.backup(resourceGroupName, name, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = backupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> backupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupItemInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listBackups(final String resourceGroupName, final String name) {
        ServiceResponse<Page<BackupItemInner>> response = listBackupsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<BackupItemInner>(response.body()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listBackupsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BackupItemInner>> listBackupsAsync(final String resourceGroupName, final String name, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listBackupsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listBackupsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listBackupsAsync(final String resourceGroupName, final String name) {
        return listBackupsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listBackupsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listBackupsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<BackupItemInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listBackups(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listBackupsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listBackupsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BackupItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RestoreRequestInner object if successful.
     */
    public RestoreRequestInner discoverRestore(String resourceGroupName, String name, RestoreRequestInner request) {
        return discoverRestoreWithServiceResponseAsync(resourceGroupName, name, request).toBlocking().single().body();
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RestoreRequestInner> discoverRestoreAsync(String resourceGroupName, String name, RestoreRequestInner request, final ServiceCallback<RestoreRequestInner> serviceCallback) {
        return ServiceFuture.fromResponse(discoverRestoreWithServiceResponseAsync(resourceGroupName, name, request), serviceCallback);
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<RestoreRequestInner> discoverRestoreAsync(String resourceGroupName, String name, RestoreRequestInner request) {
        return discoverRestoreWithServiceResponseAsync(resourceGroupName, name, request).map(new Func1<ServiceResponse<RestoreRequestInner>, RestoreRequestInner>() {
            @Override
            public RestoreRequestInner call(ServiceResponse<RestoreRequestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<ServiceResponse<RestoreRequestInner>> discoverRestoreWithServiceResponseAsync(String resourceGroupName, String name, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.discoverRestore(resourceGroupName, name, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreRequestInner> clientResponse = discoverRestoreDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreRequestInner> discoverRestoreDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RestoreRequestInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RestoreRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner getBackupStatus(String resourceGroupName, String name, String backupId) {
        return getBackupStatusWithServiceResponseAsync(resourceGroupName, name, backupId).toBlocking().single().body();
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupItemInner> getBackupStatusAsync(String resourceGroupName, String name, String backupId, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceFuture.fromResponse(getBackupStatusWithServiceResponseAsync(resourceGroupName, name, backupId), serviceCallback);
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> getBackupStatusAsync(String resourceGroupName, String name, String backupId) {
        return getBackupStatusWithServiceResponseAsync(resourceGroupName, name, backupId).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> getBackupStatusWithServiceResponseAsync(String resourceGroupName, String name, String backupId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getBackupStatus(resourceGroupName, name, backupId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = getBackupStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> getBackupStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupItemInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteBackup(String resourceGroupName, String name, String backupId) {
        deleteBackupWithServiceResponseAsync(resourceGroupName, name, backupId).toBlocking().single().body();
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteBackupAsync(String resourceGroupName, String name, String backupId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteBackupWithServiceResponseAsync(resourceGroupName, name, backupId), serviceCallback);
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteBackupAsync(String resourceGroupName, String name, String backupId) {
        return deleteBackupWithServiceResponseAsync(resourceGroupName, name, backupId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteBackupWithServiceResponseAsync(String resourceGroupName, String name, String backupId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteBackup(resourceGroupName, name, backupId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteBackupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param backupId ID of backup.
     * @param request Information on backup request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner listBackupStatusSecrets(String resourceGroupName, String name, String backupId, BackupRequestInner request) {
        return listBackupStatusSecretsWithServiceResponseAsync(resourceGroupName, name, backupId, request).toBlocking().single().body();
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param backupId ID of backup.
     * @param request Information on backup request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupItemInner> listBackupStatusSecretsAsync(String resourceGroupName, String name, String backupId, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceFuture.fromResponse(listBackupStatusSecretsWithServiceResponseAsync(resourceGroupName, name, backupId, request), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param backupId ID of backup.
     * @param request Information on backup request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> listBackupStatusSecretsAsync(String resourceGroupName, String name, String backupId, BackupRequestInner request) {
        return listBackupStatusSecretsWithServiceResponseAsync(resourceGroupName, name, backupId, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param backupId ID of backup.
     * @param request Information on backup request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> listBackupStatusSecretsWithServiceResponseAsync(String resourceGroupName, String name, String backupId, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.listBackupStatusSecrets(resourceGroupName, name, backupId, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = listBackupStatusSecretsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> listBackupStatusSecretsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupItemInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request .
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner restore(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return restoreWithServiceResponseAsync(resourceGroupName, name, backupId, request).toBlocking().last().body();
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request .
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RestoreResponseInner> restoreAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(restoreWithServiceResponseAsync(resourceGroupName, name, backupId, request), serviceCallback);
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request .
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<RestoreResponseInner> restoreAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return restoreWithServiceResponseAsync(resourceGroupName, name, backupId, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request .
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<RestoreResponseInner>> restoreWithServiceResponseAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        Observable<Response<ResponseBody>> observable = service.restore(resourceGroupName, name, backupId, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<RestoreResponseInner>() { }.getType());
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request .
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner beginRestore(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return beginRestoreWithServiceResponseAsync(resourceGroupName, name, backupId, request).toBlocking().single().body();
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request .
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RestoreResponseInner> beginRestoreAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginRestoreWithServiceResponseAsync(resourceGroupName, name, backupId, request), serviceCallback);
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request .
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<RestoreResponseInner> beginRestoreAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return beginRestoreWithServiceResponseAsync(resourceGroupName, name, backupId, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request .
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<ServiceResponse<RestoreResponseInner>> beginRestoreWithServiceResponseAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.beginRestore(resourceGroupName, name, backupId, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreResponseInner> clientResponse = beginRestoreDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreResponseInner> beginRestoreDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RestoreResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RestoreResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteConfigResourceInner&gt; object if successful.
     */
    public PagedList<SiteConfigResourceInner> listConfigurations(final String resourceGroupName, final String name) {
        ServiceResponse<Page<SiteConfigResourceInner>> response = listConfigurationsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<SiteConfigResourceInner>(response.body()) {
            @Override
            public Page<SiteConfigResourceInner> nextPage(String nextPageLink) {
                return listConfigurationsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteConfigResourceInner>> listConfigurationsAsync(final String resourceGroupName, final String name, final ListOperationCallback<SiteConfigResourceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listConfigurationsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SiteConfigResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> call(String nextPageLink) {
                    return listConfigurationsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigResourceInner&gt; object
     */
    public Observable<Page<SiteConfigResourceInner>> listConfigurationsAsync(final String resourceGroupName, final String name) {
        return listConfigurationsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<SiteConfigResourceInner>>, Page<SiteConfigResourceInner>>() {
                @Override
                public Page<SiteConfigResourceInner> call(ServiceResponse<Page<SiteConfigResourceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigResourceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> listConfigurationsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listConfigurationsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SiteConfigResourceInner>>, Observable<ServiceResponse<Page<SiteConfigResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> call(ServiceResponse<Page<SiteConfigResourceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listConfigurationsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
    ServiceResponse<PageImpl<SiteConfigResourceInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SiteConfigResourceInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteConfigResourceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> listConfigurationsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listConfigurations(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteConfigResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteConfigResourceInner>> result = listConfigurationsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteConfigResourceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteConfigResourceInner>> listConfigurationsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteConfigResourceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteConfigResourceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param appSettings Application settings of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateApplicationSettings(String resourceGroupName, String name, StringDictionaryInner appSettings) {
        return updateApplicationSettingsWithServiceResponseAsync(resourceGroupName, name, appSettings).toBlocking().single().body();
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param appSettings Application settings of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> updateApplicationSettingsAsync(String resourceGroupName, String name, StringDictionaryInner appSettings, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateApplicationSettingsWithServiceResponseAsync(resourceGroupName, name, appSettings), serviceCallback);
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param appSettings Application settings of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateApplicationSettingsAsync(String resourceGroupName, String name, StringDictionaryInner appSettings) {
        return updateApplicationSettingsWithServiceResponseAsync(resourceGroupName, name, appSettings).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param appSettings Application settings of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateApplicationSettingsWithServiceResponseAsync(String resourceGroupName, String name, StringDictionaryInner appSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (appSettings == null) {
            throw new IllegalArgumentException("Parameter appSettings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(appSettings);
        return service.updateApplicationSettings(resourceGroupName, name, this.client.subscriptionId(), appSettings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateApplicationSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateApplicationSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listApplicationSettings(String resourceGroupName, String name) {
        return listApplicationSettingsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> listApplicationSettingsAsync(String resourceGroupName, String name, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(listApplicationSettingsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listApplicationSettingsAsync(String resourceGroupName, String name) {
        return listApplicationSettingsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listApplicationSettingsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listApplicationSettings(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listApplicationSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listApplicationSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param siteAuthSettings Auth settings associated with web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner updateAuthSettings(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings) {
        return updateAuthSettingsWithServiceResponseAsync(resourceGroupName, name, siteAuthSettings).toBlocking().single().body();
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param siteAuthSettings Auth settings associated with web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteAuthSettingsInner> updateAuthSettingsAsync(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateAuthSettingsWithServiceResponseAsync(resourceGroupName, name, siteAuthSettings), serviceCallback);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param siteAuthSettings Auth settings associated with web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> updateAuthSettingsAsync(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings) {
        return updateAuthSettingsWithServiceResponseAsync(resourceGroupName, name, siteAuthSettings).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param siteAuthSettings Auth settings associated with web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> updateAuthSettingsWithServiceResponseAsync(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteAuthSettings == null) {
            throw new IllegalArgumentException("Parameter siteAuthSettings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteAuthSettings);
        return service.updateAuthSettings(resourceGroupName, name, this.client.subscriptionId(), siteAuthSettings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = updateAuthSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> updateAuthSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteAuthSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner getAuthSettings(String resourceGroupName, String name) {
        return getAuthSettingsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteAuthSettingsInner> getAuthSettingsAsync(String resourceGroupName, String name, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getAuthSettingsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> getAuthSettingsAsync(String resourceGroupName, String name) {
        return getAuthSettingsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> getAuthSettingsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getAuthSettings(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = getAuthSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> getAuthSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteAuthSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Edited backup configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner updateBackupConfiguration(String resourceGroupName, String name, BackupRequestInner request) {
        return updateBackupConfigurationWithServiceResponseAsync(resourceGroupName, name, request).toBlocking().single().body();
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Edited backup configuration.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupRequestInner> updateBackupConfigurationAsync(String resourceGroupName, String name, BackupRequestInner request, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateBackupConfigurationWithServiceResponseAsync(resourceGroupName, name, request), serviceCallback);
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Edited backup configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> updateBackupConfigurationAsync(String resourceGroupName, String name, BackupRequestInner request) {
        return updateBackupConfigurationWithServiceResponseAsync(resourceGroupName, name, request).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Edited backup configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> updateBackupConfigurationWithServiceResponseAsync(String resourceGroupName, String name, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.updateBackupConfiguration(resourceGroupName, name, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = updateBackupConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> updateBackupConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupRequestInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteBackupConfiguration(String resourceGroupName, String name) {
        deleteBackupConfigurationWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteBackupConfigurationAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteBackupConfigurationWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteBackupConfigurationAsync(String resourceGroupName, String name) {
        return deleteBackupConfigurationWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteBackupConfigurationWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteBackupConfiguration(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteBackupConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteBackupConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner getBackupConfiguration(String resourceGroupName, String name) {
        return getBackupConfigurationWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupRequestInner> getBackupConfigurationAsync(String resourceGroupName, String name, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceFuture.fromResponse(getBackupConfigurationWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> getBackupConfigurationAsync(String resourceGroupName, String name) {
        return getBackupConfigurationWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> getBackupConfigurationWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getBackupConfiguration(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = getBackupConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> getBackupConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupRequestInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner updateConnectionStrings(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings) {
        return updateConnectionStringsWithServiceResponseAsync(resourceGroupName, name, connectionStrings).toBlocking().single().body();
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ConnectionStringDictionaryInner> updateConnectionStringsAsync(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateConnectionStringsWithServiceResponseAsync(resourceGroupName, name, connectionStrings), serviceCallback);
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> updateConnectionStringsAsync(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings) {
        return updateConnectionStringsWithServiceResponseAsync(resourceGroupName, name, connectionStrings).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> updateConnectionStringsWithServiceResponseAsync(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionStrings == null) {
            throw new IllegalArgumentException("Parameter connectionStrings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionStrings);
        return service.updateConnectionStrings(resourceGroupName, name, this.client.subscriptionId(), connectionStrings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = updateConnectionStringsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> updateConnectionStringsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ConnectionStringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner listConnectionStrings(String resourceGroupName, String name) {
        return listConnectionStringsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ConnectionStringDictionaryInner> listConnectionStringsAsync(String resourceGroupName, String name, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(listConnectionStringsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> listConnectionStringsAsync(String resourceGroupName, String name) {
        return listConnectionStringsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> listConnectionStringsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listConnectionStrings(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = listConnectionStringsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> listConnectionStringsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ConnectionStringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner getDiagnosticLogsConfiguration(String resourceGroupName, String name) {
        return getDiagnosticLogsConfigurationWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteLogsConfigInner> getDiagnosticLogsConfigurationAsync(String resourceGroupName, String name, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDiagnosticLogsConfigurationWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> getDiagnosticLogsConfigurationAsync(String resourceGroupName, String name) {
        return getDiagnosticLogsConfigurationWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> getDiagnosticLogsConfigurationWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDiagnosticLogsConfiguration(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = getDiagnosticLogsConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> getDiagnosticLogsConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteLogsConfigInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner updateDiagnosticLogsConfig(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig) {
        return updateDiagnosticLogsConfigWithServiceResponseAsync(resourceGroupName, name, siteLogsConfig).toBlocking().single().body();
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteLogsConfigInner> updateDiagnosticLogsConfigAsync(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateDiagnosticLogsConfigWithServiceResponseAsync(resourceGroupName, name, siteLogsConfig), serviceCallback);
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> updateDiagnosticLogsConfigAsync(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig) {
        return updateDiagnosticLogsConfigWithServiceResponseAsync(resourceGroupName, name, siteLogsConfig).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> updateDiagnosticLogsConfigWithServiceResponseAsync(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteLogsConfig == null) {
            throw new IllegalArgumentException("Parameter siteLogsConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteLogsConfig);
        return service.updateDiagnosticLogsConfig(resourceGroupName, name, this.client.subscriptionId(), siteLogsConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = updateDiagnosticLogsConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> updateDiagnosticLogsConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteLogsConfigInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateMetadata(String resourceGroupName, String name, StringDictionaryInner metadata) {
        return updateMetadataWithServiceResponseAsync(resourceGroupName, name, metadata).toBlocking().single().body();
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> updateMetadataAsync(String resourceGroupName, String name, StringDictionaryInner metadata, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateMetadataWithServiceResponseAsync(resourceGroupName, name, metadata), serviceCallback);
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateMetadataAsync(String resourceGroupName, String name, StringDictionaryInner metadata) {
        return updateMetadataWithServiceResponseAsync(resourceGroupName, name, metadata).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateMetadataWithServiceResponseAsync(String resourceGroupName, String name, StringDictionaryInner metadata) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (metadata == null) {
            throw new IllegalArgumentException("Parameter metadata is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(metadata);
        return service.updateMetadata(resourceGroupName, name, this.client.subscriptionId(), metadata, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateMetadataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listMetadata(String resourceGroupName, String name) {
        return listMetadataWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> listMetadataAsync(String resourceGroupName, String name, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(listMetadataWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listMetadataAsync(String resourceGroupName, String name) {
        return listMetadataWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listMetadataWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listMetadata(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listMetadataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserInner object if successful.
     */
    public UserInner listPublishingCredentials(String resourceGroupName, String name) {
        return listPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).toBlocking().last().body();
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserInner> listPublishingCredentialsAsync(String resourceGroupName, String name, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceFuture.fromResponse(listPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<UserInner> listPublishingCredentialsAsync(String resourceGroupName, String name) {
        return listPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<UserInner>> listPublishingCredentialsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.listPublishingCredentials(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<UserInner>() { }.getType());
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserInner object if successful.
     */
    public UserInner beginListPublishingCredentials(String resourceGroupName, String name) {
        return beginListPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserInner> beginListPublishingCredentialsAsync(String resourceGroupName, String name, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginListPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserInner object
     */
    public Observable<UserInner> beginListPublishingCredentialsAsync(String resourceGroupName, String name) {
        return beginListPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserInner object
     */
    public Observable<ServiceResponse<UserInner>> beginListPublishingCredentialsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginListPublishingCredentials(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserInner>>>() {
                @Override
                public Observable<ServiceResponse<UserInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserInner> clientResponse = beginListPublishingCredentialsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserInner> beginListPublishingCredentialsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UserInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<UserInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param pushSettings Push settings associated with web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushSettingsInner object if successful.
     */
    public PushSettingsInner updateSitePushSettings(String resourceGroupName, String name, PushSettingsInner pushSettings) {
        return updateSitePushSettingsWithServiceResponseAsync(resourceGroupName, name, pushSettings).toBlocking().single().body();
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param pushSettings Push settings associated with web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushSettingsInner> updateSitePushSettingsAsync(String resourceGroupName, String name, PushSettingsInner pushSettings, final ServiceCallback<PushSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateSitePushSettingsWithServiceResponseAsync(resourceGroupName, name, pushSettings), serviceCallback);
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param pushSettings Push settings associated with web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<PushSettingsInner> updateSitePushSettingsAsync(String resourceGroupName, String name, PushSettingsInner pushSettings) {
        return updateSitePushSettingsWithServiceResponseAsync(resourceGroupName, name, pushSettings).map(new Func1<ServiceResponse<PushSettingsInner>, PushSettingsInner>() {
            @Override
            public PushSettingsInner call(ServiceResponse<PushSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param pushSettings Push settings associated with web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<ServiceResponse<PushSettingsInner>> updateSitePushSettingsWithServiceResponseAsync(String resourceGroupName, String name, PushSettingsInner pushSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (pushSettings == null) {
            throw new IllegalArgumentException("Parameter pushSettings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(pushSettings);
        return service.updateSitePushSettings(resourceGroupName, name, this.client.subscriptionId(), pushSettings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<PushSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushSettingsInner> clientResponse = updateSitePushSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushSettingsInner> updateSitePushSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PushSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PushSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushSettingsInner object if successful.
     */
    public PushSettingsInner listSitePushSettings(String resourceGroupName, String name) {
        return listSitePushSettingsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushSettingsInner> listSitePushSettingsAsync(String resourceGroupName, String name, final ServiceCallback<PushSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(listSitePushSettingsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<PushSettingsInner> listSitePushSettingsAsync(String resourceGroupName, String name) {
        return listSitePushSettingsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<PushSettingsInner>, PushSettingsInner>() {
            @Override
            public PushSettingsInner call(ServiceResponse<PushSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<ServiceResponse<PushSettingsInner>> listSitePushSettingsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSitePushSettings(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<PushSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushSettingsInner> clientResponse = listSitePushSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushSettingsInner> listSitePushSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PushSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PushSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SlotConfigNamesResourceInner object if successful.
     */
    public SlotConfigNamesResourceInner listSlotConfigurationNames(String resourceGroupName, String name) {
        return listSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SlotConfigNamesResourceInner> listSlotConfigurationNamesAsync(String resourceGroupName, String name, final ServiceCallback<SlotConfigNamesResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(listSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<SlotConfigNamesResourceInner> listSlotConfigurationNamesAsync(String resourceGroupName, String name) {
        return listSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SlotConfigNamesResourceInner>, SlotConfigNamesResourceInner>() {
            @Override
            public SlotConfigNamesResourceInner call(ServiceResponse<SlotConfigNamesResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<ServiceResponse<SlotConfigNamesResourceInner>> listSlotConfigurationNamesWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSlotConfigurationNames(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SlotConfigNamesResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SlotConfigNamesResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SlotConfigNamesResourceInner> clientResponse = listSlotConfigurationNamesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SlotConfigNamesResourceInner> listSlotConfigurationNamesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SlotConfigNamesResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SlotConfigNamesResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotConfigNames Names of application settings and connection strings. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SlotConfigNamesResourceInner object if successful.
     */
    public SlotConfigNamesResourceInner updateSlotConfigurationNames(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames) {
        return updateSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name, slotConfigNames).toBlocking().single().body();
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotConfigNames Names of application settings and connection strings. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SlotConfigNamesResourceInner> updateSlotConfigurationNamesAsync(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames, final ServiceCallback<SlotConfigNamesResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name, slotConfigNames), serviceCallback);
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotConfigNames Names of application settings and connection strings. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<SlotConfigNamesResourceInner> updateSlotConfigurationNamesAsync(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames) {
        return updateSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name, slotConfigNames).map(new Func1<ServiceResponse<SlotConfigNamesResourceInner>, SlotConfigNamesResourceInner>() {
            @Override
            public SlotConfigNamesResourceInner call(ServiceResponse<SlotConfigNamesResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotConfigNames Names of application settings and connection strings. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<ServiceResponse<SlotConfigNamesResourceInner>> updateSlotConfigurationNamesWithServiceResponseAsync(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotConfigNames == null) {
            throw new IllegalArgumentException("Parameter slotConfigNames is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotConfigNames);
        return service.updateSlotConfigurationNames(resourceGroupName, name, this.client.subscriptionId(), slotConfigNames, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SlotConfigNamesResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SlotConfigNamesResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SlotConfigNamesResourceInner> clientResponse = updateSlotConfigurationNamesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SlotConfigNamesResourceInner> updateSlotConfigurationNamesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SlotConfigNamesResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SlotConfigNamesResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner getConfiguration(String resourceGroupName, String name) {
        return getConfigurationWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> getConfigurationAsync(String resourceGroupName, String name, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getConfigurationWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> getConfigurationAsync(String resourceGroupName, String name) {
        return getConfigurationWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> getConfigurationWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getConfiguration(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = getConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> getConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner createOrUpdateConfiguration(String resourceGroupName, String name, SiteConfigResourceInner siteConfig) {
        return createOrUpdateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig).toBlocking().single().body();
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> createOrUpdateConfigurationAsync(String resourceGroupName, String name, SiteConfigResourceInner siteConfig, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig), serviceCallback);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> createOrUpdateConfigurationAsync(String resourceGroupName, String name, SiteConfigResourceInner siteConfig) {
        return createOrUpdateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> createOrUpdateConfigurationWithServiceResponseAsync(String resourceGroupName, String name, SiteConfigResourceInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        return service.createOrUpdateConfiguration(resourceGroupName, name, this.client.subscriptionId(), siteConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = createOrUpdateConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> createOrUpdateConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner updateConfiguration(String resourceGroupName, String name, SiteConfigResourceInner siteConfig) {
        return updateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig).toBlocking().single().body();
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> updateConfigurationAsync(String resourceGroupName, String name, SiteConfigResourceInner siteConfig, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig), serviceCallback);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> updateConfigurationAsync(String resourceGroupName, String name, SiteConfigResourceInner siteConfig) {
        return updateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> updateConfigurationWithServiceResponseAsync(String resourceGroupName, String name, SiteConfigResourceInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        return service.updateConfiguration(resourceGroupName, name, this.client.subscriptionId(), siteConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = updateConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> updateConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object if successful.
     */
    public PagedList<SiteConfigurationSnapshotInfoInner> listConfigurationSnapshotInfo(final String resourceGroupName, final String name) {
        ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>> response = listConfigurationSnapshotInfoSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<SiteConfigurationSnapshotInfoInner>(response.body()) {
            @Override
            public Page<SiteConfigurationSnapshotInfoInner> nextPage(String nextPageLink) {
                return listConfigurationSnapshotInfoNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoAsync(final String resourceGroupName, final String name, final ListOperationCallback<SiteConfigurationSnapshotInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listConfigurationSnapshotInfoSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> call(String nextPageLink) {
                    return listConfigurationSnapshotInfoNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object
     */
    public Observable<Page<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoAsync(final String resourceGroupName, final String name) {
        return listConfigurationSnapshotInfoWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>, Page<SiteConfigurationSnapshotInfoInner>>() {
                @Override
                public Page<SiteConfigurationSnapshotInfoInner> call(ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> listConfigurationSnapshotInfoWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listConfigurationSnapshotInfoSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>, Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> call(ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listConfigurationSnapshotInfoNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
    ServiceResponse<PageImpl<SiteConfigurationSnapshotInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SiteConfigurationSnapshotInfoInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> listConfigurationSnapshotInfoSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listConfigurationSnapshotInfo(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteConfigurationSnapshotInfoInner>> result = listConfigurationSnapshotInfoDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteConfigurationSnapshotInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteConfigurationSnapshotInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner getConfigurationSnapshot(String resourceGroupName, String name, String snapshotId) {
        return getConfigurationSnapshotWithServiceResponseAsync(resourceGroupName, name, snapshotId).toBlocking().single().body();
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> getConfigurationSnapshotAsync(String resourceGroupName, String name, String snapshotId, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getConfigurationSnapshotWithServiceResponseAsync(resourceGroupName, name, snapshotId), serviceCallback);
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> getConfigurationSnapshotAsync(String resourceGroupName, String name, String snapshotId) {
        return getConfigurationSnapshotWithServiceResponseAsync(resourceGroupName, name, snapshotId).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> getConfigurationSnapshotWithServiceResponseAsync(String resourceGroupName, String name, String snapshotId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (snapshotId == null) {
            throw new IllegalArgumentException("Parameter snapshotId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getConfigurationSnapshot(resourceGroupName, name, snapshotId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = getConfigurationSnapshotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> getConfigurationSnapshotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void recoverSiteConfigurationSnapshot(String resourceGroupName, String name, String snapshotId) {
        recoverSiteConfigurationSnapshotWithServiceResponseAsync(resourceGroupName, name, snapshotId).toBlocking().single().body();
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> recoverSiteConfigurationSnapshotAsync(String resourceGroupName, String name, String snapshotId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(recoverSiteConfigurationSnapshotWithServiceResponseAsync(resourceGroupName, name, snapshotId), serviceCallback);
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> recoverSiteConfigurationSnapshotAsync(String resourceGroupName, String name, String snapshotId) {
        return recoverSiteConfigurationSnapshotWithServiceResponseAsync(resourceGroupName, name, snapshotId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> recoverSiteConfigurationSnapshotWithServiceResponseAsync(String resourceGroupName, String name, String snapshotId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (snapshotId == null) {
            throw new IllegalArgumentException("Parameter snapshotId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.recoverSiteConfigurationSnapshot(resourceGroupName, name, snapshotId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = recoverSiteConfigurationSnapshotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> recoverSiteConfigurationSnapshotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the last lines of docker logs for the given site.
     * Gets the last lines of docker logs for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream getWebSiteContainerLogs(String resourceGroupName, String name) {
        return getWebSiteContainerLogsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the last lines of docker logs for the given site.
     * Gets the last lines of docker logs for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> getWebSiteContainerLogsAsync(String resourceGroupName, String name, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(getWebSiteContainerLogsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the last lines of docker logs for the given site.
     * Gets the last lines of docker logs for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> getWebSiteContainerLogsAsync(String resourceGroupName, String name) {
        return getWebSiteContainerLogsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the last lines of docker logs for the given site.
     * Gets the last lines of docker logs for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> getWebSiteContainerLogsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getWebSiteContainerLogs(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = getWebSiteContainerLogsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> getWebSiteContainerLogsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputStream, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the ZIP archived docker log files for the given site.
     * Gets the ZIP archived docker log files for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream getWebSiteContainerLogsZip(String resourceGroupName, String name) {
        return getWebSiteContainerLogsZipWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the ZIP archived docker log files for the given site.
     * Gets the ZIP archived docker log files for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> getWebSiteContainerLogsZipAsync(String resourceGroupName, String name, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(getWebSiteContainerLogsZipWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the ZIP archived docker log files for the given site.
     * Gets the ZIP archived docker log files for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> getWebSiteContainerLogsZipAsync(String resourceGroupName, String name) {
        return getWebSiteContainerLogsZipWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the ZIP archived docker log files for the given site.
     * Gets the ZIP archived docker log files for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> getWebSiteContainerLogsZipWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getWebSiteContainerLogsZip(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = getWebSiteContainerLogsZipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> getWebSiteContainerLogsZipDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputStream, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ContinuousWebJobInner&gt; object if successful.
     */
    public PagedList<ContinuousWebJobInner> listContinuousWebJobs(final String resourceGroupName, final String name) {
        ServiceResponse<Page<ContinuousWebJobInner>> response = listContinuousWebJobsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<ContinuousWebJobInner>(response.body()) {
            @Override
            public Page<ContinuousWebJobInner> nextPage(String nextPageLink) {
                return listContinuousWebJobsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ContinuousWebJobInner>> listContinuousWebJobsAsync(final String resourceGroupName, final String name, final ListOperationCallback<ContinuousWebJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listContinuousWebJobsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<ContinuousWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> call(String nextPageLink) {
                    return listContinuousWebJobsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ContinuousWebJobInner&gt; object
     */
    public Observable<Page<ContinuousWebJobInner>> listContinuousWebJobsAsync(final String resourceGroupName, final String name) {
        return listContinuousWebJobsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<ContinuousWebJobInner>>, Page<ContinuousWebJobInner>>() {
                @Override
                public Page<ContinuousWebJobInner> call(ServiceResponse<Page<ContinuousWebJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ContinuousWebJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> listContinuousWebJobsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listContinuousWebJobsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<ContinuousWebJobInner>>, Observable<ServiceResponse<Page<ContinuousWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> call(ServiceResponse<Page<ContinuousWebJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listContinuousWebJobsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<ContinuousWebJobInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ContinuousWebJobInner>> * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ContinuousWebJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> listContinuousWebJobsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listContinuousWebJobs(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ContinuousWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ContinuousWebJobInner>> result = listContinuousWebJobsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ContinuousWebJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ContinuousWebJobInner>> listContinuousWebJobsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ContinuousWebJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ContinuousWebJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ContinuousWebJobInner object if successful.
     */
    public ContinuousWebJobInner getContinuousWebJob(String resourceGroupName, String name, String webJobName) {
        return getContinuousWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).toBlocking().single().body();
    }

    /**
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ContinuousWebJobInner> getContinuousWebJobAsync(String resourceGroupName, String name, String webJobName, final ServiceCallback<ContinuousWebJobInner> serviceCallback) {
        return ServiceFuture.fromResponse(getContinuousWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName), serviceCallback);
    }

    /**
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ContinuousWebJobInner object
     */
    public Observable<ContinuousWebJobInner> getContinuousWebJobAsync(String resourceGroupName, String name, String webJobName) {
        return getContinuousWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).map(new Func1<ServiceResponse<ContinuousWebJobInner>, ContinuousWebJobInner>() {
            @Override
            public ContinuousWebJobInner call(ServiceResponse<ContinuousWebJobInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ContinuousWebJobInner object
     */
    public Observable<ServiceResponse<ContinuousWebJobInner>> getContinuousWebJobWithServiceResponseAsync(String resourceGroupName, String name, String webJobName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getContinuousWebJob(resourceGroupName, name, webJobName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ContinuousWebJobInner>>>() {
                @Override
                public Observable<ServiceResponse<ContinuousWebJobInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ContinuousWebJobInner> clientResponse = getContinuousWebJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ContinuousWebJobInner> getContinuousWebJobDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ContinuousWebJobInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ContinuousWebJobInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteContinuousWebJob(String resourceGroupName, String name, String webJobName) {
        deleteContinuousWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).toBlocking().single().body();
    }

    /**
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteContinuousWebJobAsync(String resourceGroupName, String name, String webJobName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteContinuousWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName), serviceCallback);
    }

    /**
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteContinuousWebJobAsync(String resourceGroupName, String name, String webJobName) {
        return deleteContinuousWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteContinuousWebJobWithServiceResponseAsync(String resourceGroupName, String name, String webJobName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteContinuousWebJob(resourceGroupName, name, webJobName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteContinuousWebJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteContinuousWebJobDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Start a continuous web job for an app, or a deployment slot.
     * Start a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startContinuousWebJob(String resourceGroupName, String name, String webJobName) {
        startContinuousWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).toBlocking().single().body();
    }

    /**
     * Start a continuous web job for an app, or a deployment slot.
     * Start a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startContinuousWebJobAsync(String resourceGroupName, String name, String webJobName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startContinuousWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName), serviceCallback);
    }

    /**
     * Start a continuous web job for an app, or a deployment slot.
     * Start a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startContinuousWebJobAsync(String resourceGroupName, String name, String webJobName) {
        return startContinuousWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Start a continuous web job for an app, or a deployment slot.
     * Start a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startContinuousWebJobWithServiceResponseAsync(String resourceGroupName, String name, String webJobName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.startContinuousWebJob(resourceGroupName, name, webJobName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startContinuousWebJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> startContinuousWebJobDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stop a continuous web job for an app, or a deployment slot.
     * Stop a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void stopContinuousWebJob(String resourceGroupName, String name, String webJobName) {
        stopContinuousWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).toBlocking().single().body();
    }

    /**
     * Stop a continuous web job for an app, or a deployment slot.
     * Stop a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> stopContinuousWebJobAsync(String resourceGroupName, String name, String webJobName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(stopContinuousWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName), serviceCallback);
    }

    /**
     * Stop a continuous web job for an app, or a deployment slot.
     * Stop a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stopContinuousWebJobAsync(String resourceGroupName, String name, String webJobName) {
        return stopContinuousWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stop a continuous web job for an app, or a deployment slot.
     * Stop a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stopContinuousWebJobWithServiceResponseAsync(String resourceGroupName, String name, String webJobName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.stopContinuousWebJob(resourceGroupName, name, webJobName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stopContinuousWebJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> stopContinuousWebJobDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listDeployments(final String resourceGroupName, final String name) {
        ServiceResponse<Page<DeploymentInner>> response = listDeploymentsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<DeploymentInner>(response.body()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeploymentInner>> listDeploymentsAsync(final String resourceGroupName, final String name, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDeploymentsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listDeploymentsAsync(final String resourceGroupName, final String name) {
        return listDeploymentsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listDeploymentsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDeploymentsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listDeployments(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listDeploymentsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listDeploymentsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DeploymentInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get a deployment by its ID for an app, or a deployment slot.
     * Get a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner getDeployment(String resourceGroupName, String name, String id) {
        return getDeploymentWithServiceResponseAsync(resourceGroupName, name, id).toBlocking().single().body();
    }

    /**
     * Get a deployment by its ID for an app, or a deployment slot.
     * Get a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeploymentInner> getDeploymentAsync(String resourceGroupName, String name, String id, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeploymentWithServiceResponseAsync(resourceGroupName, name, id), serviceCallback);
    }

    /**
     * Get a deployment by its ID for an app, or a deployment slot.
     * Get a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> getDeploymentAsync(String resourceGroupName, String name, String id) {
        return getDeploymentWithServiceResponseAsync(resourceGroupName, name, id).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a deployment by its ID for an app, or a deployment slot.
     * Get a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDeployment(resourceGroupName, name, id, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DeploymentInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment for an app, or a deployment slot.
     * Create a deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner createDeployment(String resourceGroupName, String name, String id, DeploymentInner deployment) {
        return createDeploymentWithServiceResponseAsync(resourceGroupName, name, id, deployment).toBlocking().single().body();
    }

    /**
     * Create a deployment for an app, or a deployment slot.
     * Create a deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param deployment Deployment details.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeploymentInner> createDeploymentAsync(String resourceGroupName, String name, String id, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceFuture.fromResponse(createDeploymentWithServiceResponseAsync(resourceGroupName, name, id, deployment), serviceCallback);
    }

    /**
     * Create a deployment for an app, or a deployment slot.
     * Create a deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> createDeploymentAsync(String resourceGroupName, String name, String id, DeploymentInner deployment) {
        return createDeploymentWithServiceResponseAsync(resourceGroupName, name, id, deployment).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a deployment for an app, or a deployment slot.
     * Create a deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(deployment);
        return service.createDeployment(resourceGroupName, name, id, this.client.subscriptionId(), deployment, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DeploymentInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a deployment by its ID for an app, or a deployment slot.
     * Delete a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteDeployment(String resourceGroupName, String name, String id) {
        deleteDeploymentWithServiceResponseAsync(resourceGroupName, name, id).toBlocking().single().body();
    }

    /**
     * Delete a deployment by its ID for an app, or a deployment slot.
     * Delete a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteDeploymentAsync(String resourceGroupName, String name, String id, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteDeploymentWithServiceResponseAsync(resourceGroupName, name, id), serviceCallback);
    }

    /**
     * Delete a deployment by its ID for an app, or a deployment slot.
     * Delete a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteDeploymentAsync(String resourceGroupName, String name, String id) {
        return deleteDeploymentWithServiceResponseAsync(resourceGroupName, name, id).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a deployment by its ID for an app, or a deployment slot.
     * Delete a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteDeployment(resourceGroupName, name, id, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployment log for specific deployment for an app, or a deployment slot.
     * List deployment log for specific deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id The ID of a specific deployment. This is the value of the name property in the JSON response from "GET /api/sites/{siteName}/deployments".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner listDeploymentLog(String resourceGroupName, String name, String id) {
        return listDeploymentLogWithServiceResponseAsync(resourceGroupName, name, id).toBlocking().single().body();
    }

    /**
     * List deployment log for specific deployment for an app, or a deployment slot.
     * List deployment log for specific deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id The ID of a specific deployment. This is the value of the name property in the JSON response from "GET /api/sites/{siteName}/deployments".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeploymentInner> listDeploymentLogAsync(String resourceGroupName, String name, String id, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceFuture.fromResponse(listDeploymentLogWithServiceResponseAsync(resourceGroupName, name, id), serviceCallback);
    }

    /**
     * List deployment log for specific deployment for an app, or a deployment slot.
     * List deployment log for specific deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id The ID of a specific deployment. This is the value of the name property in the JSON response from "GET /api/sites/{siteName}/deployments".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> listDeploymentLogAsync(String resourceGroupName, String name, String id) {
        return listDeploymentLogWithServiceResponseAsync(resourceGroupName, name, id).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * List deployment log for specific deployment for an app, or a deployment slot.
     * List deployment log for specific deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id The ID of a specific deployment. This is the value of the name property in the JSON response from "GET /api/sites/{siteName}/deployments".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> listDeploymentLogWithServiceResponseAsync(String resourceGroupName, String name, String id) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listDeploymentLog(resourceGroupName, name, id, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = listDeploymentLogDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> listDeploymentLogDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DeploymentInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;IdentifierInner&gt; object if successful.
     */
    public PagedList<IdentifierInner> listDomainOwnershipIdentifiers(final String resourceGroupName, final String name) {
        ServiceResponse<Page<IdentifierInner>> response = listDomainOwnershipIdentifiersSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<IdentifierInner>(response.body()) {
            @Override
            public Page<IdentifierInner> nextPage(String nextPageLink) {
                return listDomainOwnershipIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IdentifierInner>> listDomainOwnershipIdentifiersAsync(final String resourceGroupName, final String name, final ListOperationCallback<IdentifierInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDomainOwnershipIdentifiersSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(String nextPageLink) {
                    return listDomainOwnershipIdentifiersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<Page<IdentifierInner>> listDomainOwnershipIdentifiersAsync(final String resourceGroupName, final String name) {
        return listDomainOwnershipIdentifiersWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<IdentifierInner>>, Page<IdentifierInner>>() {
                @Override
                public Page<IdentifierInner> call(ServiceResponse<Page<IdentifierInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listDomainOwnershipIdentifiersSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<IdentifierInner>>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(ServiceResponse<Page<IdentifierInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDomainOwnershipIdentifiersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
    ServiceResponse<PageImpl<IdentifierInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<IdentifierInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;IdentifierInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listDomainOwnershipIdentifiers(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<IdentifierInner>> result = listDomainOwnershipIdentifiersDelegate(response);
                        return Observable.just(new ServiceResponse<Page<IdentifierInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<IdentifierInner>> listDomainOwnershipIdentifiersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<IdentifierInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<IdentifierInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IdentifierInner object if successful.
     */
    public IdentifierInner getDomainOwnershipIdentifier(String resourceGroupName, String name, String domainOwnershipIdentifierName) {
        return getDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName).toBlocking().single().body();
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IdentifierInner> getDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, final ServiceCallback<IdentifierInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName), serviceCallback);
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<IdentifierInner> getDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName) {
        return getDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName).map(new Func1<ServiceResponse<IdentifierInner>, IdentifierInner>() {
            @Override
            public IdentifierInner call(ServiceResponse<IdentifierInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<ServiceResponse<IdentifierInner>> getDomainOwnershipIdentifierWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IdentifierInner>>>() {
                @Override
                public Observable<ServiceResponse<IdentifierInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IdentifierInner> clientResponse = getDomainOwnershipIdentifierDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IdentifierInner> getDomainOwnershipIdentifierDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IdentifierInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IdentifierInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IdentifierInner object if successful.
     */
    public IdentifierInner createOrUpdateDomainOwnershipIdentifier(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier) {
        return createOrUpdateDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier).toBlocking().single().body();
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IdentifierInner> createOrUpdateDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier, final ServiceCallback<IdentifierInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier), serviceCallback);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<IdentifierInner> createOrUpdateDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier) {
        return createOrUpdateDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier).map(new Func1<ServiceResponse<IdentifierInner>, IdentifierInner>() {
            @Override
            public IdentifierInner call(ServiceResponse<IdentifierInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<ServiceResponse<IdentifierInner>> createOrUpdateDomainOwnershipIdentifierWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (domainOwnershipIdentifier == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifier is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(domainOwnershipIdentifier);
        return service.createOrUpdateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, this.client.subscriptionId(), domainOwnershipIdentifier, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IdentifierInner>>>() {
                @Override
                public Observable<ServiceResponse<IdentifierInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IdentifierInner> clientResponse = createOrUpdateDomainOwnershipIdentifierDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IdentifierInner> createOrUpdateDomainOwnershipIdentifierDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IdentifierInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IdentifierInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteDomainOwnershipIdentifier(String resourceGroupName, String name, String domainOwnershipIdentifierName) {
        deleteDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName).toBlocking().single().body();
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName), serviceCallback);
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName) {
        return deleteDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteDomainOwnershipIdentifierWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDomainOwnershipIdentifierDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDomainOwnershipIdentifierDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IdentifierInner object if successful.
     */
    public IdentifierInner updateDomainOwnershipIdentifier(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier) {
        return updateDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier).toBlocking().single().body();
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IdentifierInner> updateDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier, final ServiceCallback<IdentifierInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier), serviceCallback);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<IdentifierInner> updateDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier) {
        return updateDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier).map(new Func1<ServiceResponse<IdentifierInner>, IdentifierInner>() {
            @Override
            public IdentifierInner call(ServiceResponse<IdentifierInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<ServiceResponse<IdentifierInner>> updateDomainOwnershipIdentifierWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (domainOwnershipIdentifier == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifier is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(domainOwnershipIdentifier);
        return service.updateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, this.client.subscriptionId(), domainOwnershipIdentifier, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IdentifierInner>>>() {
                @Override
                public Observable<ServiceResponse<IdentifierInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IdentifierInner> clientResponse = updateDomainOwnershipIdentifierDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IdentifierInner> updateDomainOwnershipIdentifierDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IdentifierInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IdentifierInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployStatusInner object if successful.
     */
    public MSDeployStatusInner getMSDeployStatus(String resourceGroupName, String name) {
        return getMSDeployStatusWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployStatusInner> getMSDeployStatusAsync(String resourceGroupName, String name, final ServiceCallback<MSDeployStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMSDeployStatusWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<MSDeployStatusInner> getMSDeployStatusAsync(String resourceGroupName, String name) {
        return getMSDeployStatusWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<MSDeployStatusInner>, MSDeployStatusInner>() {
            @Override
            public MSDeployStatusInner call(ServiceResponse<MSDeployStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<ServiceResponse<MSDeployStatusInner>> getMSDeployStatusWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getMSDeployStatus(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MSDeployStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<MSDeployStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MSDeployStatusInner> clientResponse = getMSDeployStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MSDeployStatusInner> getMSDeployStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MSDeployStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MSDeployStatusInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployStatusInner object if successful.
     */
    public MSDeployStatusInner createMSDeployOperation(String resourceGroupName, String name, MSDeploy mSDeploy) {
        return createMSDeployOperationWithServiceResponseAsync(resourceGroupName, name, mSDeploy).toBlocking().last().body();
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param mSDeploy Details of MSDeploy operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployStatusInner> createMSDeployOperationAsync(String resourceGroupName, String name, MSDeploy mSDeploy, final ServiceCallback<MSDeployStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(createMSDeployOperationWithServiceResponseAsync(resourceGroupName, name, mSDeploy), serviceCallback);
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<MSDeployStatusInner> createMSDeployOperationAsync(String resourceGroupName, String name, MSDeploy mSDeploy) {
        return createMSDeployOperationWithServiceResponseAsync(resourceGroupName, name, mSDeploy).map(new Func1<ServiceResponse<MSDeployStatusInner>, MSDeployStatusInner>() {
            @Override
            public MSDeployStatusInner call(ServiceResponse<MSDeployStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<MSDeployStatusInner>> createMSDeployOperationWithServiceResponseAsync(String resourceGroupName, String name, MSDeploy mSDeploy) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (mSDeploy == null) {
            throw new IllegalArgumentException("Parameter mSDeploy is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(mSDeploy);
        Observable<Response<ResponseBody>> observable = service.createMSDeployOperation(resourceGroupName, name, this.client.subscriptionId(), mSDeploy, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<MSDeployStatusInner>() { }.getType());
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployStatusInner object if successful.
     */
    public MSDeployStatusInner beginCreateMSDeployOperation(String resourceGroupName, String name, MSDeploy mSDeploy) {
        return beginCreateMSDeployOperationWithServiceResponseAsync(resourceGroupName, name, mSDeploy).toBlocking().single().body();
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param mSDeploy Details of MSDeploy operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployStatusInner> beginCreateMSDeployOperationAsync(String resourceGroupName, String name, MSDeploy mSDeploy, final ServiceCallback<MSDeployStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateMSDeployOperationWithServiceResponseAsync(resourceGroupName, name, mSDeploy), serviceCallback);
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<MSDeployStatusInner> beginCreateMSDeployOperationAsync(String resourceGroupName, String name, MSDeploy mSDeploy) {
        return beginCreateMSDeployOperationWithServiceResponseAsync(resourceGroupName, name, mSDeploy).map(new Func1<ServiceResponse<MSDeployStatusInner>, MSDeployStatusInner>() {
            @Override
            public MSDeployStatusInner call(ServiceResponse<MSDeployStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<ServiceResponse<MSDeployStatusInner>> beginCreateMSDeployOperationWithServiceResponseAsync(String resourceGroupName, String name, MSDeploy mSDeploy) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (mSDeploy == null) {
            throw new IllegalArgumentException("Parameter mSDeploy is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(mSDeploy);
        return service.beginCreateMSDeployOperation(resourceGroupName, name, this.client.subscriptionId(), mSDeploy, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MSDeployStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<MSDeployStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MSDeployStatusInner> clientResponse = beginCreateMSDeployOperationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MSDeployStatusInner> beginCreateMSDeployOperationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MSDeployStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<MSDeployStatusInner>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployLogInner object if successful.
     */
    public MSDeployLogInner getMSDeployLog(String resourceGroupName, String name) {
        return getMSDeployLogWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployLogInner> getMSDeployLogAsync(String resourceGroupName, String name, final ServiceCallback<MSDeployLogInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMSDeployLogWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployLogInner object
     */
    public Observable<MSDeployLogInner> getMSDeployLogAsync(String resourceGroupName, String name) {
        return getMSDeployLogWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<MSDeployLogInner>, MSDeployLogInner>() {
            @Override
            public MSDeployLogInner call(ServiceResponse<MSDeployLogInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployLogInner object
     */
    public Observable<ServiceResponse<MSDeployLogInner>> getMSDeployLogWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getMSDeployLog(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MSDeployLogInner>>>() {
                @Override
                public Observable<ServiceResponse<MSDeployLogInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MSDeployLogInner> clientResponse = getMSDeployLogDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MSDeployLogInner> getMSDeployLogDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MSDeployLogInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MSDeployLogInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;FunctionEnvelopeInner&gt; object if successful.
     */
    public PagedList<FunctionEnvelopeInner> listFunctions(final String resourceGroupName, final String name) {
        ServiceResponse<Page<FunctionEnvelopeInner>> response = listFunctionsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<FunctionEnvelopeInner>(response.body()) {
            @Override
            public Page<FunctionEnvelopeInner> nextPage(String nextPageLink) {
                return listFunctionsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FunctionEnvelopeInner>> listFunctionsAsync(final String resourceGroupName, final String name, final ListOperationCallback<FunctionEnvelopeInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listFunctionsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<FunctionEnvelopeInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> call(String nextPageLink) {
                    return listFunctionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;FunctionEnvelopeInner&gt; object
     */
    public Observable<Page<FunctionEnvelopeInner>> listFunctionsAsync(final String resourceGroupName, final String name) {
        return listFunctionsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<FunctionEnvelopeInner>>, Page<FunctionEnvelopeInner>>() {
                @Override
                public Page<FunctionEnvelopeInner> call(ServiceResponse<Page<FunctionEnvelopeInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;FunctionEnvelopeInner&gt; object
     */
    public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> listFunctionsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listFunctionsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<FunctionEnvelopeInner>>, Observable<ServiceResponse<Page<FunctionEnvelopeInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> call(ServiceResponse<Page<FunctionEnvelopeInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listFunctionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
    ServiceResponse<PageImpl<FunctionEnvelopeInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<FunctionEnvelopeInner>> * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;FunctionEnvelopeInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> listFunctionsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listFunctions(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<FunctionEnvelopeInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<FunctionEnvelopeInner>> result = listFunctionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<FunctionEnvelopeInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<FunctionEnvelopeInner>> listFunctionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<FunctionEnvelopeInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<FunctionEnvelopeInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Fetch a short lived token that can be exchanged for a master key.
     * Fetch a short lived token that can be exchanged for a master key.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String getFunctionsAdminToken(String resourceGroupName, String name) {
        return getFunctionsAdminTokenWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Fetch a short lived token that can be exchanged for a master key.
     * Fetch a short lived token that can be exchanged for a master key.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> getFunctionsAdminTokenAsync(String resourceGroupName, String name, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(getFunctionsAdminTokenWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Fetch a short lived token that can be exchanged for a master key.
     * Fetch a short lived token that can be exchanged for a master key.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> getFunctionsAdminTokenAsync(String resourceGroupName, String name) {
        return getFunctionsAdminTokenWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Fetch a short lived token that can be exchanged for a master key.
     * Fetch a short lived token that can be exchanged for a master key.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> getFunctionsAdminTokenWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getFunctionsAdminToken(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = getFunctionsAdminTokenDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> getFunctionsAdminTokenDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<String, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get function information by its ID for web site, or a deployment slot.
     * Get function information by its ID for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionEnvelopeInner object if successful.
     */
    public FunctionEnvelopeInner getFunction(String resourceGroupName, String name, String functionName) {
        return getFunctionWithServiceResponseAsync(resourceGroupName, name, functionName).toBlocking().single().body();
    }

    /**
     * Get function information by its ID for web site, or a deployment slot.
     * Get function information by its ID for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionEnvelopeInner> getFunctionAsync(String resourceGroupName, String name, String functionName, final ServiceCallback<FunctionEnvelopeInner> serviceCallback) {
        return ServiceFuture.fromResponse(getFunctionWithServiceResponseAsync(resourceGroupName, name, functionName), serviceCallback);
    }

    /**
     * Get function information by its ID for web site, or a deployment slot.
     * Get function information by its ID for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionEnvelopeInner object
     */
    public Observable<FunctionEnvelopeInner> getFunctionAsync(String resourceGroupName, String name, String functionName) {
        return getFunctionWithServiceResponseAsync(resourceGroupName, name, functionName).map(new Func1<ServiceResponse<FunctionEnvelopeInner>, FunctionEnvelopeInner>() {
            @Override
            public FunctionEnvelopeInner call(ServiceResponse<FunctionEnvelopeInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get function information by its ID for web site, or a deployment slot.
     * Get function information by its ID for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionEnvelopeInner object
     */
    public Observable<ServiceResponse<FunctionEnvelopeInner>> getFunctionWithServiceResponseAsync(String resourceGroupName, String name, String functionName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getFunction(resourceGroupName, name, functionName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FunctionEnvelopeInner>>>() {
                @Override
                public Observable<ServiceResponse<FunctionEnvelopeInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FunctionEnvelopeInner> clientResponse = getFunctionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FunctionEnvelopeInner> getFunctionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FunctionEnvelopeInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FunctionEnvelopeInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param functionEnvelope Function details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionEnvelopeInner object if successful.
     */
    public FunctionEnvelopeInner createFunction(String resourceGroupName, String name, String functionName, FunctionEnvelopeInner functionEnvelope) {
        return createFunctionWithServiceResponseAsync(resourceGroupName, name, functionName, functionEnvelope).toBlocking().last().body();
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param functionEnvelope Function details.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionEnvelopeInner> createFunctionAsync(String resourceGroupName, String name, String functionName, FunctionEnvelopeInner functionEnvelope, final ServiceCallback<FunctionEnvelopeInner> serviceCallback) {
        return ServiceFuture.fromResponse(createFunctionWithServiceResponseAsync(resourceGroupName, name, functionName, functionEnvelope), serviceCallback);
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param functionEnvelope Function details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<FunctionEnvelopeInner> createFunctionAsync(String resourceGroupName, String name, String functionName, FunctionEnvelopeInner functionEnvelope) {
        return createFunctionWithServiceResponseAsync(resourceGroupName, name, functionName, functionEnvelope).map(new Func1<ServiceResponse<FunctionEnvelopeInner>, FunctionEnvelopeInner>() {
            @Override
            public FunctionEnvelopeInner call(ServiceResponse<FunctionEnvelopeInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param functionEnvelope Function details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<FunctionEnvelopeInner>> createFunctionWithServiceResponseAsync(String resourceGroupName, String name, String functionName, FunctionEnvelopeInner functionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (functionEnvelope == null) {
            throw new IllegalArgumentException("Parameter functionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(functionEnvelope);
        Observable<Response<ResponseBody>> observable = service.createFunction(resourceGroupName, name, functionName, this.client.subscriptionId(), functionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<FunctionEnvelopeInner>() { }.getType());
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param functionEnvelope Function details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionEnvelopeInner object if successful.
     */
    public FunctionEnvelopeInner beginCreateFunction(String resourceGroupName, String name, String functionName, FunctionEnvelopeInner functionEnvelope) {
        return beginCreateFunctionWithServiceResponseAsync(resourceGroupName, name, functionName, functionEnvelope).toBlocking().single().body();
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param functionEnvelope Function details.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionEnvelopeInner> beginCreateFunctionAsync(String resourceGroupName, String name, String functionName, FunctionEnvelopeInner functionEnvelope, final ServiceCallback<FunctionEnvelopeInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateFunctionWithServiceResponseAsync(resourceGroupName, name, functionName, functionEnvelope), serviceCallback);
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param functionEnvelope Function details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionEnvelopeInner object
     */
    public Observable<FunctionEnvelopeInner> beginCreateFunctionAsync(String resourceGroupName, String name, String functionName, FunctionEnvelopeInner functionEnvelope) {
        return beginCreateFunctionWithServiceResponseAsync(resourceGroupName, name, functionName, functionEnvelope).map(new Func1<ServiceResponse<FunctionEnvelopeInner>, FunctionEnvelopeInner>() {
            @Override
            public FunctionEnvelopeInner call(ServiceResponse<FunctionEnvelopeInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param functionEnvelope Function details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionEnvelopeInner object
     */
    public Observable<ServiceResponse<FunctionEnvelopeInner>> beginCreateFunctionWithServiceResponseAsync(String resourceGroupName, String name, String functionName, FunctionEnvelopeInner functionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (functionEnvelope == null) {
            throw new IllegalArgumentException("Parameter functionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(functionEnvelope);
        return service.beginCreateFunction(resourceGroupName, name, functionName, this.client.subscriptionId(), functionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FunctionEnvelopeInner>>>() {
                @Override
                public Observable<ServiceResponse<FunctionEnvelopeInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FunctionEnvelopeInner> clientResponse = beginCreateFunctionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FunctionEnvelopeInner> beginCreateFunctionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FunctionEnvelopeInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<FunctionEnvelopeInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a function for web site, or a deployment slot.
     * Delete a function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteFunction(String resourceGroupName, String name, String functionName) {
        deleteFunctionWithServiceResponseAsync(resourceGroupName, name, functionName).toBlocking().single().body();
    }

    /**
     * Delete a function for web site, or a deployment slot.
     * Delete a function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteFunctionAsync(String resourceGroupName, String name, String functionName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteFunctionWithServiceResponseAsync(resourceGroupName, name, functionName), serviceCallback);
    }

    /**
     * Delete a function for web site, or a deployment slot.
     * Delete a function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteFunctionAsync(String resourceGroupName, String name, String functionName) {
        return deleteFunctionWithServiceResponseAsync(resourceGroupName, name, functionName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a function for web site, or a deployment slot.
     * Delete a function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteFunctionWithServiceResponseAsync(String resourceGroupName, String name, String functionName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteFunction(resourceGroupName, name, functionName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteFunctionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteFunctionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get function secrets for a function in a web site, or a deployment slot.
     * Get function secrets for a function in a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionSecretsInner object if successful.
     */
    public FunctionSecretsInner listFunctionSecrets(String resourceGroupName, String name, String functionName) {
        return listFunctionSecretsWithServiceResponseAsync(resourceGroupName, name, functionName).toBlocking().single().body();
    }

    /**
     * Get function secrets for a function in a web site, or a deployment slot.
     * Get function secrets for a function in a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionSecretsInner> listFunctionSecretsAsync(String resourceGroupName, String name, String functionName, final ServiceCallback<FunctionSecretsInner> serviceCallback) {
        return ServiceFuture.fromResponse(listFunctionSecretsWithServiceResponseAsync(resourceGroupName, name, functionName), serviceCallback);
    }

    /**
     * Get function secrets for a function in a web site, or a deployment slot.
     * Get function secrets for a function in a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionSecretsInner object
     */
    public Observable<FunctionSecretsInner> listFunctionSecretsAsync(String resourceGroupName, String name, String functionName) {
        return listFunctionSecretsWithServiceResponseAsync(resourceGroupName, name, functionName).map(new Func1<ServiceResponse<FunctionSecretsInner>, FunctionSecretsInner>() {
            @Override
            public FunctionSecretsInner call(ServiceResponse<FunctionSecretsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get function secrets for a function in a web site, or a deployment slot.
     * Get function secrets for a function in a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionSecretsInner object
     */
    public Observable<ServiceResponse<FunctionSecretsInner>> listFunctionSecretsWithServiceResponseAsync(String resourceGroupName, String name, String functionName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listFunctionSecrets(resourceGroupName, name, functionName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FunctionSecretsInner>>>() {
                @Override
                public Observable<ServiceResponse<FunctionSecretsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FunctionSecretsInner> clientResponse = listFunctionSecretsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FunctionSecretsInner> listFunctionSecretsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FunctionSecretsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FunctionSecretsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> listHostNameBindings(final String resourceGroupName, final String name) {
        ServiceResponse<Page<HostNameBindingInner>> response = listHostNameBindingsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.body()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return listHostNameBindingsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<HostNameBindingInner>> listHostNameBindingsAsync(final String resourceGroupName, final String name, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listHostNameBindingsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return listHostNameBindingsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> listHostNameBindingsAsync(final String resourceGroupName, final String name) {
        return listHostNameBindingsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listHostNameBindingsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listHostNameBindingsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listHostNameBindings(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = listHostNameBindingsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> listHostNameBindingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<HostNameBindingInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner getHostNameBinding(String resourceGroupName, String name, String hostName) {
        return getHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).toBlocking().single().body();
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HostNameBindingInner> getHostNameBindingAsync(String resourceGroupName, String name, String hostName, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceFuture.fromResponse(getHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName), serviceCallback);
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> getHostNameBindingAsync(String resourceGroupName, String name, String hostName) {
        return getHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> getHostNameBindingWithServiceResponseAsync(String resourceGroupName, String name, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getHostNameBinding(resourceGroupName, name, hostName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = getHostNameBindingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> getHostNameBindingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HostNameBindingInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner createOrUpdateHostNameBinding(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding) {
        return createOrUpdateHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName, hostNameBinding).toBlocking().single().body();
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HostNameBindingInner> createOrUpdateHostNameBindingAsync(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName, hostNameBinding), serviceCallback);
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> createOrUpdateHostNameBindingAsync(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding) {
        return createOrUpdateHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName, hostNameBinding).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> createOrUpdateHostNameBindingWithServiceResponseAsync(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (hostNameBinding == null) {
            throw new IllegalArgumentException("Parameter hostNameBinding is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(hostNameBinding);
        return service.createOrUpdateHostNameBinding(resourceGroupName, name, hostName, this.client.subscriptionId(), hostNameBinding, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = createOrUpdateHostNameBindingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> createOrUpdateHostNameBindingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HostNameBindingInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteHostNameBinding(String resourceGroupName, String name, String hostName) {
        deleteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).toBlocking().single().body();
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteHostNameBindingAsync(String resourceGroupName, String name, String hostName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName), serviceCallback);
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteHostNameBindingAsync(String resourceGroupName, String name, String hostName) {
        return deleteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteHostNameBindingWithServiceResponseAsync(String resourceGroupName, String name, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteHostNameBinding(resourceGroupName, name, hostName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteHostNameBindingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteHostNameBindingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner getHybridConnection(String resourceGroupName, String name, String namespaceName, String relayName) {
        return getHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).toBlocking().single().body();
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> getHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName), serviceCallback);
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> getHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        return getHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> getHybridConnectionWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getHybridConnection(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = getHybridConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> getHybridConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param connectionEnvelope The details of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner createOrUpdateHybridConnection(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        return createOrUpdateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param connectionEnvelope The details of the hybrid connection.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> createOrUpdateHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param connectionEnvelope The details of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> createOrUpdateHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        return createOrUpdateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param connectionEnvelope The details of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> createOrUpdateHybridConnectionWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateHybridConnection(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = createOrUpdateHybridConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> createOrUpdateHybridConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteHybridConnection(String resourceGroupName, String name, String namespaceName, String relayName) {
        deleteHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).toBlocking().single().body();
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName), serviceCallback);
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        return deleteHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteHybridConnectionWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteHybridConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteHybridConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param connectionEnvelope The details of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner updateHybridConnection(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        return updateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param connectionEnvelope The details of the hybrid connection.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> updateHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param connectionEnvelope The details of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> updateHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        return updateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param connectionEnvelope The details of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> updateHybridConnectionWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateHybridConnection(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = updateHybridConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> updateHybridConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionKeyInner object if successful.
     */
    public HybridConnectionKeyInner listHybridConnectionKeys(String resourceGroupName, String name, String namespaceName, String relayName) {
        return listHybridConnectionKeysWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).toBlocking().single().body();
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionKeyInner> listHybridConnectionKeysAsync(String resourceGroupName, String name, String namespaceName, String relayName, final ServiceCallback<HybridConnectionKeyInner> serviceCallback) {
        return ServiceFuture.fromResponse(listHybridConnectionKeysWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName), serviceCallback);
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionKeyInner object
     */
    public Observable<HybridConnectionKeyInner> listHybridConnectionKeysAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        return listHybridConnectionKeysWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).map(new Func1<ServiceResponse<HybridConnectionKeyInner>, HybridConnectionKeyInner>() {
            @Override
            public HybridConnectionKeyInner call(ServiceResponse<HybridConnectionKeyInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionKeyInner object
     */
    public Observable<ServiceResponse<HybridConnectionKeyInner>> listHybridConnectionKeysWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionKeyInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionKeyInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionKeyInner> clientResponse = listHybridConnectionKeysDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionKeyInner> listHybridConnectionKeysDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionKeyInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionKeyInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner listHybridConnections(String resourceGroupName, String name) {
        return listHybridConnectionsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> listHybridConnectionsAsync(String resourceGroupName, String name, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(listHybridConnectionsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> listHybridConnectionsAsync(String resourceGroupName, String name) {
        return listHybridConnectionsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> listHybridConnectionsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listHybridConnections(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = listHybridConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> listHybridConnectionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner listRelayServiceConnections(String resourceGroupName, String name) {
        return listRelayServiceConnectionsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> listRelayServiceConnectionsAsync(String resourceGroupName, String name, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(listRelayServiceConnectionsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> listRelayServiceConnectionsAsync(String resourceGroupName, String name) {
        return listRelayServiceConnectionsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> listRelayServiceConnectionsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listRelayServiceConnections(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = listRelayServiceConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> listRelayServiceConnectionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner getRelayServiceConnection(String resourceGroupName, String name, String entityName) {
        return getRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).toBlocking().single().body();
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> getRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(getRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName), serviceCallback);
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> getRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName) {
        return getRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> getRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = getRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> getRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner createOrUpdateRelayServiceConnection(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> createOrUpdateRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = createOrUpdateRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteRelayServiceConnection(String resourceGroupName, String name, String entityName) {
        deleteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).toBlocking().single().body();
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName), serviceCallback);
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName) {
        return deleteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner updateRelayServiceConnection(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> updateRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> updateRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> updateRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = updateRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> updateRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> listInstanceIdentifiers(final String resourceGroupName, final String name) {
        ServiceResponse<Page<SiteInstanceInner>> response = listInstanceIdentifiersSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.body()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return listInstanceIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInstanceInner>> listInstanceIdentifiersAsync(final String resourceGroupName, final String name, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceIdentifiersSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return listInstanceIdentifiersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> listInstanceIdentifiersAsync(final String resourceGroupName, final String name) {
        return listInstanceIdentifiersWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listInstanceIdentifiersSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceIdentifiersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listInstanceIdentifiers(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = listInstanceIdentifiersDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> listInstanceIdentifiersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInstanceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployStatusInner object if successful.
     */
    public MSDeployStatusInner getInstanceMsDeployStatus(String resourceGroupName, String name, String instanceId) {
        return getInstanceMsDeployStatusWithServiceResponseAsync(resourceGroupName, name, instanceId).toBlocking().single().body();
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployStatusInner> getInstanceMsDeployStatusAsync(String resourceGroupName, String name, String instanceId, final ServiceCallback<MSDeployStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(getInstanceMsDeployStatusWithServiceResponseAsync(resourceGroupName, name, instanceId), serviceCallback);
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<MSDeployStatusInner> getInstanceMsDeployStatusAsync(String resourceGroupName, String name, String instanceId) {
        return getInstanceMsDeployStatusWithServiceResponseAsync(resourceGroupName, name, instanceId).map(new Func1<ServiceResponse<MSDeployStatusInner>, MSDeployStatusInner>() {
            @Override
            public MSDeployStatusInner call(ServiceResponse<MSDeployStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<ServiceResponse<MSDeployStatusInner>> getInstanceMsDeployStatusWithServiceResponseAsync(String resourceGroupName, String name, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceMsDeployStatus(resourceGroupName, name, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MSDeployStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<MSDeployStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MSDeployStatusInner> clientResponse = getInstanceMsDeployStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MSDeployStatusInner> getInstanceMsDeployStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MSDeployStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MSDeployStatusInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployStatusInner object if successful.
     */
    public MSDeployStatusInner createInstanceMSDeployOperation(String resourceGroupName, String name, String instanceId, MSDeploy mSDeploy) {
        return createInstanceMSDeployOperationWithServiceResponseAsync(resourceGroupName, name, instanceId, mSDeploy).toBlocking().last().body();
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployStatusInner> createInstanceMSDeployOperationAsync(String resourceGroupName, String name, String instanceId, MSDeploy mSDeploy, final ServiceCallback<MSDeployStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(createInstanceMSDeployOperationWithServiceResponseAsync(resourceGroupName, name, instanceId, mSDeploy), serviceCallback);
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<MSDeployStatusInner> createInstanceMSDeployOperationAsync(String resourceGroupName, String name, String instanceId, MSDeploy mSDeploy) {
        return createInstanceMSDeployOperationWithServiceResponseAsync(resourceGroupName, name, instanceId, mSDeploy).map(new Func1<ServiceResponse<MSDeployStatusInner>, MSDeployStatusInner>() {
            @Override
            public MSDeployStatusInner call(ServiceResponse<MSDeployStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<MSDeployStatusInner>> createInstanceMSDeployOperationWithServiceResponseAsync(String resourceGroupName, String name, String instanceId, MSDeploy mSDeploy) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (mSDeploy == null) {
            throw new IllegalArgumentException("Parameter mSDeploy is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(mSDeploy);
        Observable<Response<ResponseBody>> observable = service.createInstanceMSDeployOperation(resourceGroupName, name, instanceId, this.client.subscriptionId(), mSDeploy, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<MSDeployStatusInner>() { }.getType());
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployStatusInner object if successful.
     */
    public MSDeployStatusInner beginCreateInstanceMSDeployOperation(String resourceGroupName, String name, String instanceId, MSDeploy mSDeploy) {
        return beginCreateInstanceMSDeployOperationWithServiceResponseAsync(resourceGroupName, name, instanceId, mSDeploy).toBlocking().single().body();
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployStatusInner> beginCreateInstanceMSDeployOperationAsync(String resourceGroupName, String name, String instanceId, MSDeploy mSDeploy, final ServiceCallback<MSDeployStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateInstanceMSDeployOperationWithServiceResponseAsync(resourceGroupName, name, instanceId, mSDeploy), serviceCallback);
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<MSDeployStatusInner> beginCreateInstanceMSDeployOperationAsync(String resourceGroupName, String name, String instanceId, MSDeploy mSDeploy) {
        return beginCreateInstanceMSDeployOperationWithServiceResponseAsync(resourceGroupName, name, instanceId, mSDeploy).map(new Func1<ServiceResponse<MSDeployStatusInner>, MSDeployStatusInner>() {
            @Override
            public MSDeployStatusInner call(ServiceResponse<MSDeployStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<ServiceResponse<MSDeployStatusInner>> beginCreateInstanceMSDeployOperationWithServiceResponseAsync(String resourceGroupName, String name, String instanceId, MSDeploy mSDeploy) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (mSDeploy == null) {
            throw new IllegalArgumentException("Parameter mSDeploy is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(mSDeploy);
        return service.beginCreateInstanceMSDeployOperation(resourceGroupName, name, instanceId, this.client.subscriptionId(), mSDeploy, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MSDeployStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<MSDeployStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MSDeployStatusInner> clientResponse = beginCreateInstanceMSDeployOperationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MSDeployStatusInner> beginCreateInstanceMSDeployOperationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MSDeployStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<MSDeployStatusInner>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployLogInner object if successful.
     */
    public MSDeployLogInner getInstanceMSDeployLog(String resourceGroupName, String name, String instanceId) {
        return getInstanceMSDeployLogWithServiceResponseAsync(resourceGroupName, name, instanceId).toBlocking().single().body();
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployLogInner> getInstanceMSDeployLogAsync(String resourceGroupName, String name, String instanceId, final ServiceCallback<MSDeployLogInner> serviceCallback) {
        return ServiceFuture.fromResponse(getInstanceMSDeployLogWithServiceResponseAsync(resourceGroupName, name, instanceId), serviceCallback);
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployLogInner object
     */
    public Observable<MSDeployLogInner> getInstanceMSDeployLogAsync(String resourceGroupName, String name, String instanceId) {
        return getInstanceMSDeployLogWithServiceResponseAsync(resourceGroupName, name, instanceId).map(new Func1<ServiceResponse<MSDeployLogInner>, MSDeployLogInner>() {
            @Override
            public MSDeployLogInner call(ServiceResponse<MSDeployLogInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployLogInner object
     */
    public Observable<ServiceResponse<MSDeployLogInner>> getInstanceMSDeployLogWithServiceResponseAsync(String resourceGroupName, String name, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceMSDeployLog(resourceGroupName, name, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MSDeployLogInner>>>() {
                @Override
                public Observable<ServiceResponse<MSDeployLogInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MSDeployLogInner> clientResponse = getInstanceMSDeployLogDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MSDeployLogInner> getInstanceMSDeployLogDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MSDeployLogInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MSDeployLogInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessInfoInner&gt; object if successful.
     */
    public PagedList<ProcessInfoInner> listInstanceProcesses(final String resourceGroupName, final String name, final String instanceId) {
        ServiceResponse<Page<ProcessInfoInner>> response = listInstanceProcessesSinglePageAsync(resourceGroupName, name, instanceId).toBlocking().single();
        return new PagedList<ProcessInfoInner>(response.body()) {
            @Override
            public Page<ProcessInfoInner> nextPage(String nextPageLink) {
                return listInstanceProcessesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessInfoInner>> listInstanceProcessesAsync(final String resourceGroupName, final String name, final String instanceId, final ListOperationCallback<ProcessInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceProcessesSinglePageAsync(resourceGroupName, name, instanceId),
            new Func1<String, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(String nextPageLink) {
                    return listInstanceProcessesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<Page<ProcessInfoInner>> listInstanceProcessesAsync(final String resourceGroupName, final String name, final String instanceId) {
        return listInstanceProcessesWithServiceResponseAsync(resourceGroupName, name, instanceId)
            .map(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Page<ProcessInfoInner>>() {
                @Override
                public Page<ProcessInfoInner> call(ServiceResponse<Page<ProcessInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listInstanceProcessesWithServiceResponseAsync(final String resourceGroupName, final String name, final String instanceId) {
        return listInstanceProcessesSinglePageAsync(resourceGroupName, name, instanceId)
            .concatMap(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(ServiceResponse<Page<ProcessInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceProcessesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param name Site name.
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listInstanceProcessesSinglePageAsync(final String resourceGroupName, final String name, final String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listInstanceProcesses(resourceGroupName, name, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessInfoInner>> result = listInstanceProcessesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessInfoInner>> listInstanceProcessesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProcessInfoInner object if successful.
     */
    public ProcessInfoInner getInstanceProcess(String resourceGroupName, String name, String processId, String instanceId) {
        return getInstanceProcessWithServiceResponseAsync(resourceGroupName, name, processId, instanceId).toBlocking().single().body();
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProcessInfoInner> getInstanceProcessAsync(String resourceGroupName, String name, String processId, String instanceId, final ServiceCallback<ProcessInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getInstanceProcessWithServiceResponseAsync(resourceGroupName, name, processId, instanceId), serviceCallback);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessInfoInner object
     */
    public Observable<ProcessInfoInner> getInstanceProcessAsync(String resourceGroupName, String name, String processId, String instanceId) {
        return getInstanceProcessWithServiceResponseAsync(resourceGroupName, name, processId, instanceId).map(new Func1<ServiceResponse<ProcessInfoInner>, ProcessInfoInner>() {
            @Override
            public ProcessInfoInner call(ServiceResponse<ProcessInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessInfoInner object
     */
    public Observable<ServiceResponse<ProcessInfoInner>> getInstanceProcessWithServiceResponseAsync(String resourceGroupName, String name, String processId, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceProcess(resourceGroupName, name, processId, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProcessInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ProcessInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProcessInfoInner> clientResponse = getInstanceProcessDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProcessInfoInner> getInstanceProcessDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProcessInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProcessInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteInstanceProcess(String resourceGroupName, String name, String processId, String instanceId) {
        deleteInstanceProcessWithServiceResponseAsync(resourceGroupName, name, processId, instanceId).toBlocking().single().body();
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteInstanceProcessAsync(String resourceGroupName, String name, String processId, String instanceId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteInstanceProcessWithServiceResponseAsync(resourceGroupName, name, processId, instanceId), serviceCallback);
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteInstanceProcessAsync(String resourceGroupName, String name, String processId, String instanceId) {
        return deleteInstanceProcessWithServiceResponseAsync(resourceGroupName, name, processId, instanceId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteInstanceProcessWithServiceResponseAsync(String resourceGroupName, String name, String processId, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteInstanceProcess(resourceGroupName, name, processId, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteInstanceProcessDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteInstanceProcessDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream getInstanceProcessDump(String resourceGroupName, String name, String processId, String instanceId) {
        return getInstanceProcessDumpWithServiceResponseAsync(resourceGroupName, name, processId, instanceId).toBlocking().single().body();
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> getInstanceProcessDumpAsync(String resourceGroupName, String name, String processId, String instanceId, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(getInstanceProcessDumpWithServiceResponseAsync(resourceGroupName, name, processId, instanceId), serviceCallback);
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> getInstanceProcessDumpAsync(String resourceGroupName, String name, String processId, String instanceId) {
        return getInstanceProcessDumpWithServiceResponseAsync(resourceGroupName, name, processId, instanceId).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> getInstanceProcessDumpWithServiceResponseAsync(String resourceGroupName, String name, String processId, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceProcessDump(resourceGroupName, name, processId, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = getInstanceProcessDumpDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> getInstanceProcessDumpDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputStream, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object if successful.
     */
    public PagedList<ProcessModuleInfoInner> listInstanceProcessModules(final String resourceGroupName, final String name, final String processId, final String instanceId) {
        ServiceResponse<Page<ProcessModuleInfoInner>> response = listInstanceProcessModulesSinglePageAsync(resourceGroupName, name, processId, instanceId).toBlocking().single();
        return new PagedList<ProcessModuleInfoInner>(response.body()) {
            @Override
            public Page<ProcessModuleInfoInner> nextPage(String nextPageLink) {
                return listInstanceProcessModulesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessModuleInfoInner>> listInstanceProcessModulesAsync(final String resourceGroupName, final String name, final String processId, final String instanceId, final ListOperationCallback<ProcessModuleInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceProcessModulesSinglePageAsync(resourceGroupName, name, processId, instanceId),
            new Func1<String, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(String nextPageLink) {
                    return listInstanceProcessModulesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<Page<ProcessModuleInfoInner>> listInstanceProcessModulesAsync(final String resourceGroupName, final String name, final String processId, final String instanceId) {
        return listInstanceProcessModulesWithServiceResponseAsync(resourceGroupName, name, processId, instanceId)
            .map(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Page<ProcessModuleInfoInner>>() {
                @Override
                public Page<ProcessModuleInfoInner> call(ServiceResponse<Page<ProcessModuleInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listInstanceProcessModulesWithServiceResponseAsync(final String resourceGroupName, final String name, final String processId, final String instanceId) {
        return listInstanceProcessModulesSinglePageAsync(resourceGroupName, name, processId, instanceId)
            .concatMap(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(ServiceResponse<Page<ProcessModuleInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceProcessModulesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param name Site name.
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param processId PID.
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listInstanceProcessModulesSinglePageAsync(final String resourceGroupName, final String name, final String processId, final String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listInstanceProcessModules(resourceGroupName, name, processId, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessModuleInfoInner>> result = listInstanceProcessModulesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessModuleInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessModuleInfoInner>> listInstanceProcessModulesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessModuleInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessModuleInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProcessModuleInfoInner object if successful.
     */
    public ProcessModuleInfoInner getInstanceProcessModule(String resourceGroupName, String name, String processId, String baseAddress, String instanceId) {
        return getInstanceProcessModuleWithServiceResponseAsync(resourceGroupName, name, processId, baseAddress, instanceId).toBlocking().single().body();
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProcessModuleInfoInner> getInstanceProcessModuleAsync(String resourceGroupName, String name, String processId, String baseAddress, String instanceId, final ServiceCallback<ProcessModuleInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getInstanceProcessModuleWithServiceResponseAsync(resourceGroupName, name, processId, baseAddress, instanceId), serviceCallback);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessModuleInfoInner object
     */
    public Observable<ProcessModuleInfoInner> getInstanceProcessModuleAsync(String resourceGroupName, String name, String processId, String baseAddress, String instanceId) {
        return getInstanceProcessModuleWithServiceResponseAsync(resourceGroupName, name, processId, baseAddress, instanceId).map(new Func1<ServiceResponse<ProcessModuleInfoInner>, ProcessModuleInfoInner>() {
            @Override
            public ProcessModuleInfoInner call(ServiceResponse<ProcessModuleInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessModuleInfoInner object
     */
    public Observable<ServiceResponse<ProcessModuleInfoInner>> getInstanceProcessModuleWithServiceResponseAsync(String resourceGroupName, String name, String processId, String baseAddress, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (baseAddress == null) {
            throw new IllegalArgumentException("Parameter baseAddress is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceProcessModule(resourceGroupName, name, processId, baseAddress, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProcessModuleInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ProcessModuleInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProcessModuleInfoInner> clientResponse = getInstanceProcessModuleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProcessModuleInfoInner> getInstanceProcessModuleDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProcessModuleInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProcessModuleInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object if successful.
     */
    public PagedList<ProcessThreadInfoInner> listInstanceProcessThreads(final String resourceGroupName, final String name, final String processId, final String instanceId) {
        ServiceResponse<Page<ProcessThreadInfoInner>> response = listInstanceProcessThreadsSinglePageAsync(resourceGroupName, name, processId, instanceId).toBlocking().single();
        return new PagedList<ProcessThreadInfoInner>(response.body()) {
            @Override
            public Page<ProcessThreadInfoInner> nextPage(String nextPageLink) {
                return listInstanceProcessThreadsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessThreadInfoInner>> listInstanceProcessThreadsAsync(final String resourceGroupName, final String name, final String processId, final String instanceId, final ListOperationCallback<ProcessThreadInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceProcessThreadsSinglePageAsync(resourceGroupName, name, processId, instanceId),
            new Func1<String, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(String nextPageLink) {
                    return listInstanceProcessThreadsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<Page<ProcessThreadInfoInner>> listInstanceProcessThreadsAsync(final String resourceGroupName, final String name, final String processId, final String instanceId) {
        return listInstanceProcessThreadsWithServiceResponseAsync(resourceGroupName, name, processId, instanceId)
            .map(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Page<ProcessThreadInfoInner>>() {
                @Override
                public Page<ProcessThreadInfoInner> call(ServiceResponse<Page<ProcessThreadInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listInstanceProcessThreadsWithServiceResponseAsync(final String resourceGroupName, final String name, final String processId, final String instanceId) {
        return listInstanceProcessThreadsSinglePageAsync(resourceGroupName, name, processId, instanceId)
            .concatMap(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(ServiceResponse<Page<ProcessThreadInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceProcessThreadsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param name Site name.
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param processId PID.
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listInstanceProcessThreadsSinglePageAsync(final String resourceGroupName, final String name, final String processId, final String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listInstanceProcessThreads(resourceGroupName, name, processId, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessThreadInfoInner>> result = listInstanceProcessThreadsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessThreadInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessThreadInfoInner>> listInstanceProcessThreadsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessThreadInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessThreadInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProcessThreadInfoInner object if successful.
     */
    public ProcessThreadInfoInner getInstanceProcessThread(String resourceGroupName, String name, String processId, String threadId, String instanceId) {
        return getInstanceProcessThreadWithServiceResponseAsync(resourceGroupName, name, processId, threadId, instanceId).toBlocking().single().body();
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProcessThreadInfoInner> getInstanceProcessThreadAsync(String resourceGroupName, String name, String processId, String threadId, String instanceId, final ServiceCallback<ProcessThreadInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getInstanceProcessThreadWithServiceResponseAsync(resourceGroupName, name, processId, threadId, instanceId), serviceCallback);
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessThreadInfoInner object
     */
    public Observable<ProcessThreadInfoInner> getInstanceProcessThreadAsync(String resourceGroupName, String name, String processId, String threadId, String instanceId) {
        return getInstanceProcessThreadWithServiceResponseAsync(resourceGroupName, name, processId, threadId, instanceId).map(new Func1<ServiceResponse<ProcessThreadInfoInner>, ProcessThreadInfoInner>() {
            @Override
            public ProcessThreadInfoInner call(ServiceResponse<ProcessThreadInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessThreadInfoInner object
     */
    public Observable<ServiceResponse<ProcessThreadInfoInner>> getInstanceProcessThreadWithServiceResponseAsync(String resourceGroupName, String name, String processId, String threadId, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (threadId == null) {
            throw new IllegalArgumentException("Parameter threadId is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceProcessThread(resourceGroupName, name, processId, threadId, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProcessThreadInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ProcessThreadInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProcessThreadInfoInner> clientResponse = getInstanceProcessThreadDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProcessThreadInfoInner> getInstanceProcessThreadDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProcessThreadInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProcessThreadInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteCloneabilityInner object if successful.
     */
    public SiteCloneabilityInner isCloneable(String resourceGroupName, String name) {
        return isCloneableWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteCloneabilityInner> isCloneableAsync(String resourceGroupName, String name, final ServiceCallback<SiteCloneabilityInner> serviceCallback) {
        return ServiceFuture.fromResponse(isCloneableWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<SiteCloneabilityInner> isCloneableAsync(String resourceGroupName, String name) {
        return isCloneableWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteCloneabilityInner>, SiteCloneabilityInner>() {
            @Override
            public SiteCloneabilityInner call(ServiceResponse<SiteCloneabilityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<ServiceResponse<SiteCloneabilityInner>> isCloneableWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.isCloneable(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteCloneabilityInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteCloneabilityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteCloneabilityInner> clientResponse = isCloneableDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteCloneabilityInner> isCloneableDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteCloneabilityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteCloneabilityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * This is to allow calling via powershell and ARM template.
     * This is to allow calling via powershell and ARM template.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionSecretsInner object if successful.
     */
    public FunctionSecretsInner listSyncFunctionTriggers(String resourceGroupName, String name) {
        return listSyncFunctionTriggersWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * This is to allow calling via powershell and ARM template.
     * This is to allow calling via powershell and ARM template.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionSecretsInner> listSyncFunctionTriggersAsync(String resourceGroupName, String name, final ServiceCallback<FunctionSecretsInner> serviceCallback) {
        return ServiceFuture.fromResponse(listSyncFunctionTriggersWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * This is to allow calling via powershell and ARM template.
     * This is to allow calling via powershell and ARM template.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionSecretsInner object
     */
    public Observable<FunctionSecretsInner> listSyncFunctionTriggersAsync(String resourceGroupName, String name) {
        return listSyncFunctionTriggersWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<FunctionSecretsInner>, FunctionSecretsInner>() {
            @Override
            public FunctionSecretsInner call(ServiceResponse<FunctionSecretsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * This is to allow calling via powershell and ARM template.
     * This is to allow calling via powershell and ARM template.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionSecretsInner object
     */
    public Observable<ServiceResponse<FunctionSecretsInner>> listSyncFunctionTriggersWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSyncFunctionTriggers(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FunctionSecretsInner>>>() {
                @Override
                public Observable<ServiceResponse<FunctionSecretsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FunctionSecretsInner> clientResponse = listSyncFunctionTriggersDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FunctionSecretsInner> listSyncFunctionTriggersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FunctionSecretsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FunctionSecretsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object if successful.
     */
    public PagedList<ResourceMetricDefinitionInner> listMetricDefinitions(final String resourceGroupName, final String name) {
        ServiceResponse<Page<ResourceMetricDefinitionInner>> response = listMetricDefinitionsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<ResourceMetricDefinitionInner>(response.body()) {
            @Override
            public Page<ResourceMetricDefinitionInner> nextPage(String nextPageLink) {
                return listMetricDefinitionsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricDefinitionInner>> listMetricDefinitionsAsync(final String resourceGroupName, final String name, final ListOperationCallback<ResourceMetricDefinitionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricDefinitionsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(String nextPageLink) {
                    return listMetricDefinitionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<Page<ResourceMetricDefinitionInner>> listMetricDefinitionsAsync(final String resourceGroupName, final String name) {
        return listMetricDefinitionsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Page<ResourceMetricDefinitionInner>>() {
                @Override
                public Page<ResourceMetricDefinitionInner> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listMetricDefinitionsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricDefinitionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listMetricDefinitions(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> result = listMetricDefinitionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricDefinitionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> listMetricDefinitionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricDefinitionInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetrics(final String resourceGroupName, final String name) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.body()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name) {
        return listMetricsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listMetricsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean details = null;
        final String filter = null;
        return service.listMetrics(resourceGroupName, name, this.client.subscriptionId(), details, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetrics(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSinglePageAsync(resourceGroupName, name, details, filter).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.body()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name, final Boolean details, final String filter, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsSinglePageAsync(resourceGroupName, name, details, filter),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        return listMetricsWithServiceResponseAsync(resourceGroupName, name, details, filter)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsWithServiceResponseAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        return listMetricsSinglePageAsync(resourceGroupName, name, details, filter)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param details Specify "true" to include metric details in the response. It is "false" by default.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSinglePageAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listMetrics(resourceGroupName, name, this.client.subscriptionId(), details, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> listMetricsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param subscriptionName Azure subscription.
     * @param migrationOptions Migration migrationOptions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageMigrationResponseInner object if successful.
     */
    public StorageMigrationResponseInner migrateStorage(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptions migrationOptions) {
        return migrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, migrationOptions).toBlocking().last().body();
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param subscriptionName Azure subscription.
     * @param migrationOptions Migration migrationOptions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageMigrationResponseInner> migrateStorageAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptions migrationOptions, final ServiceCallback<StorageMigrationResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(migrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, migrationOptions), serviceCallback);
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param subscriptionName Azure subscription.
     * @param migrationOptions Migration migrationOptions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<StorageMigrationResponseInner> migrateStorageAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptions migrationOptions) {
        return migrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, migrationOptions).map(new Func1<ServiceResponse<StorageMigrationResponseInner>, StorageMigrationResponseInner>() {
            @Override
            public StorageMigrationResponseInner call(ServiceResponse<StorageMigrationResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param subscriptionName Azure subscription.
     * @param migrationOptions Migration migrationOptions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<StorageMigrationResponseInner>> migrateStorageWithServiceResponseAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptions migrationOptions) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (subscriptionName == null) {
            throw new IllegalArgumentException("Parameter subscriptionName is required and cannot be null.");
        }
        if (migrationOptions == null) {
            throw new IllegalArgumentException("Parameter migrationOptions is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(migrationOptions);
        Observable<Response<ResponseBody>> observable = service.migrateStorage(resourceGroupName, name, this.client.subscriptionId(), subscriptionName, migrationOptions, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<StorageMigrationResponseInner>() { }.getType());
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param subscriptionName Azure subscription.
     * @param migrationOptions Migration migrationOptions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageMigrationResponseInner object if successful.
     */
    public StorageMigrationResponseInner beginMigrateStorage(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptions migrationOptions) {
        return beginMigrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, migrationOptions).toBlocking().single().body();
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param subscriptionName Azure subscription.
     * @param migrationOptions Migration migrationOptions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageMigrationResponseInner> beginMigrateStorageAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptions migrationOptions, final ServiceCallback<StorageMigrationResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginMigrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, migrationOptions), serviceCallback);
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param subscriptionName Azure subscription.
     * @param migrationOptions Migration migrationOptions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageMigrationResponseInner object
     */
    public Observable<StorageMigrationResponseInner> beginMigrateStorageAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptions migrationOptions) {
        return beginMigrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, migrationOptions).map(new Func1<ServiceResponse<StorageMigrationResponseInner>, StorageMigrationResponseInner>() {
            @Override
            public StorageMigrationResponseInner call(ServiceResponse<StorageMigrationResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param subscriptionName Azure subscription.
     * @param migrationOptions Migration migrationOptions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageMigrationResponseInner object
     */
    public Observable<ServiceResponse<StorageMigrationResponseInner>> beginMigrateStorageWithServiceResponseAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptions migrationOptions) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (subscriptionName == null) {
            throw new IllegalArgumentException("Parameter subscriptionName is required and cannot be null.");
        }
        if (migrationOptions == null) {
            throw new IllegalArgumentException("Parameter migrationOptions is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(migrationOptions);
        return service.beginMigrateStorage(resourceGroupName, name, this.client.subscriptionId(), subscriptionName, migrationOptions, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StorageMigrationResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<StorageMigrationResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StorageMigrationResponseInner> clientResponse = beginMigrateStorageDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StorageMigrationResponseInner> beginMigrateStorageDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StorageMigrationResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StorageMigrationResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationRequestEnvelope MySql migration options.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationInner object if successful.
     */
    public OperationInner migrateMySql(String resourceGroupName, String name, MigrateMySqlRequest migrationRequestEnvelope) {
        return migrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope).toBlocking().last().body();
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationRequestEnvelope MySql migration options.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationInner> migrateMySqlAsync(String resourceGroupName, String name, MigrateMySqlRequest migrationRequestEnvelope, final ServiceCallback<OperationInner> serviceCallback) {
        return ServiceFuture.fromResponse(migrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope), serviceCallback);
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationRequestEnvelope MySql migration options.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationInner> migrateMySqlAsync(String resourceGroupName, String name, MigrateMySqlRequest migrationRequestEnvelope) {
        return migrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope).map(new Func1<ServiceResponse<OperationInner>, OperationInner>() {
            @Override
            public OperationInner call(ServiceResponse<OperationInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationRequestEnvelope MySql migration options.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<OperationInner>> migrateMySqlWithServiceResponseAsync(String resourceGroupName, String name, MigrateMySqlRequest migrationRequestEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (migrationRequestEnvelope == null) {
            throw new IllegalArgumentException("Parameter migrationRequestEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(migrationRequestEnvelope);
        Observable<Response<ResponseBody>> observable = service.migrateMySql(resourceGroupName, name, this.client.subscriptionId(), migrationRequestEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<OperationInner>() { }.getType());
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationRequestEnvelope MySql migration options.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationInner object if successful.
     */
    public OperationInner beginMigrateMySql(String resourceGroupName, String name, MigrateMySqlRequest migrationRequestEnvelope) {
        return beginMigrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope).toBlocking().single().body();
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationRequestEnvelope MySql migration options.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationInner> beginMigrateMySqlAsync(String resourceGroupName, String name, MigrateMySqlRequest migrationRequestEnvelope, final ServiceCallback<OperationInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginMigrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope), serviceCallback);
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationRequestEnvelope MySql migration options.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationInner object
     */
    public Observable<OperationInner> beginMigrateMySqlAsync(String resourceGroupName, String name, MigrateMySqlRequest migrationRequestEnvelope) {
        return beginMigrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope).map(new Func1<ServiceResponse<OperationInner>, OperationInner>() {
            @Override
            public OperationInner call(ServiceResponse<OperationInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationRequestEnvelope MySql migration options.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationInner object
     */
    public Observable<ServiceResponse<OperationInner>> beginMigrateMySqlWithServiceResponseAsync(String resourceGroupName, String name, MigrateMySqlRequest migrationRequestEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (migrationRequestEnvelope == null) {
            throw new IllegalArgumentException("Parameter migrationRequestEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(migrationRequestEnvelope);
        return service.beginMigrateMySql(resourceGroupName, name, this.client.subscriptionId(), migrationRequestEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationInner> clientResponse = beginMigrateMySqlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationInner> beginMigrateMySqlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MigrateMySqlStatusInner object if successful.
     */
    public MigrateMySqlStatusInner getMigrateMySqlStatus(String resourceGroupName, String name) {
        return getMigrateMySqlStatusWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MigrateMySqlStatusInner> getMigrateMySqlStatusAsync(String resourceGroupName, String name, final ServiceCallback<MigrateMySqlStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMigrateMySqlStatusWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MigrateMySqlStatusInner object
     */
    public Observable<MigrateMySqlStatusInner> getMigrateMySqlStatusAsync(String resourceGroupName, String name) {
        return getMigrateMySqlStatusWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<MigrateMySqlStatusInner>, MigrateMySqlStatusInner>() {
            @Override
            public MigrateMySqlStatusInner call(ServiceResponse<MigrateMySqlStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MigrateMySqlStatusInner object
     */
    public Observable<ServiceResponse<MigrateMySqlStatusInner>> getMigrateMySqlStatusWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getMigrateMySqlStatus(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MigrateMySqlStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<MigrateMySqlStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MigrateMySqlStatusInner> clientResponse = getMigrateMySqlStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MigrateMySqlStatusInner> getMigrateMySqlStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MigrateMySqlStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MigrateMySqlStatusInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NetworkFeaturesInner object if successful.
     */
    public NetworkFeaturesInner listNetworkFeatures(String resourceGroupName, String name, String view) {
        return listNetworkFeaturesWithServiceResponseAsync(resourceGroupName, name, view).toBlocking().single().body();
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NetworkFeaturesInner> listNetworkFeaturesAsync(String resourceGroupName, String name, String view, final ServiceCallback<NetworkFeaturesInner> serviceCallback) {
        return ServiceFuture.fromResponse(listNetworkFeaturesWithServiceResponseAsync(resourceGroupName, name, view), serviceCallback);
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<NetworkFeaturesInner> listNetworkFeaturesAsync(String resourceGroupName, String name, String view) {
        return listNetworkFeaturesWithServiceResponseAsync(resourceGroupName, name, view).map(new Func1<ServiceResponse<NetworkFeaturesInner>, NetworkFeaturesInner>() {
            @Override
            public NetworkFeaturesInner call(ServiceResponse<NetworkFeaturesInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<ServiceResponse<NetworkFeaturesInner>> listNetworkFeaturesWithServiceResponseAsync(String resourceGroupName, String name, String view) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (view == null) {
            throw new IllegalArgumentException("Parameter view is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listNetworkFeatures(resourceGroupName, name, view, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NetworkFeaturesInner>>>() {
                @Override
                public Observable<ServiceResponse<NetworkFeaturesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NetworkFeaturesInner> clientResponse = listNetworkFeaturesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NetworkFeaturesInner> listNetworkFeaturesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<NetworkFeaturesInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<NetworkFeaturesInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String startWebSiteNetworkTrace(String resourceGroupName, String name) {
        return startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> startWebSiteNetworkTraceAsync(String resourceGroupName, String name, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> startWebSiteNetworkTraceAsync(String resourceGroupName, String name) {
        return startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> startWebSiteNetworkTraceWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Integer durationInSeconds = null;
        final Integer maxFrameLength = null;
        final String sasUrl = null;
        return service.startWebSiteNetworkTrace(resourceGroupName, name, this.client.subscriptionId(), durationInSeconds, maxFrameLength, sasUrl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = startWebSiteNetworkTraceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String startWebSiteNetworkTrace(String resourceGroupName, String name, Integer durationInSeconds, Integer maxFrameLength, String sasUrl) {
        return startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name, durationInSeconds, maxFrameLength, sasUrl).toBlocking().single().body();
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> startWebSiteNetworkTraceAsync(String resourceGroupName, String name, Integer durationInSeconds, Integer maxFrameLength, String sasUrl, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name, durationInSeconds, maxFrameLength, sasUrl), serviceCallback);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> startWebSiteNetworkTraceAsync(String resourceGroupName, String name, Integer durationInSeconds, Integer maxFrameLength, String sasUrl) {
        return startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name, durationInSeconds, maxFrameLength, sasUrl).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> startWebSiteNetworkTraceWithServiceResponseAsync(String resourceGroupName, String name, Integer durationInSeconds, Integer maxFrameLength, String sasUrl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.startWebSiteNetworkTrace(resourceGroupName, name, this.client.subscriptionId(), durationInSeconds, maxFrameLength, sasUrl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = startWebSiteNetworkTraceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> startWebSiteNetworkTraceDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<String, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String stopWebSiteNetworkTrace(String resourceGroupName, String name) {
        return stopWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> stopWebSiteNetworkTraceAsync(String resourceGroupName, String name, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(stopWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> stopWebSiteNetworkTraceAsync(String resourceGroupName, String name) {
        return stopWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> stopWebSiteNetworkTraceWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.stopWebSiteNetworkTrace(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = stopWebSiteNetworkTraceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> stopWebSiteNetworkTraceDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<String, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void generateNewSitePublishingPassword(String resourceGroupName, String name) {
        generateNewSitePublishingPasswordWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> generateNewSitePublishingPasswordAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(generateNewSitePublishingPasswordWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> generateNewSitePublishingPasswordAsync(String resourceGroupName, String name) {
        return generateNewSitePublishingPasswordWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> generateNewSitePublishingPasswordWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.generateNewSitePublishingPassword(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = generateNewSitePublishingPasswordDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> generateNewSitePublishingPasswordDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCounters(final String resourceGroupName, final String name) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.body()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PerfMonResponseInner>> listPerfMonCountersAsync(final String resourceGroupName, final String name, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPerfMonCountersSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersAsync(final String resourceGroupName, final String name) {
        return listPerfMonCountersWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listPerfMonCountersSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        return service.listPerfMonCounters(resourceGroupName, name, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCounters(final String resourceGroupName, final String name, final String filter) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersSinglePageAsync(resourceGroupName, name, filter).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.body()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PerfMonResponseInner>> listPerfMonCountersAsync(final String resourceGroupName, final String name, final String filter, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPerfMonCountersSinglePageAsync(resourceGroupName, name, filter),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersAsync(final String resourceGroupName, final String name, final String filter) {
        return listPerfMonCountersWithServiceResponseAsync(resourceGroupName, name, filter)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersWithServiceResponseAsync(final String resourceGroupName, final String name, final String filter) {
        return listPerfMonCountersSinglePageAsync(resourceGroupName, name, filter)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param name Name of web app.
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSinglePageAsync(final String resourceGroupName, final String name, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listPerfMonCounters(resourceGroupName, name, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PerfMonResponseInner>> listPerfMonCountersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<PerfMonResponseInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<PerfMonResponseInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SitePhpErrorLogFlagInner object if successful.
     */
    public SitePhpErrorLogFlagInner getSitePhpErrorLogFlag(String resourceGroupName, String name) {
        return getSitePhpErrorLogFlagWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SitePhpErrorLogFlagInner> getSitePhpErrorLogFlagAsync(String resourceGroupName, String name, final ServiceCallback<SitePhpErrorLogFlagInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSitePhpErrorLogFlagWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SitePhpErrorLogFlagInner object
     */
    public Observable<SitePhpErrorLogFlagInner> getSitePhpErrorLogFlagAsync(String resourceGroupName, String name) {
        return getSitePhpErrorLogFlagWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SitePhpErrorLogFlagInner>, SitePhpErrorLogFlagInner>() {
            @Override
            public SitePhpErrorLogFlagInner call(ServiceResponse<SitePhpErrorLogFlagInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SitePhpErrorLogFlagInner object
     */
    public Observable<ServiceResponse<SitePhpErrorLogFlagInner>> getSitePhpErrorLogFlagWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSitePhpErrorLogFlag(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SitePhpErrorLogFlagInner>>>() {
                @Override
                public Observable<ServiceResponse<SitePhpErrorLogFlagInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SitePhpErrorLogFlagInner> clientResponse = getSitePhpErrorLogFlagDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SitePhpErrorLogFlagInner> getSitePhpErrorLogFlagDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SitePhpErrorLogFlagInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SitePhpErrorLogFlagInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PremierAddOnInner object if successful.
     */
    public PremierAddOnInner listPremierAddOns(String resourceGroupName, String name) {
        return listPremierAddOnsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PremierAddOnInner> listPremierAddOnsAsync(String resourceGroupName, String name, final ServiceCallback<PremierAddOnInner> serviceCallback) {
        return ServiceFuture.fromResponse(listPremierAddOnsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<PremierAddOnInner> listPremierAddOnsAsync(String resourceGroupName, String name) {
        return listPremierAddOnsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<PremierAddOnInner>, PremierAddOnInner>() {
            @Override
            public PremierAddOnInner call(ServiceResponse<PremierAddOnInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<ServiceResponse<PremierAddOnInner>> listPremierAddOnsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listPremierAddOns(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PremierAddOnInner>>>() {
                @Override
                public Observable<ServiceResponse<PremierAddOnInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PremierAddOnInner> clientResponse = listPremierAddOnsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PremierAddOnInner> listPremierAddOnsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PremierAddOnInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PremierAddOnInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PremierAddOnInner object if successful.
     */
    public PremierAddOnInner getPremierAddOn(String resourceGroupName, String name, String premierAddOnName) {
        return getPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).toBlocking().single().body();
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PremierAddOnInner> getPremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, final ServiceCallback<PremierAddOnInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName), serviceCallback);
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<PremierAddOnInner> getPremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName) {
        return getPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).map(new Func1<ServiceResponse<PremierAddOnInner>, PremierAddOnInner>() {
            @Override
            public PremierAddOnInner call(ServiceResponse<PremierAddOnInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<ServiceResponse<PremierAddOnInner>> getPremierAddOnWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getPremierAddOn(resourceGroupName, name, premierAddOnName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PremierAddOnInner>>>() {
                @Override
                public Observable<ServiceResponse<PremierAddOnInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PremierAddOnInner> clientResponse = getPremierAddOnDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PremierAddOnInner> getPremierAddOnDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PremierAddOnInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PremierAddOnInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PremierAddOnInner object if successful.
     */
    public PremierAddOnInner addPremierAddOn(String resourceGroupName, String name, String premierAddOnName, PremierAddOnInner premierAddOn) {
        return addPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, premierAddOn).toBlocking().single().body();
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PremierAddOnInner> addPremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, PremierAddOnInner premierAddOn, final ServiceCallback<PremierAddOnInner> serviceCallback) {
        return ServiceFuture.fromResponse(addPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, premierAddOn), serviceCallback);
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<PremierAddOnInner> addPremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, PremierAddOnInner premierAddOn) {
        return addPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, premierAddOn).map(new Func1<ServiceResponse<PremierAddOnInner>, PremierAddOnInner>() {
            @Override
            public PremierAddOnInner call(ServiceResponse<PremierAddOnInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<ServiceResponse<PremierAddOnInner>> addPremierAddOnWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, PremierAddOnInner premierAddOn) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (premierAddOn == null) {
            throw new IllegalArgumentException("Parameter premierAddOn is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(premierAddOn);
        return service.addPremierAddOn(resourceGroupName, name, premierAddOnName, this.client.subscriptionId(), premierAddOn, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PremierAddOnInner>>>() {
                @Override
                public Observable<ServiceResponse<PremierAddOnInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PremierAddOnInner> clientResponse = addPremierAddOnDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PremierAddOnInner> addPremierAddOnDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PremierAddOnInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PremierAddOnInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deletePremierAddOn(String resourceGroupName, String name, String premierAddOnName) {
        deletePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).toBlocking().single().body();
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deletePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deletePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName), serviceCallback);
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deletePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName) {
        return deletePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deletePremierAddOnWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deletePremierAddOn(resourceGroupName, name, premierAddOnName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deletePremierAddOnDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deletePremierAddOnDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessInfoInner&gt; object if successful.
     */
    public PagedList<ProcessInfoInner> listProcesses(final String resourceGroupName, final String name) {
        ServiceResponse<Page<ProcessInfoInner>> response = listProcessesSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<ProcessInfoInner>(response.body()) {
            @Override
            public Page<ProcessInfoInner> nextPage(String nextPageLink) {
                return listProcessesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessInfoInner>> listProcessesAsync(final String resourceGroupName, final String name, final ListOperationCallback<ProcessInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listProcessesSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(String nextPageLink) {
                    return listProcessesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<Page<ProcessInfoInner>> listProcessesAsync(final String resourceGroupName, final String name) {
        return listProcessesWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Page<ProcessInfoInner>>() {
                @Override
                public Page<ProcessInfoInner> call(ServiceResponse<Page<ProcessInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listProcessesWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listProcessesSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(ServiceResponse<Page<ProcessInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listProcessesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listProcessesSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listProcesses(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessInfoInner>> result = listProcessesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessInfoInner>> listProcessesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProcessInfoInner object if successful.
     */
    public ProcessInfoInner getProcess(String resourceGroupName, String name, String processId) {
        return getProcessWithServiceResponseAsync(resourceGroupName, name, processId).toBlocking().single().body();
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProcessInfoInner> getProcessAsync(String resourceGroupName, String name, String processId, final ServiceCallback<ProcessInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getProcessWithServiceResponseAsync(resourceGroupName, name, processId), serviceCallback);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessInfoInner object
     */
    public Observable<ProcessInfoInner> getProcessAsync(String resourceGroupName, String name, String processId) {
        return getProcessWithServiceResponseAsync(resourceGroupName, name, processId).map(new Func1<ServiceResponse<ProcessInfoInner>, ProcessInfoInner>() {
            @Override
            public ProcessInfoInner call(ServiceResponse<ProcessInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessInfoInner object
     */
    public Observable<ServiceResponse<ProcessInfoInner>> getProcessWithServiceResponseAsync(String resourceGroupName, String name, String processId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getProcess(resourceGroupName, name, processId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProcessInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ProcessInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProcessInfoInner> clientResponse = getProcessDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProcessInfoInner> getProcessDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProcessInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProcessInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteProcess(String resourceGroupName, String name, String processId) {
        deleteProcessWithServiceResponseAsync(resourceGroupName, name, processId).toBlocking().single().body();
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteProcessAsync(String resourceGroupName, String name, String processId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteProcessWithServiceResponseAsync(resourceGroupName, name, processId), serviceCallback);
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteProcessAsync(String resourceGroupName, String name, String processId) {
        return deleteProcessWithServiceResponseAsync(resourceGroupName, name, processId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteProcessWithServiceResponseAsync(String resourceGroupName, String name, String processId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteProcess(resourceGroupName, name, processId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteProcessDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteProcessDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream getProcessDump(String resourceGroupName, String name, String processId) {
        return getProcessDumpWithServiceResponseAsync(resourceGroupName, name, processId).toBlocking().single().body();
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> getProcessDumpAsync(String resourceGroupName, String name, String processId, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(getProcessDumpWithServiceResponseAsync(resourceGroupName, name, processId), serviceCallback);
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> getProcessDumpAsync(String resourceGroupName, String name, String processId) {
        return getProcessDumpWithServiceResponseAsync(resourceGroupName, name, processId).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> getProcessDumpWithServiceResponseAsync(String resourceGroupName, String name, String processId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getProcessDump(resourceGroupName, name, processId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = getProcessDumpDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> getProcessDumpDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputStream, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object if successful.
     */
    public PagedList<ProcessModuleInfoInner> listProcessModules(final String resourceGroupName, final String name, final String processId) {
        ServiceResponse<Page<ProcessModuleInfoInner>> response = listProcessModulesSinglePageAsync(resourceGroupName, name, processId).toBlocking().single();
        return new PagedList<ProcessModuleInfoInner>(response.body()) {
            @Override
            public Page<ProcessModuleInfoInner> nextPage(String nextPageLink) {
                return listProcessModulesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessModuleInfoInner>> listProcessModulesAsync(final String resourceGroupName, final String name, final String processId, final ListOperationCallback<ProcessModuleInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listProcessModulesSinglePageAsync(resourceGroupName, name, processId),
            new Func1<String, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(String nextPageLink) {
                    return listProcessModulesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<Page<ProcessModuleInfoInner>> listProcessModulesAsync(final String resourceGroupName, final String name, final String processId) {
        return listProcessModulesWithServiceResponseAsync(resourceGroupName, name, processId)
            .map(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Page<ProcessModuleInfoInner>>() {
                @Override
                public Page<ProcessModuleInfoInner> call(ServiceResponse<Page<ProcessModuleInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listProcessModulesWithServiceResponseAsync(final String resourceGroupName, final String name, final String processId) {
        return listProcessModulesSinglePageAsync(resourceGroupName, name, processId)
            .concatMap(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(ServiceResponse<Page<ProcessModuleInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listProcessModulesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param name Site name.
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listProcessModulesSinglePageAsync(final String resourceGroupName, final String name, final String processId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listProcessModules(resourceGroupName, name, processId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessModuleInfoInner>> result = listProcessModulesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessModuleInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessModuleInfoInner>> listProcessModulesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessModuleInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessModuleInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProcessModuleInfoInner object if successful.
     */
    public ProcessModuleInfoInner getProcessModule(String resourceGroupName, String name, String processId, String baseAddress) {
        return getProcessModuleWithServiceResponseAsync(resourceGroupName, name, processId, baseAddress).toBlocking().single().body();
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProcessModuleInfoInner> getProcessModuleAsync(String resourceGroupName, String name, String processId, String baseAddress, final ServiceCallback<ProcessModuleInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getProcessModuleWithServiceResponseAsync(resourceGroupName, name, processId, baseAddress), serviceCallback);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessModuleInfoInner object
     */
    public Observable<ProcessModuleInfoInner> getProcessModuleAsync(String resourceGroupName, String name, String processId, String baseAddress) {
        return getProcessModuleWithServiceResponseAsync(resourceGroupName, name, processId, baseAddress).map(new Func1<ServiceResponse<ProcessModuleInfoInner>, ProcessModuleInfoInner>() {
            @Override
            public ProcessModuleInfoInner call(ServiceResponse<ProcessModuleInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessModuleInfoInner object
     */
    public Observable<ServiceResponse<ProcessModuleInfoInner>> getProcessModuleWithServiceResponseAsync(String resourceGroupName, String name, String processId, String baseAddress) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (baseAddress == null) {
            throw new IllegalArgumentException("Parameter baseAddress is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getProcessModule(resourceGroupName, name, processId, baseAddress, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProcessModuleInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ProcessModuleInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProcessModuleInfoInner> clientResponse = getProcessModuleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProcessModuleInfoInner> getProcessModuleDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProcessModuleInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProcessModuleInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object if successful.
     */
    public PagedList<ProcessThreadInfoInner> listProcessThreads(final String resourceGroupName, final String name, final String processId) {
        ServiceResponse<Page<ProcessThreadInfoInner>> response = listProcessThreadsSinglePageAsync(resourceGroupName, name, processId).toBlocking().single();
        return new PagedList<ProcessThreadInfoInner>(response.body()) {
            @Override
            public Page<ProcessThreadInfoInner> nextPage(String nextPageLink) {
                return listProcessThreadsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessThreadInfoInner>> listProcessThreadsAsync(final String resourceGroupName, final String name, final String processId, final ListOperationCallback<ProcessThreadInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listProcessThreadsSinglePageAsync(resourceGroupName, name, processId),
            new Func1<String, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(String nextPageLink) {
                    return listProcessThreadsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<Page<ProcessThreadInfoInner>> listProcessThreadsAsync(final String resourceGroupName, final String name, final String processId) {
        return listProcessThreadsWithServiceResponseAsync(resourceGroupName, name, processId)
            .map(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Page<ProcessThreadInfoInner>>() {
                @Override
                public Page<ProcessThreadInfoInner> call(ServiceResponse<Page<ProcessThreadInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listProcessThreadsWithServiceResponseAsync(final String resourceGroupName, final String name, final String processId) {
        return listProcessThreadsSinglePageAsync(resourceGroupName, name, processId)
            .concatMap(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(ServiceResponse<Page<ProcessThreadInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listProcessThreadsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param name Site name.
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param processId PID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listProcessThreadsSinglePageAsync(final String resourceGroupName, final String name, final String processId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listProcessThreads(resourceGroupName, name, processId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessThreadInfoInner>> result = listProcessThreadsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessThreadInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessThreadInfoInner>> listProcessThreadsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessThreadInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessThreadInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProcessThreadInfoInner object if successful.
     */
    public ProcessThreadInfoInner getProcessThread(String resourceGroupName, String name, String processId, String threadId) {
        return getProcessThreadWithServiceResponseAsync(resourceGroupName, name, processId, threadId).toBlocking().single().body();
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProcessThreadInfoInner> getProcessThreadAsync(String resourceGroupName, String name, String processId, String threadId, final ServiceCallback<ProcessThreadInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getProcessThreadWithServiceResponseAsync(resourceGroupName, name, processId, threadId), serviceCallback);
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessThreadInfoInner object
     */
    public Observable<ProcessThreadInfoInner> getProcessThreadAsync(String resourceGroupName, String name, String processId, String threadId) {
        return getProcessThreadWithServiceResponseAsync(resourceGroupName, name, processId, threadId).map(new Func1<ServiceResponse<ProcessThreadInfoInner>, ProcessThreadInfoInner>() {
            @Override
            public ProcessThreadInfoInner call(ServiceResponse<ProcessThreadInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessThreadInfoInner object
     */
    public Observable<ServiceResponse<ProcessThreadInfoInner>> getProcessThreadWithServiceResponseAsync(String resourceGroupName, String name, String processId, String threadId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (threadId == null) {
            throw new IllegalArgumentException("Parameter threadId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getProcessThread(resourceGroupName, name, processId, threadId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProcessThreadInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ProcessThreadInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProcessThreadInfoInner> clientResponse = getProcessThreadDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProcessThreadInfoInner> getProcessThreadDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProcessThreadInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProcessThreadInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PublicCertificateInner&gt; object if successful.
     */
    public PagedList<PublicCertificateInner> listPublicCertificates(final String resourceGroupName, final String name) {
        ServiceResponse<Page<PublicCertificateInner>> response = listPublicCertificatesSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<PublicCertificateInner>(response.body()) {
            @Override
            public Page<PublicCertificateInner> nextPage(String nextPageLink) {
                return listPublicCertificatesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PublicCertificateInner>> listPublicCertificatesAsync(final String resourceGroupName, final String name, final ListOperationCallback<PublicCertificateInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPublicCertificatesSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<PublicCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PublicCertificateInner>>> call(String nextPageLink) {
                    return listPublicCertificatesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PublicCertificateInner&gt; object
     */
    public Observable<Page<PublicCertificateInner>> listPublicCertificatesAsync(final String resourceGroupName, final String name) {
        return listPublicCertificatesWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<PublicCertificateInner>>, Page<PublicCertificateInner>>() {
                @Override
                public Page<PublicCertificateInner> call(ServiceResponse<Page<PublicCertificateInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PublicCertificateInner&gt; object
     */
    public Observable<ServiceResponse<Page<PublicCertificateInner>>> listPublicCertificatesWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listPublicCertificatesSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<PublicCertificateInner>>, Observable<ServiceResponse<Page<PublicCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PublicCertificateInner>>> call(ServiceResponse<Page<PublicCertificateInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPublicCertificatesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
    ServiceResponse<PageImpl<PublicCertificateInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<PublicCertificateInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PublicCertificateInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PublicCertificateInner>>> listPublicCertificatesSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listPublicCertificates(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PublicCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PublicCertificateInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PublicCertificateInner>> result = listPublicCertificatesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PublicCertificateInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PublicCertificateInner>> listPublicCertificatesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<PublicCertificateInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<PublicCertificateInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the named public certificate for an app (or deployment slot, if specified).
     * Get the named public certificate for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PublicCertificateInner object if successful.
     */
    public PublicCertificateInner getPublicCertificate(String resourceGroupName, String name, String publicCertificateName) {
        return getPublicCertificateWithServiceResponseAsync(resourceGroupName, name, publicCertificateName).toBlocking().single().body();
    }

    /**
     * Get the named public certificate for an app (or deployment slot, if specified).
     * Get the named public certificate for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PublicCertificateInner> getPublicCertificateAsync(String resourceGroupName, String name, String publicCertificateName, final ServiceCallback<PublicCertificateInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPublicCertificateWithServiceResponseAsync(resourceGroupName, name, publicCertificateName), serviceCallback);
    }

    /**
     * Get the named public certificate for an app (or deployment slot, if specified).
     * Get the named public certificate for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PublicCertificateInner object
     */
    public Observable<PublicCertificateInner> getPublicCertificateAsync(String resourceGroupName, String name, String publicCertificateName) {
        return getPublicCertificateWithServiceResponseAsync(resourceGroupName, name, publicCertificateName).map(new Func1<ServiceResponse<PublicCertificateInner>, PublicCertificateInner>() {
            @Override
            public PublicCertificateInner call(ServiceResponse<PublicCertificateInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the named public certificate for an app (or deployment slot, if specified).
     * Get the named public certificate for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PublicCertificateInner object
     */
    public Observable<ServiceResponse<PublicCertificateInner>> getPublicCertificateWithServiceResponseAsync(String resourceGroupName, String name, String publicCertificateName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (publicCertificateName == null) {
            throw new IllegalArgumentException("Parameter publicCertificateName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getPublicCertificate(resourceGroupName, name, publicCertificateName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PublicCertificateInner>>>() {
                @Override
                public Observable<ServiceResponse<PublicCertificateInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PublicCertificateInner> clientResponse = getPublicCertificateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PublicCertificateInner> getPublicCertificateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PublicCertificateInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PublicCertificateInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param publicCertificate Public certificate details. This is the JSON representation of a PublicCertificate object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PublicCertificateInner object if successful.
     */
    public PublicCertificateInner createOrUpdatePublicCertificate(String resourceGroupName, String name, String publicCertificateName, PublicCertificateInner publicCertificate) {
        return createOrUpdatePublicCertificateWithServiceResponseAsync(resourceGroupName, name, publicCertificateName, publicCertificate).toBlocking().single().body();
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param publicCertificate Public certificate details. This is the JSON representation of a PublicCertificate object.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PublicCertificateInner> createOrUpdatePublicCertificateAsync(String resourceGroupName, String name, String publicCertificateName, PublicCertificateInner publicCertificate, final ServiceCallback<PublicCertificateInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdatePublicCertificateWithServiceResponseAsync(resourceGroupName, name, publicCertificateName, publicCertificate), serviceCallback);
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param publicCertificate Public certificate details. This is the JSON representation of a PublicCertificate object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PublicCertificateInner object
     */
    public Observable<PublicCertificateInner> createOrUpdatePublicCertificateAsync(String resourceGroupName, String name, String publicCertificateName, PublicCertificateInner publicCertificate) {
        return createOrUpdatePublicCertificateWithServiceResponseAsync(resourceGroupName, name, publicCertificateName, publicCertificate).map(new Func1<ServiceResponse<PublicCertificateInner>, PublicCertificateInner>() {
            @Override
            public PublicCertificateInner call(ServiceResponse<PublicCertificateInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param publicCertificate Public certificate details. This is the JSON representation of a PublicCertificate object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PublicCertificateInner object
     */
    public Observable<ServiceResponse<PublicCertificateInner>> createOrUpdatePublicCertificateWithServiceResponseAsync(String resourceGroupName, String name, String publicCertificateName, PublicCertificateInner publicCertificate) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (publicCertificateName == null) {
            throw new IllegalArgumentException("Parameter publicCertificateName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (publicCertificate == null) {
            throw new IllegalArgumentException("Parameter publicCertificate is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(publicCertificate);
        return service.createOrUpdatePublicCertificate(resourceGroupName, name, publicCertificateName, this.client.subscriptionId(), publicCertificate, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PublicCertificateInner>>>() {
                @Override
                public Observable<ServiceResponse<PublicCertificateInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PublicCertificateInner> clientResponse = createOrUpdatePublicCertificateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PublicCertificateInner> createOrUpdatePublicCertificateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PublicCertificateInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PublicCertificateInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deletePublicCertificate(String resourceGroupName, String name, String publicCertificateName) {
        deletePublicCertificateWithServiceResponseAsync(resourceGroupName, name, publicCertificateName).toBlocking().single().body();
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deletePublicCertificateAsync(String resourceGroupName, String name, String publicCertificateName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deletePublicCertificateWithServiceResponseAsync(resourceGroupName, name, publicCertificateName), serviceCallback);
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deletePublicCertificateAsync(String resourceGroupName, String name, String publicCertificateName) {
        return deletePublicCertificateWithServiceResponseAsync(resourceGroupName, name, publicCertificateName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deletePublicCertificateWithServiceResponseAsync(String resourceGroupName, String name, String publicCertificateName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (publicCertificateName == null) {
            throw new IllegalArgumentException("Parameter publicCertificateName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deletePublicCertificate(resourceGroupName, name, publicCertificateName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deletePublicCertificateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deletePublicCertificateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream listPublishingProfileXmlWithSecrets(String resourceGroupName, String name) {
        return listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> listPublishingProfileXmlWithSecretsAsync(String resourceGroupName, String name, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listPublishingProfileXmlWithSecretsAsync(String resourceGroupName, String name) {
        return listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listPublishingProfileXmlWithSecretsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final PublishingProfileFormat format = null;
        CsmPublishingProfileOptions publishingProfileOptions = new CsmPublishingProfileOptions();
        publishingProfileOptions.withFormat(null);
        return service.listPublishingProfileXmlWithSecrets(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), publishingProfileOptions, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listPublishingProfileXmlWithSecretsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param format Name of the format. Valid values are:
     FileZilla3
     WebDeploy -- default
     Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream listPublishingProfileXmlWithSecrets(String resourceGroupName, String name, PublishingProfileFormat format) {
        return listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name, format).toBlocking().single().body();
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param format Name of the format. Valid values are:
     FileZilla3
     WebDeploy -- default
     Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> listPublishingProfileXmlWithSecretsAsync(String resourceGroupName, String name, PublishingProfileFormat format, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name, format), serviceCallback);
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param format Name of the format. Valid values are:
     FileZilla3
     WebDeploy -- default
     Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listPublishingProfileXmlWithSecretsAsync(String resourceGroupName, String name, PublishingProfileFormat format) {
        return listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name, format).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param format Name of the format. Valid values are:
     FileZilla3
     WebDeploy -- default
     Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listPublishingProfileXmlWithSecretsWithServiceResponseAsync(String resourceGroupName, String name, PublishingProfileFormat format) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        CsmPublishingProfileOptions publishingProfileOptions = new CsmPublishingProfileOptions();
        publishingProfileOptions.withFormat(format);
        return service.listPublishingProfileXmlWithSecrets(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), publishingProfileOptions, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listPublishingProfileXmlWithSecretsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> listPublishingProfileXmlWithSecretsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputStream, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void recover(String resourceGroupName, String name, SnapshotRecoveryRequest recoveryEntity) {
        recoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).toBlocking().last().body();
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> recoverAsync(String resourceGroupName, String name, SnapshotRecoveryRequest recoveryEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(recoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> recoverAsync(String resourceGroupName, String name, SnapshotRecoveryRequest recoveryEntity) {
        return recoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> recoverWithServiceResponseAsync(String resourceGroupName, String name, SnapshotRecoveryRequest recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        Observable<Response<ResponseBody>> observable = service.recover(resourceGroupName, name, this.client.subscriptionId(), recoveryEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginRecover(String resourceGroupName, String name, SnapshotRecoveryRequest recoveryEntity) {
        beginRecoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).toBlocking().single().body();
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginRecoverAsync(String resourceGroupName, String name, SnapshotRecoveryRequest recoveryEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginRecoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginRecoverAsync(String resourceGroupName, String name, SnapshotRecoveryRequest recoveryEntity) {
        return beginRecoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginRecoverWithServiceResponseAsync(String resourceGroupName, String name, SnapshotRecoveryRequest recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        return service.beginRecover(resourceGroupName, name, this.client.subscriptionId(), recoveryEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginRecoverDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginRecoverDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resetProductionSlotConfig(String resourceGroupName, String name) {
        resetProductionSlotConfigWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resetProductionSlotConfigAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resetProductionSlotConfigWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resetProductionSlotConfigAsync(String resourceGroupName, String name) {
        return resetProductionSlotConfigWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resetProductionSlotConfigWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.resetProductionSlotConfig(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resetProductionSlotConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> resetProductionSlotConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restart(String resourceGroupName, String name) {
        restartWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restartAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restartWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restartAsync(String resourceGroupName, String name) {
        return restartWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restartWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean softRestart = null;
        final Boolean synchronous = null;
        return service.restart(resourceGroupName, name, this.client.subscriptionId(), softRestart, synchronous, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restartDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restart(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous) {
        restartWithServiceResponseAsync(resourceGroupName, name, softRestart, synchronous).toBlocking().single().body();
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restartAsync(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restartWithServiceResponseAsync(resourceGroupName, name, softRestart, synchronous), serviceCallback);
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restartAsync(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous) {
        return restartWithServiceResponseAsync(resourceGroupName, name, softRestart, synchronous).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restartWithServiceResponseAsync(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.restart(resourceGroupName, name, this.client.subscriptionId(), softRestart, synchronous, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restartDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> restartDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteExtensionInfoInner&gt; object if successful.
     */
    public PagedList<SiteExtensionInfoInner> listSiteExtensions(final String resourceGroupName, final String name) {
        ServiceResponse<Page<SiteExtensionInfoInner>> response = listSiteExtensionsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<SiteExtensionInfoInner>(response.body()) {
            @Override
            public Page<SiteExtensionInfoInner> nextPage(String nextPageLink) {
                return listSiteExtensionsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteExtensionInfoInner>> listSiteExtensionsAsync(final String resourceGroupName, final String name, final ListOperationCallback<SiteExtensionInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSiteExtensionsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SiteExtensionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> call(String nextPageLink) {
                    return listSiteExtensionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteExtensionInfoInner&gt; object
     */
    public Observable<Page<SiteExtensionInfoInner>> listSiteExtensionsAsync(final String resourceGroupName, final String name) {
        return listSiteExtensionsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<SiteExtensionInfoInner>>, Page<SiteExtensionInfoInner>>() {
                @Override
                public Page<SiteExtensionInfoInner> call(ServiceResponse<Page<SiteExtensionInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteExtensionInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> listSiteExtensionsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listSiteExtensionsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SiteExtensionInfoInner>>, Observable<ServiceResponse<Page<SiteExtensionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> call(ServiceResponse<Page<SiteExtensionInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSiteExtensionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
    ServiceResponse<PageImpl<SiteExtensionInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SiteExtensionInfoInner>> * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteExtensionInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> listSiteExtensionsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteExtensions(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteExtensionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteExtensionInfoInner>> result = listSiteExtensionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteExtensionInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteExtensionInfoInner>> listSiteExtensionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteExtensionInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteExtensionInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get site extension information by its ID for a web site, or a deployment slot.
     * Get site extension information by its ID for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteExtensionInfoInner object if successful.
     */
    public SiteExtensionInfoInner getSiteExtension(String resourceGroupName, String name, String siteExtensionId) {
        return getSiteExtensionWithServiceResponseAsync(resourceGroupName, name, siteExtensionId).toBlocking().single().body();
    }

    /**
     * Get site extension information by its ID for a web site, or a deployment slot.
     * Get site extension information by its ID for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteExtensionInfoInner> getSiteExtensionAsync(String resourceGroupName, String name, String siteExtensionId, final ServiceCallback<SiteExtensionInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSiteExtensionWithServiceResponseAsync(resourceGroupName, name, siteExtensionId), serviceCallback);
    }

    /**
     * Get site extension information by its ID for a web site, or a deployment slot.
     * Get site extension information by its ID for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteExtensionInfoInner object
     */
    public Observable<SiteExtensionInfoInner> getSiteExtensionAsync(String resourceGroupName, String name, String siteExtensionId) {
        return getSiteExtensionWithServiceResponseAsync(resourceGroupName, name, siteExtensionId).map(new Func1<ServiceResponse<SiteExtensionInfoInner>, SiteExtensionInfoInner>() {
            @Override
            public SiteExtensionInfoInner call(ServiceResponse<SiteExtensionInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get site extension information by its ID for a web site, or a deployment slot.
     * Get site extension information by its ID for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteExtensionInfoInner object
     */
    public Observable<ServiceResponse<SiteExtensionInfoInner>> getSiteExtensionWithServiceResponseAsync(String resourceGroupName, String name, String siteExtensionId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (siteExtensionId == null) {
            throw new IllegalArgumentException("Parameter siteExtensionId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteExtension(resourceGroupName, name, siteExtensionId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteExtensionInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteExtensionInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteExtensionInfoInner> clientResponse = getSiteExtensionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteExtensionInfoInner> getSiteExtensionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteExtensionInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteExtensionInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteExtensionInfoInner object if successful.
     */
    public SiteExtensionInfoInner installSiteExtension(String resourceGroupName, String name, String siteExtensionId) {
        return installSiteExtensionWithServiceResponseAsync(resourceGroupName, name, siteExtensionId).toBlocking().last().body();
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteExtensionInfoInner> installSiteExtensionAsync(String resourceGroupName, String name, String siteExtensionId, final ServiceCallback<SiteExtensionInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(installSiteExtensionWithServiceResponseAsync(resourceGroupName, name, siteExtensionId), serviceCallback);
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SiteExtensionInfoInner> installSiteExtensionAsync(String resourceGroupName, String name, String siteExtensionId) {
        return installSiteExtensionWithServiceResponseAsync(resourceGroupName, name, siteExtensionId).map(new Func1<ServiceResponse<SiteExtensionInfoInner>, SiteExtensionInfoInner>() {
            @Override
            public SiteExtensionInfoInner call(ServiceResponse<SiteExtensionInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteExtensionInfoInner>> installSiteExtensionWithServiceResponseAsync(String resourceGroupName, String name, String siteExtensionId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (siteExtensionId == null) {
            throw new IllegalArgumentException("Parameter siteExtensionId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.installSiteExtension(resourceGroupName, name, siteExtensionId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteExtensionInfoInner>() { }.getType());
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteExtensionInfoInner object if successful.
     */
    public SiteExtensionInfoInner beginInstallSiteExtension(String resourceGroupName, String name, String siteExtensionId) {
        return beginInstallSiteExtensionWithServiceResponseAsync(resourceGroupName, name, siteExtensionId).toBlocking().single().body();
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteExtensionInfoInner> beginInstallSiteExtensionAsync(String resourceGroupName, String name, String siteExtensionId, final ServiceCallback<SiteExtensionInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginInstallSiteExtensionWithServiceResponseAsync(resourceGroupName, name, siteExtensionId), serviceCallback);
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteExtensionInfoInner object
     */
    public Observable<SiteExtensionInfoInner> beginInstallSiteExtensionAsync(String resourceGroupName, String name, String siteExtensionId) {
        return beginInstallSiteExtensionWithServiceResponseAsync(resourceGroupName, name, siteExtensionId).map(new Func1<ServiceResponse<SiteExtensionInfoInner>, SiteExtensionInfoInner>() {
            @Override
            public SiteExtensionInfoInner call(ServiceResponse<SiteExtensionInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteExtensionInfoInner object
     */
    public Observable<ServiceResponse<SiteExtensionInfoInner>> beginInstallSiteExtensionWithServiceResponseAsync(String resourceGroupName, String name, String siteExtensionId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (siteExtensionId == null) {
            throw new IllegalArgumentException("Parameter siteExtensionId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginInstallSiteExtension(resourceGroupName, name, siteExtensionId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteExtensionInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteExtensionInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteExtensionInfoInner> clientResponse = beginInstallSiteExtensionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteExtensionInfoInner> beginInstallSiteExtensionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteExtensionInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteExtensionInfoInner>() { }.getType())
                .register(201, new TypeToken<SiteExtensionInfoInner>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Remove a site extension from a web site, or a deployment slot.
     * Remove a site extension from a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteSiteExtension(String resourceGroupName, String name, String siteExtensionId) {
        deleteSiteExtensionWithServiceResponseAsync(resourceGroupName, name, siteExtensionId).toBlocking().single().body();
    }

    /**
     * Remove a site extension from a web site, or a deployment slot.
     * Remove a site extension from a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteSiteExtensionAsync(String resourceGroupName, String name, String siteExtensionId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteSiteExtensionWithServiceResponseAsync(resourceGroupName, name, siteExtensionId), serviceCallback);
    }

    /**
     * Remove a site extension from a web site, or a deployment slot.
     * Remove a site extension from a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteSiteExtensionAsync(String resourceGroupName, String name, String siteExtensionId) {
        return deleteSiteExtensionWithServiceResponseAsync(resourceGroupName, name, siteExtensionId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Remove a site extension from a web site, or a deployment slot.
     * Remove a site extension from a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteSiteExtensionWithServiceResponseAsync(String resourceGroupName, String name, String siteExtensionId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (siteExtensionId == null) {
            throw new IllegalArgumentException("Parameter siteExtensionId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteExtension(resourceGroupName, name, siteExtensionId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteSiteExtensionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteSiteExtensionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listSlots(final String resourceGroupName, final String name) {
        ServiceResponse<Page<SiteInner>> response = listSlotsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<SiteInner>(response.body()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listSlotsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInner>> listSlotsAsync(final String resourceGroupName, final String name, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSlotsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listSlotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listSlotsAsync(final String resourceGroupName, final String name) {
        return listSlotsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSlotsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listSlotsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSlotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SiteInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSlotsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSlots(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listSlotsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listSlotsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner getSlot(String resourceGroupName, String name, String slot) {
        return getSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> getSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> getSlotAsync(String resourceGroupName, String name, String slot) {
        return getSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> getSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner createOrUpdateSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).toBlocking().last().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> createOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SiteInner> createOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final Boolean skipDnsRegistration = null;
        final Boolean skipCustomDomainVerification = null;
        final Boolean forceDnsRegistration = null;
        final String ttlInSeconds = null;
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }
    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation.
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS.
     * @param ttlInSeconds Time to live in seconds for web app's default domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner createOrUpdateSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().last().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation.
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS.
     * @param ttlInSeconds Time to live in seconds for web app's default domain name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> createOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation.
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS.
     * @param ttlInSeconds Time to live in seconds for web app's default domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SiteInner> createOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation.
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS.
     * @param ttlInSeconds Time to live in seconds for web app's default domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner beginCreateOrUpdateSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> beginCreateOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginCreateOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final Boolean skipDnsRegistration = null;
        final Boolean skipCustomDomainVerification = null;
        final Boolean forceDnsRegistration = null;
        final String ttlInSeconds = null;
        return service.beginCreateOrUpdateSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation.
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS.
     * @param ttlInSeconds Time to live in seconds for web app's default domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner beginCreateOrUpdateSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().single().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation.
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS.
     * @param ttlInSeconds Time to live in seconds for web app's default domain name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> beginCreateOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation.
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS.
     * @param ttlInSeconds Time to live in seconds for web app's default domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginCreateOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation.
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS.
     * @param ttlInSeconds Time to live in seconds for web app's default domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        return service.beginCreateOrUpdateSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> beginCreateOrUpdateSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteSlot(String resourceGroupName, String name, String slot) {
        deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteSlotAsync(String resourceGroupName, String name, String slot) {
        return deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean deleteMetrics = null;
        final Boolean deleteEmptyServerFarm = null;
        final Boolean skipDnsRegistration = null;
        return service.deleteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @param deleteMetrics If true, web app metrics are also deleted.
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @param skipDnsRegistration If true, DNS registration is skipped.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteSlot(String resourceGroupName, String name, String slot, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration) {
        deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration).toBlocking().single().body();
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @param deleteMetrics If true, web app metrics are also deleted.
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @param skipDnsRegistration If true, DNS registration is skipped.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteSlotAsync(String resourceGroupName, String name, String slot, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration), serviceCallback);
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @param deleteMetrics If true, web app metrics are also deleted.
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @param skipDnsRegistration If true, DNS registration is skipped.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteSlotAsync(String resourceGroupName, String name, String slot, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration) {
        return deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @param deleteMetrics If true, web app metrics are also deleted.
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @param skipDnsRegistration If true, DNS registration is skipped.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner updateSlot(String resourceGroupName, String name, String slot, SitePatchResource siteEnvelope) {
        return updateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> updateSlotAsync(String resourceGroupName, String name, String slot, SitePatchResource siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> updateSlotAsync(String resourceGroupName, String name, String slot, SitePatchResource siteEnvelope) {
        return updateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> updateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SitePatchResource siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final Boolean skipDnsRegistration = null;
        final Boolean skipCustomDomainVerification = null;
        final Boolean forceDnsRegistration = null;
        final String ttlInSeconds = null;
        return service.updateSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = updateSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation.
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS.
     * @param ttlInSeconds Time to live in seconds for web app's default domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner updateSlot(String resourceGroupName, String name, String slot, SitePatchResource siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return updateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().single().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation.
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS.
     * @param ttlInSeconds Time to live in seconds for web app's default domain name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> updateSlotAsync(String resourceGroupName, String name, String slot, SitePatchResource siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation.
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS.
     * @param ttlInSeconds Time to live in seconds for web app's default domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> updateSlotAsync(String resourceGroupName, String name, String slot, SitePatchResource siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return updateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation.
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS.
     * @param ttlInSeconds Time to live in seconds for web app's default domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> updateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SitePatchResource siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        return service.updateSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = updateSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> updateSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CustomHostnameAnalysisResultInner object if successful.
     */
    public CustomHostnameAnalysisResultInner analyzeCustomHostnameSlot(String resourceGroupName, String name, String slot) {
        return analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CustomHostnameAnalysisResultInner> analyzeCustomHostnameSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<CustomHostnameAnalysisResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<CustomHostnameAnalysisResultInner> analyzeCustomHostnameSlotAsync(String resourceGroupName, String name, String slot) {
        return analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<CustomHostnameAnalysisResultInner>, CustomHostnameAnalysisResultInner>() {
            @Override
            public CustomHostnameAnalysisResultInner call(ServiceResponse<CustomHostnameAnalysisResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> analyzeCustomHostnameSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String hostName = null;
        return service.analyzeCustomHostnameSlot(resourceGroupName, name, slot, this.client.subscriptionId(), hostName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CustomHostnameAnalysisResultInner>>>() {
                @Override
                public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CustomHostnameAnalysisResultInner> clientResponse = analyzeCustomHostnameSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Custom hostname.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CustomHostnameAnalysisResultInner object if successful.
     */
    public CustomHostnameAnalysisResultInner analyzeCustomHostnameSlot(String resourceGroupName, String name, String slot, String hostName) {
        return analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).toBlocking().single().body();
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Custom hostname.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CustomHostnameAnalysisResultInner> analyzeCustomHostnameSlotAsync(String resourceGroupName, String name, String slot, String hostName, final ServiceCallback<CustomHostnameAnalysisResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName), serviceCallback);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Custom hostname.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<CustomHostnameAnalysisResultInner> analyzeCustomHostnameSlotAsync(String resourceGroupName, String name, String slot, String hostName) {
        return analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).map(new Func1<ServiceResponse<CustomHostnameAnalysisResultInner>, CustomHostnameAnalysisResultInner>() {
            @Override
            public CustomHostnameAnalysisResultInner call(ServiceResponse<CustomHostnameAnalysisResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Custom hostname.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> analyzeCustomHostnameSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.analyzeCustomHostnameSlot(resourceGroupName, name, slot, this.client.subscriptionId(), hostName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CustomHostnameAnalysisResultInner>>>() {
                @Override
                public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CustomHostnameAnalysisResultInner> clientResponse = analyzeCustomHostnameSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CustomHostnameAnalysisResultInner> analyzeCustomHostnameSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<CustomHostnameAnalysisResultInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<CustomHostnameAnalysisResultInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void applySlotConfigurationSlot(String resourceGroupName, String name, String slot, CsmSlotEntity slotSwapEntity) {
        applySlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().single().body();
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> applySlotConfigurationSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntity slotSwapEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(applySlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity), serviceCallback);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> applySlotConfigurationSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntity slotSwapEntity) {
        return applySlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> applySlotConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSlotEntity slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.applySlotConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = applySlotConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> applySlotConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a backup for the production slot.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner backupSlot(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return backupSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).toBlocking().single().body();
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a backup for the production slot.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupItemInner> backupSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceFuture.fromResponse(backupSlotWithServiceResponseAsync(resourceGroupName, name, slot, request), serviceCallback);
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a backup for the production slot.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> backupSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return backupSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a backup for the production slot.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> backupSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.backupSlot(resourceGroupName, name, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = backupSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> backupSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupItemInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listBackupsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<BackupItemInner>> response = listBackupsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<BackupItemInner>(response.body()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listBackupsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BackupItemInner>> listBackupsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listBackupsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listBackupsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listBackupsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listBackupsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listBackupsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listBackupsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<BackupItemInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<BackupItemInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listBackupsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listBackupsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listBackupsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BackupItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will perform discovery for the production slot.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RestoreRequestInner object if successful.
     */
    public RestoreRequestInner discoverRestoreSlot(String resourceGroupName, String name, String slot, RestoreRequestInner request) {
        return discoverRestoreSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).toBlocking().single().body();
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will perform discovery for the production slot.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RestoreRequestInner> discoverRestoreSlotAsync(String resourceGroupName, String name, String slot, RestoreRequestInner request, final ServiceCallback<RestoreRequestInner> serviceCallback) {
        return ServiceFuture.fromResponse(discoverRestoreSlotWithServiceResponseAsync(resourceGroupName, name, slot, request), serviceCallback);
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will perform discovery for the production slot.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<RestoreRequestInner> discoverRestoreSlotAsync(String resourceGroupName, String name, String slot, RestoreRequestInner request) {
        return discoverRestoreSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).map(new Func1<ServiceResponse<RestoreRequestInner>, RestoreRequestInner>() {
            @Override
            public RestoreRequestInner call(ServiceResponse<RestoreRequestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will perform discovery for the production slot.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<ServiceResponse<RestoreRequestInner>> discoverRestoreSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.discoverRestoreSlot(resourceGroupName, name, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreRequestInner> clientResponse = discoverRestoreSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreRequestInner> discoverRestoreSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RestoreRequestInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RestoreRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner getBackupStatusSlot(String resourceGroupName, String name, String backupId, String slot) {
        return getBackupStatusSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).toBlocking().single().body();
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a backup of the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupItemInner> getBackupStatusSlotAsync(String resourceGroupName, String name, String backupId, String slot, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceFuture.fromResponse(getBackupStatusSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot), serviceCallback);
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> getBackupStatusSlotAsync(String resourceGroupName, String name, String backupId, String slot) {
        return getBackupStatusSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> getBackupStatusSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getBackupStatusSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = getBackupStatusSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> getBackupStatusSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupItemInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteBackupSlot(String resourceGroupName, String name, String backupId, String slot) {
        deleteBackupSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).toBlocking().single().body();
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a backup of the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteBackupSlotAsync(String resourceGroupName, String name, String backupId, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteBackupSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot), serviceCallback);
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteBackupSlotAsync(String resourceGroupName, String name, String backupId, String slot) {
        return deleteBackupSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteBackupSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteBackupSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteBackupSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteBackupSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param backupId ID of backup.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner listBackupStatusSecretsSlot(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request) {
        return listBackupStatusSecretsSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).toBlocking().single().body();
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param backupId ID of backup.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupItemInner> listBackupStatusSecretsSlotAsync(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceFuture.fromResponse(listBackupStatusSecretsSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param backupId ID of backup.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> listBackupStatusSecretsSlotAsync(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request) {
        return listBackupStatusSecretsSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param backupId ID of backup.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> listBackupStatusSecretsSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.listBackupStatusSecretsSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = listBackupStatusSecretsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> listBackupStatusSecretsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupItemInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request .
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner restoreSlot(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return restoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).toBlocking().last().body();
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request .
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RestoreResponseInner> restoreSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(restoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request), serviceCallback);
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request .
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<RestoreResponseInner> restoreSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return restoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request .
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<RestoreResponseInner>> restoreSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        Observable<Response<ResponseBody>> observable = service.restoreSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<RestoreResponseInner>() { }.getType());
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request .
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner beginRestoreSlot(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return beginRestoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).toBlocking().single().body();
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request .
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RestoreResponseInner> beginRestoreSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginRestoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request), serviceCallback);
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request .
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<RestoreResponseInner> beginRestoreSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return beginRestoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request .
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<ServiceResponse<RestoreResponseInner>> beginRestoreSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.beginRestoreSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreResponseInner> clientResponse = beginRestoreSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreResponseInner> beginRestoreSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RestoreResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RestoreResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteConfigResourceInner&gt; object if successful.
     */
    public PagedList<SiteConfigResourceInner> listConfigurationsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<SiteConfigResourceInner>> response = listConfigurationsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<SiteConfigResourceInner>(response.body()) {
            @Override
            public Page<SiteConfigResourceInner> nextPage(String nextPageLink) {
                return listConfigurationsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteConfigResourceInner>> listConfigurationsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<SiteConfigResourceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listConfigurationsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<SiteConfigResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> call(String nextPageLink) {
                    return listConfigurationsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigResourceInner&gt; object
     */
    public Observable<Page<SiteConfigResourceInner>> listConfigurationsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listConfigurationsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<SiteConfigResourceInner>>, Page<SiteConfigResourceInner>>() {
                @Override
                public Page<SiteConfigResourceInner> call(ServiceResponse<Page<SiteConfigResourceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigResourceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> listConfigurationsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listConfigurationsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<SiteConfigResourceInner>>, Observable<ServiceResponse<Page<SiteConfigResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> call(ServiceResponse<Page<SiteConfigResourceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listConfigurationsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
    ServiceResponse<PageImpl<SiteConfigResourceInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SiteConfigResourceInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<SiteConfigResourceInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteConfigResourceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> listConfigurationsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listConfigurationsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteConfigResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteConfigResourceInner>> result = listConfigurationsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteConfigResourceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteConfigResourceInner>> listConfigurationsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteConfigResourceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteConfigResourceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the application settings for the production slot.
     * @param appSettings Application settings of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateApplicationSettingsSlot(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings) {
        return updateApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, appSettings).toBlocking().single().body();
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the application settings for the production slot.
     * @param appSettings Application settings of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> updateApplicationSettingsSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, appSettings), serviceCallback);
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the application settings for the production slot.
     * @param appSettings Application settings of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateApplicationSettingsSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings) {
        return updateApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, appSettings).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the application settings for the production slot.
     * @param appSettings Application settings of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateApplicationSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (appSettings == null) {
            throw new IllegalArgumentException("Parameter appSettings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(appSettings);
        return service.updateApplicationSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), appSettings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateApplicationSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateApplicationSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the application settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listApplicationSettingsSlot(String resourceGroupName, String name, String slot) {
        return listApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the application settings for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> listApplicationSettingsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(listApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the application settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listApplicationSettingsSlotAsync(String resourceGroupName, String name, String slot) {
        return listApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the application settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listApplicationSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listApplicationSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listApplicationSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listApplicationSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner updateAuthSettingsSlot(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings) {
        return updateAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteAuthSettings).toBlocking().single().body();
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteAuthSettingsInner> updateAuthSettingsSlotAsync(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteAuthSettings), serviceCallback);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> updateAuthSettingsSlotAsync(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings) {
        return updateAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteAuthSettings).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> updateAuthSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteAuthSettings == null) {
            throw new IllegalArgumentException("Parameter siteAuthSettings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteAuthSettings);
        return service.updateAuthSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteAuthSettings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = updateAuthSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> updateAuthSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteAuthSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner getAuthSettingsSlot(String resourceGroupName, String name, String slot) {
        return getAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the settings for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteAuthSettingsInner> getAuthSettingsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> getAuthSettingsSlotAsync(String resourceGroupName, String name, String slot) {
        return getAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> getAuthSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getAuthSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = getAuthSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> getAuthSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteAuthSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the backup configuration for the production slot.
     * @param request Edited backup configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner updateBackupConfigurationSlot(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return updateBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).toBlocking().single().body();
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the backup configuration for the production slot.
     * @param request Edited backup configuration.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupRequestInner> updateBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, request), serviceCallback);
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the backup configuration for the production slot.
     * @param request Edited backup configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> updateBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return updateBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the backup configuration for the production slot.
     * @param request Edited backup configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> updateBackupConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(request);
        return service.updateBackupConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), request, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = updateBackupConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> updateBackupConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupRequestInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the backup configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteBackupConfigurationSlot(String resourceGroupName, String name, String slot) {
        deleteBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the backup configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the backup configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return deleteBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the backup configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteBackupConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteBackupConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteBackupConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteBackupConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the backup configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner getBackupConfigurationSlot(String resourceGroupName, String name, String slot) {
        return getBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the backup configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupRequestInner> getBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceFuture.fromResponse(getBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the backup configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> getBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return getBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the backup configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> getBackupConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getBackupConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = getBackupConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> getBackupConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupRequestInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the connection settings for the production slot.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner updateConnectionStringsSlot(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings) {
        return updateConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot, connectionStrings).toBlocking().single().body();
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the connection settings for the production slot.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ConnectionStringDictionaryInner> updateConnectionStringsSlotAsync(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot, connectionStrings), serviceCallback);
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the connection settings for the production slot.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> updateConnectionStringsSlotAsync(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings) {
        return updateConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot, connectionStrings).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the connection settings for the production slot.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> updateConnectionStringsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionStrings == null) {
            throw new IllegalArgumentException("Parameter connectionStrings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionStrings);
        return service.updateConnectionStringsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), connectionStrings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = updateConnectionStringsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> updateConnectionStringsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ConnectionStringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the connection settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner listConnectionStringsSlot(String resourceGroupName, String name, String slot) {
        return listConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the connection settings for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ConnectionStringDictionaryInner> listConnectionStringsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(listConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the connection settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> listConnectionStringsSlotAsync(String resourceGroupName, String name, String slot) {
        return listConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the connection settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> listConnectionStringsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listConnectionStringsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = listConnectionStringsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> listConnectionStringsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ConnectionStringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the logging configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner getDiagnosticLogsConfigurationSlot(String resourceGroupName, String name, String slot) {
        return getDiagnosticLogsConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the logging configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteLogsConfigInner> getDiagnosticLogsConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDiagnosticLogsConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the logging configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> getDiagnosticLogsConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return getDiagnosticLogsConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the logging configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> getDiagnosticLogsConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDiagnosticLogsConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = getDiagnosticLogsConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> getDiagnosticLogsConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteLogsConfigInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the logging configuration for the production slot.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner updateDiagnosticLogsConfigSlot(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig) {
        return updateDiagnosticLogsConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteLogsConfig).toBlocking().single().body();
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the logging configuration for the production slot.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteLogsConfigInner> updateDiagnosticLogsConfigSlotAsync(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateDiagnosticLogsConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteLogsConfig), serviceCallback);
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the logging configuration for the production slot.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> updateDiagnosticLogsConfigSlotAsync(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig) {
        return updateDiagnosticLogsConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteLogsConfig).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the logging configuration for the production slot.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> updateDiagnosticLogsConfigSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteLogsConfig == null) {
            throw new IllegalArgumentException("Parameter siteLogsConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteLogsConfig);
        return service.updateDiagnosticLogsConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteLogsConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = updateDiagnosticLogsConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> updateDiagnosticLogsConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteLogsConfigInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the metadata for the production slot.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateMetadataSlot(String resourceGroupName, String name, String slot, StringDictionaryInner metadata) {
        return updateMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot, metadata).toBlocking().single().body();
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the metadata for the production slot.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> updateMetadataSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner metadata, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot, metadata), serviceCallback);
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the metadata for the production slot.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateMetadataSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner metadata) {
        return updateMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot, metadata).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the metadata for the production slot.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateMetadataSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, StringDictionaryInner metadata) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (metadata == null) {
            throw new IllegalArgumentException("Parameter metadata is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(metadata);
        return service.updateMetadataSlot(resourceGroupName, name, slot, this.client.subscriptionId(), metadata, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateMetadataSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateMetadataSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the metadata for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listMetadataSlot(String resourceGroupName, String name, String slot) {
        return listMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the metadata for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> listMetadataSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(listMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the metadata for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listMetadataSlotAsync(String resourceGroupName, String name, String slot) {
        return listMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the metadata for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listMetadataSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listMetadataSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listMetadataSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listMetadataSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserInner object if successful.
     */
    public UserInner listPublishingCredentialsSlot(String resourceGroupName, String name, String slot) {
        return listPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().last().body();
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserInner> listPublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceFuture.fromResponse(listPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<UserInner> listPublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot) {
        return listPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<UserInner>> listPublishingCredentialsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.listPublishingCredentialsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<UserInner>() { }.getType());
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserInner object if successful.
     */
    public UserInner beginListPublishingCredentialsSlot(String resourceGroupName, String name, String slot) {
        return beginListPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserInner> beginListPublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginListPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserInner object
     */
    public Observable<UserInner> beginListPublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot) {
        return beginListPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserInner object
     */
    public Observable<ServiceResponse<UserInner>> beginListPublishingCredentialsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginListPublishingCredentialsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserInner>>>() {
                @Override
                public Observable<ServiceResponse<UserInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserInner> clientResponse = beginListPublishingCredentialsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserInner> beginListPublishingCredentialsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UserInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<UserInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param pushSettings Push settings associated with web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushSettingsInner object if successful.
     */
    public PushSettingsInner updateSitePushSettingsSlot(String resourceGroupName, String name, String slot, PushSettingsInner pushSettings) {
        return updateSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, pushSettings).toBlocking().single().body();
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param pushSettings Push settings associated with web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushSettingsInner> updateSitePushSettingsSlotAsync(String resourceGroupName, String name, String slot, PushSettingsInner pushSettings, final ServiceCallback<PushSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, pushSettings), serviceCallback);
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param pushSettings Push settings associated with web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<PushSettingsInner> updateSitePushSettingsSlotAsync(String resourceGroupName, String name, String slot, PushSettingsInner pushSettings) {
        return updateSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, pushSettings).map(new Func1<ServiceResponse<PushSettingsInner>, PushSettingsInner>() {
            @Override
            public PushSettingsInner call(ServiceResponse<PushSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param pushSettings Push settings associated with web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<ServiceResponse<PushSettingsInner>> updateSitePushSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, PushSettingsInner pushSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (pushSettings == null) {
            throw new IllegalArgumentException("Parameter pushSettings is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(pushSettings);
        return service.updateSitePushSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), pushSettings, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<PushSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushSettingsInner> clientResponse = updateSitePushSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushSettingsInner> updateSitePushSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PushSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PushSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushSettingsInner object if successful.
     */
    public PushSettingsInner listSitePushSettingsSlot(String resourceGroupName, String name, String slot) {
        return listSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushSettingsInner> listSitePushSettingsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<PushSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(listSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<PushSettingsInner> listSitePushSettingsSlotAsync(String resourceGroupName, String name, String slot) {
        return listSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<PushSettingsInner>, PushSettingsInner>() {
            @Override
            public PushSettingsInner call(ServiceResponse<PushSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<ServiceResponse<PushSettingsInner>> listSitePushSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSitePushSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<PushSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushSettingsInner> clientResponse = listSitePushSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushSettingsInner> listSitePushSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PushSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PushSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner getConfigurationSlot(String resourceGroupName, String name, String slot) {
        return getConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> getConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> getConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return getConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> getConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = getConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> getConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner createOrUpdateConfigurationSlot(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig) {
        return createOrUpdateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).toBlocking().single().body();
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> createOrUpdateConfigurationSlotAsync(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig), serviceCallback);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> createOrUpdateConfigurationSlotAsync(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig) {
        return createOrUpdateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> createOrUpdateConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        return service.createOrUpdateConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = createOrUpdateConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> createOrUpdateConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner updateConfigurationSlot(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig) {
        return updateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).toBlocking().single().body();
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> updateConfigurationSlotAsync(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig), serviceCallback);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> updateConfigurationSlotAsync(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig) {
        return updateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> updateConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        return service.updateConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteConfig, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = updateConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> updateConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object if successful.
     */
    public PagedList<SiteConfigurationSnapshotInfoInner> listConfigurationSnapshotInfoSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>> response = listConfigurationSnapshotInfoSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<SiteConfigurationSnapshotInfoInner>(response.body()) {
            @Override
            public Page<SiteConfigurationSnapshotInfoInner> nextPage(String nextPageLink) {
                return listConfigurationSnapshotInfoSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<SiteConfigurationSnapshotInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listConfigurationSnapshotInfoSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> call(String nextPageLink) {
                    return listConfigurationSnapshotInfoSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object
     */
    public Observable<Page<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listConfigurationSnapshotInfoSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>, Page<SiteConfigurationSnapshotInfoInner>>() {
                @Override
                public Page<SiteConfigurationSnapshotInfoInner> call(ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> listConfigurationSnapshotInfoSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listConfigurationSnapshotInfoSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>, Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> call(ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listConfigurationSnapshotInfoSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
    ServiceResponse<PageImpl<SiteConfigurationSnapshotInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SiteConfigurationSnapshotInfoInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<SiteConfigurationSnapshotInfoInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> listConfigurationSnapshotInfoSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteConfigurationSnapshotInfoInner>> result = listConfigurationSnapshotInfoSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteConfigurationSnapshotInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteConfigurationSnapshotInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner getConfigurationSnapshotSlot(String resourceGroupName, String name, String snapshotId, String slot) {
        return getConfigurationSnapshotSlotWithServiceResponseAsync(resourceGroupName, name, snapshotId, slot).toBlocking().single().body();
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> getConfigurationSnapshotSlotAsync(String resourceGroupName, String name, String snapshotId, String slot, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getConfigurationSnapshotSlotWithServiceResponseAsync(resourceGroupName, name, snapshotId, slot), serviceCallback);
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> getConfigurationSnapshotSlotAsync(String resourceGroupName, String name, String snapshotId, String slot) {
        return getConfigurationSnapshotSlotWithServiceResponseAsync(resourceGroupName, name, snapshotId, slot).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> getConfigurationSnapshotSlotWithServiceResponseAsync(String resourceGroupName, String name, String snapshotId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (snapshotId == null) {
            throw new IllegalArgumentException("Parameter snapshotId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = getConfigurationSnapshotSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> getConfigurationSnapshotSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void recoverSiteConfigurationSnapshotSlot(String resourceGroupName, String name, String snapshotId, String slot) {
        recoverSiteConfigurationSnapshotSlotWithServiceResponseAsync(resourceGroupName, name, snapshotId, slot).toBlocking().single().body();
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> recoverSiteConfigurationSnapshotSlotAsync(String resourceGroupName, String name, String snapshotId, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(recoverSiteConfigurationSnapshotSlotWithServiceResponseAsync(resourceGroupName, name, snapshotId, slot), serviceCallback);
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> recoverSiteConfigurationSnapshotSlotAsync(String resourceGroupName, String name, String snapshotId, String slot) {
        return recoverSiteConfigurationSnapshotSlotWithServiceResponseAsync(resourceGroupName, name, snapshotId, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> recoverSiteConfigurationSnapshotSlotWithServiceResponseAsync(String resourceGroupName, String name, String snapshotId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (snapshotId == null) {
            throw new IllegalArgumentException("Parameter snapshotId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.recoverSiteConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = recoverSiteConfigurationSnapshotSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> recoverSiteConfigurationSnapshotSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the last lines of docker logs for the given site.
     * Gets the last lines of docker logs for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream getWebSiteContainerLogsSlot(String resourceGroupName, String name, String slot) {
        return getWebSiteContainerLogsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the last lines of docker logs for the given site.
     * Gets the last lines of docker logs for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> getWebSiteContainerLogsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(getWebSiteContainerLogsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the last lines of docker logs for the given site.
     * Gets the last lines of docker logs for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> getWebSiteContainerLogsSlotAsync(String resourceGroupName, String name, String slot) {
        return getWebSiteContainerLogsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the last lines of docker logs for the given site.
     * Gets the last lines of docker logs for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> getWebSiteContainerLogsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getWebSiteContainerLogsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = getWebSiteContainerLogsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> getWebSiteContainerLogsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputStream, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the ZIP archived docker log files for the given site.
     * Gets the ZIP archived docker log files for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream getWebSiteContainerLogsZipSlot(String resourceGroupName, String name, String slot) {
        return getWebSiteContainerLogsZipSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the ZIP archived docker log files for the given site.
     * Gets the ZIP archived docker log files for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> getWebSiteContainerLogsZipSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(getWebSiteContainerLogsZipSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the ZIP archived docker log files for the given site.
     * Gets the ZIP archived docker log files for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> getWebSiteContainerLogsZipSlotAsync(String resourceGroupName, String name, String slot) {
        return getWebSiteContainerLogsZipSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the ZIP archived docker log files for the given site.
     * Gets the ZIP archived docker log files for the given site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> getWebSiteContainerLogsZipSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getWebSiteContainerLogsZipSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = getWebSiteContainerLogsZipSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> getWebSiteContainerLogsZipSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputStream, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ContinuousWebJobInner&gt; object if successful.
     */
    public PagedList<ContinuousWebJobInner> listContinuousWebJobsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<ContinuousWebJobInner>> response = listContinuousWebJobsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<ContinuousWebJobInner>(response.body()) {
            @Override
            public Page<ContinuousWebJobInner> nextPage(String nextPageLink) {
                return listContinuousWebJobsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ContinuousWebJobInner>> listContinuousWebJobsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<ContinuousWebJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listContinuousWebJobsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<ContinuousWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> call(String nextPageLink) {
                    return listContinuousWebJobsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ContinuousWebJobInner&gt; object
     */
    public Observable<Page<ContinuousWebJobInner>> listContinuousWebJobsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listContinuousWebJobsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<ContinuousWebJobInner>>, Page<ContinuousWebJobInner>>() {
                @Override
                public Page<ContinuousWebJobInner> call(ServiceResponse<Page<ContinuousWebJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ContinuousWebJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> listContinuousWebJobsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listContinuousWebJobsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<ContinuousWebJobInner>>, Observable<ServiceResponse<Page<ContinuousWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> call(ServiceResponse<Page<ContinuousWebJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listContinuousWebJobsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<ContinuousWebJobInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ContinuousWebJobInner>> * @param name Site name.
    ServiceResponse<PageImpl<ContinuousWebJobInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ContinuousWebJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> listContinuousWebJobsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listContinuousWebJobsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ContinuousWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ContinuousWebJobInner>> result = listContinuousWebJobsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ContinuousWebJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ContinuousWebJobInner>> listContinuousWebJobsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ContinuousWebJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ContinuousWebJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ContinuousWebJobInner object if successful.
     */
    public ContinuousWebJobInner getContinuousWebJobSlot(String resourceGroupName, String name, String webJobName, String slot) {
        return getContinuousWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).toBlocking().single().body();
    }

    /**
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ContinuousWebJobInner> getContinuousWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot, final ServiceCallback<ContinuousWebJobInner> serviceCallback) {
        return ServiceFuture.fromResponse(getContinuousWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot), serviceCallback);
    }

    /**
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ContinuousWebJobInner object
     */
    public Observable<ContinuousWebJobInner> getContinuousWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot) {
        return getContinuousWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).map(new Func1<ServiceResponse<ContinuousWebJobInner>, ContinuousWebJobInner>() {
            @Override
            public ContinuousWebJobInner call(ServiceResponse<ContinuousWebJobInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     * Gets a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ContinuousWebJobInner object
     */
    public Observable<ServiceResponse<ContinuousWebJobInner>> getContinuousWebJobSlotWithServiceResponseAsync(String resourceGroupName, String name, String webJobName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getContinuousWebJobSlot(resourceGroupName, name, webJobName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ContinuousWebJobInner>>>() {
                @Override
                public Observable<ServiceResponse<ContinuousWebJobInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ContinuousWebJobInner> clientResponse = getContinuousWebJobSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ContinuousWebJobInner> getContinuousWebJobSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ContinuousWebJobInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ContinuousWebJobInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteContinuousWebJobSlot(String resourceGroupName, String name, String webJobName, String slot) {
        deleteContinuousWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).toBlocking().single().body();
    }

    /**
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteContinuousWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteContinuousWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot), serviceCallback);
    }

    /**
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteContinuousWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot) {
        return deleteContinuousWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     * Delete a continuous web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteContinuousWebJobSlotWithServiceResponseAsync(String resourceGroupName, String name, String webJobName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteContinuousWebJobSlot(resourceGroupName, name, webJobName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteContinuousWebJobSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteContinuousWebJobSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Start a continuous web job for an app, or a deployment slot.
     * Start a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startContinuousWebJobSlot(String resourceGroupName, String name, String webJobName, String slot) {
        startContinuousWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).toBlocking().single().body();
    }

    /**
     * Start a continuous web job for an app, or a deployment slot.
     * Start a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startContinuousWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startContinuousWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot), serviceCallback);
    }

    /**
     * Start a continuous web job for an app, or a deployment slot.
     * Start a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startContinuousWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot) {
        return startContinuousWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Start a continuous web job for an app, or a deployment slot.
     * Start a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startContinuousWebJobSlotWithServiceResponseAsync(String resourceGroupName, String name, String webJobName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.startContinuousWebJobSlot(resourceGroupName, name, webJobName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startContinuousWebJobSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> startContinuousWebJobSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stop a continuous web job for an app, or a deployment slot.
     * Stop a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void stopContinuousWebJobSlot(String resourceGroupName, String name, String webJobName, String slot) {
        stopContinuousWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).toBlocking().single().body();
    }

    /**
     * Stop a continuous web job for an app, or a deployment slot.
     * Stop a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> stopContinuousWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(stopContinuousWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot), serviceCallback);
    }

    /**
     * Stop a continuous web job for an app, or a deployment slot.
     * Stop a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stopContinuousWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot) {
        return stopContinuousWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stop a continuous web job for an app, or a deployment slot.
     * Stop a continuous web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stopContinuousWebJobSlotWithServiceResponseAsync(String resourceGroupName, String name, String webJobName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.stopContinuousWebJobSlot(resourceGroupName, name, webJobName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stopContinuousWebJobSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> stopContinuousWebJobSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listDeploymentsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<DeploymentInner>> response = listDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<DeploymentInner>(response.body()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeploymentInner>> listDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listDeploymentsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDeploymentsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<DeploymentInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listDeploymentsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listDeploymentsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listDeploymentsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DeploymentInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get a deployment by its ID for an app, or a deployment slot.
     * Get a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner getDeploymentSlot(String resourceGroupName, String name, String id, String slot) {
        return getDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).toBlocking().single().body();
    }

    /**
     * Get a deployment by its ID for an app, or a deployment slot.
     * Get a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeploymentInner> getDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot), serviceCallback);
    }

    /**
     * Get a deployment by its ID for an app, or a deployment slot.
     * Get a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> getDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot) {
        return getDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a deployment by its ID for an app, or a deployment slot.
     * Get a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDeploymentSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DeploymentInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment for an app, or a deployment slot.
     * Create a deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param slot Name of the deployment slot. If a slot is not specified, the API creates a deployment for the production slot.
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner createDeploymentSlot(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment) {
        return createDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, deployment).toBlocking().single().body();
    }

    /**
     * Create a deployment for an app, or a deployment slot.
     * Create a deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param slot Name of the deployment slot. If a slot is not specified, the API creates a deployment for the production slot.
     * @param deployment Deployment details.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeploymentInner> createDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceFuture.fromResponse(createDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, deployment), serviceCallback);
    }

    /**
     * Create a deployment for an app, or a deployment slot.
     * Create a deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param slot Name of the deployment slot. If a slot is not specified, the API creates a deployment for the production slot.
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> createDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment) {
        return createDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, deployment).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a deployment for an app, or a deployment slot.
     * Create a deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param slot Name of the deployment slot. If a slot is not specified, the API creates a deployment for the production slot.
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(deployment);
        return service.createDeploymentSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), deployment, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DeploymentInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a deployment by its ID for an app, or a deployment slot.
     * Delete a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteDeploymentSlot(String resourceGroupName, String name, String id, String slot) {
        deleteDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).toBlocking().single().body();
    }

    /**
     * Delete a deployment by its ID for an app, or a deployment slot.
     * Delete a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot), serviceCallback);
    }

    /**
     * Delete a deployment by its ID for an app, or a deployment slot.
     * Delete a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot) {
        return deleteDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a deployment by its ID for an app, or a deployment slot.
     * Delete a deployment by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteDeploymentSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployment log for specific deployment for an app, or a deployment slot.
     * List deployment log for specific deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id The ID of a specific deployment. This is the value of the name property in the JSON response from "GET /api/sites/{siteName}/deployments".
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner listDeploymentLogSlot(String resourceGroupName, String name, String id, String slot) {
        return listDeploymentLogSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).toBlocking().single().body();
    }

    /**
     * List deployment log for specific deployment for an app, or a deployment slot.
     * List deployment log for specific deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id The ID of a specific deployment. This is the value of the name property in the JSON response from "GET /api/sites/{siteName}/deployments".
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeploymentInner> listDeploymentLogSlotAsync(String resourceGroupName, String name, String id, String slot, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceFuture.fromResponse(listDeploymentLogSlotWithServiceResponseAsync(resourceGroupName, name, id, slot), serviceCallback);
    }

    /**
     * List deployment log for specific deployment for an app, or a deployment slot.
     * List deployment log for specific deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id The ID of a specific deployment. This is the value of the name property in the JSON response from "GET /api/sites/{siteName}/deployments".
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> listDeploymentLogSlotAsync(String resourceGroupName, String name, String id, String slot) {
        return listDeploymentLogSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * List deployment log for specific deployment for an app, or a deployment slot.
     * List deployment log for specific deployment for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id The ID of a specific deployment. This is the value of the name property in the JSON response from "GET /api/sites/{siteName}/deployments".
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> listDeploymentLogSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listDeploymentLogSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = listDeploymentLogSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> listDeploymentLogSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DeploymentInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;IdentifierInner&gt; object if successful.
     */
    public PagedList<IdentifierInner> listDomainOwnershipIdentifiersSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<IdentifierInner>> response = listDomainOwnershipIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<IdentifierInner>(response.body()) {
            @Override
            public Page<IdentifierInner> nextPage(String nextPageLink) {
                return listDomainOwnershipIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IdentifierInner>> listDomainOwnershipIdentifiersSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<IdentifierInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDomainOwnershipIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(String nextPageLink) {
                    return listDomainOwnershipIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<Page<IdentifierInner>> listDomainOwnershipIdentifiersSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listDomainOwnershipIdentifiersSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<IdentifierInner>>, Page<IdentifierInner>>() {
                @Override
                public Page<IdentifierInner> call(ServiceResponse<Page<IdentifierInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listDomainOwnershipIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<IdentifierInner>>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(ServiceResponse<Page<IdentifierInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDomainOwnershipIdentifiersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
    ServiceResponse<PageImpl<IdentifierInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<IdentifierInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<IdentifierInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;IdentifierInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<IdentifierInner>> result = listDomainOwnershipIdentifiersSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<IdentifierInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<IdentifierInner>> listDomainOwnershipIdentifiersSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<IdentifierInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<IdentifierInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IdentifierInner object if successful.
     */
    public IdentifierInner getDomainOwnershipIdentifierSlot(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot) {
        return getDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot).toBlocking().single().body();
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IdentifierInner> getDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, final ServiceCallback<IdentifierInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot), serviceCallback);
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<IdentifierInner> getDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot) {
        return getDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot).map(new Func1<ServiceResponse<IdentifierInner>, IdentifierInner>() {
            @Override
            public IdentifierInner call(ServiceResponse<IdentifierInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<ServiceResponse<IdentifierInner>> getDomainOwnershipIdentifierSlotWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IdentifierInner>>>() {
                @Override
                public Observable<ServiceResponse<IdentifierInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IdentifierInner> clientResponse = getDomainOwnershipIdentifierSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IdentifierInner> getDomainOwnershipIdentifierSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IdentifierInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IdentifierInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IdentifierInner object if successful.
     */
    public IdentifierInner createOrUpdateDomainOwnershipIdentifierSlot(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier) {
        return createOrUpdateDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier).toBlocking().single().body();
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IdentifierInner> createOrUpdateDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier, final ServiceCallback<IdentifierInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier), serviceCallback);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<IdentifierInner> createOrUpdateDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier) {
        return createOrUpdateDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier).map(new Func1<ServiceResponse<IdentifierInner>, IdentifierInner>() {
            @Override
            public IdentifierInner call(ServiceResponse<IdentifierInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<ServiceResponse<IdentifierInner>> createOrUpdateDomainOwnershipIdentifierSlotWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (domainOwnershipIdentifier == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifier is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(domainOwnershipIdentifier);
        return service.createOrUpdateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, this.client.subscriptionId(), domainOwnershipIdentifier, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IdentifierInner>>>() {
                @Override
                public Observable<ServiceResponse<IdentifierInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IdentifierInner> clientResponse = createOrUpdateDomainOwnershipIdentifierSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IdentifierInner> createOrUpdateDomainOwnershipIdentifierSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IdentifierInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IdentifierInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteDomainOwnershipIdentifierSlot(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot) {
        deleteDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot).toBlocking().single().body();
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot), serviceCallback);
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot) {
        return deleteDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteDomainOwnershipIdentifierSlotWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDomainOwnershipIdentifierSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDomainOwnershipIdentifierSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IdentifierInner object if successful.
     */
    public IdentifierInner updateDomainOwnershipIdentifierSlot(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier) {
        return updateDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier).toBlocking().single().body();
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IdentifierInner> updateDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier, final ServiceCallback<IdentifierInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier), serviceCallback);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<IdentifierInner> updateDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier) {
        return updateDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier).map(new Func1<ServiceResponse<IdentifierInner>, IdentifierInner>() {
            @Override
            public IdentifierInner call(ServiceResponse<IdentifierInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<ServiceResponse<IdentifierInner>> updateDomainOwnershipIdentifierSlotWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (domainOwnershipIdentifier == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifier is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(domainOwnershipIdentifier);
        return service.updateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, this.client.subscriptionId(), domainOwnershipIdentifier, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IdentifierInner>>>() {
                @Override
                public Observable<ServiceResponse<IdentifierInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IdentifierInner> clientResponse = updateDomainOwnershipIdentifierSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IdentifierInner> updateDomainOwnershipIdentifierSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IdentifierInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IdentifierInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployStatusInner object if successful.
     */
    public MSDeployStatusInner getMSDeployStatusSlot(String resourceGroupName, String name, String slot) {
        return getMSDeployStatusSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployStatusInner> getMSDeployStatusSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<MSDeployStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMSDeployStatusSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<MSDeployStatusInner> getMSDeployStatusSlotAsync(String resourceGroupName, String name, String slot) {
        return getMSDeployStatusSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<MSDeployStatusInner>, MSDeployStatusInner>() {
            @Override
            public MSDeployStatusInner call(ServiceResponse<MSDeployStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<ServiceResponse<MSDeployStatusInner>> getMSDeployStatusSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getMSDeployStatusSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MSDeployStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<MSDeployStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MSDeployStatusInner> clientResponse = getMSDeployStatusSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MSDeployStatusInner> getMSDeployStatusSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MSDeployStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MSDeployStatusInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployStatusInner object if successful.
     */
    public MSDeployStatusInner createMSDeployOperationSlot(String resourceGroupName, String name, String slot, MSDeploy mSDeploy) {
        return createMSDeployOperationSlotWithServiceResponseAsync(resourceGroupName, name, slot, mSDeploy).toBlocking().last().body();
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param mSDeploy Details of MSDeploy operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployStatusInner> createMSDeployOperationSlotAsync(String resourceGroupName, String name, String slot, MSDeploy mSDeploy, final ServiceCallback<MSDeployStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(createMSDeployOperationSlotWithServiceResponseAsync(resourceGroupName, name, slot, mSDeploy), serviceCallback);
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<MSDeployStatusInner> createMSDeployOperationSlotAsync(String resourceGroupName, String name, String slot, MSDeploy mSDeploy) {
        return createMSDeployOperationSlotWithServiceResponseAsync(resourceGroupName, name, slot, mSDeploy).map(new Func1<ServiceResponse<MSDeployStatusInner>, MSDeployStatusInner>() {
            @Override
            public MSDeployStatusInner call(ServiceResponse<MSDeployStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<MSDeployStatusInner>> createMSDeployOperationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, MSDeploy mSDeploy) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (mSDeploy == null) {
            throw new IllegalArgumentException("Parameter mSDeploy is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(mSDeploy);
        Observable<Response<ResponseBody>> observable = service.createMSDeployOperationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), mSDeploy, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<MSDeployStatusInner>() { }.getType());
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployStatusInner object if successful.
     */
    public MSDeployStatusInner beginCreateMSDeployOperationSlot(String resourceGroupName, String name, String slot, MSDeploy mSDeploy) {
        return beginCreateMSDeployOperationSlotWithServiceResponseAsync(resourceGroupName, name, slot, mSDeploy).toBlocking().single().body();
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param mSDeploy Details of MSDeploy operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployStatusInner> beginCreateMSDeployOperationSlotAsync(String resourceGroupName, String name, String slot, MSDeploy mSDeploy, final ServiceCallback<MSDeployStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateMSDeployOperationSlotWithServiceResponseAsync(resourceGroupName, name, slot, mSDeploy), serviceCallback);
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<MSDeployStatusInner> beginCreateMSDeployOperationSlotAsync(String resourceGroupName, String name, String slot, MSDeploy mSDeploy) {
        return beginCreateMSDeployOperationSlotWithServiceResponseAsync(resourceGroupName, name, slot, mSDeploy).map(new Func1<ServiceResponse<MSDeployStatusInner>, MSDeployStatusInner>() {
            @Override
            public MSDeployStatusInner call(ServiceResponse<MSDeployStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<ServiceResponse<MSDeployStatusInner>> beginCreateMSDeployOperationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, MSDeploy mSDeploy) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (mSDeploy == null) {
            throw new IllegalArgumentException("Parameter mSDeploy is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(mSDeploy);
        return service.beginCreateMSDeployOperationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), mSDeploy, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MSDeployStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<MSDeployStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MSDeployStatusInner> clientResponse = beginCreateMSDeployOperationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MSDeployStatusInner> beginCreateMSDeployOperationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MSDeployStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<MSDeployStatusInner>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployLogInner object if successful.
     */
    public MSDeployLogInner getMSDeployLogSlot(String resourceGroupName, String name, String slot) {
        return getMSDeployLogSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployLogInner> getMSDeployLogSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<MSDeployLogInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMSDeployLogSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployLogInner object
     */
    public Observable<MSDeployLogInner> getMSDeployLogSlotAsync(String resourceGroupName, String name, String slot) {
        return getMSDeployLogSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<MSDeployLogInner>, MSDeployLogInner>() {
            @Override
            public MSDeployLogInner call(ServiceResponse<MSDeployLogInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployLogInner object
     */
    public Observable<ServiceResponse<MSDeployLogInner>> getMSDeployLogSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getMSDeployLogSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MSDeployLogInner>>>() {
                @Override
                public Observable<ServiceResponse<MSDeployLogInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MSDeployLogInner> clientResponse = getMSDeployLogSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MSDeployLogInner> getMSDeployLogSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MSDeployLogInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MSDeployLogInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;FunctionEnvelopeInner&gt; object if successful.
     */
    public PagedList<FunctionEnvelopeInner> listInstanceFunctionsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<FunctionEnvelopeInner>> response = listInstanceFunctionsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<FunctionEnvelopeInner>(response.body()) {
            @Override
            public Page<FunctionEnvelopeInner> nextPage(String nextPageLink) {
                return listInstanceFunctionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FunctionEnvelopeInner>> listInstanceFunctionsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<FunctionEnvelopeInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceFunctionsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<FunctionEnvelopeInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> call(String nextPageLink) {
                    return listInstanceFunctionsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;FunctionEnvelopeInner&gt; object
     */
    public Observable<Page<FunctionEnvelopeInner>> listInstanceFunctionsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listInstanceFunctionsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<FunctionEnvelopeInner>>, Page<FunctionEnvelopeInner>>() {
                @Override
                public Page<FunctionEnvelopeInner> call(ServiceResponse<Page<FunctionEnvelopeInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;FunctionEnvelopeInner&gt; object
     */
    public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> listInstanceFunctionsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listInstanceFunctionsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<FunctionEnvelopeInner>>, Observable<ServiceResponse<Page<FunctionEnvelopeInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> call(ServiceResponse<Page<FunctionEnvelopeInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceFunctionsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
    ServiceResponse<PageImpl<FunctionEnvelopeInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<FunctionEnvelopeInner>> * @param name Site name.
    ServiceResponse<PageImpl<FunctionEnvelopeInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;FunctionEnvelopeInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> listInstanceFunctionsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listInstanceFunctionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<FunctionEnvelopeInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<FunctionEnvelopeInner>> result = listInstanceFunctionsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<FunctionEnvelopeInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<FunctionEnvelopeInner>> listInstanceFunctionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<FunctionEnvelopeInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<FunctionEnvelopeInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Fetch a short lived token that can be exchanged for a master key.
     * Fetch a short lived token that can be exchanged for a master key.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String getFunctionsAdminTokenSlot(String resourceGroupName, String name, String slot) {
        return getFunctionsAdminTokenSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Fetch a short lived token that can be exchanged for a master key.
     * Fetch a short lived token that can be exchanged for a master key.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> getFunctionsAdminTokenSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(getFunctionsAdminTokenSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Fetch a short lived token that can be exchanged for a master key.
     * Fetch a short lived token that can be exchanged for a master key.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> getFunctionsAdminTokenSlotAsync(String resourceGroupName, String name, String slot) {
        return getFunctionsAdminTokenSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Fetch a short lived token that can be exchanged for a master key.
     * Fetch a short lived token that can be exchanged for a master key.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> getFunctionsAdminTokenSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getFunctionsAdminTokenSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = getFunctionsAdminTokenSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> getFunctionsAdminTokenSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<String, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get function information by its ID for web site, or a deployment slot.
     * Get function information by its ID for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionEnvelopeInner object if successful.
     */
    public FunctionEnvelopeInner getInstanceFunctionSlot(String resourceGroupName, String name, String functionName, String slot) {
        return getInstanceFunctionSlotWithServiceResponseAsync(resourceGroupName, name, functionName, slot).toBlocking().single().body();
    }

    /**
     * Get function information by its ID for web site, or a deployment slot.
     * Get function information by its ID for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionEnvelopeInner> getInstanceFunctionSlotAsync(String resourceGroupName, String name, String functionName, String slot, final ServiceCallback<FunctionEnvelopeInner> serviceCallback) {
        return ServiceFuture.fromResponse(getInstanceFunctionSlotWithServiceResponseAsync(resourceGroupName, name, functionName, slot), serviceCallback);
    }

    /**
     * Get function information by its ID for web site, or a deployment slot.
     * Get function information by its ID for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionEnvelopeInner object
     */
    public Observable<FunctionEnvelopeInner> getInstanceFunctionSlotAsync(String resourceGroupName, String name, String functionName, String slot) {
        return getInstanceFunctionSlotWithServiceResponseAsync(resourceGroupName, name, functionName, slot).map(new Func1<ServiceResponse<FunctionEnvelopeInner>, FunctionEnvelopeInner>() {
            @Override
            public FunctionEnvelopeInner call(ServiceResponse<FunctionEnvelopeInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get function information by its ID for web site, or a deployment slot.
     * Get function information by its ID for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionEnvelopeInner object
     */
    public Observable<ServiceResponse<FunctionEnvelopeInner>> getInstanceFunctionSlotWithServiceResponseAsync(String resourceGroupName, String name, String functionName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceFunctionSlot(resourceGroupName, name, functionName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FunctionEnvelopeInner>>>() {
                @Override
                public Observable<ServiceResponse<FunctionEnvelopeInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FunctionEnvelopeInner> clientResponse = getInstanceFunctionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FunctionEnvelopeInner> getInstanceFunctionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FunctionEnvelopeInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FunctionEnvelopeInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param functionEnvelope Function details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionEnvelopeInner object if successful.
     */
    public FunctionEnvelopeInner createInstanceFunctionSlot(String resourceGroupName, String name, String functionName, String slot, FunctionEnvelopeInner functionEnvelope) {
        return createInstanceFunctionSlotWithServiceResponseAsync(resourceGroupName, name, functionName, slot, functionEnvelope).toBlocking().last().body();
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param functionEnvelope Function details.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionEnvelopeInner> createInstanceFunctionSlotAsync(String resourceGroupName, String name, String functionName, String slot, FunctionEnvelopeInner functionEnvelope, final ServiceCallback<FunctionEnvelopeInner> serviceCallback) {
        return ServiceFuture.fromResponse(createInstanceFunctionSlotWithServiceResponseAsync(resourceGroupName, name, functionName, slot, functionEnvelope), serviceCallback);
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param functionEnvelope Function details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<FunctionEnvelopeInner> createInstanceFunctionSlotAsync(String resourceGroupName, String name, String functionName, String slot, FunctionEnvelopeInner functionEnvelope) {
        return createInstanceFunctionSlotWithServiceResponseAsync(resourceGroupName, name, functionName, slot, functionEnvelope).map(new Func1<ServiceResponse<FunctionEnvelopeInner>, FunctionEnvelopeInner>() {
            @Override
            public FunctionEnvelopeInner call(ServiceResponse<FunctionEnvelopeInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param functionEnvelope Function details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<FunctionEnvelopeInner>> createInstanceFunctionSlotWithServiceResponseAsync(String resourceGroupName, String name, String functionName, String slot, FunctionEnvelopeInner functionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (functionEnvelope == null) {
            throw new IllegalArgumentException("Parameter functionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(functionEnvelope);
        Observable<Response<ResponseBody>> observable = service.createInstanceFunctionSlot(resourceGroupName, name, functionName, slot, this.client.subscriptionId(), functionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<FunctionEnvelopeInner>() { }.getType());
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param functionEnvelope Function details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionEnvelopeInner object if successful.
     */
    public FunctionEnvelopeInner beginCreateInstanceFunctionSlot(String resourceGroupName, String name, String functionName, String slot, FunctionEnvelopeInner functionEnvelope) {
        return beginCreateInstanceFunctionSlotWithServiceResponseAsync(resourceGroupName, name, functionName, slot, functionEnvelope).toBlocking().single().body();
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param functionEnvelope Function details.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionEnvelopeInner> beginCreateInstanceFunctionSlotAsync(String resourceGroupName, String name, String functionName, String slot, FunctionEnvelopeInner functionEnvelope, final ServiceCallback<FunctionEnvelopeInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateInstanceFunctionSlotWithServiceResponseAsync(resourceGroupName, name, functionName, slot, functionEnvelope), serviceCallback);
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param functionEnvelope Function details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionEnvelopeInner object
     */
    public Observable<FunctionEnvelopeInner> beginCreateInstanceFunctionSlotAsync(String resourceGroupName, String name, String functionName, String slot, FunctionEnvelopeInner functionEnvelope) {
        return beginCreateInstanceFunctionSlotWithServiceResponseAsync(resourceGroupName, name, functionName, slot, functionEnvelope).map(new Func1<ServiceResponse<FunctionEnvelopeInner>, FunctionEnvelopeInner>() {
            @Override
            public FunctionEnvelopeInner call(ServiceResponse<FunctionEnvelopeInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create function for web site, or a deployment slot.
     * Create function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param functionEnvelope Function details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionEnvelopeInner object
     */
    public Observable<ServiceResponse<FunctionEnvelopeInner>> beginCreateInstanceFunctionSlotWithServiceResponseAsync(String resourceGroupName, String name, String functionName, String slot, FunctionEnvelopeInner functionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (functionEnvelope == null) {
            throw new IllegalArgumentException("Parameter functionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(functionEnvelope);
        return service.beginCreateInstanceFunctionSlot(resourceGroupName, name, functionName, slot, this.client.subscriptionId(), functionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FunctionEnvelopeInner>>>() {
                @Override
                public Observable<ServiceResponse<FunctionEnvelopeInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FunctionEnvelopeInner> clientResponse = beginCreateInstanceFunctionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FunctionEnvelopeInner> beginCreateInstanceFunctionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FunctionEnvelopeInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<FunctionEnvelopeInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a function for web site, or a deployment slot.
     * Delete a function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteInstanceFunctionSlot(String resourceGroupName, String name, String functionName, String slot) {
        deleteInstanceFunctionSlotWithServiceResponseAsync(resourceGroupName, name, functionName, slot).toBlocking().single().body();
    }

    /**
     * Delete a function for web site, or a deployment slot.
     * Delete a function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteInstanceFunctionSlotAsync(String resourceGroupName, String name, String functionName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteInstanceFunctionSlotWithServiceResponseAsync(resourceGroupName, name, functionName, slot), serviceCallback);
    }

    /**
     * Delete a function for web site, or a deployment slot.
     * Delete a function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteInstanceFunctionSlotAsync(String resourceGroupName, String name, String functionName, String slot) {
        return deleteInstanceFunctionSlotWithServiceResponseAsync(resourceGroupName, name, functionName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a function for web site, or a deployment slot.
     * Delete a function for web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteInstanceFunctionSlotWithServiceResponseAsync(String resourceGroupName, String name, String functionName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteInstanceFunctionSlot(resourceGroupName, name, functionName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteInstanceFunctionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteInstanceFunctionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get function secrets for a function in a web site, or a deployment slot.
     * Get function secrets for a function in a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionSecretsInner object if successful.
     */
    public FunctionSecretsInner listFunctionSecretsSlot(String resourceGroupName, String name, String functionName, String slot) {
        return listFunctionSecretsSlotWithServiceResponseAsync(resourceGroupName, name, functionName, slot).toBlocking().single().body();
    }

    /**
     * Get function secrets for a function in a web site, or a deployment slot.
     * Get function secrets for a function in a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionSecretsInner> listFunctionSecretsSlotAsync(String resourceGroupName, String name, String functionName, String slot, final ServiceCallback<FunctionSecretsInner> serviceCallback) {
        return ServiceFuture.fromResponse(listFunctionSecretsSlotWithServiceResponseAsync(resourceGroupName, name, functionName, slot), serviceCallback);
    }

    /**
     * Get function secrets for a function in a web site, or a deployment slot.
     * Get function secrets for a function in a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionSecretsInner object
     */
    public Observable<FunctionSecretsInner> listFunctionSecretsSlotAsync(String resourceGroupName, String name, String functionName, String slot) {
        return listFunctionSecretsSlotWithServiceResponseAsync(resourceGroupName, name, functionName, slot).map(new Func1<ServiceResponse<FunctionSecretsInner>, FunctionSecretsInner>() {
            @Override
            public FunctionSecretsInner call(ServiceResponse<FunctionSecretsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get function secrets for a function in a web site, or a deployment slot.
     * Get function secrets for a function in a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionSecretsInner object
     */
    public Observable<ServiceResponse<FunctionSecretsInner>> listFunctionSecretsSlotWithServiceResponseAsync(String resourceGroupName, String name, String functionName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (functionName == null) {
            throw new IllegalArgumentException("Parameter functionName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listFunctionSecretsSlot(resourceGroupName, name, functionName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FunctionSecretsInner>>>() {
                @Override
                public Observable<ServiceResponse<FunctionSecretsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FunctionSecretsInner> clientResponse = listFunctionSecretsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FunctionSecretsInner> listFunctionSecretsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FunctionSecretsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FunctionSecretsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> listHostNameBindingsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<HostNameBindingInner>> response = listHostNameBindingsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.body()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return listHostNameBindingsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<HostNameBindingInner>> listHostNameBindingsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listHostNameBindingsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return listHostNameBindingsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> listHostNameBindingsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listHostNameBindingsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listHostNameBindingsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listHostNameBindingsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listHostNameBindingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = listHostNameBindingsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> listHostNameBindingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<HostNameBindingInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner getHostNameBindingSlot(String resourceGroupName, String name, String slot, String hostName) {
        return getHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).toBlocking().single().body();
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HostNameBindingInner> getHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceFuture.fromResponse(getHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName), serviceCallback);
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> getHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName) {
        return getHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> getHostNameBindingSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getHostNameBindingSlot(resourceGroupName, name, slot, hostName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = getHostNameBindingSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> getHostNameBindingSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HostNameBindingInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner createOrUpdateHostNameBindingSlot(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding) {
        return createOrUpdateHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, hostName, slot, hostNameBinding).toBlocking().single().body();
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HostNameBindingInner> createOrUpdateHostNameBindingSlotAsync(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, hostName, slot, hostNameBinding), serviceCallback);
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> createOrUpdateHostNameBindingSlotAsync(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding) {
        return createOrUpdateHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, hostName, slot, hostNameBinding).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> createOrUpdateHostNameBindingSlotWithServiceResponseAsync(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (hostNameBinding == null) {
            throw new IllegalArgumentException("Parameter hostNameBinding is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(hostNameBinding);
        return service.createOrUpdateHostNameBindingSlot(resourceGroupName, name, hostName, slot, this.client.subscriptionId(), hostNameBinding, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = createOrUpdateHostNameBindingSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> createOrUpdateHostNameBindingSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HostNameBindingInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteHostNameBindingSlot(String resourceGroupName, String name, String slot, String hostName) {
        deleteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).toBlocking().single().body();
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName), serviceCallback);
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName) {
        return deleteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteHostNameBindingSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteHostNameBindingSlot(resourceGroupName, name, slot, hostName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteHostNameBindingSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteHostNameBindingSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner getHybridConnectionSlot(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return getHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).toBlocking().single().body();
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> getHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot), serviceCallback);
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> getHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return getHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> getHybridConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = getHybridConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> getHybridConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner createOrUpdateHybridConnectionSlot(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        return createOrUpdateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> createOrUpdateHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> createOrUpdateHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        return createOrUpdateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> createOrUpdateHybridConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = createOrUpdateHybridConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> createOrUpdateHybridConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteHybridConnectionSlot(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        deleteHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).toBlocking().single().body();
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot), serviceCallback);
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return deleteHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteHybridConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteHybridConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteHybridConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner updateHybridConnectionSlot(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        return updateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> updateHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> updateHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        return updateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> updateHybridConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = updateHybridConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> updateHybridConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionKeyInner object if successful.
     */
    public HybridConnectionKeyInner listHybridConnectionKeysSlot(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return listHybridConnectionKeysSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).toBlocking().single().body();
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionKeyInner> listHybridConnectionKeysSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, final ServiceCallback<HybridConnectionKeyInner> serviceCallback) {
        return ServiceFuture.fromResponse(listHybridConnectionKeysSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot), serviceCallback);
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionKeyInner object
     */
    public Observable<HybridConnectionKeyInner> listHybridConnectionKeysSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return listHybridConnectionKeysSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).map(new Func1<ServiceResponse<HybridConnectionKeyInner>, HybridConnectionKeyInner>() {
            @Override
            public HybridConnectionKeyInner call(ServiceResponse<HybridConnectionKeyInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionKeyInner object
     */
    public Observable<ServiceResponse<HybridConnectionKeyInner>> listHybridConnectionKeysSlotWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listHybridConnectionKeysSlot(resourceGroupName, name, namespaceName, relayName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionKeyInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionKeyInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionKeyInner> clientResponse = listHybridConnectionKeysSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionKeyInner> listHybridConnectionKeysSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionKeyInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionKeyInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner listHybridConnectionsSlot(String resourceGroupName, String name, String slot) {
        return listHybridConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> listHybridConnectionsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(listHybridConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> listHybridConnectionsSlotAsync(String resourceGroupName, String name, String slot) {
        return listHybridConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> listHybridConnectionsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listHybridConnectionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = listHybridConnectionsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> listHybridConnectionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get hybrid connections for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner listRelayServiceConnectionsSlot(String resourceGroupName, String name, String slot) {
        return listRelayServiceConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get hybrid connections for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> listRelayServiceConnectionsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(listRelayServiceConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get hybrid connections for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> listRelayServiceConnectionsSlotAsync(String resourceGroupName, String name, String slot) {
        return listRelayServiceConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get hybrid connections for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> listRelayServiceConnectionsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listRelayServiceConnectionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = listRelayServiceConnectionsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> listRelayServiceConnectionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a hybrid connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner getRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot) {
        return getRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).toBlocking().single().body();
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a hybrid connection for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> getRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(getRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot), serviceCallback);
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a hybrid connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> getRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot) {
        return getRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a hybrid connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> getRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = getRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> getRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner createOrUpdateRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> createOrUpdateRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = createOrUpdateRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a hybrid connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot) {
        deleteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).toBlocking().single().body();
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a hybrid connection for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot), serviceCallback);
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a hybrid connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot) {
        return deleteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a hybrid connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner updateRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> updateRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> updateRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> updateRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = updateRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> updateRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production slot instances.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> listInstanceIdentifiersSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<SiteInstanceInner>> response = listInstanceIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.body()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production slot instances.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInstanceInner>> listInstanceIdentifiersSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production slot instances.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> listInstanceIdentifiersSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listInstanceIdentifiersSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production slot instances.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listInstanceIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceIdentifiersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production slot instances.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listInstanceIdentifiersSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = listInstanceIdentifiersSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> listInstanceIdentifiersSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInstanceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployStatusInner object if successful.
     */
    public MSDeployStatusInner getInstanceMsDeployStatusSlot(String resourceGroupName, String name, String slot, String instanceId) {
        return getInstanceMsDeployStatusSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId).toBlocking().single().body();
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployStatusInner> getInstanceMsDeployStatusSlotAsync(String resourceGroupName, String name, String slot, String instanceId, final ServiceCallback<MSDeployStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(getInstanceMsDeployStatusSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId), serviceCallback);
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<MSDeployStatusInner> getInstanceMsDeployStatusSlotAsync(String resourceGroupName, String name, String slot, String instanceId) {
        return getInstanceMsDeployStatusSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId).map(new Func1<ServiceResponse<MSDeployStatusInner>, MSDeployStatusInner>() {
            @Override
            public MSDeployStatusInner call(ServiceResponse<MSDeployStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the status of the last MSDeploy operation.
     * Get the status of the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<ServiceResponse<MSDeployStatusInner>> getInstanceMsDeployStatusSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceMsDeployStatusSlot(resourceGroupName, name, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MSDeployStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<MSDeployStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MSDeployStatusInner> clientResponse = getInstanceMsDeployStatusSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MSDeployStatusInner> getInstanceMsDeployStatusSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MSDeployStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MSDeployStatusInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployStatusInner object if successful.
     */
    public MSDeployStatusInner createInstanceMSDeployOperationSlot(String resourceGroupName, String name, String slot, String instanceId, MSDeploy mSDeploy) {
        return createInstanceMSDeployOperationSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId, mSDeploy).toBlocking().last().body();
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployStatusInner> createInstanceMSDeployOperationSlotAsync(String resourceGroupName, String name, String slot, String instanceId, MSDeploy mSDeploy, final ServiceCallback<MSDeployStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(createInstanceMSDeployOperationSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId, mSDeploy), serviceCallback);
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<MSDeployStatusInner> createInstanceMSDeployOperationSlotAsync(String resourceGroupName, String name, String slot, String instanceId, MSDeploy mSDeploy) {
        return createInstanceMSDeployOperationSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId, mSDeploy).map(new Func1<ServiceResponse<MSDeployStatusInner>, MSDeployStatusInner>() {
            @Override
            public MSDeployStatusInner call(ServiceResponse<MSDeployStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<MSDeployStatusInner>> createInstanceMSDeployOperationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String instanceId, MSDeploy mSDeploy) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (mSDeploy == null) {
            throw new IllegalArgumentException("Parameter mSDeploy is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(mSDeploy);
        Observable<Response<ResponseBody>> observable = service.createInstanceMSDeployOperationSlot(resourceGroupName, name, slot, instanceId, this.client.subscriptionId(), mSDeploy, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<MSDeployStatusInner>() { }.getType());
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployStatusInner object if successful.
     */
    public MSDeployStatusInner beginCreateInstanceMSDeployOperationSlot(String resourceGroupName, String name, String slot, String instanceId, MSDeploy mSDeploy) {
        return beginCreateInstanceMSDeployOperationSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId, mSDeploy).toBlocking().single().body();
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployStatusInner> beginCreateInstanceMSDeployOperationSlotAsync(String resourceGroupName, String name, String slot, String instanceId, MSDeploy mSDeploy, final ServiceCallback<MSDeployStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateInstanceMSDeployOperationSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId, mSDeploy), serviceCallback);
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<MSDeployStatusInner> beginCreateInstanceMSDeployOperationSlotAsync(String resourceGroupName, String name, String slot, String instanceId, MSDeploy mSDeploy) {
        return beginCreateInstanceMSDeployOperationSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId, mSDeploy).map(new Func1<ServiceResponse<MSDeployStatusInner>, MSDeployStatusInner>() {
            @Override
            public MSDeployStatusInner call(ServiceResponse<MSDeployStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Invoke the MSDeploy web app extension.
     * Invoke the MSDeploy web app extension.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployStatusInner object
     */
    public Observable<ServiceResponse<MSDeployStatusInner>> beginCreateInstanceMSDeployOperationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String instanceId, MSDeploy mSDeploy) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (mSDeploy == null) {
            throw new IllegalArgumentException("Parameter mSDeploy is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(mSDeploy);
        return service.beginCreateInstanceMSDeployOperationSlot(resourceGroupName, name, slot, instanceId, this.client.subscriptionId(), mSDeploy, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MSDeployStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<MSDeployStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MSDeployStatusInner> clientResponse = beginCreateInstanceMSDeployOperationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MSDeployStatusInner> beginCreateInstanceMSDeployOperationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MSDeployStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<MSDeployStatusInner>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MSDeployLogInner object if successful.
     */
    public MSDeployLogInner getInstanceMSDeployLogSlot(String resourceGroupName, String name, String slot, String instanceId) {
        return getInstanceMSDeployLogSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId).toBlocking().single().body();
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MSDeployLogInner> getInstanceMSDeployLogSlotAsync(String resourceGroupName, String name, String slot, String instanceId, final ServiceCallback<MSDeployLogInner> serviceCallback) {
        return ServiceFuture.fromResponse(getInstanceMSDeployLogSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId), serviceCallback);
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployLogInner object
     */
    public Observable<MSDeployLogInner> getInstanceMSDeployLogSlotAsync(String resourceGroupName, String name, String slot, String instanceId) {
        return getInstanceMSDeployLogSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId).map(new Func1<ServiceResponse<MSDeployLogInner>, MSDeployLogInner>() {
            @Override
            public MSDeployLogInner call(ServiceResponse<MSDeployLogInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the MSDeploy Log for the last MSDeploy operation.
     * Get the MSDeploy Log for the last MSDeploy operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MSDeployLogInner object
     */
    public Observable<ServiceResponse<MSDeployLogInner>> getInstanceMSDeployLogSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceMSDeployLogSlot(resourceGroupName, name, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MSDeployLogInner>>>() {
                @Override
                public Observable<ServiceResponse<MSDeployLogInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MSDeployLogInner> clientResponse = getInstanceMSDeployLogSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MSDeployLogInner> getInstanceMSDeployLogSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MSDeployLogInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MSDeployLogInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessInfoInner&gt; object if successful.
     */
    public PagedList<ProcessInfoInner> listInstanceProcessesSlot(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        ServiceResponse<Page<ProcessInfoInner>> response = listInstanceProcessesSlotSinglePageAsync(resourceGroupName, name, slot, instanceId).toBlocking().single();
        return new PagedList<ProcessInfoInner>(response.body()) {
            @Override
            public Page<ProcessInfoInner> nextPage(String nextPageLink) {
                return listInstanceProcessesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessInfoInner>> listInstanceProcessesSlotAsync(final String resourceGroupName, final String name, final String slot, final String instanceId, final ListOperationCallback<ProcessInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceProcessesSlotSinglePageAsync(resourceGroupName, name, slot, instanceId),
            new Func1<String, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(String nextPageLink) {
                    return listInstanceProcessesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<Page<ProcessInfoInner>> listInstanceProcessesSlotAsync(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        return listInstanceProcessesSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId)
            .map(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Page<ProcessInfoInner>>() {
                @Override
                public Page<ProcessInfoInner> call(ServiceResponse<Page<ProcessInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listInstanceProcessesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        return listInstanceProcessesSlotSinglePageAsync(resourceGroupName, name, slot, instanceId)
            .concatMap(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(ServiceResponse<Page<ProcessInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceProcessesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param name Site name.
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listInstanceProcessesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listInstanceProcessesSlot(resourceGroupName, name, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessInfoInner>> result = listInstanceProcessesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessInfoInner>> listInstanceProcessesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProcessInfoInner object if successful.
     */
    public ProcessInfoInner getInstanceProcessSlot(String resourceGroupName, String name, String processId, String slot, String instanceId) {
        return getInstanceProcessSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot, instanceId).toBlocking().single().body();
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProcessInfoInner> getInstanceProcessSlotAsync(String resourceGroupName, String name, String processId, String slot, String instanceId, final ServiceCallback<ProcessInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getInstanceProcessSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot, instanceId), serviceCallback);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessInfoInner object
     */
    public Observable<ProcessInfoInner> getInstanceProcessSlotAsync(String resourceGroupName, String name, String processId, String slot, String instanceId) {
        return getInstanceProcessSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot, instanceId).map(new Func1<ServiceResponse<ProcessInfoInner>, ProcessInfoInner>() {
            @Override
            public ProcessInfoInner call(ServiceResponse<ProcessInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessInfoInner object
     */
    public Observable<ServiceResponse<ProcessInfoInner>> getInstanceProcessSlotWithServiceResponseAsync(String resourceGroupName, String name, String processId, String slot, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceProcessSlot(resourceGroupName, name, processId, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProcessInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ProcessInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProcessInfoInner> clientResponse = getInstanceProcessSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProcessInfoInner> getInstanceProcessSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProcessInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProcessInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteInstanceProcessSlot(String resourceGroupName, String name, String processId, String slot, String instanceId) {
        deleteInstanceProcessSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot, instanceId).toBlocking().single().body();
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteInstanceProcessSlotAsync(String resourceGroupName, String name, String processId, String slot, String instanceId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteInstanceProcessSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot, instanceId), serviceCallback);
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteInstanceProcessSlotAsync(String resourceGroupName, String name, String processId, String slot, String instanceId) {
        return deleteInstanceProcessSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot, instanceId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteInstanceProcessSlotWithServiceResponseAsync(String resourceGroupName, String name, String processId, String slot, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteInstanceProcessSlot(resourceGroupName, name, processId, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteInstanceProcessSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteInstanceProcessSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream getInstanceProcessDumpSlot(String resourceGroupName, String name, String processId, String slot, String instanceId) {
        return getInstanceProcessDumpSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot, instanceId).toBlocking().single().body();
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> getInstanceProcessDumpSlotAsync(String resourceGroupName, String name, String processId, String slot, String instanceId, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(getInstanceProcessDumpSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot, instanceId), serviceCallback);
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> getInstanceProcessDumpSlotAsync(String resourceGroupName, String name, String processId, String slot, String instanceId) {
        return getInstanceProcessDumpSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot, instanceId).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> getInstanceProcessDumpSlotWithServiceResponseAsync(String resourceGroupName, String name, String processId, String slot, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceProcessDumpSlot(resourceGroupName, name, processId, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = getInstanceProcessDumpSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> getInstanceProcessDumpSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputStream, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object if successful.
     */
    public PagedList<ProcessModuleInfoInner> listInstanceProcessModulesSlot(final String resourceGroupName, final String name, final String processId, final String slot, final String instanceId) {
        ServiceResponse<Page<ProcessModuleInfoInner>> response = listInstanceProcessModulesSlotSinglePageAsync(resourceGroupName, name, processId, slot, instanceId).toBlocking().single();
        return new PagedList<ProcessModuleInfoInner>(response.body()) {
            @Override
            public Page<ProcessModuleInfoInner> nextPage(String nextPageLink) {
                return listInstanceProcessModulesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessModuleInfoInner>> listInstanceProcessModulesSlotAsync(final String resourceGroupName, final String name, final String processId, final String slot, final String instanceId, final ListOperationCallback<ProcessModuleInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceProcessModulesSlotSinglePageAsync(resourceGroupName, name, processId, slot, instanceId),
            new Func1<String, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(String nextPageLink) {
                    return listInstanceProcessModulesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<Page<ProcessModuleInfoInner>> listInstanceProcessModulesSlotAsync(final String resourceGroupName, final String name, final String processId, final String slot, final String instanceId) {
        return listInstanceProcessModulesSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot, instanceId)
            .map(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Page<ProcessModuleInfoInner>>() {
                @Override
                public Page<ProcessModuleInfoInner> call(ServiceResponse<Page<ProcessModuleInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listInstanceProcessModulesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String processId, final String slot, final String instanceId) {
        return listInstanceProcessModulesSlotSinglePageAsync(resourceGroupName, name, processId, slot, instanceId)
            .concatMap(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(ServiceResponse<Page<ProcessModuleInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceProcessModulesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param name Site name.
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param processId PID.
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listInstanceProcessModulesSlotSinglePageAsync(final String resourceGroupName, final String name, final String processId, final String slot, final String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listInstanceProcessModulesSlot(resourceGroupName, name, processId, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessModuleInfoInner>> result = listInstanceProcessModulesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessModuleInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessModuleInfoInner>> listInstanceProcessModulesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessModuleInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessModuleInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProcessModuleInfoInner object if successful.
     */
    public ProcessModuleInfoInner getInstanceProcessModuleSlot(String resourceGroupName, String name, String processId, String baseAddress, String slot, String instanceId) {
        return getInstanceProcessModuleSlotWithServiceResponseAsync(resourceGroupName, name, processId, baseAddress, slot, instanceId).toBlocking().single().body();
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProcessModuleInfoInner> getInstanceProcessModuleSlotAsync(String resourceGroupName, String name, String processId, String baseAddress, String slot, String instanceId, final ServiceCallback<ProcessModuleInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getInstanceProcessModuleSlotWithServiceResponseAsync(resourceGroupName, name, processId, baseAddress, slot, instanceId), serviceCallback);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessModuleInfoInner object
     */
    public Observable<ProcessModuleInfoInner> getInstanceProcessModuleSlotAsync(String resourceGroupName, String name, String processId, String baseAddress, String slot, String instanceId) {
        return getInstanceProcessModuleSlotWithServiceResponseAsync(resourceGroupName, name, processId, baseAddress, slot, instanceId).map(new Func1<ServiceResponse<ProcessModuleInfoInner>, ProcessModuleInfoInner>() {
            @Override
            public ProcessModuleInfoInner call(ServiceResponse<ProcessModuleInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessModuleInfoInner object
     */
    public Observable<ServiceResponse<ProcessModuleInfoInner>> getInstanceProcessModuleSlotWithServiceResponseAsync(String resourceGroupName, String name, String processId, String baseAddress, String slot, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (baseAddress == null) {
            throw new IllegalArgumentException("Parameter baseAddress is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceProcessModuleSlot(resourceGroupName, name, processId, baseAddress, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProcessModuleInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ProcessModuleInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProcessModuleInfoInner> clientResponse = getInstanceProcessModuleSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProcessModuleInfoInner> getInstanceProcessModuleSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProcessModuleInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProcessModuleInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object if successful.
     */
    public PagedList<ProcessThreadInfoInner> listInstanceProcessThreadsSlot(final String resourceGroupName, final String name, final String processId, final String slot, final String instanceId) {
        ServiceResponse<Page<ProcessThreadInfoInner>> response = listInstanceProcessThreadsSlotSinglePageAsync(resourceGroupName, name, processId, slot, instanceId).toBlocking().single();
        return new PagedList<ProcessThreadInfoInner>(response.body()) {
            @Override
            public Page<ProcessThreadInfoInner> nextPage(String nextPageLink) {
                return listInstanceProcessThreadsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessThreadInfoInner>> listInstanceProcessThreadsSlotAsync(final String resourceGroupName, final String name, final String processId, final String slot, final String instanceId, final ListOperationCallback<ProcessThreadInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceProcessThreadsSlotSinglePageAsync(resourceGroupName, name, processId, slot, instanceId),
            new Func1<String, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(String nextPageLink) {
                    return listInstanceProcessThreadsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<Page<ProcessThreadInfoInner>> listInstanceProcessThreadsSlotAsync(final String resourceGroupName, final String name, final String processId, final String slot, final String instanceId) {
        return listInstanceProcessThreadsSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot, instanceId)
            .map(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Page<ProcessThreadInfoInner>>() {
                @Override
                public Page<ProcessThreadInfoInner> call(ServiceResponse<Page<ProcessThreadInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listInstanceProcessThreadsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String processId, final String slot, final String instanceId) {
        return listInstanceProcessThreadsSlotSinglePageAsync(resourceGroupName, name, processId, slot, instanceId)
            .concatMap(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(ServiceResponse<Page<ProcessThreadInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceProcessThreadsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param name Site name.
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param processId PID.
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listInstanceProcessThreadsSlotSinglePageAsync(final String resourceGroupName, final String name, final String processId, final String slot, final String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listInstanceProcessThreadsSlot(resourceGroupName, name, processId, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessThreadInfoInner>> result = listInstanceProcessThreadsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessThreadInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessThreadInfoInner>> listInstanceProcessThreadsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessThreadInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessThreadInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProcessThreadInfoInner object if successful.
     */
    public ProcessThreadInfoInner getInstanceProcessThreadSlot(String resourceGroupName, String name, String processId, String threadId, String slot, String instanceId) {
        return getInstanceProcessThreadSlotWithServiceResponseAsync(resourceGroupName, name, processId, threadId, slot, instanceId).toBlocking().single().body();
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProcessThreadInfoInner> getInstanceProcessThreadSlotAsync(String resourceGroupName, String name, String processId, String threadId, String slot, String instanceId, final ServiceCallback<ProcessThreadInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getInstanceProcessThreadSlotWithServiceResponseAsync(resourceGroupName, name, processId, threadId, slot, instanceId), serviceCallback);
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessThreadInfoInner object
     */
    public Observable<ProcessThreadInfoInner> getInstanceProcessThreadSlotAsync(String resourceGroupName, String name, String processId, String threadId, String slot, String instanceId) {
        return getInstanceProcessThreadSlotWithServiceResponseAsync(resourceGroupName, name, processId, threadId, slot, instanceId).map(new Func1<ServiceResponse<ProcessThreadInfoInner>, ProcessThreadInfoInner>() {
            @Override
            public ProcessThreadInfoInner call(ServiceResponse<ProcessThreadInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessThreadInfoInner object
     */
    public Observable<ServiceResponse<ProcessThreadInfoInner>> getInstanceProcessThreadSlotWithServiceResponseAsync(String resourceGroupName, String name, String processId, String threadId, String slot, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (threadId == null) {
            throw new IllegalArgumentException("Parameter threadId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInstanceProcessThreadSlot(resourceGroupName, name, processId, threadId, slot, instanceId, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProcessThreadInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ProcessThreadInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProcessThreadInfoInner> clientResponse = getInstanceProcessThreadSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProcessThreadInfoInner> getInstanceProcessThreadSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProcessThreadInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProcessThreadInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns information on the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteCloneabilityInner object if successful.
     */
    public SiteCloneabilityInner isCloneableSlot(String resourceGroupName, String name, String slot) {
        return isCloneableSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns information on the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteCloneabilityInner> isCloneableSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteCloneabilityInner> serviceCallback) {
        return ServiceFuture.fromResponse(isCloneableSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns information on the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<SiteCloneabilityInner> isCloneableSlotAsync(String resourceGroupName, String name, String slot) {
        return isCloneableSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteCloneabilityInner>, SiteCloneabilityInner>() {
            @Override
            public SiteCloneabilityInner call(ServiceResponse<SiteCloneabilityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns information on the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<ServiceResponse<SiteCloneabilityInner>> isCloneableSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.isCloneableSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteCloneabilityInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteCloneabilityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteCloneabilityInner> clientResponse = isCloneableSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteCloneabilityInner> isCloneableSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteCloneabilityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteCloneabilityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * This is to allow calling via powershell and ARM template.
     * This is to allow calling via powershell and ARM template.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FunctionSecretsInner object if successful.
     */
    public FunctionSecretsInner listSyncFunctionTriggersSlot(String resourceGroupName, String name, String slot) {
        return listSyncFunctionTriggersSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * This is to allow calling via powershell and ARM template.
     * This is to allow calling via powershell and ARM template.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FunctionSecretsInner> listSyncFunctionTriggersSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<FunctionSecretsInner> serviceCallback) {
        return ServiceFuture.fromResponse(listSyncFunctionTriggersSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * This is to allow calling via powershell and ARM template.
     * This is to allow calling via powershell and ARM template.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionSecretsInner object
     */
    public Observable<FunctionSecretsInner> listSyncFunctionTriggersSlotAsync(String resourceGroupName, String name, String slot) {
        return listSyncFunctionTriggersSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<FunctionSecretsInner>, FunctionSecretsInner>() {
            @Override
            public FunctionSecretsInner call(ServiceResponse<FunctionSecretsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * This is to allow calling via powershell and ARM template.
     * This is to allow calling via powershell and ARM template.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FunctionSecretsInner object
     */
    public Observable<ServiceResponse<FunctionSecretsInner>> listSyncFunctionTriggersSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSyncFunctionTriggersSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FunctionSecretsInner>>>() {
                @Override
                public Observable<ServiceResponse<FunctionSecretsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FunctionSecretsInner> clientResponse = listSyncFunctionTriggersSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FunctionSecretsInner> listSyncFunctionTriggersSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FunctionSecretsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FunctionSecretsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metric definitions of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object if successful.
     */
    public PagedList<ResourceMetricDefinitionInner> listMetricDefinitionsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<ResourceMetricDefinitionInner>> response = listMetricDefinitionsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<ResourceMetricDefinitionInner>(response.body()) {
            @Override
            public Page<ResourceMetricDefinitionInner> nextPage(String nextPageLink) {
                return listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metric definitions of the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricDefinitionInner>> listMetricDefinitionsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<ResourceMetricDefinitionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricDefinitionsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(String nextPageLink) {
                    return listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metric definitions of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<Page<ResourceMetricDefinitionInner>> listMetricDefinitionsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listMetricDefinitionsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Page<ResourceMetricDefinitionInner>>() {
                @Override
                public Page<ResourceMetricDefinitionInner> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metric definitions of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listMetricDefinitionsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricDefinitionsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API will get metric definitions of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listMetricDefinitionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> result = listMetricDefinitionsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricDefinitionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> listMetricDefinitionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricDefinitionInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetricsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.body()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricInner>> listMetricsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listMetricsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listMetricsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean details = null;
        final String filter = null;
        return service.listMetricsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), details, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetricsSlot(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSlotSinglePageAsync(resourceGroupName, name, slot, details, filter).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.body()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricInner>> listMetricsSlotAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsSlotSinglePageAsync(resourceGroupName, name, slot, details, filter),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsSlotAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        return listMetricsSlotWithServiceResponseAsync(resourceGroupName, name, slot, details, filter)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        return listMetricsSlotSinglePageAsync(resourceGroupName, name, slot, details, filter)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param details Specify "true" to include metric details in the response. It is "false" by default.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listMetricsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), details, filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> listMetricsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of the deployment slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MigrateMySqlStatusInner object if successful.
     */
    public MigrateMySqlStatusInner getMigrateMySqlStatusSlot(String resourceGroupName, String name, String slot) {
        return getMigrateMySqlStatusSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of the deployment slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MigrateMySqlStatusInner> getMigrateMySqlStatusSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<MigrateMySqlStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMigrateMySqlStatusSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of the deployment slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MigrateMySqlStatusInner object
     */
    public Observable<MigrateMySqlStatusInner> getMigrateMySqlStatusSlotAsync(String resourceGroupName, String name, String slot) {
        return getMigrateMySqlStatusSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<MigrateMySqlStatusInner>, MigrateMySqlStatusInner>() {
            @Override
            public MigrateMySqlStatusInner call(ServiceResponse<MigrateMySqlStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of the deployment slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MigrateMySqlStatusInner object
     */
    public Observable<ServiceResponse<MigrateMySqlStatusInner>> getMigrateMySqlStatusSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getMigrateMySqlStatusSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MigrateMySqlStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<MigrateMySqlStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MigrateMySqlStatusInner> clientResponse = getMigrateMySqlStatusSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MigrateMySqlStatusInner> getMigrateMySqlStatusSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MigrateMySqlStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MigrateMySqlStatusInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get network features for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NetworkFeaturesInner object if successful.
     */
    public NetworkFeaturesInner listNetworkFeaturesSlot(String resourceGroupName, String name, String view, String slot) {
        return listNetworkFeaturesSlotWithServiceResponseAsync(resourceGroupName, name, view, slot).toBlocking().single().body();
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get network features for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NetworkFeaturesInner> listNetworkFeaturesSlotAsync(String resourceGroupName, String name, String view, String slot, final ServiceCallback<NetworkFeaturesInner> serviceCallback) {
        return ServiceFuture.fromResponse(listNetworkFeaturesSlotWithServiceResponseAsync(resourceGroupName, name, view, slot), serviceCallback);
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get network features for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<NetworkFeaturesInner> listNetworkFeaturesSlotAsync(String resourceGroupName, String name, String view, String slot) {
        return listNetworkFeaturesSlotWithServiceResponseAsync(resourceGroupName, name, view, slot).map(new Func1<ServiceResponse<NetworkFeaturesInner>, NetworkFeaturesInner>() {
            @Override
            public NetworkFeaturesInner call(ServiceResponse<NetworkFeaturesInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get network features for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<ServiceResponse<NetworkFeaturesInner>> listNetworkFeaturesSlotWithServiceResponseAsync(String resourceGroupName, String name, String view, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (view == null) {
            throw new IllegalArgumentException("Parameter view is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listNetworkFeaturesSlot(resourceGroupName, name, view, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NetworkFeaturesInner>>>() {
                @Override
                public Observable<ServiceResponse<NetworkFeaturesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NetworkFeaturesInner> clientResponse = listNetworkFeaturesSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NetworkFeaturesInner> listNetworkFeaturesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<NetworkFeaturesInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<NetworkFeaturesInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String startWebSiteNetworkTraceSlot(String resourceGroupName, String name, String slot) {
        return startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> startWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> startWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot) {
        return startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> startWebSiteNetworkTraceSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Integer durationInSeconds = null;
        final Integer maxFrameLength = null;
        final String sasUrl = null;
        return service.startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, this.client.subscriptionId(), durationInSeconds, maxFrameLength, sasUrl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = startWebSiteNetworkTraceSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String startWebSiteNetworkTraceSlot(String resourceGroupName, String name, String slot, Integer durationInSeconds, Integer maxFrameLength, String sasUrl) {
        return startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot, durationInSeconds, maxFrameLength, sasUrl).toBlocking().single().body();
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> startWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot, Integer durationInSeconds, Integer maxFrameLength, String sasUrl, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot, durationInSeconds, maxFrameLength, sasUrl), serviceCallback);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> startWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot, Integer durationInSeconds, Integer maxFrameLength, String sasUrl) {
        return startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot, durationInSeconds, maxFrameLength, sasUrl).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> startWebSiteNetworkTraceSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, Integer durationInSeconds, Integer maxFrameLength, String sasUrl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, this.client.subscriptionId(), durationInSeconds, maxFrameLength, sasUrl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = startWebSiteNetworkTraceSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> startWebSiteNetworkTraceSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<String, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String stopWebSiteNetworkTraceSlot(String resourceGroupName, String name, String slot) {
        return stopWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> stopWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(stopWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> stopWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot) {
        return stopWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> stopWebSiteNetworkTraceSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.stopWebSiteNetworkTraceSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = stopWebSiteNetworkTraceSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> stopWebSiteNetworkTraceSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<String, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API generate a new publishing password for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void generateNewSitePublishingPasswordSlot(String resourceGroupName, String name, String slot) {
        generateNewSitePublishingPasswordSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API generate a new publishing password for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> generateNewSitePublishingPasswordSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(generateNewSitePublishingPasswordSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API generate a new publishing password for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> generateNewSitePublishingPasswordSlotAsync(String resourceGroupName, String name, String slot) {
        return generateNewSitePublishingPasswordSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API generate a new publishing password for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> generateNewSitePublishingPasswordSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = generateNewSitePublishingPasswordSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> generateNewSitePublishingPasswordSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCountersSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.body()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PerfMonResponseInner>> listPerfMonCountersSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listPerfMonCountersSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        return service.listPerfMonCountersSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCountersSlot(final String resourceGroupName, final String name, final String slot, final String filter) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot, filter).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.body()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PerfMonResponseInner>> listPerfMonCountersSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot, filter),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        return listPerfMonCountersSlotWithServiceResponseAsync(resourceGroupName, name, slot, filter)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        return listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot, filter)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param name Name of web app.
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listPerfMonCountersSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PerfMonResponseInner>> listPerfMonCountersSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<PerfMonResponseInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<PerfMonResponseInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SitePhpErrorLogFlagInner object if successful.
     */
    public SitePhpErrorLogFlagInner getSitePhpErrorLogFlagSlot(String resourceGroupName, String name, String slot) {
        return getSitePhpErrorLogFlagSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SitePhpErrorLogFlagInner> getSitePhpErrorLogFlagSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SitePhpErrorLogFlagInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSitePhpErrorLogFlagSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SitePhpErrorLogFlagInner object
     */
    public Observable<SitePhpErrorLogFlagInner> getSitePhpErrorLogFlagSlotAsync(String resourceGroupName, String name, String slot) {
        return getSitePhpErrorLogFlagSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SitePhpErrorLogFlagInner>, SitePhpErrorLogFlagInner>() {
            @Override
            public SitePhpErrorLogFlagInner call(ServiceResponse<SitePhpErrorLogFlagInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SitePhpErrorLogFlagInner object
     */
    public Observable<ServiceResponse<SitePhpErrorLogFlagInner>> getSitePhpErrorLogFlagSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSitePhpErrorLogFlagSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SitePhpErrorLogFlagInner>>>() {
                @Override
                public Observable<ServiceResponse<SitePhpErrorLogFlagInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SitePhpErrorLogFlagInner> clientResponse = getSitePhpErrorLogFlagSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SitePhpErrorLogFlagInner> getSitePhpErrorLogFlagSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SitePhpErrorLogFlagInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SitePhpErrorLogFlagInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the premier add-ons for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PremierAddOnInner object if successful.
     */
    public PremierAddOnInner listPremierAddOnsSlot(String resourceGroupName, String name, String slot) {
        return listPremierAddOnsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the premier add-ons for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PremierAddOnInner> listPremierAddOnsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<PremierAddOnInner> serviceCallback) {
        return ServiceFuture.fromResponse(listPremierAddOnsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the premier add-ons for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<PremierAddOnInner> listPremierAddOnsSlotAsync(String resourceGroupName, String name, String slot) {
        return listPremierAddOnsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<PremierAddOnInner>, PremierAddOnInner>() {
            @Override
            public PremierAddOnInner call(ServiceResponse<PremierAddOnInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the premier add-ons for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<ServiceResponse<PremierAddOnInner>> listPremierAddOnsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listPremierAddOnsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PremierAddOnInner>>>() {
                @Override
                public Observable<ServiceResponse<PremierAddOnInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PremierAddOnInner> clientResponse = listPremierAddOnsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PremierAddOnInner> listPremierAddOnsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PremierAddOnInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PremierAddOnInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named add-on for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PremierAddOnInner object if successful.
     */
    public PremierAddOnInner getPremierAddOnSlot(String resourceGroupName, String name, String premierAddOnName, String slot) {
        return getPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).toBlocking().single().body();
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named add-on for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PremierAddOnInner> getPremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, final ServiceCallback<PremierAddOnInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot), serviceCallback);
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named add-on for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<PremierAddOnInner> getPremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        return getPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).map(new Func1<ServiceResponse<PremierAddOnInner>, PremierAddOnInner>() {
            @Override
            public PremierAddOnInner call(ServiceResponse<PremierAddOnInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named add-on for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<ServiceResponse<PremierAddOnInner>> getPremierAddOnSlotWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PremierAddOnInner>>>() {
                @Override
                public Observable<ServiceResponse<PremierAddOnInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PremierAddOnInner> clientResponse = getPremierAddOnSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PremierAddOnInner> getPremierAddOnSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PremierAddOnInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PremierAddOnInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the named add-on for the production slot.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PremierAddOnInner object if successful.
     */
    public PremierAddOnInner addPremierAddOnSlot(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnInner premierAddOn) {
        return addPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot, premierAddOn).toBlocking().single().body();
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the named add-on for the production slot.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PremierAddOnInner> addPremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnInner premierAddOn, final ServiceCallback<PremierAddOnInner> serviceCallback) {
        return ServiceFuture.fromResponse(addPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot, premierAddOn), serviceCallback);
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the named add-on for the production slot.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<PremierAddOnInner> addPremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnInner premierAddOn) {
        return addPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot, premierAddOn).map(new Func1<ServiceResponse<PremierAddOnInner>, PremierAddOnInner>() {
            @Override
            public PremierAddOnInner call(ServiceResponse<PremierAddOnInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the named add-on for the production slot.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<ServiceResponse<PremierAddOnInner>> addPremierAddOnSlotWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnInner premierAddOn) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (premierAddOn == null) {
            throw new IllegalArgumentException("Parameter premierAddOn is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(premierAddOn);
        return service.addPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, this.client.subscriptionId(), premierAddOn, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PremierAddOnInner>>>() {
                @Override
                public Observable<ServiceResponse<PremierAddOnInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PremierAddOnInner> clientResponse = addPremierAddOnSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PremierAddOnInner> addPremierAddOnSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PremierAddOnInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PremierAddOnInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the named add-on for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deletePremierAddOnSlot(String resourceGroupName, String name, String premierAddOnName, String slot) {
        deletePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).toBlocking().single().body();
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the named add-on for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deletePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deletePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot), serviceCallback);
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the named add-on for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deletePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        return deletePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the named add-on for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deletePremierAddOnSlotWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deletePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deletePremierAddOnSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deletePremierAddOnSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessInfoInner&gt; object if successful.
     */
    public PagedList<ProcessInfoInner> listProcessesSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<ProcessInfoInner>> response = listProcessesSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<ProcessInfoInner>(response.body()) {
            @Override
            public Page<ProcessInfoInner> nextPage(String nextPageLink) {
                return listProcessesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessInfoInner>> listProcessesSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<ProcessInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listProcessesSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(String nextPageLink) {
                    return listProcessesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<Page<ProcessInfoInner>> listProcessesSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listProcessesSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Page<ProcessInfoInner>>() {
                @Override
                public Page<ProcessInfoInner> call(ServiceResponse<Page<ProcessInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listProcessesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listProcessesSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(ServiceResponse<Page<ProcessInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listProcessesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param name Site name.
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listProcessesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listProcessesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessInfoInner>> result = listProcessesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessInfoInner>> listProcessesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProcessInfoInner object if successful.
     */
    public ProcessInfoInner getProcessSlot(String resourceGroupName, String name, String processId, String slot) {
        return getProcessSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot).toBlocking().single().body();
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProcessInfoInner> getProcessSlotAsync(String resourceGroupName, String name, String processId, String slot, final ServiceCallback<ProcessInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getProcessSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot), serviceCallback);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessInfoInner object
     */
    public Observable<ProcessInfoInner> getProcessSlotAsync(String resourceGroupName, String name, String processId, String slot) {
        return getProcessSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot).map(new Func1<ServiceResponse<ProcessInfoInner>, ProcessInfoInner>() {
            @Override
            public ProcessInfoInner call(ServiceResponse<ProcessInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessInfoInner object
     */
    public Observable<ServiceResponse<ProcessInfoInner>> getProcessSlotWithServiceResponseAsync(String resourceGroupName, String name, String processId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getProcessSlot(resourceGroupName, name, processId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProcessInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ProcessInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProcessInfoInner> clientResponse = getProcessSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProcessInfoInner> getProcessSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProcessInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProcessInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteProcessSlot(String resourceGroupName, String name, String processId, String slot) {
        deleteProcessSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot).toBlocking().single().body();
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteProcessSlotAsync(String resourceGroupName, String name, String processId, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteProcessSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot), serviceCallback);
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteProcessSlotAsync(String resourceGroupName, String name, String processId, String slot) {
        return deleteProcessSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     * Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteProcessSlotWithServiceResponseAsync(String resourceGroupName, String name, String processId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteProcessSlot(resourceGroupName, name, processId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteProcessSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteProcessSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream getProcessDumpSlot(String resourceGroupName, String name, String processId, String slot) {
        return getProcessDumpSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot).toBlocking().single().body();
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> getProcessDumpSlotAsync(String resourceGroupName, String name, String processId, String slot, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(getProcessDumpSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot), serviceCallback);
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> getProcessDumpSlotAsync(String resourceGroupName, String name, String processId, String slot) {
        return getProcessDumpSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     * Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> getProcessDumpSlotWithServiceResponseAsync(String resourceGroupName, String name, String processId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getProcessDumpSlot(resourceGroupName, name, processId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = getProcessDumpSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> getProcessDumpSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputStream, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object if successful.
     */
    public PagedList<ProcessModuleInfoInner> listProcessModulesSlot(final String resourceGroupName, final String name, final String processId, final String slot) {
        ServiceResponse<Page<ProcessModuleInfoInner>> response = listProcessModulesSlotSinglePageAsync(resourceGroupName, name, processId, slot).toBlocking().single();
        return new PagedList<ProcessModuleInfoInner>(response.body()) {
            @Override
            public Page<ProcessModuleInfoInner> nextPage(String nextPageLink) {
                return listProcessModulesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessModuleInfoInner>> listProcessModulesSlotAsync(final String resourceGroupName, final String name, final String processId, final String slot, final ListOperationCallback<ProcessModuleInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listProcessModulesSlotSinglePageAsync(resourceGroupName, name, processId, slot),
            new Func1<String, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(String nextPageLink) {
                    return listProcessModulesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<Page<ProcessModuleInfoInner>> listProcessModulesSlotAsync(final String resourceGroupName, final String name, final String processId, final String slot) {
        return listProcessModulesSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot)
            .map(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Page<ProcessModuleInfoInner>>() {
                @Override
                public Page<ProcessModuleInfoInner> call(ServiceResponse<Page<ProcessModuleInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listProcessModulesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String processId, final String slot) {
        return listProcessModulesSlotSinglePageAsync(resourceGroupName, name, processId, slot)
            .concatMap(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(ServiceResponse<Page<ProcessModuleInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listProcessModulesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param name Site name.
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param processId PID.
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listProcessModulesSlotSinglePageAsync(final String resourceGroupName, final String name, final String processId, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listProcessModulesSlot(resourceGroupName, name, processId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessModuleInfoInner>> result = listProcessModulesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessModuleInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessModuleInfoInner>> listProcessModulesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessModuleInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessModuleInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProcessModuleInfoInner object if successful.
     */
    public ProcessModuleInfoInner getProcessModuleSlot(String resourceGroupName, String name, String processId, String baseAddress, String slot) {
        return getProcessModuleSlotWithServiceResponseAsync(resourceGroupName, name, processId, baseAddress, slot).toBlocking().single().body();
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProcessModuleInfoInner> getProcessModuleSlotAsync(String resourceGroupName, String name, String processId, String baseAddress, String slot, final ServiceCallback<ProcessModuleInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getProcessModuleSlotWithServiceResponseAsync(resourceGroupName, name, processId, baseAddress, slot), serviceCallback);
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessModuleInfoInner object
     */
    public Observable<ProcessModuleInfoInner> getProcessModuleSlotAsync(String resourceGroupName, String name, String processId, String baseAddress, String slot) {
        return getProcessModuleSlotWithServiceResponseAsync(resourceGroupName, name, processId, baseAddress, slot).map(new Func1<ServiceResponse<ProcessModuleInfoInner>, ProcessModuleInfoInner>() {
            @Override
            public ProcessModuleInfoInner call(ServiceResponse<ProcessModuleInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get process information by its ID for a specific scaled-out instance in a web site.
     * Get process information by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessModuleInfoInner object
     */
    public Observable<ServiceResponse<ProcessModuleInfoInner>> getProcessModuleSlotWithServiceResponseAsync(String resourceGroupName, String name, String processId, String baseAddress, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (baseAddress == null) {
            throw new IllegalArgumentException("Parameter baseAddress is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getProcessModuleSlot(resourceGroupName, name, processId, baseAddress, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProcessModuleInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ProcessModuleInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProcessModuleInfoInner> clientResponse = getProcessModuleSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProcessModuleInfoInner> getProcessModuleSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProcessModuleInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProcessModuleInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object if successful.
     */
    public PagedList<ProcessThreadInfoInner> listProcessThreadsSlot(final String resourceGroupName, final String name, final String processId, final String slot) {
        ServiceResponse<Page<ProcessThreadInfoInner>> response = listProcessThreadsSlotSinglePageAsync(resourceGroupName, name, processId, slot).toBlocking().single();
        return new PagedList<ProcessThreadInfoInner>(response.body()) {
            @Override
            public Page<ProcessThreadInfoInner> nextPage(String nextPageLink) {
                return listProcessThreadsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessThreadInfoInner>> listProcessThreadsSlotAsync(final String resourceGroupName, final String name, final String processId, final String slot, final ListOperationCallback<ProcessThreadInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listProcessThreadsSlotSinglePageAsync(resourceGroupName, name, processId, slot),
            new Func1<String, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(String nextPageLink) {
                    return listProcessThreadsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<Page<ProcessThreadInfoInner>> listProcessThreadsSlotAsync(final String resourceGroupName, final String name, final String processId, final String slot) {
        return listProcessThreadsSlotWithServiceResponseAsync(resourceGroupName, name, processId, slot)
            .map(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Page<ProcessThreadInfoInner>>() {
                @Override
                public Page<ProcessThreadInfoInner> call(ServiceResponse<Page<ProcessThreadInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listProcessThreadsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String processId, final String slot) {
        return listProcessThreadsSlotSinglePageAsync(resourceGroupName, name, processId, slot)
            .concatMap(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(ServiceResponse<Page<ProcessThreadInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listProcessThreadsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param name Site name.
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param processId PID.
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listProcessThreadsSlotSinglePageAsync(final String resourceGroupName, final String name, final String processId, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listProcessThreadsSlot(resourceGroupName, name, processId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessThreadInfoInner>> result = listProcessThreadsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessThreadInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessThreadInfoInner>> listProcessThreadsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessThreadInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessThreadInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProcessThreadInfoInner object if successful.
     */
    public ProcessThreadInfoInner getProcessThreadSlot(String resourceGroupName, String name, String processId, String threadId, String slot) {
        return getProcessThreadSlotWithServiceResponseAsync(resourceGroupName, name, processId, threadId, slot).toBlocking().single().body();
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProcessThreadInfoInner> getProcessThreadSlotAsync(String resourceGroupName, String name, String processId, String threadId, String slot, final ServiceCallback<ProcessThreadInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getProcessThreadSlotWithServiceResponseAsync(resourceGroupName, name, processId, threadId, slot), serviceCallback);
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessThreadInfoInner object
     */
    public Observable<ProcessThreadInfoInner> getProcessThreadSlotAsync(String resourceGroupName, String name, String processId, String threadId, String slot) {
        return getProcessThreadSlotWithServiceResponseAsync(resourceGroupName, name, processId, threadId, slot).map(new Func1<ServiceResponse<ProcessThreadInfoInner>, ProcessThreadInfoInner>() {
            @Override
            public ProcessThreadInfoInner call(ServiceResponse<ProcessThreadInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     * Get thread information by Thread ID for a specific process, in a specific scaled-out instance in a web site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param threadId TID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProcessThreadInfoInner object
     */
    public Observable<ServiceResponse<ProcessThreadInfoInner>> getProcessThreadSlotWithServiceResponseAsync(String resourceGroupName, String name, String processId, String threadId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        if (threadId == null) {
            throw new IllegalArgumentException("Parameter threadId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getProcessThreadSlot(resourceGroupName, name, processId, threadId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProcessThreadInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ProcessThreadInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProcessThreadInfoInner> clientResponse = getProcessThreadSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProcessThreadInfoInner> getProcessThreadSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProcessThreadInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProcessThreadInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PublicCertificateInner&gt; object if successful.
     */
    public PagedList<PublicCertificateInner> listPublicCertificatesSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<PublicCertificateInner>> response = listPublicCertificatesSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<PublicCertificateInner>(response.body()) {
            @Override
            public Page<PublicCertificateInner> nextPage(String nextPageLink) {
                return listPublicCertificatesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PublicCertificateInner>> listPublicCertificatesSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<PublicCertificateInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPublicCertificatesSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<PublicCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PublicCertificateInner>>> call(String nextPageLink) {
                    return listPublicCertificatesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PublicCertificateInner&gt; object
     */
    public Observable<Page<PublicCertificateInner>> listPublicCertificatesSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listPublicCertificatesSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<PublicCertificateInner>>, Page<PublicCertificateInner>>() {
                @Override
                public Page<PublicCertificateInner> call(ServiceResponse<Page<PublicCertificateInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PublicCertificateInner&gt; object
     */
    public Observable<ServiceResponse<Page<PublicCertificateInner>>> listPublicCertificatesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listPublicCertificatesSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<PublicCertificateInner>>, Observable<ServiceResponse<Page<PublicCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PublicCertificateInner>>> call(ServiceResponse<Page<PublicCertificateInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPublicCertificatesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
    ServiceResponse<PageImpl<PublicCertificateInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<PublicCertificateInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<PublicCertificateInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PublicCertificateInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PublicCertificateInner>>> listPublicCertificatesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listPublicCertificatesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PublicCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PublicCertificateInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PublicCertificateInner>> result = listPublicCertificatesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PublicCertificateInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PublicCertificateInner>> listPublicCertificatesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<PublicCertificateInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<PublicCertificateInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the named public certificate for an app (or deployment slot, if specified).
     * Get the named public certificate for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
     * @param publicCertificateName Public certificate name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PublicCertificateInner object if successful.
     */
    public PublicCertificateInner getPublicCertificateSlot(String resourceGroupName, String name, String slot, String publicCertificateName) {
        return getPublicCertificateSlotWithServiceResponseAsync(resourceGroupName, name, slot, publicCertificateName).toBlocking().single().body();
    }

    /**
     * Get the named public certificate for an app (or deployment slot, if specified).
     * Get the named public certificate for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
     * @param publicCertificateName Public certificate name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PublicCertificateInner> getPublicCertificateSlotAsync(String resourceGroupName, String name, String slot, String publicCertificateName, final ServiceCallback<PublicCertificateInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPublicCertificateSlotWithServiceResponseAsync(resourceGroupName, name, slot, publicCertificateName), serviceCallback);
    }

    /**
     * Get the named public certificate for an app (or deployment slot, if specified).
     * Get the named public certificate for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
     * @param publicCertificateName Public certificate name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PublicCertificateInner object
     */
    public Observable<PublicCertificateInner> getPublicCertificateSlotAsync(String resourceGroupName, String name, String slot, String publicCertificateName) {
        return getPublicCertificateSlotWithServiceResponseAsync(resourceGroupName, name, slot, publicCertificateName).map(new Func1<ServiceResponse<PublicCertificateInner>, PublicCertificateInner>() {
            @Override
            public PublicCertificateInner call(ServiceResponse<PublicCertificateInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the named public certificate for an app (or deployment slot, if specified).
     * Get the named public certificate for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
     * @param publicCertificateName Public certificate name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PublicCertificateInner object
     */
    public Observable<ServiceResponse<PublicCertificateInner>> getPublicCertificateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String publicCertificateName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (publicCertificateName == null) {
            throw new IllegalArgumentException("Parameter publicCertificateName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getPublicCertificateSlot(resourceGroupName, name, slot, publicCertificateName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PublicCertificateInner>>>() {
                @Override
                public Observable<ServiceResponse<PublicCertificateInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PublicCertificateInner> clientResponse = getPublicCertificateSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PublicCertificateInner> getPublicCertificateSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PublicCertificateInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PublicCertificateInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
     * @param publicCertificate Public certificate details. This is the JSON representation of a PublicCertificate object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PublicCertificateInner object if successful.
     */
    public PublicCertificateInner createOrUpdatePublicCertificateSlot(String resourceGroupName, String name, String publicCertificateName, String slot, PublicCertificateInner publicCertificate) {
        return createOrUpdatePublicCertificateSlotWithServiceResponseAsync(resourceGroupName, name, publicCertificateName, slot, publicCertificate).toBlocking().single().body();
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
     * @param publicCertificate Public certificate details. This is the JSON representation of a PublicCertificate object.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PublicCertificateInner> createOrUpdatePublicCertificateSlotAsync(String resourceGroupName, String name, String publicCertificateName, String slot, PublicCertificateInner publicCertificate, final ServiceCallback<PublicCertificateInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdatePublicCertificateSlotWithServiceResponseAsync(resourceGroupName, name, publicCertificateName, slot, publicCertificate), serviceCallback);
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
     * @param publicCertificate Public certificate details. This is the JSON representation of a PublicCertificate object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PublicCertificateInner object
     */
    public Observable<PublicCertificateInner> createOrUpdatePublicCertificateSlotAsync(String resourceGroupName, String name, String publicCertificateName, String slot, PublicCertificateInner publicCertificate) {
        return createOrUpdatePublicCertificateSlotWithServiceResponseAsync(resourceGroupName, name, publicCertificateName, slot, publicCertificate).map(new Func1<ServiceResponse<PublicCertificateInner>, PublicCertificateInner>() {
            @Override
            public PublicCertificateInner call(ServiceResponse<PublicCertificateInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
     * @param publicCertificate Public certificate details. This is the JSON representation of a PublicCertificate object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PublicCertificateInner object
     */
    public Observable<ServiceResponse<PublicCertificateInner>> createOrUpdatePublicCertificateSlotWithServiceResponseAsync(String resourceGroupName, String name, String publicCertificateName, String slot, PublicCertificateInner publicCertificate) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (publicCertificateName == null) {
            throw new IllegalArgumentException("Parameter publicCertificateName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (publicCertificate == null) {
            throw new IllegalArgumentException("Parameter publicCertificate is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(publicCertificate);
        return service.createOrUpdatePublicCertificateSlot(resourceGroupName, name, publicCertificateName, slot, this.client.subscriptionId(), publicCertificate, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PublicCertificateInner>>>() {
                @Override
                public Observable<ServiceResponse<PublicCertificateInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PublicCertificateInner> clientResponse = createOrUpdatePublicCertificateSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PublicCertificateInner> createOrUpdatePublicCertificateSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PublicCertificateInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PublicCertificateInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param publicCertificateName Public certificate name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deletePublicCertificateSlot(String resourceGroupName, String name, String slot, String publicCertificateName) {
        deletePublicCertificateSlotWithServiceResponseAsync(resourceGroupName, name, slot, publicCertificateName).toBlocking().single().body();
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param publicCertificateName Public certificate name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deletePublicCertificateSlotAsync(String resourceGroupName, String name, String slot, String publicCertificateName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deletePublicCertificateSlotWithServiceResponseAsync(resourceGroupName, name, slot, publicCertificateName), serviceCallback);
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param publicCertificateName Public certificate name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deletePublicCertificateSlotAsync(String resourceGroupName, String name, String slot, String publicCertificateName) {
        return deletePublicCertificateSlotWithServiceResponseAsync(resourceGroupName, name, slot, publicCertificateName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param publicCertificateName Public certificate name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deletePublicCertificateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String publicCertificateName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (publicCertificateName == null) {
            throw new IllegalArgumentException("Parameter publicCertificateName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deletePublicCertificateSlot(resourceGroupName, name, slot, publicCertificateName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deletePublicCertificateSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deletePublicCertificateSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream listPublishingProfileXmlWithSecretsSlot(String resourceGroupName, String name, String slot) {
        return listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> listPublishingProfileXmlWithSecretsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listPublishingProfileXmlWithSecretsSlotAsync(String resourceGroupName, String name, String slot) {
        return listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final PublishingProfileFormat format = null;
        CsmPublishingProfileOptions publishingProfileOptions = new CsmPublishingProfileOptions();
        publishingProfileOptions.withFormat(null);
        return service.listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), publishingProfileOptions, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listPublishingProfileXmlWithSecretsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @param format Name of the format. Valid values are:
     FileZilla3
     WebDeploy -- default
     Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream listPublishingProfileXmlWithSecretsSlot(String resourceGroupName, String name, String slot, PublishingProfileFormat format) {
        return listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot, format).toBlocking().single().body();
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @param format Name of the format. Valid values are:
     FileZilla3
     WebDeploy -- default
     Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> listPublishingProfileXmlWithSecretsSlotAsync(String resourceGroupName, String name, String slot, PublishingProfileFormat format, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot, format), serviceCallback);
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @param format Name of the format. Valid values are:
     FileZilla3
     WebDeploy -- default
     Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listPublishingProfileXmlWithSecretsSlotAsync(String resourceGroupName, String name, String slot, PublishingProfileFormat format) {
        return listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot, format).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @param format Name of the format. Valid values are:
     FileZilla3
     WebDeploy -- default
     Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, PublishingProfileFormat format) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        CsmPublishingProfileOptions publishingProfileOptions = new CsmPublishingProfileOptions();
        publishingProfileOptions.withFormat(format);
        return service.listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), publishingProfileOptions, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listPublishingProfileXmlWithSecretsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> listPublishingProfileXmlWithSecretsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputStream, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void recoverSlot(String resourceGroupName, String name, String slot, SnapshotRecoveryRequest recoveryEntity) {
        recoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).toBlocking().last().body();
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> recoverSlotAsync(String resourceGroupName, String name, String slot, SnapshotRecoveryRequest recoveryEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(recoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> recoverSlotAsync(String resourceGroupName, String name, String slot, SnapshotRecoveryRequest recoveryEntity) {
        return recoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> recoverSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SnapshotRecoveryRequest recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        Observable<Response<ResponseBody>> observable = service.recoverSlot(resourceGroupName, name, slot, this.client.subscriptionId(), recoveryEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginRecoverSlot(String resourceGroupName, String name, String slot, SnapshotRecoveryRequest recoveryEntity) {
        beginRecoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).toBlocking().single().body();
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginRecoverSlotAsync(String resourceGroupName, String name, String slot, SnapshotRecoveryRequest recoveryEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginRecoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginRecoverSlotAsync(String resourceGroupName, String name, String slot, SnapshotRecoveryRequest recoveryEntity) {
        return beginRecoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Recovers a web app to a previous snapshot.
     * Recovers a web app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginRecoverSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SnapshotRecoveryRequest recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        return service.beginRecoverSlot(resourceGroupName, name, slot, this.client.subscriptionId(), recoveryEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginRecoverSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginRecoverSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API resets configuration settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resetSlotConfigurationSlot(String resourceGroupName, String name, String slot) {
        resetSlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API resets configuration settings for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resetSlotConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resetSlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API resets configuration settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resetSlotConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return resetSlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API resets configuration settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resetSlotConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.resetSlotConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resetSlotConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> resetSlotConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restartSlot(String resourceGroupName, String name, String slot) {
        restartSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restartSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restartSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restartSlotAsync(String resourceGroupName, String name, String slot) {
        return restartSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restartSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean softRestart = null;
        final Boolean synchronous = null;
        return service.restartSlot(resourceGroupName, name, slot, this.client.subscriptionId(), softRestart, synchronous, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restartSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restartSlot(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous) {
        restartSlotWithServiceResponseAsync(resourceGroupName, name, slot, softRestart, synchronous).toBlocking().single().body();
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restartSlotAsync(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restartSlotWithServiceResponseAsync(resourceGroupName, name, slot, softRestart, synchronous), serviceCallback);
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restartSlotAsync(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous) {
        return restartSlotWithServiceResponseAsync(resourceGroupName, name, slot, softRestart, synchronous).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restartSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.restartSlot(resourceGroupName, name, slot, this.client.subscriptionId(), softRestart, synchronous, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restartSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> restartSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteExtensionInfoInner&gt; object if successful.
     */
    public PagedList<SiteExtensionInfoInner> listSiteExtensionsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<SiteExtensionInfoInner>> response = listSiteExtensionsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<SiteExtensionInfoInner>(response.body()) {
            @Override
            public Page<SiteExtensionInfoInner> nextPage(String nextPageLink) {
                return listSiteExtensionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteExtensionInfoInner>> listSiteExtensionsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<SiteExtensionInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSiteExtensionsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<SiteExtensionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> call(String nextPageLink) {
                    return listSiteExtensionsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteExtensionInfoInner&gt; object
     */
    public Observable<Page<SiteExtensionInfoInner>> listSiteExtensionsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listSiteExtensionsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<SiteExtensionInfoInner>>, Page<SiteExtensionInfoInner>>() {
                @Override
                public Page<SiteExtensionInfoInner> call(ServiceResponse<Page<SiteExtensionInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteExtensionInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> listSiteExtensionsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listSiteExtensionsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<SiteExtensionInfoInner>>, Observable<ServiceResponse<Page<SiteExtensionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> call(ServiceResponse<Page<SiteExtensionInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSiteExtensionsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
    ServiceResponse<PageImpl<SiteExtensionInfoInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SiteExtensionInfoInner>> * @param name Site name.
    ServiceResponse<PageImpl<SiteExtensionInfoInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteExtensionInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> listSiteExtensionsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSiteExtensionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteExtensionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteExtensionInfoInner>> result = listSiteExtensionsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteExtensionInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteExtensionInfoInner>> listSiteExtensionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteExtensionInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteExtensionInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get site extension information by its ID for a web site, or a deployment slot.
     * Get site extension information by its ID for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteExtensionInfoInner object if successful.
     */
    public SiteExtensionInfoInner getSiteExtensionSlot(String resourceGroupName, String name, String siteExtensionId, String slot) {
        return getSiteExtensionSlotWithServiceResponseAsync(resourceGroupName, name, siteExtensionId, slot).toBlocking().single().body();
    }

    /**
     * Get site extension information by its ID for a web site, or a deployment slot.
     * Get site extension information by its ID for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteExtensionInfoInner> getSiteExtensionSlotAsync(String resourceGroupName, String name, String siteExtensionId, String slot, final ServiceCallback<SiteExtensionInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSiteExtensionSlotWithServiceResponseAsync(resourceGroupName, name, siteExtensionId, slot), serviceCallback);
    }

    /**
     * Get site extension information by its ID for a web site, or a deployment slot.
     * Get site extension information by its ID for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteExtensionInfoInner object
     */
    public Observable<SiteExtensionInfoInner> getSiteExtensionSlotAsync(String resourceGroupName, String name, String siteExtensionId, String slot) {
        return getSiteExtensionSlotWithServiceResponseAsync(resourceGroupName, name, siteExtensionId, slot).map(new Func1<ServiceResponse<SiteExtensionInfoInner>, SiteExtensionInfoInner>() {
            @Override
            public SiteExtensionInfoInner call(ServiceResponse<SiteExtensionInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get site extension information by its ID for a web site, or a deployment slot.
     * Get site extension information by its ID for a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteExtensionInfoInner object
     */
    public Observable<ServiceResponse<SiteExtensionInfoInner>> getSiteExtensionSlotWithServiceResponseAsync(String resourceGroupName, String name, String siteExtensionId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (siteExtensionId == null) {
            throw new IllegalArgumentException("Parameter siteExtensionId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSiteExtensionSlot(resourceGroupName, name, siteExtensionId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteExtensionInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteExtensionInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteExtensionInfoInner> clientResponse = getSiteExtensionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteExtensionInfoInner> getSiteExtensionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteExtensionInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteExtensionInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteExtensionInfoInner object if successful.
     */
    public SiteExtensionInfoInner installSiteExtensionSlot(String resourceGroupName, String name, String siteExtensionId, String slot) {
        return installSiteExtensionSlotWithServiceResponseAsync(resourceGroupName, name, siteExtensionId, slot).toBlocking().last().body();
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteExtensionInfoInner> installSiteExtensionSlotAsync(String resourceGroupName, String name, String siteExtensionId, String slot, final ServiceCallback<SiteExtensionInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(installSiteExtensionSlotWithServiceResponseAsync(resourceGroupName, name, siteExtensionId, slot), serviceCallback);
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SiteExtensionInfoInner> installSiteExtensionSlotAsync(String resourceGroupName, String name, String siteExtensionId, String slot) {
        return installSiteExtensionSlotWithServiceResponseAsync(resourceGroupName, name, siteExtensionId, slot).map(new Func1<ServiceResponse<SiteExtensionInfoInner>, SiteExtensionInfoInner>() {
            @Override
            public SiteExtensionInfoInner call(ServiceResponse<SiteExtensionInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteExtensionInfoInner>> installSiteExtensionSlotWithServiceResponseAsync(String resourceGroupName, String name, String siteExtensionId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (siteExtensionId == null) {
            throw new IllegalArgumentException("Parameter siteExtensionId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.installSiteExtensionSlot(resourceGroupName, name, siteExtensionId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteExtensionInfoInner>() { }.getType());
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteExtensionInfoInner object if successful.
     */
    public SiteExtensionInfoInner beginInstallSiteExtensionSlot(String resourceGroupName, String name, String siteExtensionId, String slot) {
        return beginInstallSiteExtensionSlotWithServiceResponseAsync(resourceGroupName, name, siteExtensionId, slot).toBlocking().single().body();
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteExtensionInfoInner> beginInstallSiteExtensionSlotAsync(String resourceGroupName, String name, String siteExtensionId, String slot, final ServiceCallback<SiteExtensionInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginInstallSiteExtensionSlotWithServiceResponseAsync(resourceGroupName, name, siteExtensionId, slot), serviceCallback);
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteExtensionInfoInner object
     */
    public Observable<SiteExtensionInfoInner> beginInstallSiteExtensionSlotAsync(String resourceGroupName, String name, String siteExtensionId, String slot) {
        return beginInstallSiteExtensionSlotWithServiceResponseAsync(resourceGroupName, name, siteExtensionId, slot).map(new Func1<ServiceResponse<SiteExtensionInfoInner>, SiteExtensionInfoInner>() {
            @Override
            public SiteExtensionInfoInner call(ServiceResponse<SiteExtensionInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Install site extension on a web site, or a deployment slot.
     * Install site extension on a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteExtensionInfoInner object
     */
    public Observable<ServiceResponse<SiteExtensionInfoInner>> beginInstallSiteExtensionSlotWithServiceResponseAsync(String resourceGroupName, String name, String siteExtensionId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (siteExtensionId == null) {
            throw new IllegalArgumentException("Parameter siteExtensionId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginInstallSiteExtensionSlot(resourceGroupName, name, siteExtensionId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteExtensionInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteExtensionInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteExtensionInfoInner> clientResponse = beginInstallSiteExtensionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteExtensionInfoInner> beginInstallSiteExtensionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteExtensionInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteExtensionInfoInner>() { }.getType())
                .register(201, new TypeToken<SiteExtensionInfoInner>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Remove a site extension from a web site, or a deployment slot.
     * Remove a site extension from a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteSiteExtensionSlot(String resourceGroupName, String name, String siteExtensionId, String slot) {
        deleteSiteExtensionSlotWithServiceResponseAsync(resourceGroupName, name, siteExtensionId, slot).toBlocking().single().body();
    }

    /**
     * Remove a site extension from a web site, or a deployment slot.
     * Remove a site extension from a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteSiteExtensionSlotAsync(String resourceGroupName, String name, String siteExtensionId, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteSiteExtensionSlotWithServiceResponseAsync(resourceGroupName, name, siteExtensionId, slot), serviceCallback);
    }

    /**
     * Remove a site extension from a web site, or a deployment slot.
     * Remove a site extension from a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteSiteExtensionSlotAsync(String resourceGroupName, String name, String siteExtensionId, String slot) {
        return deleteSiteExtensionSlotWithServiceResponseAsync(resourceGroupName, name, siteExtensionId, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Remove a site extension from a web site, or a deployment slot.
     * Remove a site extension from a web site, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteSiteExtensionSlotWithServiceResponseAsync(String resourceGroupName, String name, String siteExtensionId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (siteExtensionId == null) {
            throw new IllegalArgumentException("Parameter siteExtensionId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSiteExtensionSlot(resourceGroupName, name, siteExtensionId, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteSiteExtensionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteSiteExtensionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> listSlotDifferencesSlot(final String resourceGroupName, final String name, final String slot, final CsmSlotEntity slotSwapEntity) {
        ServiceResponse<Page<SlotDifferenceInner>> response = listSlotDifferencesSlotSinglePageAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.body()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return listSlotDifferencesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SlotDifferenceInner>> listSlotDifferencesSlotAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntity slotSwapEntity, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSlotDifferencesSlotSinglePageAsync(resourceGroupName, name, slot, slotSwapEntity),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return listSlotDifferencesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> listSlotDifferencesSlotAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntity slotSwapEntity) {
        return listSlotDifferencesSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntity slotSwapEntity) {
        return listSlotDifferencesSlotSinglePageAsync(resourceGroupName, name, slot, slotSwapEntity)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSlotDifferencesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntity slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.listSlotDifferencesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = listSlotDifferencesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> listSlotDifferencesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SlotDifferenceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void swapSlotSlot(String resourceGroupName, String name, String slot, CsmSlotEntity slotSwapEntity) {
        swapSlotSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().last().body();
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> swapSlotSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntity slotSwapEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(swapSlotSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> swapSlotSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntity slotSwapEntity) {
        return swapSlotSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> swapSlotSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSlotEntity slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        Observable<Response<ResponseBody>> observable = service.swapSlotSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginSwapSlotSlot(String resourceGroupName, String name, String slot, CsmSlotEntity slotSwapEntity) {
        beginSwapSlotSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().single().body();
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginSwapSlotSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntity slotSwapEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginSwapSlotSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginSwapSlotSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntity slotSwapEntity) {
        return beginSwapSlotSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginSwapSlotSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSlotEntity slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.beginSwapSlotSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginSwapSlotSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginSwapSlotSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SnapshotInner&gt; object if successful.
     */
    public PagedList<SnapshotInner> listSnapshotsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<SnapshotInner>> response = listSnapshotsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<SnapshotInner>(response.body()) {
            @Override
            public Page<SnapshotInner> nextPage(String nextPageLink) {
                return listSnapshotsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SnapshotInner>> listSnapshotsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<SnapshotInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSnapshotsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(String nextPageLink) {
                    return listSnapshotsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<Page<SnapshotInner>> listSnapshotsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listSnapshotsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<SnapshotInner>>, Page<SnapshotInner>>() {
                @Override
                public Page<SnapshotInner> call(ServiceResponse<Page<SnapshotInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listSnapshotsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<SnapshotInner>>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(ServiceResponse<Page<SnapshotInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSnapshotsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
    ServiceResponse<PageImpl<SnapshotInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SnapshotInner>> * @param name Website Name.
    ServiceResponse<PageImpl<SnapshotInner>> * @param slot Website Slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SnapshotInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSnapshotsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SnapshotInner>> result = listSnapshotsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SnapshotInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SnapshotInner>> listSnapshotsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SnapshotInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SnapshotInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the source control configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner getSourceControlSlot(String resourceGroupName, String name, String slot) {
        return getSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the source control configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteSourceControlInner> getSourceControlSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the source control configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> getSourceControlSlotAsync(String resourceGroupName, String name, String slot) {
        return getSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the source control configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> getSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = getSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> getSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteSourceControlInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .register(201, new TypeToken<SiteSourceControlInner>() { }.getType())
                .register(202, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner createOrUpdateSourceControlSlot(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).toBlocking().last().body();
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteSourceControlInner> createOrUpdateSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl), serviceCallback);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SiteSourceControlInner> createOrUpdateSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> createOrUpdateSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteSourceControl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteSourceControlInner>() { }.getType());
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner beginCreateOrUpdateSourceControlSlot(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return beginCreateOrUpdateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).toBlocking().single().body();
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteSourceControlInner> beginCreateOrUpdateSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl), serviceCallback);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> beginCreateOrUpdateSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return beginCreateOrUpdateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> beginCreateOrUpdateSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        return service.beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteSourceControl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = beginCreateOrUpdateSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> beginCreateOrUpdateSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteSourceControlInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .register(201, new TypeToken<SiteSourceControlInner>() { }.getType())
                .register(202, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the source control configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteSourceControlSlot(String resourceGroupName, String name, String slot) {
        deleteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the source control configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteSourceControlSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the source control configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteSourceControlSlotAsync(String resourceGroupName, String name, String slot) {
        return deleteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the source control configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner updateSourceControlSlot(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return updateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).toBlocking().single().body();
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteSourceControlInner> updateSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl), serviceCallback);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> updateSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return updateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> updateSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        return service.updateSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteSourceControl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = updateSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> updateSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteSourceControlInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .register(201, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will start the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startSlot(String resourceGroupName, String name, String slot) {
        startSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will start the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will start the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startSlotAsync(String resourceGroupName, String name, String slot) {
        return startSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will start the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.startSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> startSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will stop the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void stopSlot(String resourceGroupName, String name, String slot) {
        stopSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will stop the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> stopSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(stopSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will stop the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stopSlotAsync(String resourceGroupName, String name, String slot) {
        return stopSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will stop the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stopSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.stopSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stopSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> stopSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void syncRepositorySlot(String resourceGroupName, String name, String slot) {
        syncRepositorySlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> syncRepositorySlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(syncRepositorySlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> syncRepositorySlotAsync(String resourceGroupName, String name, String slot) {
        return syncRepositorySlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> syncRepositorySlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.syncRepositorySlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = syncRepositorySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> syncRepositorySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Syncs function trigger metadata to the scale controller.
     * Syncs function trigger metadata to the scale controller.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void syncFunctionTriggersSlot(String resourceGroupName, String name, String slot) {
        syncFunctionTriggersSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Syncs function trigger metadata to the scale controller.
     * Syncs function trigger metadata to the scale controller.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> syncFunctionTriggersSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(syncFunctionTriggersSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Syncs function trigger metadata to the scale controller.
     * Syncs function trigger metadata to the scale controller.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> syncFunctionTriggersSlotAsync(String resourceGroupName, String name, String slot) {
        return syncFunctionTriggersSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Syncs function trigger metadata to the scale controller.
     * Syncs function trigger metadata to the scale controller.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> syncFunctionTriggersSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.syncFunctionTriggersSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = syncFunctionTriggersSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> syncFunctionTriggersSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;TriggeredWebJobInner&gt; object if successful.
     */
    public PagedList<TriggeredWebJobInner> listTriggeredWebJobsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<TriggeredWebJobInner>> response = listTriggeredWebJobsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<TriggeredWebJobInner>(response.body()) {
            @Override
            public Page<TriggeredWebJobInner> nextPage(String nextPageLink) {
                return listTriggeredWebJobsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<TriggeredWebJobInner>> listTriggeredWebJobsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<TriggeredWebJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listTriggeredWebJobsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<TriggeredWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> call(String nextPageLink) {
                    return listTriggeredWebJobsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredWebJobInner&gt; object
     */
    public Observable<Page<TriggeredWebJobInner>> listTriggeredWebJobsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listTriggeredWebJobsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<TriggeredWebJobInner>>, Page<TriggeredWebJobInner>>() {
                @Override
                public Page<TriggeredWebJobInner> call(ServiceResponse<Page<TriggeredWebJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredWebJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> listTriggeredWebJobsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listTriggeredWebJobsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<TriggeredWebJobInner>>, Observable<ServiceResponse<Page<TriggeredWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> call(ServiceResponse<Page<TriggeredWebJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listTriggeredWebJobsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<TriggeredWebJobInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<TriggeredWebJobInner>> * @param name Site name.
    ServiceResponse<PageImpl<TriggeredWebJobInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;TriggeredWebJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> listTriggeredWebJobsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listTriggeredWebJobsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<TriggeredWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<TriggeredWebJobInner>> result = listTriggeredWebJobsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<TriggeredWebJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<TriggeredWebJobInner>> listTriggeredWebJobsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<TriggeredWebJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<TriggeredWebJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TriggeredWebJobInner object if successful.
     */
    public TriggeredWebJobInner getTriggeredWebJobSlot(String resourceGroupName, String name, String webJobName, String slot) {
        return getTriggeredWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).toBlocking().single().body();
    }

    /**
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TriggeredWebJobInner> getTriggeredWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot, final ServiceCallback<TriggeredWebJobInner> serviceCallback) {
        return ServiceFuture.fromResponse(getTriggeredWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot), serviceCallback);
    }

    /**
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TriggeredWebJobInner object
     */
    public Observable<TriggeredWebJobInner> getTriggeredWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot) {
        return getTriggeredWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).map(new Func1<ServiceResponse<TriggeredWebJobInner>, TriggeredWebJobInner>() {
            @Override
            public TriggeredWebJobInner call(ServiceResponse<TriggeredWebJobInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TriggeredWebJobInner object
     */
    public Observable<ServiceResponse<TriggeredWebJobInner>> getTriggeredWebJobSlotWithServiceResponseAsync(String resourceGroupName, String name, String webJobName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getTriggeredWebJobSlot(resourceGroupName, name, webJobName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TriggeredWebJobInner>>>() {
                @Override
                public Observable<ServiceResponse<TriggeredWebJobInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TriggeredWebJobInner> clientResponse = getTriggeredWebJobSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TriggeredWebJobInner> getTriggeredWebJobSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<TriggeredWebJobInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TriggeredWebJobInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteTriggeredWebJobSlot(String resourceGroupName, String name, String webJobName, String slot) {
        deleteTriggeredWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).toBlocking().single().body();
    }

    /**
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteTriggeredWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteTriggeredWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot), serviceCallback);
    }

    /**
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteTriggeredWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot) {
        return deleteTriggeredWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteTriggeredWebJobSlotWithServiceResponseAsync(String resourceGroupName, String name, String webJobName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteTriggeredWebJobSlot(resourceGroupName, name, webJobName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteTriggeredWebJobSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteTriggeredWebJobSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;TriggeredJobHistoryInner&gt; object if successful.
     */
    public PagedList<TriggeredJobHistoryInner> listTriggeredWebJobHistorySlot(final String resourceGroupName, final String name, final String webJobName, final String slot) {
        ServiceResponse<Page<TriggeredJobHistoryInner>> response = listTriggeredWebJobHistorySlotSinglePageAsync(resourceGroupName, name, webJobName, slot).toBlocking().single();
        return new PagedList<TriggeredJobHistoryInner>(response.body()) {
            @Override
            public Page<TriggeredJobHistoryInner> nextPage(String nextPageLink) {
                return listTriggeredWebJobHistorySlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<TriggeredJobHistoryInner>> listTriggeredWebJobHistorySlotAsync(final String resourceGroupName, final String name, final String webJobName, final String slot, final ListOperationCallback<TriggeredJobHistoryInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listTriggeredWebJobHistorySlotSinglePageAsync(resourceGroupName, name, webJobName, slot),
            new Func1<String, Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> call(String nextPageLink) {
                    return listTriggeredWebJobHistorySlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredJobHistoryInner&gt; object
     */
    public Observable<Page<TriggeredJobHistoryInner>> listTriggeredWebJobHistorySlotAsync(final String resourceGroupName, final String name, final String webJobName, final String slot) {
        return listTriggeredWebJobHistorySlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot)
            .map(new Func1<ServiceResponse<Page<TriggeredJobHistoryInner>>, Page<TriggeredJobHistoryInner>>() {
                @Override
                public Page<TriggeredJobHistoryInner> call(ServiceResponse<Page<TriggeredJobHistoryInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredJobHistoryInner&gt; object
     */
    public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> listTriggeredWebJobHistorySlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String webJobName, final String slot) {
        return listTriggeredWebJobHistorySlotSinglePageAsync(resourceGroupName, name, webJobName, slot)
            .concatMap(new Func1<ServiceResponse<Page<TriggeredJobHistoryInner>>, Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> call(ServiceResponse<Page<TriggeredJobHistoryInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listTriggeredWebJobHistorySlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<TriggeredJobHistoryInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<TriggeredJobHistoryInner>> * @param name Site name.
    ServiceResponse<PageImpl<TriggeredJobHistoryInner>> * @param webJobName Name of Web Job.
    ServiceResponse<PageImpl<TriggeredJobHistoryInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;TriggeredJobHistoryInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> listTriggeredWebJobHistorySlotSinglePageAsync(final String resourceGroupName, final String name, final String webJobName, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listTriggeredWebJobHistorySlot(resourceGroupName, name, webJobName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<TriggeredJobHistoryInner>> result = listTriggeredWebJobHistorySlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<TriggeredJobHistoryInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<TriggeredJobHistoryInner>> listTriggeredWebJobHistorySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<TriggeredJobHistoryInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<TriggeredJobHistoryInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param id History ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TriggeredJobHistoryInner object if successful.
     */
    public TriggeredJobHistoryInner getTriggeredWebJobHistorySlot(String resourceGroupName, String name, String webJobName, String id, String slot) {
        return getTriggeredWebJobHistorySlotWithServiceResponseAsync(resourceGroupName, name, webJobName, id, slot).toBlocking().single().body();
    }

    /**
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param id History ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TriggeredJobHistoryInner> getTriggeredWebJobHistorySlotAsync(String resourceGroupName, String name, String webJobName, String id, String slot, final ServiceCallback<TriggeredJobHistoryInner> serviceCallback) {
        return ServiceFuture.fromResponse(getTriggeredWebJobHistorySlotWithServiceResponseAsync(resourceGroupName, name, webJobName, id, slot), serviceCallback);
    }

    /**
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param id History ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TriggeredJobHistoryInner object
     */
    public Observable<TriggeredJobHistoryInner> getTriggeredWebJobHistorySlotAsync(String resourceGroupName, String name, String webJobName, String id, String slot) {
        return getTriggeredWebJobHistorySlotWithServiceResponseAsync(resourceGroupName, name, webJobName, id, slot).map(new Func1<ServiceResponse<TriggeredJobHistoryInner>, TriggeredJobHistoryInner>() {
            @Override
            public TriggeredJobHistoryInner call(ServiceResponse<TriggeredJobHistoryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param id History ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TriggeredJobHistoryInner object
     */
    public Observable<ServiceResponse<TriggeredJobHistoryInner>> getTriggeredWebJobHistorySlotWithServiceResponseAsync(String resourceGroupName, String name, String webJobName, String id, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getTriggeredWebJobHistorySlot(resourceGroupName, name, webJobName, id, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TriggeredJobHistoryInner>>>() {
                @Override
                public Observable<ServiceResponse<TriggeredJobHistoryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TriggeredJobHistoryInner> clientResponse = getTriggeredWebJobHistorySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TriggeredJobHistoryInner> getTriggeredWebJobHistorySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<TriggeredJobHistoryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TriggeredJobHistoryInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Run a triggered web job for an app, or a deployment slot.
     * Run a triggered web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void runTriggeredWebJobSlot(String resourceGroupName, String name, String webJobName, String slot) {
        runTriggeredWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).toBlocking().single().body();
    }

    /**
     * Run a triggered web job for an app, or a deployment slot.
     * Run a triggered web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> runTriggeredWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(runTriggeredWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot), serviceCallback);
    }

    /**
     * Run a triggered web job for an app, or a deployment slot.
     * Run a triggered web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> runTriggeredWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot) {
        return runTriggeredWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Run a triggered web job for an app, or a deployment slot.
     * Run a triggered web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> runTriggeredWebJobSlotWithServiceResponseAsync(String resourceGroupName, String name, String webJobName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.runTriggeredWebJobSlot(resourceGroupName, name, webJobName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = runTriggeredWebJobSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> runTriggeredWebJobSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsagesSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.body()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CsmUsageQuotaInner>> listUsagesSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listUsagesSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listUsagesSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listUsagesSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        return service.listUsagesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsagesSlot(final String resourceGroupName, final String name, final String slot, final String filter) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesSlotSinglePageAsync(resourceGroupName, name, slot, filter).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.body()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CsmUsageQuotaInner>> listUsagesSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listUsagesSlotSinglePageAsync(resourceGroupName, name, slot, filter),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        return listUsagesSlotWithServiceResponseAsync(resourceGroupName, name, slot, filter)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        return listUsagesSlotSinglePageAsync(resourceGroupName, name, slot, filter)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listUsagesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> listUsagesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<CsmUsageQuotaInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get virtual network connections for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;VnetInfoInner&gt; object if successful.
     */
    public List<VnetInfoInner> listVnetConnectionsSlot(String resourceGroupName, String name, String slot) {
        return listVnetConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get virtual network connections for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<VnetInfoInner>> listVnetConnectionsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<List<VnetInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listVnetConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get virtual network connections for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<List<VnetInfoInner>> listVnetConnectionsSlotAsync(String resourceGroupName, String name, String slot) {
        return listVnetConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<List<VnetInfoInner>>, List<VnetInfoInner>>() {
            @Override
            public List<VnetInfoInner> call(ServiceResponse<List<VnetInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get virtual network connections for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<VnetInfoInner>>> listVnetConnectionsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listVnetConnectionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<VnetInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<VnetInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<VnetInfoInner>> clientResponse = listVnetConnectionsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<VnetInfoInner>> listVnetConnectionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<VnetInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<VnetInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named virtual network for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner getVnetConnectionSlot(String resourceGroupName, String name, String vnetName, String slot) {
        return getVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).toBlocking().single().body();
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named virtual network for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetInfoInner> getVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot), serviceCallback);
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named virtual network for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> getVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot) {
        return getVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named virtual network for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> getVnetConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getVnetConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = getVnetConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> getVnetConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner createOrUpdateVnetConnectionSlot(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return createOrUpdateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetInfoInner> createOrUpdateVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> createOrUpdateVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return createOrUpdateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> createOrUpdateVnetConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateVnetConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = createOrUpdateVnetConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> createOrUpdateVnetConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteVnetConnectionSlot(String resourceGroupName, String name, String vnetName, String slot) {
        deleteVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).toBlocking().single().body();
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the connection for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot), serviceCallback);
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot) {
        return deleteVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteVnetConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteVnetConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteVnetConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteVnetConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner updateVnetConnectionSlot(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return updateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetInfoInner> updateVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> updateVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return updateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> updateVnetConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateVnetConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = updateVnetConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> updateVnetConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a gateway for the production slot's Virtual Network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner getVnetConnectionGatewaySlot(String resourceGroupName, String name, String vnetName, String gatewayName, String slot) {
        return getVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot).toBlocking().single().body();
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a gateway for the production slot's Virtual Network.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetGatewayInner> getVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceFuture.fromResponse(getVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot), serviceCallback);
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a gateway for the production slot's Virtual Network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> getVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot) {
        return getVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a gateway for the production slot's Virtual Network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> getVnetConnectionGatewaySlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = getVnetConnectionGatewaySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> getVnetConnectionGatewaySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetGatewayInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner createOrUpdateVnetConnectionGatewaySlot(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetGatewayInner> createOrUpdateVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> createOrUpdateVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> createOrUpdateVnetConnectionGatewaySlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = createOrUpdateVnetConnectionGatewaySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> createOrUpdateVnetConnectionGatewaySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetGatewayInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner updateVnetConnectionGatewaySlot(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return updateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetGatewayInner> updateVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> updateVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return updateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> updateVnetConnectionGatewaySlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = updateVnetConnectionGatewaySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> updateVnetConnectionGatewaySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetGatewayInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;WebJobInner&gt; object if successful.
     */
    public PagedList<WebJobInner> listWebJobsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<WebJobInner>> response = listWebJobsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<WebJobInner>(response.body()) {
            @Override
            public Page<WebJobInner> nextPage(String nextPageLink) {
                return listWebJobsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<WebJobInner>> listWebJobsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<WebJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listWebJobsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<WebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebJobInner>>> call(String nextPageLink) {
                    return listWebJobsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebJobInner&gt; object
     */
    public Observable<Page<WebJobInner>> listWebJobsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listWebJobsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<WebJobInner>>, Page<WebJobInner>>() {
                @Override
                public Page<WebJobInner> call(ServiceResponse<Page<WebJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<WebJobInner>>> listWebJobsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listWebJobsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<WebJobInner>>, Observable<ServiceResponse<Page<WebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebJobInner>>> call(ServiceResponse<Page<WebJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listWebJobsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<WebJobInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<WebJobInner>> * @param name Site name.
    ServiceResponse<PageImpl<WebJobInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;WebJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<WebJobInner>>> listWebJobsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listWebJobsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<WebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<WebJobInner>> result = listWebJobsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<WebJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<WebJobInner>> listWebJobsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<WebJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<WebJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get webjob information for an app, or a deployment slot.
     * Get webjob information for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of the web job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WebJobInner object if successful.
     */
    public WebJobInner getWebJobSlot(String resourceGroupName, String name, String webJobName, String slot) {
        return getWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).toBlocking().single().body();
    }

    /**
     * Get webjob information for an app, or a deployment slot.
     * Get webjob information for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of the web job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WebJobInner> getWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot, final ServiceCallback<WebJobInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot), serviceCallback);
    }

    /**
     * Get webjob information for an app, or a deployment slot.
     * Get webjob information for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of the web job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WebJobInner object
     */
    public Observable<WebJobInner> getWebJobSlotAsync(String resourceGroupName, String name, String webJobName, String slot) {
        return getWebJobSlotWithServiceResponseAsync(resourceGroupName, name, webJobName, slot).map(new Func1<ServiceResponse<WebJobInner>, WebJobInner>() {
            @Override
            public WebJobInner call(ServiceResponse<WebJobInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get webjob information for an app, or a deployment slot.
     * Get webjob information for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of the web job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WebJobInner object
     */
    public Observable<ServiceResponse<WebJobInner>> getWebJobSlotWithServiceResponseAsync(String resourceGroupName, String name, String webJobName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getWebJobSlot(resourceGroupName, name, webJobName, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WebJobInner>>>() {
                @Override
                public Observable<ServiceResponse<WebJobInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WebJobInner> clientResponse = getWebJobSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<WebJobInner> getWebJobSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<WebJobInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<WebJobInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> listSlotDifferencesFromProduction(final String resourceGroupName, final String name, final CsmSlotEntity slotSwapEntity) {
        ServiceResponse<Page<SlotDifferenceInner>> response = listSlotDifferencesFromProductionSinglePageAsync(resourceGroupName, name, slotSwapEntity).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.body()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return listSlotDifferencesFromProductionNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SlotDifferenceInner>> listSlotDifferencesFromProductionAsync(final String resourceGroupName, final String name, final CsmSlotEntity slotSwapEntity, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSlotDifferencesFromProductionSinglePageAsync(resourceGroupName, name, slotSwapEntity),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return listSlotDifferencesFromProductionNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> listSlotDifferencesFromProductionAsync(final String resourceGroupName, final String name, final CsmSlotEntity slotSwapEntity) {
        return listSlotDifferencesFromProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesFromProductionWithServiceResponseAsync(final String resourceGroupName, final String name, final CsmSlotEntity slotSwapEntity) {
        return listSlotDifferencesFromProductionSinglePageAsync(resourceGroupName, name, slotSwapEntity)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSlotDifferencesFromProductionNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesFromProductionSinglePageAsync(final String resourceGroupName, final String name, final CsmSlotEntity slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.listSlotDifferencesFromProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = listSlotDifferencesFromProductionDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> listSlotDifferencesFromProductionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SlotDifferenceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void swapSlotWithProduction(String resourceGroupName, String name, CsmSlotEntity slotSwapEntity) {
        swapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).toBlocking().last().body();
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> swapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntity slotSwapEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(swapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> swapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntity slotSwapEntity) {
        return swapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> swapSlotWithProductionWithServiceResponseAsync(String resourceGroupName, String name, CsmSlotEntity slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        Observable<Response<ResponseBody>> observable = service.swapSlotWithProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginSwapSlotWithProduction(String resourceGroupName, String name, CsmSlotEntity slotSwapEntity) {
        beginSwapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).toBlocking().single().body();
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginSwapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntity slotSwapEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginSwapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginSwapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntity slotSwapEntity) {
        return beginSwapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginSwapSlotWithProductionWithServiceResponseAsync(String resourceGroupName, String name, CsmSlotEntity slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        return service.beginSwapSlotWithProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginSwapSlotWithProductionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginSwapSlotWithProductionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SnapshotInner&gt; object if successful.
     */
    public PagedList<SnapshotInner> listSnapshots(final String resourceGroupName, final String name) {
        ServiceResponse<Page<SnapshotInner>> response = listSnapshotsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<SnapshotInner>(response.body()) {
            @Override
            public Page<SnapshotInner> nextPage(String nextPageLink) {
                return listSnapshotsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SnapshotInner>> listSnapshotsAsync(final String resourceGroupName, final String name, final ListOperationCallback<SnapshotInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSnapshotsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(String nextPageLink) {
                    return listSnapshotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<Page<SnapshotInner>> listSnapshotsAsync(final String resourceGroupName, final String name) {
        return listSnapshotsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<SnapshotInner>>, Page<SnapshotInner>>() {
                @Override
                public Page<SnapshotInner> call(ServiceResponse<Page<SnapshotInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listSnapshotsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SnapshotInner>>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(ServiceResponse<Page<SnapshotInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSnapshotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
    ServiceResponse<PageImpl<SnapshotInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SnapshotInner>> * @param name Website Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SnapshotInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSnapshots(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SnapshotInner>> result = listSnapshotsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SnapshotInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SnapshotInner>> listSnapshotsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SnapshotInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SnapshotInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner getSourceControl(String resourceGroupName, String name) {
        return getSourceControlWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteSourceControlInner> getSourceControlAsync(String resourceGroupName, String name, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSourceControlWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> getSourceControlAsync(String resourceGroupName, String name) {
        return getSourceControlWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> getSourceControlWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSourceControl(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = getSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> getSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteSourceControlInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .register(201, new TypeToken<SiteSourceControlInner>() { }.getType())
                .register(202, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner createOrUpdateSourceControl(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).toBlocking().last().body();
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteSourceControlInner> createOrUpdateSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl), serviceCallback);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SiteSourceControlInner> createOrUpdateSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> createOrUpdateSourceControlWithServiceResponseAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSourceControl(resourceGroupName, name, this.client.subscriptionId(), siteSourceControl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteSourceControlInner>() { }.getType());
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner beginCreateOrUpdateSourceControl(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return beginCreateOrUpdateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).toBlocking().single().body();
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteSourceControlInner> beginCreateOrUpdateSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl), serviceCallback);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> beginCreateOrUpdateSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return beginCreateOrUpdateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> beginCreateOrUpdateSourceControlWithServiceResponseAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        return service.beginCreateOrUpdateSourceControl(resourceGroupName, name, this.client.subscriptionId(), siteSourceControl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = beginCreateOrUpdateSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> beginCreateOrUpdateSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteSourceControlInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .register(201, new TypeToken<SiteSourceControlInner>() { }.getType())
                .register(202, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteSourceControl(String resourceGroupName, String name) {
        deleteSourceControlWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteSourceControlAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteSourceControlWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteSourceControlAsync(String resourceGroupName, String name) {
        return deleteSourceControlWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteSourceControlWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteSourceControl(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner updateSourceControl(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return updateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).toBlocking().single().body();
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteSourceControlInner> updateSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl), serviceCallback);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> updateSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return updateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> updateSourceControlWithServiceResponseAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        return service.updateSourceControl(resourceGroupName, name, this.client.subscriptionId(), siteSourceControl, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = updateSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> updateSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteSourceControlInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .register(201, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void start(String resourceGroupName, String name) {
        startWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startAsync(String resourceGroupName, String name) {
        return startWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.start(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> startDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void stop(String resourceGroupName, String name) {
        stopWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> stopAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(stopWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stopAsync(String resourceGroupName, String name) {
        return stopWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stopWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.stop(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stopDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> stopDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void syncRepository(String resourceGroupName, String name) {
        syncRepositoryWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> syncRepositoryAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(syncRepositoryWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> syncRepositoryAsync(String resourceGroupName, String name) {
        return syncRepositoryWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> syncRepositoryWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.syncRepository(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = syncRepositoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> syncRepositoryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Syncs function trigger metadata to the scale controller.
     * Syncs function trigger metadata to the scale controller.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void syncFunctionTriggers(String resourceGroupName, String name) {
        syncFunctionTriggersWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Syncs function trigger metadata to the scale controller.
     * Syncs function trigger metadata to the scale controller.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> syncFunctionTriggersAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(syncFunctionTriggersWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Syncs function trigger metadata to the scale controller.
     * Syncs function trigger metadata to the scale controller.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> syncFunctionTriggersAsync(String resourceGroupName, String name) {
        return syncFunctionTriggersWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Syncs function trigger metadata to the scale controller.
     * Syncs function trigger metadata to the scale controller.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> syncFunctionTriggersWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.syncFunctionTriggers(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = syncFunctionTriggersDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> syncFunctionTriggersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;TriggeredWebJobInner&gt; object if successful.
     */
    public PagedList<TriggeredWebJobInner> listTriggeredWebJobs(final String resourceGroupName, final String name) {
        ServiceResponse<Page<TriggeredWebJobInner>> response = listTriggeredWebJobsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<TriggeredWebJobInner>(response.body()) {
            @Override
            public Page<TriggeredWebJobInner> nextPage(String nextPageLink) {
                return listTriggeredWebJobsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<TriggeredWebJobInner>> listTriggeredWebJobsAsync(final String resourceGroupName, final String name, final ListOperationCallback<TriggeredWebJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listTriggeredWebJobsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<TriggeredWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> call(String nextPageLink) {
                    return listTriggeredWebJobsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredWebJobInner&gt; object
     */
    public Observable<Page<TriggeredWebJobInner>> listTriggeredWebJobsAsync(final String resourceGroupName, final String name) {
        return listTriggeredWebJobsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<TriggeredWebJobInner>>, Page<TriggeredWebJobInner>>() {
                @Override
                public Page<TriggeredWebJobInner> call(ServiceResponse<Page<TriggeredWebJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredWebJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> listTriggeredWebJobsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listTriggeredWebJobsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<TriggeredWebJobInner>>, Observable<ServiceResponse<Page<TriggeredWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> call(ServiceResponse<Page<TriggeredWebJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listTriggeredWebJobsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<TriggeredWebJobInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<TriggeredWebJobInner>> * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;TriggeredWebJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> listTriggeredWebJobsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listTriggeredWebJobs(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<TriggeredWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<TriggeredWebJobInner>> result = listTriggeredWebJobsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<TriggeredWebJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<TriggeredWebJobInner>> listTriggeredWebJobsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<TriggeredWebJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<TriggeredWebJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TriggeredWebJobInner object if successful.
     */
    public TriggeredWebJobInner getTriggeredWebJob(String resourceGroupName, String name, String webJobName) {
        return getTriggeredWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).toBlocking().single().body();
    }

    /**
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TriggeredWebJobInner> getTriggeredWebJobAsync(String resourceGroupName, String name, String webJobName, final ServiceCallback<TriggeredWebJobInner> serviceCallback) {
        return ServiceFuture.fromResponse(getTriggeredWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName), serviceCallback);
    }

    /**
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TriggeredWebJobInner object
     */
    public Observable<TriggeredWebJobInner> getTriggeredWebJobAsync(String resourceGroupName, String name, String webJobName) {
        return getTriggeredWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).map(new Func1<ServiceResponse<TriggeredWebJobInner>, TriggeredWebJobInner>() {
            @Override
            public TriggeredWebJobInner call(ServiceResponse<TriggeredWebJobInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     * Gets a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TriggeredWebJobInner object
     */
    public Observable<ServiceResponse<TriggeredWebJobInner>> getTriggeredWebJobWithServiceResponseAsync(String resourceGroupName, String name, String webJobName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getTriggeredWebJob(resourceGroupName, name, webJobName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TriggeredWebJobInner>>>() {
                @Override
                public Observable<ServiceResponse<TriggeredWebJobInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TriggeredWebJobInner> clientResponse = getTriggeredWebJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TriggeredWebJobInner> getTriggeredWebJobDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<TriggeredWebJobInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TriggeredWebJobInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteTriggeredWebJob(String resourceGroupName, String name, String webJobName) {
        deleteTriggeredWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).toBlocking().single().body();
    }

    /**
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteTriggeredWebJobAsync(String resourceGroupName, String name, String webJobName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteTriggeredWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName), serviceCallback);
    }

    /**
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteTriggeredWebJobAsync(String resourceGroupName, String name, String webJobName) {
        return deleteTriggeredWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     * Delete a triggered web job by its ID for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteTriggeredWebJobWithServiceResponseAsync(String resourceGroupName, String name, String webJobName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteTriggeredWebJob(resourceGroupName, name, webJobName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteTriggeredWebJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteTriggeredWebJobDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;TriggeredJobHistoryInner&gt; object if successful.
     */
    public PagedList<TriggeredJobHistoryInner> listTriggeredWebJobHistory(final String resourceGroupName, final String name, final String webJobName) {
        ServiceResponse<Page<TriggeredJobHistoryInner>> response = listTriggeredWebJobHistorySinglePageAsync(resourceGroupName, name, webJobName).toBlocking().single();
        return new PagedList<TriggeredJobHistoryInner>(response.body()) {
            @Override
            public Page<TriggeredJobHistoryInner> nextPage(String nextPageLink) {
                return listTriggeredWebJobHistoryNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<TriggeredJobHistoryInner>> listTriggeredWebJobHistoryAsync(final String resourceGroupName, final String name, final String webJobName, final ListOperationCallback<TriggeredJobHistoryInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listTriggeredWebJobHistorySinglePageAsync(resourceGroupName, name, webJobName),
            new Func1<String, Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> call(String nextPageLink) {
                    return listTriggeredWebJobHistoryNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredJobHistoryInner&gt; object
     */
    public Observable<Page<TriggeredJobHistoryInner>> listTriggeredWebJobHistoryAsync(final String resourceGroupName, final String name, final String webJobName) {
        return listTriggeredWebJobHistoryWithServiceResponseAsync(resourceGroupName, name, webJobName)
            .map(new Func1<ServiceResponse<Page<TriggeredJobHistoryInner>>, Page<TriggeredJobHistoryInner>>() {
                @Override
                public Page<TriggeredJobHistoryInner> call(ServiceResponse<Page<TriggeredJobHistoryInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredJobHistoryInner&gt; object
     */
    public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> listTriggeredWebJobHistoryWithServiceResponseAsync(final String resourceGroupName, final String name, final String webJobName) {
        return listTriggeredWebJobHistorySinglePageAsync(resourceGroupName, name, webJobName)
            .concatMap(new Func1<ServiceResponse<Page<TriggeredJobHistoryInner>>, Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> call(ServiceResponse<Page<TriggeredJobHistoryInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listTriggeredWebJobHistoryNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<TriggeredJobHistoryInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<TriggeredJobHistoryInner>> * @param name Site name.
    ServiceResponse<PageImpl<TriggeredJobHistoryInner>> * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;TriggeredJobHistoryInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> listTriggeredWebJobHistorySinglePageAsync(final String resourceGroupName, final String name, final String webJobName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listTriggeredWebJobHistory(resourceGroupName, name, webJobName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<TriggeredJobHistoryInner>> result = listTriggeredWebJobHistoryDelegate(response);
                        return Observable.just(new ServiceResponse<Page<TriggeredJobHistoryInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<TriggeredJobHistoryInner>> listTriggeredWebJobHistoryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<TriggeredJobHistoryInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<TriggeredJobHistoryInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param id History ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TriggeredJobHistoryInner object if successful.
     */
    public TriggeredJobHistoryInner getTriggeredWebJobHistory(String resourceGroupName, String name, String webJobName, String id) {
        return getTriggeredWebJobHistoryWithServiceResponseAsync(resourceGroupName, name, webJobName, id).toBlocking().single().body();
    }

    /**
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param id History ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TriggeredJobHistoryInner> getTriggeredWebJobHistoryAsync(String resourceGroupName, String name, String webJobName, String id, final ServiceCallback<TriggeredJobHistoryInner> serviceCallback) {
        return ServiceFuture.fromResponse(getTriggeredWebJobHistoryWithServiceResponseAsync(resourceGroupName, name, webJobName, id), serviceCallback);
    }

    /**
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param id History ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TriggeredJobHistoryInner object
     */
    public Observable<TriggeredJobHistoryInner> getTriggeredWebJobHistoryAsync(String resourceGroupName, String name, String webJobName, String id) {
        return getTriggeredWebJobHistoryWithServiceResponseAsync(resourceGroupName, name, webJobName, id).map(new Func1<ServiceResponse<TriggeredJobHistoryInner>, TriggeredJobHistoryInner>() {
            @Override
            public TriggeredJobHistoryInner call(ServiceResponse<TriggeredJobHistoryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     * Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param id History ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TriggeredJobHistoryInner object
     */
    public Observable<ServiceResponse<TriggeredJobHistoryInner>> getTriggeredWebJobHistoryWithServiceResponseAsync(String resourceGroupName, String name, String webJobName, String id) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getTriggeredWebJobHistory(resourceGroupName, name, webJobName, id, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TriggeredJobHistoryInner>>>() {
                @Override
                public Observable<ServiceResponse<TriggeredJobHistoryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TriggeredJobHistoryInner> clientResponse = getTriggeredWebJobHistoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TriggeredJobHistoryInner> getTriggeredWebJobHistoryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<TriggeredJobHistoryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TriggeredJobHistoryInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Run a triggered web job for an app, or a deployment slot.
     * Run a triggered web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void runTriggeredWebJob(String resourceGroupName, String name, String webJobName) {
        runTriggeredWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).toBlocking().single().body();
    }

    /**
     * Run a triggered web job for an app, or a deployment slot.
     * Run a triggered web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> runTriggeredWebJobAsync(String resourceGroupName, String name, String webJobName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(runTriggeredWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName), serviceCallback);
    }

    /**
     * Run a triggered web job for an app, or a deployment slot.
     * Run a triggered web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> runTriggeredWebJobAsync(String resourceGroupName, String name, String webJobName) {
        return runTriggeredWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Run a triggered web job for an app, or a deployment slot.
     * Run a triggered web job for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> runTriggeredWebJobWithServiceResponseAsync(String resourceGroupName, String name, String webJobName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.runTriggeredWebJob(resourceGroupName, name, webJobName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = runTriggeredWebJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> runTriggeredWebJobDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsages(final String resourceGroupName, final String name) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.body()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CsmUsageQuotaInner>> listUsagesAsync(final String resourceGroupName, final String name, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listUsagesSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesAsync(final String resourceGroupName, final String name) {
        return listUsagesWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listUsagesSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        return service.listUsages(resourceGroupName, name, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsages(final String resourceGroupName, final String name, final String filter) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesSinglePageAsync(resourceGroupName, name, filter).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.body()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CsmUsageQuotaInner>> listUsagesAsync(final String resourceGroupName, final String name, final String filter, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listUsagesSinglePageAsync(resourceGroupName, name, filter),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesAsync(final String resourceGroupName, final String name, final String filter) {
        return listUsagesWithServiceResponseAsync(resourceGroupName, name, filter)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesWithServiceResponseAsync(final String resourceGroupName, final String name, final String filter) {
        return listUsagesSinglePageAsync(resourceGroupName, name, filter)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSinglePageAsync(final String resourceGroupName, final String name, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listUsages(resourceGroupName, name, this.client.subscriptionId(), filter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> listUsagesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<CsmUsageQuotaInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;VnetInfoInner&gt; object if successful.
     */
    public List<VnetInfoInner> listVnetConnections(String resourceGroupName, String name) {
        return listVnetConnectionsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<VnetInfoInner>> listVnetConnectionsAsync(String resourceGroupName, String name, final ServiceCallback<List<VnetInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listVnetConnectionsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<List<VnetInfoInner>> listVnetConnectionsAsync(String resourceGroupName, String name) {
        return listVnetConnectionsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<List<VnetInfoInner>>, List<VnetInfoInner>>() {
            @Override
            public List<VnetInfoInner> call(ServiceResponse<List<VnetInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<VnetInfoInner>>> listVnetConnectionsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listVnetConnections(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<VnetInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<VnetInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<VnetInfoInner>> clientResponse = listVnetConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<VnetInfoInner>> listVnetConnectionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<VnetInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<VnetInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner getVnetConnection(String resourceGroupName, String name, String vnetName) {
        return getVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).toBlocking().single().body();
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetInfoInner> getVnetConnectionAsync(String resourceGroupName, String name, String vnetName, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName), serviceCallback);
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> getVnetConnectionAsync(String resourceGroupName, String name, String vnetName) {
        return getVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> getVnetConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getVnetConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = getVnetConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> getVnetConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner createOrUpdateVnetConnection(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return createOrUpdateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetInfoInner> createOrUpdateVnetConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> createOrUpdateVnetConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return createOrUpdateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> createOrUpdateVnetConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateVnetConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = createOrUpdateVnetConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> createOrUpdateVnetConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteVnetConnection(String resourceGroupName, String name, String vnetName) {
        deleteVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).toBlocking().single().body();
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteVnetConnectionAsync(String resourceGroupName, String name, String vnetName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName), serviceCallback);
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteVnetConnectionAsync(String resourceGroupName, String name, String vnetName) {
        return deleteVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteVnetConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteVnetConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteVnetConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteVnetConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner updateVnetConnection(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return updateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetInfoInner> updateVnetConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> updateVnetConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return updateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> updateVnetConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateVnetConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = updateVnetConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> updateVnetConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner getVnetConnectionGateway(String resourceGroupName, String name, String vnetName, String gatewayName) {
        return getVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName).toBlocking().single().body();
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetGatewayInner> getVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceFuture.fromResponse(getVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName), serviceCallback);
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> getVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName) {
        return getVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> getVnetConnectionGatewayWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = getVnetConnectionGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> getVnetConnectionGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetGatewayInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner createOrUpdateVnetConnectionGateway(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetGatewayInner> createOrUpdateVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> createOrUpdateVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> createOrUpdateVnetConnectionGatewayWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.createOrUpdateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = createOrUpdateVnetConnectionGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> createOrUpdateVnetConnectionGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetGatewayInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner updateVnetConnectionGateway(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return updateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetGatewayInner> updateVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> updateVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return updateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> updateVnetConnectionGatewayWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        return service.updateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), connectionEnvelope, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = updateVnetConnectionGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> updateVnetConnectionGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetGatewayInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;WebJobInner&gt; object if successful.
     */
    public PagedList<WebJobInner> listWebJobs(final String resourceGroupName, final String name) {
        ServiceResponse<Page<WebJobInner>> response = listWebJobsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<WebJobInner>(response.body()) {
            @Override
            public Page<WebJobInner> nextPage(String nextPageLink) {
                return listWebJobsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<WebJobInner>> listWebJobsAsync(final String resourceGroupName, final String name, final ListOperationCallback<WebJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listWebJobsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<WebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebJobInner>>> call(String nextPageLink) {
                    return listWebJobsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebJobInner&gt; object
     */
    public Observable<Page<WebJobInner>> listWebJobsAsync(final String resourceGroupName, final String name) {
        return listWebJobsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<WebJobInner>>, Page<WebJobInner>>() {
                @Override
                public Page<WebJobInner> call(ServiceResponse<Page<WebJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<WebJobInner>>> listWebJobsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listWebJobsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<WebJobInner>>, Observable<ServiceResponse<Page<WebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebJobInner>>> call(ServiceResponse<Page<WebJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listWebJobsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<WebJobInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<WebJobInner>> * @param name Site name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;WebJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<WebJobInner>>> listWebJobsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listWebJobs(resourceGroupName, name, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<WebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<WebJobInner>> result = listWebJobsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<WebJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<WebJobInner>> listWebJobsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<WebJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<WebJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get webjob information for an app, or a deployment slot.
     * Get webjob information for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of the web job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WebJobInner object if successful.
     */
    public WebJobInner getWebJob(String resourceGroupName, String name, String webJobName) {
        return getWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).toBlocking().single().body();
    }

    /**
     * Get webjob information for an app, or a deployment slot.
     * Get webjob information for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of the web job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WebJobInner> getWebJobAsync(String resourceGroupName, String name, String webJobName, final ServiceCallback<WebJobInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName), serviceCallback);
    }

    /**
     * Get webjob information for an app, or a deployment slot.
     * Get webjob information for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of the web job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WebJobInner object
     */
    public Observable<WebJobInner> getWebJobAsync(String resourceGroupName, String name, String webJobName) {
        return getWebJobWithServiceResponseAsync(resourceGroupName, name, webJobName).map(new Func1<ServiceResponse<WebJobInner>, WebJobInner>() {
            @Override
            public WebJobInner call(ServiceResponse<WebJobInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get webjob information for an app, or a deployment slot.
     * Get webjob information for an app, or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of the web job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WebJobInner object
     */
    public Observable<ServiceResponse<WebJobInner>> getWebJobWithServiceResponseAsync(String resourceGroupName, String name, String webJobName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (webJobName == null) {
            throw new IllegalArgumentException("Parameter webJobName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getWebJob(resourceGroupName, name, webJobName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WebJobInner>>>() {
                @Override
                public Observable<ServiceResponse<WebJobInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WebJobInner> clientResponse = getWebJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<WebJobInner> getWebJobDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<WebJobInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<WebJobInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInner>> response = listNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInner>(response.body()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInner>> listNextAsync(final String nextPageLink, final ServiceFuture<List<SiteInner>> serviceFuture, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listNextAsync(final String nextPageLink) {
        return listNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listNextWithServiceResponseAsync(final String nextPageLink) {
        return listNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listByResourceGroupNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInner>> response = listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInner>(response.body()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInner>> listByResourceGroupNextAsync(final String nextPageLink, final ServiceFuture<List<SiteInner>> serviceFuture, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listByResourceGroupNextAsync(final String nextPageLink) {
        return listByResourceGroupNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupNextWithServiceResponseAsync(final String nextPageLink) {
        return listByResourceGroupNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByResourceGroupNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listByResourceGroupNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listByResourceGroupNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listBackupsNext(final String nextPageLink) {
        ServiceResponse<Page<BackupItemInner>> response = listBackupsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<BackupItemInner>(response.body()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listBackupsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BackupItemInner>> listBackupsNextAsync(final String nextPageLink, final ServiceFuture<List<BackupItemInner>> serviceFuture, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listBackupsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listBackupsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listBackupsNextAsync(final String nextPageLink) {
        return listBackupsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsNextWithServiceResponseAsync(final String nextPageLink) {
        return listBackupsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listBackupsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listBackupsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listBackupsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listBackupsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BackupItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteConfigResourceInner&gt; object if successful.
     */
    public PagedList<SiteConfigResourceInner> listConfigurationsNext(final String nextPageLink) {
        ServiceResponse<Page<SiteConfigResourceInner>> response = listConfigurationsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteConfigResourceInner>(response.body()) {
            @Override
            public Page<SiteConfigResourceInner> nextPage(String nextPageLink) {
                return listConfigurationsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteConfigResourceInner>> listConfigurationsNextAsync(final String nextPageLink, final ServiceFuture<List<SiteConfigResourceInner>> serviceFuture, final ListOperationCallback<SiteConfigResourceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listConfigurationsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteConfigResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> call(String nextPageLink) {
                    return listConfigurationsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigResourceInner&gt; object
     */
    public Observable<Page<SiteConfigResourceInner>> listConfigurationsNextAsync(final String nextPageLink) {
        return listConfigurationsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteConfigResourceInner>>, Page<SiteConfigResourceInner>>() {
                @Override
                public Page<SiteConfigResourceInner> call(ServiceResponse<Page<SiteConfigResourceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigResourceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> listConfigurationsNextWithServiceResponseAsync(final String nextPageLink) {
        return listConfigurationsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteConfigResourceInner>>, Observable<ServiceResponse<Page<SiteConfigResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> call(ServiceResponse<Page<SiteConfigResourceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listConfigurationsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
    ServiceResponse<PageImpl<SiteConfigResourceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteConfigResourceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> listConfigurationsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listConfigurationsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteConfigResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteConfigResourceInner>> result = listConfigurationsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteConfigResourceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteConfigResourceInner>> listConfigurationsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteConfigResourceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteConfigResourceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object if successful.
     */
    public PagedList<SiteConfigurationSnapshotInfoInner> listConfigurationSnapshotInfoNext(final String nextPageLink) {
        ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>> response = listConfigurationSnapshotInfoNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteConfigurationSnapshotInfoInner>(response.body()) {
            @Override
            public Page<SiteConfigurationSnapshotInfoInner> nextPage(String nextPageLink) {
                return listConfigurationSnapshotInfoNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoNextAsync(final String nextPageLink, final ServiceFuture<List<SiteConfigurationSnapshotInfoInner>> serviceFuture, final ListOperationCallback<SiteConfigurationSnapshotInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listConfigurationSnapshotInfoNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> call(String nextPageLink) {
                    return listConfigurationSnapshotInfoNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object
     */
    public Observable<Page<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoNextAsync(final String nextPageLink) {
        return listConfigurationSnapshotInfoNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>, Page<SiteConfigurationSnapshotInfoInner>>() {
                @Override
                public Page<SiteConfigurationSnapshotInfoInner> call(ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> listConfigurationSnapshotInfoNextWithServiceResponseAsync(final String nextPageLink) {
        return listConfigurationSnapshotInfoNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>, Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> call(ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listConfigurationSnapshotInfoNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
    ServiceResponse<PageImpl<SiteConfigurationSnapshotInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> listConfigurationSnapshotInfoNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listConfigurationSnapshotInfoNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteConfigurationSnapshotInfoInner>> result = listConfigurationSnapshotInfoNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteConfigurationSnapshotInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteConfigurationSnapshotInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ContinuousWebJobInner&gt; object if successful.
     */
    public PagedList<ContinuousWebJobInner> listContinuousWebJobsNext(final String nextPageLink) {
        ServiceResponse<Page<ContinuousWebJobInner>> response = listContinuousWebJobsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ContinuousWebJobInner>(response.body()) {
            @Override
            public Page<ContinuousWebJobInner> nextPage(String nextPageLink) {
                return listContinuousWebJobsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ContinuousWebJobInner>> listContinuousWebJobsNextAsync(final String nextPageLink, final ServiceFuture<List<ContinuousWebJobInner>> serviceFuture, final ListOperationCallback<ContinuousWebJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listContinuousWebJobsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ContinuousWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> call(String nextPageLink) {
                    return listContinuousWebJobsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ContinuousWebJobInner&gt; object
     */
    public Observable<Page<ContinuousWebJobInner>> listContinuousWebJobsNextAsync(final String nextPageLink) {
        return listContinuousWebJobsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ContinuousWebJobInner>>, Page<ContinuousWebJobInner>>() {
                @Override
                public Page<ContinuousWebJobInner> call(ServiceResponse<Page<ContinuousWebJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ContinuousWebJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> listContinuousWebJobsNextWithServiceResponseAsync(final String nextPageLink) {
        return listContinuousWebJobsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ContinuousWebJobInner>>, Observable<ServiceResponse<Page<ContinuousWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> call(ServiceResponse<Page<ContinuousWebJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listContinuousWebJobsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<ContinuousWebJobInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ContinuousWebJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> listContinuousWebJobsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listContinuousWebJobsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ContinuousWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ContinuousWebJobInner>> result = listContinuousWebJobsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ContinuousWebJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ContinuousWebJobInner>> listContinuousWebJobsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ContinuousWebJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ContinuousWebJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listDeploymentsNext(final String nextPageLink) {
        ServiceResponse<Page<DeploymentInner>> response = listDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeploymentInner>(response.body()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeploymentInner>> listDeploymentsNextAsync(final String nextPageLink, final ServiceFuture<List<DeploymentInner>> serviceFuture, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDeploymentsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listDeploymentsNextAsync(final String nextPageLink) {
        return listDeploymentsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsNextWithServiceResponseAsync(final String nextPageLink) {
        return listDeploymentsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDeploymentsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listDeploymentsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listDeploymentsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listDeploymentsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DeploymentInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;IdentifierInner&gt; object if successful.
     */
    public PagedList<IdentifierInner> listDomainOwnershipIdentifiersNext(final String nextPageLink) {
        ServiceResponse<Page<IdentifierInner>> response = listDomainOwnershipIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<IdentifierInner>(response.body()) {
            @Override
            public Page<IdentifierInner> nextPage(String nextPageLink) {
                return listDomainOwnershipIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IdentifierInner>> listDomainOwnershipIdentifiersNextAsync(final String nextPageLink, final ServiceFuture<List<IdentifierInner>> serviceFuture, final ListOperationCallback<IdentifierInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDomainOwnershipIdentifiersNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(String nextPageLink) {
                    return listDomainOwnershipIdentifiersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<Page<IdentifierInner>> listDomainOwnershipIdentifiersNextAsync(final String nextPageLink) {
        return listDomainOwnershipIdentifiersNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<IdentifierInner>>, Page<IdentifierInner>>() {
                @Override
                public Page<IdentifierInner> call(ServiceResponse<Page<IdentifierInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersNextWithServiceResponseAsync(final String nextPageLink) {
        return listDomainOwnershipIdentifiersNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<IdentifierInner>>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(ServiceResponse<Page<IdentifierInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDomainOwnershipIdentifiersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
    ServiceResponse<PageImpl<IdentifierInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;IdentifierInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listDomainOwnershipIdentifiersNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<IdentifierInner>> result = listDomainOwnershipIdentifiersNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<IdentifierInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<IdentifierInner>> listDomainOwnershipIdentifiersNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<IdentifierInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<IdentifierInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;FunctionEnvelopeInner&gt; object if successful.
     */
    public PagedList<FunctionEnvelopeInner> listFunctionsNext(final String nextPageLink) {
        ServiceResponse<Page<FunctionEnvelopeInner>> response = listFunctionsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<FunctionEnvelopeInner>(response.body()) {
            @Override
            public Page<FunctionEnvelopeInner> nextPage(String nextPageLink) {
                return listFunctionsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FunctionEnvelopeInner>> listFunctionsNextAsync(final String nextPageLink, final ServiceFuture<List<FunctionEnvelopeInner>> serviceFuture, final ListOperationCallback<FunctionEnvelopeInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listFunctionsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<FunctionEnvelopeInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> call(String nextPageLink) {
                    return listFunctionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;FunctionEnvelopeInner&gt; object
     */
    public Observable<Page<FunctionEnvelopeInner>> listFunctionsNextAsync(final String nextPageLink) {
        return listFunctionsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<FunctionEnvelopeInner>>, Page<FunctionEnvelopeInner>>() {
                @Override
                public Page<FunctionEnvelopeInner> call(ServiceResponse<Page<FunctionEnvelopeInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;FunctionEnvelopeInner&gt; object
     */
    public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> listFunctionsNextWithServiceResponseAsync(final String nextPageLink) {
        return listFunctionsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<FunctionEnvelopeInner>>, Observable<ServiceResponse<Page<FunctionEnvelopeInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> call(ServiceResponse<Page<FunctionEnvelopeInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listFunctionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
    ServiceResponse<PageImpl<FunctionEnvelopeInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;FunctionEnvelopeInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> listFunctionsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listFunctionsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<FunctionEnvelopeInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<FunctionEnvelopeInner>> result = listFunctionsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<FunctionEnvelopeInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<FunctionEnvelopeInner>> listFunctionsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<FunctionEnvelopeInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<FunctionEnvelopeInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> listHostNameBindingsNext(final String nextPageLink) {
        ServiceResponse<Page<HostNameBindingInner>> response = listHostNameBindingsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.body()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return listHostNameBindingsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<HostNameBindingInner>> listHostNameBindingsNextAsync(final String nextPageLink, final ServiceFuture<List<HostNameBindingInner>> serviceFuture, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listHostNameBindingsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return listHostNameBindingsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> listHostNameBindingsNextAsync(final String nextPageLink) {
        return listHostNameBindingsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsNextWithServiceResponseAsync(final String nextPageLink) {
        return listHostNameBindingsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listHostNameBindingsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listHostNameBindingsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = listHostNameBindingsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> listHostNameBindingsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<HostNameBindingInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> listInstanceIdentifiersNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInstanceInner>> response = listInstanceIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.body()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return listInstanceIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInstanceInner>> listInstanceIdentifiersNextAsync(final String nextPageLink, final ServiceFuture<List<SiteInstanceInner>> serviceFuture, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceIdentifiersNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return listInstanceIdentifiersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> listInstanceIdentifiersNextAsync(final String nextPageLink) {
        return listInstanceIdentifiersNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceIdentifiersNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceIdentifiersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listInstanceIdentifiersNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = listInstanceIdentifiersNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> listInstanceIdentifiersNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInstanceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessInfoInner&gt; object if successful.
     */
    public PagedList<ProcessInfoInner> listInstanceProcessesNext(final String nextPageLink) {
        ServiceResponse<Page<ProcessInfoInner>> response = listInstanceProcessesNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProcessInfoInner>(response.body()) {
            @Override
            public Page<ProcessInfoInner> nextPage(String nextPageLink) {
                return listInstanceProcessesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessInfoInner>> listInstanceProcessesNextAsync(final String nextPageLink, final ServiceFuture<List<ProcessInfoInner>> serviceFuture, final ListOperationCallback<ProcessInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceProcessesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(String nextPageLink) {
                    return listInstanceProcessesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<Page<ProcessInfoInner>> listInstanceProcessesNextAsync(final String nextPageLink) {
        return listInstanceProcessesNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Page<ProcessInfoInner>>() {
                @Override
                public Page<ProcessInfoInner> call(ServiceResponse<Page<ProcessInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listInstanceProcessesNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceProcessesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(ServiceResponse<Page<ProcessInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceProcessesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listInstanceProcessesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listInstanceProcessesNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessInfoInner>> result = listInstanceProcessesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessInfoInner>> listInstanceProcessesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object if successful.
     */
    public PagedList<ProcessModuleInfoInner> listInstanceProcessModulesNext(final String nextPageLink) {
        ServiceResponse<Page<ProcessModuleInfoInner>> response = listInstanceProcessModulesNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProcessModuleInfoInner>(response.body()) {
            @Override
            public Page<ProcessModuleInfoInner> nextPage(String nextPageLink) {
                return listInstanceProcessModulesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessModuleInfoInner>> listInstanceProcessModulesNextAsync(final String nextPageLink, final ServiceFuture<List<ProcessModuleInfoInner>> serviceFuture, final ListOperationCallback<ProcessModuleInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceProcessModulesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(String nextPageLink) {
                    return listInstanceProcessModulesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<Page<ProcessModuleInfoInner>> listInstanceProcessModulesNextAsync(final String nextPageLink) {
        return listInstanceProcessModulesNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Page<ProcessModuleInfoInner>>() {
                @Override
                public Page<ProcessModuleInfoInner> call(ServiceResponse<Page<ProcessModuleInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listInstanceProcessModulesNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceProcessModulesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(ServiceResponse<Page<ProcessModuleInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceProcessModulesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listInstanceProcessModulesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listInstanceProcessModulesNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessModuleInfoInner>> result = listInstanceProcessModulesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessModuleInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessModuleInfoInner>> listInstanceProcessModulesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessModuleInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessModuleInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object if successful.
     */
    public PagedList<ProcessThreadInfoInner> listInstanceProcessThreadsNext(final String nextPageLink) {
        ServiceResponse<Page<ProcessThreadInfoInner>> response = listInstanceProcessThreadsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProcessThreadInfoInner>(response.body()) {
            @Override
            public Page<ProcessThreadInfoInner> nextPage(String nextPageLink) {
                return listInstanceProcessThreadsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessThreadInfoInner>> listInstanceProcessThreadsNextAsync(final String nextPageLink, final ServiceFuture<List<ProcessThreadInfoInner>> serviceFuture, final ListOperationCallback<ProcessThreadInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceProcessThreadsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(String nextPageLink) {
                    return listInstanceProcessThreadsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<Page<ProcessThreadInfoInner>> listInstanceProcessThreadsNextAsync(final String nextPageLink) {
        return listInstanceProcessThreadsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Page<ProcessThreadInfoInner>>() {
                @Override
                public Page<ProcessThreadInfoInner> call(ServiceResponse<Page<ProcessThreadInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listInstanceProcessThreadsNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceProcessThreadsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(ServiceResponse<Page<ProcessThreadInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceProcessThreadsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listInstanceProcessThreadsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listInstanceProcessThreadsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessThreadInfoInner>> result = listInstanceProcessThreadsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessThreadInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessThreadInfoInner>> listInstanceProcessThreadsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessThreadInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessThreadInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object if successful.
     */
    public PagedList<ResourceMetricDefinitionInner> listMetricDefinitionsNext(final String nextPageLink) {
        ServiceResponse<Page<ResourceMetricDefinitionInner>> response = listMetricDefinitionsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ResourceMetricDefinitionInner>(response.body()) {
            @Override
            public Page<ResourceMetricDefinitionInner> nextPage(String nextPageLink) {
                return listMetricDefinitionsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricDefinitionInner>> listMetricDefinitionsNextAsync(final String nextPageLink, final ServiceFuture<List<ResourceMetricDefinitionInner>> serviceFuture, final ListOperationCallback<ResourceMetricDefinitionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricDefinitionsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(String nextPageLink) {
                    return listMetricDefinitionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<Page<ResourceMetricDefinitionInner>> listMetricDefinitionsNextAsync(final String nextPageLink) {
        return listMetricDefinitionsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Page<ResourceMetricDefinitionInner>>() {
                @Override
                public Page<ResourceMetricDefinitionInner> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricDefinitionsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricDefinitionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listMetricDefinitionsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> result = listMetricDefinitionsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricDefinitionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> listMetricDefinitionsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricDefinitionInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetricsNext(final String nextPageLink) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.body()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricInner>> listMetricsNextAsync(final String nextPageLink, final ServiceFuture<List<ResourceMetricInner>> serviceFuture, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsNextAsync(final String nextPageLink) {
        return listMetricsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listMetricsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> listMetricsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCountersNext(final String nextPageLink) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.body()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PerfMonResponseInner>> listPerfMonCountersNextAsync(final String nextPageLink, final ServiceFuture<List<PerfMonResponseInner>> serviceFuture, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPerfMonCountersNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersNextAsync(final String nextPageLink) {
        return listPerfMonCountersNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersNextWithServiceResponseAsync(final String nextPageLink) {
        return listPerfMonCountersNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listPerfMonCountersNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PerfMonResponseInner>> listPerfMonCountersNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<PerfMonResponseInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<PerfMonResponseInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessInfoInner&gt; object if successful.
     */
    public PagedList<ProcessInfoInner> listProcessesNext(final String nextPageLink) {
        ServiceResponse<Page<ProcessInfoInner>> response = listProcessesNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProcessInfoInner>(response.body()) {
            @Override
            public Page<ProcessInfoInner> nextPage(String nextPageLink) {
                return listProcessesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessInfoInner>> listProcessesNextAsync(final String nextPageLink, final ServiceFuture<List<ProcessInfoInner>> serviceFuture, final ListOperationCallback<ProcessInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listProcessesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(String nextPageLink) {
                    return listProcessesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<Page<ProcessInfoInner>> listProcessesNextAsync(final String nextPageLink) {
        return listProcessesNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Page<ProcessInfoInner>>() {
                @Override
                public Page<ProcessInfoInner> call(ServiceResponse<Page<ProcessInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listProcessesNextWithServiceResponseAsync(final String nextPageLink) {
        return listProcessesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(ServiceResponse<Page<ProcessInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listProcessesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listProcessesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listProcessesNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessInfoInner>> result = listProcessesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessInfoInner>> listProcessesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object if successful.
     */
    public PagedList<ProcessModuleInfoInner> listProcessModulesNext(final String nextPageLink) {
        ServiceResponse<Page<ProcessModuleInfoInner>> response = listProcessModulesNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProcessModuleInfoInner>(response.body()) {
            @Override
            public Page<ProcessModuleInfoInner> nextPage(String nextPageLink) {
                return listProcessModulesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessModuleInfoInner>> listProcessModulesNextAsync(final String nextPageLink, final ServiceFuture<List<ProcessModuleInfoInner>> serviceFuture, final ListOperationCallback<ProcessModuleInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listProcessModulesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(String nextPageLink) {
                    return listProcessModulesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<Page<ProcessModuleInfoInner>> listProcessModulesNextAsync(final String nextPageLink) {
        return listProcessModulesNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Page<ProcessModuleInfoInner>>() {
                @Override
                public Page<ProcessModuleInfoInner> call(ServiceResponse<Page<ProcessModuleInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listProcessModulesNextWithServiceResponseAsync(final String nextPageLink) {
        return listProcessModulesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(ServiceResponse<Page<ProcessModuleInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listProcessModulesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listProcessModulesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listProcessModulesNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessModuleInfoInner>> result = listProcessModulesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessModuleInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessModuleInfoInner>> listProcessModulesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessModuleInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessModuleInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object if successful.
     */
    public PagedList<ProcessThreadInfoInner> listProcessThreadsNext(final String nextPageLink) {
        ServiceResponse<Page<ProcessThreadInfoInner>> response = listProcessThreadsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProcessThreadInfoInner>(response.body()) {
            @Override
            public Page<ProcessThreadInfoInner> nextPage(String nextPageLink) {
                return listProcessThreadsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessThreadInfoInner>> listProcessThreadsNextAsync(final String nextPageLink, final ServiceFuture<List<ProcessThreadInfoInner>> serviceFuture, final ListOperationCallback<ProcessThreadInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listProcessThreadsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(String nextPageLink) {
                    return listProcessThreadsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<Page<ProcessThreadInfoInner>> listProcessThreadsNextAsync(final String nextPageLink) {
        return listProcessThreadsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Page<ProcessThreadInfoInner>>() {
                @Override
                public Page<ProcessThreadInfoInner> call(ServiceResponse<Page<ProcessThreadInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listProcessThreadsNextWithServiceResponseAsync(final String nextPageLink) {
        return listProcessThreadsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(ServiceResponse<Page<ProcessThreadInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listProcessThreadsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listProcessThreadsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listProcessThreadsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessThreadInfoInner>> result = listProcessThreadsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessThreadInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessThreadInfoInner>> listProcessThreadsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessThreadInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessThreadInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PublicCertificateInner&gt; object if successful.
     */
    public PagedList<PublicCertificateInner> listPublicCertificatesNext(final String nextPageLink) {
        ServiceResponse<Page<PublicCertificateInner>> response = listPublicCertificatesNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<PublicCertificateInner>(response.body()) {
            @Override
            public Page<PublicCertificateInner> nextPage(String nextPageLink) {
                return listPublicCertificatesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PublicCertificateInner>> listPublicCertificatesNextAsync(final String nextPageLink, final ServiceFuture<List<PublicCertificateInner>> serviceFuture, final ListOperationCallback<PublicCertificateInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPublicCertificatesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<PublicCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PublicCertificateInner>>> call(String nextPageLink) {
                    return listPublicCertificatesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PublicCertificateInner&gt; object
     */
    public Observable<Page<PublicCertificateInner>> listPublicCertificatesNextAsync(final String nextPageLink) {
        return listPublicCertificatesNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<PublicCertificateInner>>, Page<PublicCertificateInner>>() {
                @Override
                public Page<PublicCertificateInner> call(ServiceResponse<Page<PublicCertificateInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PublicCertificateInner&gt; object
     */
    public Observable<ServiceResponse<Page<PublicCertificateInner>>> listPublicCertificatesNextWithServiceResponseAsync(final String nextPageLink) {
        return listPublicCertificatesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<PublicCertificateInner>>, Observable<ServiceResponse<Page<PublicCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PublicCertificateInner>>> call(ServiceResponse<Page<PublicCertificateInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPublicCertificatesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
    ServiceResponse<PageImpl<PublicCertificateInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PublicCertificateInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PublicCertificateInner>>> listPublicCertificatesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listPublicCertificatesNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PublicCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PublicCertificateInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PublicCertificateInner>> result = listPublicCertificatesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PublicCertificateInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PublicCertificateInner>> listPublicCertificatesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<PublicCertificateInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<PublicCertificateInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteExtensionInfoInner&gt; object if successful.
     */
    public PagedList<SiteExtensionInfoInner> listSiteExtensionsNext(final String nextPageLink) {
        ServiceResponse<Page<SiteExtensionInfoInner>> response = listSiteExtensionsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteExtensionInfoInner>(response.body()) {
            @Override
            public Page<SiteExtensionInfoInner> nextPage(String nextPageLink) {
                return listSiteExtensionsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteExtensionInfoInner>> listSiteExtensionsNextAsync(final String nextPageLink, final ServiceFuture<List<SiteExtensionInfoInner>> serviceFuture, final ListOperationCallback<SiteExtensionInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSiteExtensionsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteExtensionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> call(String nextPageLink) {
                    return listSiteExtensionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteExtensionInfoInner&gt; object
     */
    public Observable<Page<SiteExtensionInfoInner>> listSiteExtensionsNextAsync(final String nextPageLink) {
        return listSiteExtensionsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteExtensionInfoInner>>, Page<SiteExtensionInfoInner>>() {
                @Override
                public Page<SiteExtensionInfoInner> call(ServiceResponse<Page<SiteExtensionInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteExtensionInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> listSiteExtensionsNextWithServiceResponseAsync(final String nextPageLink) {
        return listSiteExtensionsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteExtensionInfoInner>>, Observable<ServiceResponse<Page<SiteExtensionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> call(ServiceResponse<Page<SiteExtensionInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSiteExtensionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
    ServiceResponse<PageImpl<SiteExtensionInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteExtensionInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> listSiteExtensionsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSiteExtensionsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteExtensionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteExtensionInfoInner>> result = listSiteExtensionsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteExtensionInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteExtensionInfoInner>> listSiteExtensionsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteExtensionInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteExtensionInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listSlotsNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInner>> response = listSlotsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInner>(response.body()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listSlotsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInner>> listSlotsNextAsync(final String nextPageLink, final ServiceFuture<List<SiteInner>> serviceFuture, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSlotsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listSlotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listSlotsNextAsync(final String nextPageLink) {
        return listSlotsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSlotsNextWithServiceResponseAsync(final String nextPageLink) {
        return listSlotsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSlotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSlotsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSlotsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listSlotsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listSlotsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listBackupsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<BackupItemInner>> response = listBackupsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<BackupItemInner>(response.body()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listBackupsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BackupItemInner>> listBackupsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<BackupItemInner>> serviceFuture, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listBackupsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listBackupsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listBackupsSlotNextAsync(final String nextPageLink) {
        return listBackupsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listBackupsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listBackupsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listBackupsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listBackupsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listBackupsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BackupItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteConfigResourceInner&gt; object if successful.
     */
    public PagedList<SiteConfigResourceInner> listConfigurationsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<SiteConfigResourceInner>> response = listConfigurationsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteConfigResourceInner>(response.body()) {
            @Override
            public Page<SiteConfigResourceInner> nextPage(String nextPageLink) {
                return listConfigurationsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteConfigResourceInner>> listConfigurationsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<SiteConfigResourceInner>> serviceFuture, final ListOperationCallback<SiteConfigResourceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listConfigurationsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteConfigResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> call(String nextPageLink) {
                    return listConfigurationsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigResourceInner&gt; object
     */
    public Observable<Page<SiteConfigResourceInner>> listConfigurationsSlotNextAsync(final String nextPageLink) {
        return listConfigurationsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteConfigResourceInner>>, Page<SiteConfigResourceInner>>() {
                @Override
                public Page<SiteConfigResourceInner> call(ServiceResponse<Page<SiteConfigResourceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigResourceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> listConfigurationsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listConfigurationsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteConfigResourceInner>>, Observable<ServiceResponse<Page<SiteConfigResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> call(ServiceResponse<Page<SiteConfigResourceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listConfigurationsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the configurations of an app.
     * List the configurations of an app.
     *
    ServiceResponse<PageImpl<SiteConfigResourceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteConfigResourceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> listConfigurationsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listConfigurationsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteConfigResourceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigResourceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteConfigResourceInner>> result = listConfigurationsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteConfigResourceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteConfigResourceInner>> listConfigurationsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteConfigResourceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteConfigResourceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object if successful.
     */
    public PagedList<SiteConfigurationSnapshotInfoInner> listConfigurationSnapshotInfoSlotNext(final String nextPageLink) {
        ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>> response = listConfigurationSnapshotInfoSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteConfigurationSnapshotInfoInner>(response.body()) {
            @Override
            public Page<SiteConfigurationSnapshotInfoInner> nextPage(String nextPageLink) {
                return listConfigurationSnapshotInfoSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoSlotNextAsync(final String nextPageLink, final ServiceFuture<List<SiteConfigurationSnapshotInfoInner>> serviceFuture, final ListOperationCallback<SiteConfigurationSnapshotInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listConfigurationSnapshotInfoSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> call(String nextPageLink) {
                    return listConfigurationSnapshotInfoSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object
     */
    public Observable<Page<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoSlotNextAsync(final String nextPageLink) {
        return listConfigurationSnapshotInfoSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>, Page<SiteConfigurationSnapshotInfoInner>>() {
                @Override
                public Page<SiteConfigurationSnapshotInfoInner> call(ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> listConfigurationSnapshotInfoSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listConfigurationSnapshotInfoSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>, Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> call(ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listConfigurationSnapshotInfoSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
    ServiceResponse<PageImpl<SiteConfigurationSnapshotInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteConfigurationSnapshotInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> listConfigurationSnapshotInfoSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listConfigurationSnapshotInfoSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteConfigurationSnapshotInfoInner>> result = listConfigurationSnapshotInfoSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteConfigurationSnapshotInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteConfigurationSnapshotInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteConfigurationSnapshotInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ContinuousWebJobInner&gt; object if successful.
     */
    public PagedList<ContinuousWebJobInner> listContinuousWebJobsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<ContinuousWebJobInner>> response = listContinuousWebJobsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ContinuousWebJobInner>(response.body()) {
            @Override
            public Page<ContinuousWebJobInner> nextPage(String nextPageLink) {
                return listContinuousWebJobsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ContinuousWebJobInner>> listContinuousWebJobsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<ContinuousWebJobInner>> serviceFuture, final ListOperationCallback<ContinuousWebJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listContinuousWebJobsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ContinuousWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> call(String nextPageLink) {
                    return listContinuousWebJobsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ContinuousWebJobInner&gt; object
     */
    public Observable<Page<ContinuousWebJobInner>> listContinuousWebJobsSlotNextAsync(final String nextPageLink) {
        return listContinuousWebJobsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ContinuousWebJobInner>>, Page<ContinuousWebJobInner>>() {
                @Override
                public Page<ContinuousWebJobInner> call(ServiceResponse<Page<ContinuousWebJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ContinuousWebJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> listContinuousWebJobsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listContinuousWebJobsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ContinuousWebJobInner>>, Observable<ServiceResponse<Page<ContinuousWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> call(ServiceResponse<Page<ContinuousWebJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listContinuousWebJobsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List continuous web jobs for an app, or a deployment slot.
     * List continuous web jobs for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<ContinuousWebJobInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ContinuousWebJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> listContinuousWebJobsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listContinuousWebJobsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ContinuousWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ContinuousWebJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ContinuousWebJobInner>> result = listContinuousWebJobsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ContinuousWebJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ContinuousWebJobInner>> listContinuousWebJobsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ContinuousWebJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ContinuousWebJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listDeploymentsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<DeploymentInner>> response = listDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeploymentInner>(response.body()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeploymentInner>> listDeploymentsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<DeploymentInner>> serviceFuture, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDeploymentsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listDeploymentsSlotNextAsync(final String nextPageLink) {
        return listDeploymentsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listDeploymentsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDeploymentsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot.
     * List deployments for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listDeploymentsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listDeploymentsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listDeploymentsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DeploymentInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;IdentifierInner&gt; object if successful.
     */
    public PagedList<IdentifierInner> listDomainOwnershipIdentifiersSlotNext(final String nextPageLink) {
        ServiceResponse<Page<IdentifierInner>> response = listDomainOwnershipIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<IdentifierInner>(response.body()) {
            @Override
            public Page<IdentifierInner> nextPage(String nextPageLink) {
                return listDomainOwnershipIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IdentifierInner>> listDomainOwnershipIdentifiersSlotNextAsync(final String nextPageLink, final ServiceFuture<List<IdentifierInner>> serviceFuture, final ListOperationCallback<IdentifierInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDomainOwnershipIdentifiersSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(String nextPageLink) {
                    return listDomainOwnershipIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<Page<IdentifierInner>> listDomainOwnershipIdentifiersSlotNextAsync(final String nextPageLink) {
        return listDomainOwnershipIdentifiersSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<IdentifierInner>>, Page<IdentifierInner>>() {
                @Override
                public Page<IdentifierInner> call(ServiceResponse<Page<IdentifierInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listDomainOwnershipIdentifiersSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<IdentifierInner>>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(ServiceResponse<Page<IdentifierInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDomainOwnershipIdentifiersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
    ServiceResponse<PageImpl<IdentifierInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;IdentifierInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listDomainOwnershipIdentifiersSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<IdentifierInner>> result = listDomainOwnershipIdentifiersSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<IdentifierInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<IdentifierInner>> listDomainOwnershipIdentifiersSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<IdentifierInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<IdentifierInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;FunctionEnvelopeInner&gt; object if successful.
     */
    public PagedList<FunctionEnvelopeInner> listInstanceFunctionsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<FunctionEnvelopeInner>> response = listInstanceFunctionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<FunctionEnvelopeInner>(response.body()) {
            @Override
            public Page<FunctionEnvelopeInner> nextPage(String nextPageLink) {
                return listInstanceFunctionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FunctionEnvelopeInner>> listInstanceFunctionsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<FunctionEnvelopeInner>> serviceFuture, final ListOperationCallback<FunctionEnvelopeInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceFunctionsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<FunctionEnvelopeInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> call(String nextPageLink) {
                    return listInstanceFunctionsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;FunctionEnvelopeInner&gt; object
     */
    public Observable<Page<FunctionEnvelopeInner>> listInstanceFunctionsSlotNextAsync(final String nextPageLink) {
        return listInstanceFunctionsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<FunctionEnvelopeInner>>, Page<FunctionEnvelopeInner>>() {
                @Override
                public Page<FunctionEnvelopeInner> call(ServiceResponse<Page<FunctionEnvelopeInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;FunctionEnvelopeInner&gt; object
     */
    public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> listInstanceFunctionsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceFunctionsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<FunctionEnvelopeInner>>, Observable<ServiceResponse<Page<FunctionEnvelopeInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> call(ServiceResponse<Page<FunctionEnvelopeInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceFunctionsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the functions for a web site, or a deployment slot.
     * List the functions for a web site, or a deployment slot.
     *
    ServiceResponse<PageImpl<FunctionEnvelopeInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;FunctionEnvelopeInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> listInstanceFunctionsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listInstanceFunctionsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<FunctionEnvelopeInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<FunctionEnvelopeInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<FunctionEnvelopeInner>> result = listInstanceFunctionsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<FunctionEnvelopeInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<FunctionEnvelopeInner>> listInstanceFunctionsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<FunctionEnvelopeInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<FunctionEnvelopeInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> listHostNameBindingsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<HostNameBindingInner>> response = listHostNameBindingsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.body()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return listHostNameBindingsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<HostNameBindingInner>> listHostNameBindingsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<HostNameBindingInner>> serviceFuture, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listHostNameBindingsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return listHostNameBindingsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> listHostNameBindingsSlotNextAsync(final String nextPageLink) {
        return listHostNameBindingsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listHostNameBindingsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listHostNameBindingsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listHostNameBindingsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = listHostNameBindingsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> listHostNameBindingsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<HostNameBindingInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> listInstanceIdentifiersSlotNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInstanceInner>> response = listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.body()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInstanceInner>> listInstanceIdentifiersSlotNextAsync(final String nextPageLink, final ServiceFuture<List<SiteInstanceInner>> serviceFuture, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> listInstanceIdentifiersSlotNextAsync(final String nextPageLink) {
        return listInstanceIdentifiersSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceIdentifiersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listInstanceIdentifiersSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = listInstanceIdentifiersSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> listInstanceIdentifiersSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInstanceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessInfoInner&gt; object if successful.
     */
    public PagedList<ProcessInfoInner> listInstanceProcessesSlotNext(final String nextPageLink) {
        ServiceResponse<Page<ProcessInfoInner>> response = listInstanceProcessesSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProcessInfoInner>(response.body()) {
            @Override
            public Page<ProcessInfoInner> nextPage(String nextPageLink) {
                return listInstanceProcessesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessInfoInner>> listInstanceProcessesSlotNextAsync(final String nextPageLink, final ServiceFuture<List<ProcessInfoInner>> serviceFuture, final ListOperationCallback<ProcessInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceProcessesSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(String nextPageLink) {
                    return listInstanceProcessesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<Page<ProcessInfoInner>> listInstanceProcessesSlotNextAsync(final String nextPageLink) {
        return listInstanceProcessesSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Page<ProcessInfoInner>>() {
                @Override
                public Page<ProcessInfoInner> call(ServiceResponse<Page<ProcessInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listInstanceProcessesSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceProcessesSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(ServiceResponse<Page<ProcessInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceProcessesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listInstanceProcessesSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listInstanceProcessesSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessInfoInner>> result = listInstanceProcessesSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessInfoInner>> listInstanceProcessesSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object if successful.
     */
    public PagedList<ProcessModuleInfoInner> listInstanceProcessModulesSlotNext(final String nextPageLink) {
        ServiceResponse<Page<ProcessModuleInfoInner>> response = listInstanceProcessModulesSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProcessModuleInfoInner>(response.body()) {
            @Override
            public Page<ProcessModuleInfoInner> nextPage(String nextPageLink) {
                return listInstanceProcessModulesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessModuleInfoInner>> listInstanceProcessModulesSlotNextAsync(final String nextPageLink, final ServiceFuture<List<ProcessModuleInfoInner>> serviceFuture, final ListOperationCallback<ProcessModuleInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceProcessModulesSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(String nextPageLink) {
                    return listInstanceProcessModulesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<Page<ProcessModuleInfoInner>> listInstanceProcessModulesSlotNextAsync(final String nextPageLink) {
        return listInstanceProcessModulesSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Page<ProcessModuleInfoInner>>() {
                @Override
                public Page<ProcessModuleInfoInner> call(ServiceResponse<Page<ProcessModuleInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listInstanceProcessModulesSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceProcessModulesSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(ServiceResponse<Page<ProcessModuleInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceProcessModulesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listInstanceProcessModulesSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listInstanceProcessModulesSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessModuleInfoInner>> result = listInstanceProcessModulesSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessModuleInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessModuleInfoInner>> listInstanceProcessModulesSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessModuleInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessModuleInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object if successful.
     */
    public PagedList<ProcessThreadInfoInner> listInstanceProcessThreadsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<ProcessThreadInfoInner>> response = listInstanceProcessThreadsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProcessThreadInfoInner>(response.body()) {
            @Override
            public Page<ProcessThreadInfoInner> nextPage(String nextPageLink) {
                return listInstanceProcessThreadsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessThreadInfoInner>> listInstanceProcessThreadsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<ProcessThreadInfoInner>> serviceFuture, final ListOperationCallback<ProcessThreadInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceProcessThreadsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(String nextPageLink) {
                    return listInstanceProcessThreadsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<Page<ProcessThreadInfoInner>> listInstanceProcessThreadsSlotNextAsync(final String nextPageLink) {
        return listInstanceProcessThreadsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Page<ProcessThreadInfoInner>>() {
                @Override
                public Page<ProcessThreadInfoInner> call(ServiceResponse<Page<ProcessThreadInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listInstanceProcessThreadsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceProcessThreadsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(ServiceResponse<Page<ProcessThreadInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceProcessThreadsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listInstanceProcessThreadsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listInstanceProcessThreadsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessThreadInfoInner>> result = listInstanceProcessThreadsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessThreadInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessThreadInfoInner>> listInstanceProcessThreadsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessThreadInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessThreadInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object if successful.
     */
    public PagedList<ResourceMetricDefinitionInner> listMetricDefinitionsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<ResourceMetricDefinitionInner>> response = listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ResourceMetricDefinitionInner>(response.body()) {
            @Override
            public Page<ResourceMetricDefinitionInner> nextPage(String nextPageLink) {
                return listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricDefinitionInner>> listMetricDefinitionsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<ResourceMetricDefinitionInner>> serviceFuture, final ListOperationCallback<ResourceMetricDefinitionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(String nextPageLink) {
                    return listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<Page<ResourceMetricDefinitionInner>> listMetricDefinitionsSlotNextAsync(final String nextPageLink) {
        return listMetricDefinitionsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Page<ResourceMetricDefinitionInner>>() {
                @Override
                public Page<ResourceMetricDefinitionInner> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricDefinitionsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listMetricDefinitionsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> result = listMetricDefinitionsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricDefinitionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> listMetricDefinitionsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricDefinitionInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetricsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.body()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricInner>> listMetricsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<ResourceMetricInner>> serviceFuture, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsSlotNextAsync(final String nextPageLink) {
        return listMetricsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listMetricsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> listMetricsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCountersSlotNext(final String nextPageLink) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.body()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PerfMonResponseInner>> listPerfMonCountersSlotNextAsync(final String nextPageLink, final ServiceFuture<List<PerfMonResponseInner>> serviceFuture, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPerfMonCountersSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersSlotNextAsync(final String nextPageLink) {
        return listPerfMonCountersSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listPerfMonCountersSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PerfMonResponseInner>> listPerfMonCountersSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<PerfMonResponseInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<PerfMonResponseInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessInfoInner&gt; object if successful.
     */
    public PagedList<ProcessInfoInner> listProcessesSlotNext(final String nextPageLink) {
        ServiceResponse<Page<ProcessInfoInner>> response = listProcessesSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProcessInfoInner>(response.body()) {
            @Override
            public Page<ProcessInfoInner> nextPage(String nextPageLink) {
                return listProcessesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessInfoInner>> listProcessesSlotNextAsync(final String nextPageLink, final ServiceFuture<List<ProcessInfoInner>> serviceFuture, final ListOperationCallback<ProcessInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listProcessesSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(String nextPageLink) {
                    return listProcessesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<Page<ProcessInfoInner>> listProcessesSlotNextAsync(final String nextPageLink) {
        return listProcessesSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Page<ProcessInfoInner>>() {
                @Override
                public Page<ProcessInfoInner> call(ServiceResponse<Page<ProcessInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listProcessesSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listProcessesSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProcessInfoInner>>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(ServiceResponse<Page<ProcessInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listProcessesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     * Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessInfoInner>>> listProcessesSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listProcessesSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessInfoInner>> result = listProcessesSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessInfoInner>> listProcessesSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object if successful.
     */
    public PagedList<ProcessModuleInfoInner> listProcessModulesSlotNext(final String nextPageLink) {
        ServiceResponse<Page<ProcessModuleInfoInner>> response = listProcessModulesSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProcessModuleInfoInner>(response.body()) {
            @Override
            public Page<ProcessModuleInfoInner> nextPage(String nextPageLink) {
                return listProcessModulesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessModuleInfoInner>> listProcessModulesSlotNextAsync(final String nextPageLink, final ServiceFuture<List<ProcessModuleInfoInner>> serviceFuture, final ListOperationCallback<ProcessModuleInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listProcessModulesSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(String nextPageLink) {
                    return listProcessModulesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<Page<ProcessModuleInfoInner>> listProcessModulesSlotNextAsync(final String nextPageLink) {
        return listProcessModulesSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Page<ProcessModuleInfoInner>>() {
                @Override
                public Page<ProcessModuleInfoInner> call(ServiceResponse<Page<ProcessModuleInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessModuleInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listProcessModulesSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listProcessModulesSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProcessModuleInfoInner>>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(ServiceResponse<Page<ProcessModuleInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listProcessModulesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     * List module information for a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessModuleInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessModuleInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> listProcessModulesSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listProcessModulesSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessModuleInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessModuleInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessModuleInfoInner>> result = listProcessModulesSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessModuleInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessModuleInfoInner>> listProcessModulesSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessModuleInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessModuleInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object if successful.
     */
    public PagedList<ProcessThreadInfoInner> listProcessThreadsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<ProcessThreadInfoInner>> response = listProcessThreadsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProcessThreadInfoInner>(response.body()) {
            @Override
            public Page<ProcessThreadInfoInner> nextPage(String nextPageLink) {
                return listProcessThreadsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProcessThreadInfoInner>> listProcessThreadsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<ProcessThreadInfoInner>> serviceFuture, final ListOperationCallback<ProcessThreadInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listProcessThreadsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(String nextPageLink) {
                    return listProcessThreadsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<Page<ProcessThreadInfoInner>> listProcessThreadsSlotNextAsync(final String nextPageLink) {
        return listProcessThreadsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Page<ProcessThreadInfoInner>>() {
                @Override
                public Page<ProcessThreadInfoInner> call(ServiceResponse<Page<ProcessThreadInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProcessThreadInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listProcessThreadsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listProcessThreadsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProcessThreadInfoInner>>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(ServiceResponse<Page<ProcessThreadInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listProcessThreadsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     * List the threads in a process by its ID for a specific scaled-out instance in a web site.
     *
    ServiceResponse<PageImpl<ProcessThreadInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProcessThreadInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> listProcessThreadsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listProcessThreadsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProcessThreadInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProcessThreadInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProcessThreadInfoInner>> result = listProcessThreadsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProcessThreadInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProcessThreadInfoInner>> listProcessThreadsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProcessThreadInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProcessThreadInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PublicCertificateInner&gt; object if successful.
     */
    public PagedList<PublicCertificateInner> listPublicCertificatesSlotNext(final String nextPageLink) {
        ServiceResponse<Page<PublicCertificateInner>> response = listPublicCertificatesSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<PublicCertificateInner>(response.body()) {
            @Override
            public Page<PublicCertificateInner> nextPage(String nextPageLink) {
                return listPublicCertificatesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PublicCertificateInner>> listPublicCertificatesSlotNextAsync(final String nextPageLink, final ServiceFuture<List<PublicCertificateInner>> serviceFuture, final ListOperationCallback<PublicCertificateInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPublicCertificatesSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<PublicCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PublicCertificateInner>>> call(String nextPageLink) {
                    return listPublicCertificatesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PublicCertificateInner&gt; object
     */
    public Observable<Page<PublicCertificateInner>> listPublicCertificatesSlotNextAsync(final String nextPageLink) {
        return listPublicCertificatesSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<PublicCertificateInner>>, Page<PublicCertificateInner>>() {
                @Override
                public Page<PublicCertificateInner> call(ServiceResponse<Page<PublicCertificateInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PublicCertificateInner&gt; object
     */
    public Observable<ServiceResponse<Page<PublicCertificateInner>>> listPublicCertificatesSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listPublicCertificatesSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<PublicCertificateInner>>, Observable<ServiceResponse<Page<PublicCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PublicCertificateInner>>> call(ServiceResponse<Page<PublicCertificateInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPublicCertificatesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get public certificates for an app or a deployment slot.
     * Get public certificates for an app or a deployment slot.
     *
    ServiceResponse<PageImpl<PublicCertificateInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PublicCertificateInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PublicCertificateInner>>> listPublicCertificatesSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listPublicCertificatesSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PublicCertificateInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PublicCertificateInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PublicCertificateInner>> result = listPublicCertificatesSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PublicCertificateInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PublicCertificateInner>> listPublicCertificatesSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<PublicCertificateInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<PublicCertificateInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteExtensionInfoInner&gt; object if successful.
     */
    public PagedList<SiteExtensionInfoInner> listSiteExtensionsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<SiteExtensionInfoInner>> response = listSiteExtensionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteExtensionInfoInner>(response.body()) {
            @Override
            public Page<SiteExtensionInfoInner> nextPage(String nextPageLink) {
                return listSiteExtensionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteExtensionInfoInner>> listSiteExtensionsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<SiteExtensionInfoInner>> serviceFuture, final ListOperationCallback<SiteExtensionInfoInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSiteExtensionsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteExtensionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> call(String nextPageLink) {
                    return listSiteExtensionsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteExtensionInfoInner&gt; object
     */
    public Observable<Page<SiteExtensionInfoInner>> listSiteExtensionsSlotNextAsync(final String nextPageLink) {
        return listSiteExtensionsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteExtensionInfoInner>>, Page<SiteExtensionInfoInner>>() {
                @Override
                public Page<SiteExtensionInfoInner> call(ServiceResponse<Page<SiteExtensionInfoInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteExtensionInfoInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> listSiteExtensionsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listSiteExtensionsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteExtensionInfoInner>>, Observable<ServiceResponse<Page<SiteExtensionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> call(ServiceResponse<Page<SiteExtensionInfoInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSiteExtensionsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get list of site extensions for a web site, or a deployment slot.
     * Get list of site extensions for a web site, or a deployment slot.
     *
    ServiceResponse<PageImpl<SiteExtensionInfoInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteExtensionInfoInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> listSiteExtensionsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSiteExtensionsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteExtensionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteExtensionInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteExtensionInfoInner>> result = listSiteExtensionsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteExtensionInfoInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteExtensionInfoInner>> listSiteExtensionsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteExtensionInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteExtensionInfoInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> listSlotDifferencesSlotNext(final String nextPageLink) {
        ServiceResponse<Page<SlotDifferenceInner>> response = listSlotDifferencesSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.body()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return listSlotDifferencesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SlotDifferenceInner>> listSlotDifferencesSlotNextAsync(final String nextPageLink, final ServiceFuture<List<SlotDifferenceInner>> serviceFuture, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSlotDifferencesSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return listSlotDifferencesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> listSlotDifferencesSlotNextAsync(final String nextPageLink) {
        return listSlotDifferencesSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listSlotDifferencesSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSlotDifferencesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSlotDifferencesSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = listSlotDifferencesSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> listSlotDifferencesSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SlotDifferenceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SnapshotInner&gt; object if successful.
     */
    public PagedList<SnapshotInner> listSnapshotsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<SnapshotInner>> response = listSnapshotsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SnapshotInner>(response.body()) {
            @Override
            public Page<SnapshotInner> nextPage(String nextPageLink) {
                return listSnapshotsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SnapshotInner>> listSnapshotsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<SnapshotInner>> serviceFuture, final ListOperationCallback<SnapshotInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSnapshotsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(String nextPageLink) {
                    return listSnapshotsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<Page<SnapshotInner>> listSnapshotsSlotNextAsync(final String nextPageLink) {
        return listSnapshotsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SnapshotInner>>, Page<SnapshotInner>>() {
                @Override
                public Page<SnapshotInner> call(ServiceResponse<Page<SnapshotInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listSnapshotsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SnapshotInner>>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(ServiceResponse<Page<SnapshotInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSnapshotsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
    ServiceResponse<PageImpl<SnapshotInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SnapshotInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSnapshotsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SnapshotInner>> result = listSnapshotsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SnapshotInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SnapshotInner>> listSnapshotsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SnapshotInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SnapshotInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;TriggeredWebJobInner&gt; object if successful.
     */
    public PagedList<TriggeredWebJobInner> listTriggeredWebJobsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<TriggeredWebJobInner>> response = listTriggeredWebJobsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<TriggeredWebJobInner>(response.body()) {
            @Override
            public Page<TriggeredWebJobInner> nextPage(String nextPageLink) {
                return listTriggeredWebJobsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<TriggeredWebJobInner>> listTriggeredWebJobsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<TriggeredWebJobInner>> serviceFuture, final ListOperationCallback<TriggeredWebJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listTriggeredWebJobsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<TriggeredWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> call(String nextPageLink) {
                    return listTriggeredWebJobsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredWebJobInner&gt; object
     */
    public Observable<Page<TriggeredWebJobInner>> listTriggeredWebJobsSlotNextAsync(final String nextPageLink) {
        return listTriggeredWebJobsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<TriggeredWebJobInner>>, Page<TriggeredWebJobInner>>() {
                @Override
                public Page<TriggeredWebJobInner> call(ServiceResponse<Page<TriggeredWebJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredWebJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> listTriggeredWebJobsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listTriggeredWebJobsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<TriggeredWebJobInner>>, Observable<ServiceResponse<Page<TriggeredWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> call(ServiceResponse<Page<TriggeredWebJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listTriggeredWebJobsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<TriggeredWebJobInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;TriggeredWebJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> listTriggeredWebJobsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listTriggeredWebJobsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<TriggeredWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<TriggeredWebJobInner>> result = listTriggeredWebJobsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<TriggeredWebJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<TriggeredWebJobInner>> listTriggeredWebJobsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<TriggeredWebJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<TriggeredWebJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;TriggeredJobHistoryInner&gt; object if successful.
     */
    public PagedList<TriggeredJobHistoryInner> listTriggeredWebJobHistorySlotNext(final String nextPageLink) {
        ServiceResponse<Page<TriggeredJobHistoryInner>> response = listTriggeredWebJobHistorySlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<TriggeredJobHistoryInner>(response.body()) {
            @Override
            public Page<TriggeredJobHistoryInner> nextPage(String nextPageLink) {
                return listTriggeredWebJobHistorySlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<TriggeredJobHistoryInner>> listTriggeredWebJobHistorySlotNextAsync(final String nextPageLink, final ServiceFuture<List<TriggeredJobHistoryInner>> serviceFuture, final ListOperationCallback<TriggeredJobHistoryInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listTriggeredWebJobHistorySlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> call(String nextPageLink) {
                    return listTriggeredWebJobHistorySlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredJobHistoryInner&gt; object
     */
    public Observable<Page<TriggeredJobHistoryInner>> listTriggeredWebJobHistorySlotNextAsync(final String nextPageLink) {
        return listTriggeredWebJobHistorySlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<TriggeredJobHistoryInner>>, Page<TriggeredJobHistoryInner>>() {
                @Override
                public Page<TriggeredJobHistoryInner> call(ServiceResponse<Page<TriggeredJobHistoryInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredJobHistoryInner&gt; object
     */
    public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> listTriggeredWebJobHistorySlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listTriggeredWebJobHistorySlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<TriggeredJobHistoryInner>>, Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> call(ServiceResponse<Page<TriggeredJobHistoryInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listTriggeredWebJobHistorySlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<TriggeredJobHistoryInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;TriggeredJobHistoryInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> listTriggeredWebJobHistorySlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listTriggeredWebJobHistorySlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<TriggeredJobHistoryInner>> result = listTriggeredWebJobHistorySlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<TriggeredJobHistoryInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<TriggeredJobHistoryInner>> listTriggeredWebJobHistorySlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<TriggeredJobHistoryInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<TriggeredJobHistoryInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsagesSlotNext(final String nextPageLink) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.body()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CsmUsageQuotaInner>> listUsagesSlotNextAsync(final String nextPageLink, final ServiceFuture<List<CsmUsageQuotaInner>> serviceFuture, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listUsagesSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesSlotNextAsync(final String nextPageLink) {
        return listUsagesSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listUsagesSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listUsagesSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> listUsagesSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<CsmUsageQuotaInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;WebJobInner&gt; object if successful.
     */
    public PagedList<WebJobInner> listWebJobsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<WebJobInner>> response = listWebJobsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<WebJobInner>(response.body()) {
            @Override
            public Page<WebJobInner> nextPage(String nextPageLink) {
                return listWebJobsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<WebJobInner>> listWebJobsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<WebJobInner>> serviceFuture, final ListOperationCallback<WebJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listWebJobsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<WebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebJobInner>>> call(String nextPageLink) {
                    return listWebJobsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebJobInner&gt; object
     */
    public Observable<Page<WebJobInner>> listWebJobsSlotNextAsync(final String nextPageLink) {
        return listWebJobsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<WebJobInner>>, Page<WebJobInner>>() {
                @Override
                public Page<WebJobInner> call(ServiceResponse<Page<WebJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<WebJobInner>>> listWebJobsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listWebJobsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<WebJobInner>>, Observable<ServiceResponse<Page<WebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebJobInner>>> call(ServiceResponse<Page<WebJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listWebJobsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<WebJobInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;WebJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<WebJobInner>>> listWebJobsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listWebJobsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<WebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<WebJobInner>> result = listWebJobsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<WebJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<WebJobInner>> listWebJobsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<WebJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<WebJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> listSlotDifferencesFromProductionNext(final String nextPageLink) {
        ServiceResponse<Page<SlotDifferenceInner>> response = listSlotDifferencesFromProductionNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.body()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return listSlotDifferencesFromProductionNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SlotDifferenceInner>> listSlotDifferencesFromProductionNextAsync(final String nextPageLink, final ServiceFuture<List<SlotDifferenceInner>> serviceFuture, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSlotDifferencesFromProductionNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return listSlotDifferencesFromProductionNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> listSlotDifferencesFromProductionNextAsync(final String nextPageLink) {
        return listSlotDifferencesFromProductionNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesFromProductionNextWithServiceResponseAsync(final String nextPageLink) {
        return listSlotDifferencesFromProductionNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSlotDifferencesFromProductionNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesFromProductionNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSlotDifferencesFromProductionNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = listSlotDifferencesFromProductionNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> listSlotDifferencesFromProductionNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SlotDifferenceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SnapshotInner&gt; object if successful.
     */
    public PagedList<SnapshotInner> listSnapshotsNext(final String nextPageLink) {
        ServiceResponse<Page<SnapshotInner>> response = listSnapshotsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SnapshotInner>(response.body()) {
            @Override
            public Page<SnapshotInner> nextPage(String nextPageLink) {
                return listSnapshotsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SnapshotInner>> listSnapshotsNextAsync(final String nextPageLink, final ServiceFuture<List<SnapshotInner>> serviceFuture, final ListOperationCallback<SnapshotInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSnapshotsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(String nextPageLink) {
                    return listSnapshotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<Page<SnapshotInner>> listSnapshotsNextAsync(final String nextPageLink) {
        return listSnapshotsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SnapshotInner>>, Page<SnapshotInner>>() {
                @Override
                public Page<SnapshotInner> call(ServiceResponse<Page<SnapshotInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsNextWithServiceResponseAsync(final String nextPageLink) {
        return listSnapshotsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SnapshotInner>>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(ServiceResponse<Page<SnapshotInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSnapshotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
    ServiceResponse<PageImpl<SnapshotInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SnapshotInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSnapshotsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SnapshotInner>> result = listSnapshotsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SnapshotInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SnapshotInner>> listSnapshotsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SnapshotInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SnapshotInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;TriggeredWebJobInner&gt; object if successful.
     */
    public PagedList<TriggeredWebJobInner> listTriggeredWebJobsNext(final String nextPageLink) {
        ServiceResponse<Page<TriggeredWebJobInner>> response = listTriggeredWebJobsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<TriggeredWebJobInner>(response.body()) {
            @Override
            public Page<TriggeredWebJobInner> nextPage(String nextPageLink) {
                return listTriggeredWebJobsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<TriggeredWebJobInner>> listTriggeredWebJobsNextAsync(final String nextPageLink, final ServiceFuture<List<TriggeredWebJobInner>> serviceFuture, final ListOperationCallback<TriggeredWebJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listTriggeredWebJobsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<TriggeredWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> call(String nextPageLink) {
                    return listTriggeredWebJobsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredWebJobInner&gt; object
     */
    public Observable<Page<TriggeredWebJobInner>> listTriggeredWebJobsNextAsync(final String nextPageLink) {
        return listTriggeredWebJobsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<TriggeredWebJobInner>>, Page<TriggeredWebJobInner>>() {
                @Override
                public Page<TriggeredWebJobInner> call(ServiceResponse<Page<TriggeredWebJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredWebJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> listTriggeredWebJobsNextWithServiceResponseAsync(final String nextPageLink) {
        return listTriggeredWebJobsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<TriggeredWebJobInner>>, Observable<ServiceResponse<Page<TriggeredWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> call(ServiceResponse<Page<TriggeredWebJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listTriggeredWebJobsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List triggered web jobs for an app, or a deployment slot.
     * List triggered web jobs for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<TriggeredWebJobInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;TriggeredWebJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> listTriggeredWebJobsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listTriggeredWebJobsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<TriggeredWebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredWebJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<TriggeredWebJobInner>> result = listTriggeredWebJobsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<TriggeredWebJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<TriggeredWebJobInner>> listTriggeredWebJobsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<TriggeredWebJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<TriggeredWebJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;TriggeredJobHistoryInner&gt; object if successful.
     */
    public PagedList<TriggeredJobHistoryInner> listTriggeredWebJobHistoryNext(final String nextPageLink) {
        ServiceResponse<Page<TriggeredJobHistoryInner>> response = listTriggeredWebJobHistoryNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<TriggeredJobHistoryInner>(response.body()) {
            @Override
            public Page<TriggeredJobHistoryInner> nextPage(String nextPageLink) {
                return listTriggeredWebJobHistoryNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<TriggeredJobHistoryInner>> listTriggeredWebJobHistoryNextAsync(final String nextPageLink, final ServiceFuture<List<TriggeredJobHistoryInner>> serviceFuture, final ListOperationCallback<TriggeredJobHistoryInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listTriggeredWebJobHistoryNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> call(String nextPageLink) {
                    return listTriggeredWebJobHistoryNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredJobHistoryInner&gt; object
     */
    public Observable<Page<TriggeredJobHistoryInner>> listTriggeredWebJobHistoryNextAsync(final String nextPageLink) {
        return listTriggeredWebJobHistoryNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<TriggeredJobHistoryInner>>, Page<TriggeredJobHistoryInner>>() {
                @Override
                public Page<TriggeredJobHistoryInner> call(ServiceResponse<Page<TriggeredJobHistoryInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;TriggeredJobHistoryInner&gt; object
     */
    public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> listTriggeredWebJobHistoryNextWithServiceResponseAsync(final String nextPageLink) {
        return listTriggeredWebJobHistoryNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<TriggeredJobHistoryInner>>, Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> call(ServiceResponse<Page<TriggeredJobHistoryInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listTriggeredWebJobHistoryNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List a triggered web job's history for an app, or a deployment slot.
     * List a triggered web job's history for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<TriggeredJobHistoryInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;TriggeredJobHistoryInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> listTriggeredWebJobHistoryNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listTriggeredWebJobHistoryNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<TriggeredJobHistoryInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<TriggeredJobHistoryInner>> result = listTriggeredWebJobHistoryNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<TriggeredJobHistoryInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<TriggeredJobHistoryInner>> listTriggeredWebJobHistoryNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<TriggeredJobHistoryInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<TriggeredJobHistoryInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsagesNext(final String nextPageLink) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.body()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CsmUsageQuotaInner>> listUsagesNextAsync(final String nextPageLink, final ServiceFuture<List<CsmUsageQuotaInner>> serviceFuture, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listUsagesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesNextAsync(final String nextPageLink) {
        return listUsagesNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesNextWithServiceResponseAsync(final String nextPageLink) {
        return listUsagesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listUsagesNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> listUsagesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<CsmUsageQuotaInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;WebJobInner&gt; object if successful.
     */
    public PagedList<WebJobInner> listWebJobsNext(final String nextPageLink) {
        ServiceResponse<Page<WebJobInner>> response = listWebJobsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<WebJobInner>(response.body()) {
            @Override
            public Page<WebJobInner> nextPage(String nextPageLink) {
                return listWebJobsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<WebJobInner>> listWebJobsNextAsync(final String nextPageLink, final ServiceFuture<List<WebJobInner>> serviceFuture, final ListOperationCallback<WebJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listWebJobsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<WebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebJobInner>>> call(String nextPageLink) {
                    return listWebJobsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebJobInner&gt; object
     */
    public Observable<Page<WebJobInner>> listWebJobsNextAsync(final String nextPageLink) {
        return listWebJobsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<WebJobInner>>, Page<WebJobInner>>() {
                @Override
                public Page<WebJobInner> call(ServiceResponse<Page<WebJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<WebJobInner>>> listWebJobsNextWithServiceResponseAsync(final String nextPageLink) {
        return listWebJobsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<WebJobInner>>, Observable<ServiceResponse<Page<WebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebJobInner>>> call(ServiceResponse<Page<WebJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listWebJobsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List webjobs for an app, or a deployment slot.
     * List webjobs for an app, or a deployment slot.
     *
    ServiceResponse<PageImpl<WebJobInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;WebJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<WebJobInner>>> listWebJobsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listWebJobsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<WebJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<WebJobInner>> result = listWebJobsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<WebJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<WebJobInner>> listWebJobsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<WebJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<WebJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
