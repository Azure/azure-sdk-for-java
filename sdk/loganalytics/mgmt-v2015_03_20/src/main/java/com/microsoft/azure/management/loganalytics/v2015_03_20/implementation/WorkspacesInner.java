/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.loganalytics.v2015_03_20.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.management.loganalytics.v2015_03_20.SearchParameters;
import com.microsoft.azure.management.loganalytics.v2015_03_20.WorkspacePurgeBody;
import com.microsoft.azure.management.loganalytics.v2015_03_20.WorkspacesPurgeHeaders;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Workspaces.
 */
public class WorkspacesInner {
    /** The Retrofit service to perform REST calls. */
    private WorkspacesService service;
    /** The service client containing this operation class. */
    private OperationalInsightsManagementClientImpl client;

    /**
     * Initializes an instance of WorkspacesInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public WorkspacesInner(Retrofit retrofit, OperationalInsightsManagementClientImpl client) {
        this.service = retrofit.create(WorkspacesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Workspaces to be
     * used by Retrofit to perform actually REST calls.
     */
    interface WorkspacesService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.loganalytics.v2015_03_20.Workspaces list" })
        @GET("subscriptions/{subscriptionId}/providers/Microsoft.OperationalInsights/linkTargets")
        Observable<Response<ResponseBody>> list(@Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.loganalytics.v2015_03_20.Workspaces getSchema" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/schema")
        Observable<Response<ResponseBody>> getSchema(@Path("resourceGroupName") String resourceGroupName, @Path("workspaceName") String workspaceName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.loganalytics.v2015_03_20.Workspaces getSearchResults" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/search")
        Observable<Response<ResponseBody>> getSearchResults(@Path("resourceGroupName") String resourceGroupName, @Path("workspaceName") String workspaceName, @Path("subscriptionId") String subscriptionId, @Body SearchParameters parameters, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.loganalytics.v2015_03_20.Workspaces beginGetSearchResults" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/search")
        Observable<Response<ResponseBody>> beginGetSearchResults(@Path("resourceGroupName") String resourceGroupName, @Path("workspaceName") String workspaceName, @Path("subscriptionId") String subscriptionId, @Body SearchParameters parameters, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.loganalytics.v2015_03_20.Workspaces updateSearchResults" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/search/{id}")
        Observable<Response<ResponseBody>> updateSearchResults(@Path("resourceGroupName") String resourceGroupName, @Path("workspaceName") String workspaceName, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.loganalytics.v2015_03_20.Workspaces purge" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/purge")
        Observable<Response<ResponseBody>> purge(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("workspaceName") String workspaceName, @Query("api-version") String apiVersion, @Body WorkspacePurgeBody body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.loganalytics.v2015_03_20.Workspaces getPurgeStatus" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/operations/{purgeId}")
        Observable<Response<ResponseBody>> getPurgeStatus(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("workspaceName") String workspaceName, @Path("purgeId") String purgeId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.loganalytics.v2015_03_20.Workspaces listKeys" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/listKeys")
        Observable<Response<ResponseBody>> listKeys(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("workspaceName") String workspaceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.loganalytics.v2015_03_20.Workspaces regenerateSharedKeys" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/regenerateSharedKey")
        Observable<Response<ResponseBody>> regenerateSharedKeys(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("workspaceName") String workspaceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.loganalytics.v2015_03_20.Workspaces deleteGateways" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/gateways/{gatewayId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteGateways(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("workspaceName") String workspaceName, @Path("gatewayId") String gatewayId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Get a list of workspaces which the current user has administrator privileges and are not associated with an Azure Subscription. The subscriptionId parameter in the Url is ignored.
     *
     * @return the PagedList<LinkTargetInner> object if successful.
     */
    public PagedList<LinkTargetInner> list() {
        PageImpl1<LinkTargetInner> page = new PageImpl1<>();
        page.setItems(listWithServiceResponseAsync().toBlocking().single().body());
        page.setNextPageLink(null);
        return new PagedList<LinkTargetInner>(page) {
            @Override
            public Page<LinkTargetInner> nextPage(String nextPageLink) {
                return null;
            }
        };
    }

    /**
     * Get a list of workspaces which the current user has administrator privileges and are not associated with an Azure Subscription. The subscriptionId parameter in the Url is ignored.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<LinkTargetInner>> listAsync(final ServiceCallback<List<LinkTargetInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get a list of workspaces which the current user has administrator privileges and are not associated with an Azure Subscription. The subscriptionId parameter in the Url is ignored.
     *
     * @return the observable to the List&lt;LinkTargetInner&gt; object
     */
    public Observable<Page<LinkTargetInner>> listAsync() {
        return listWithServiceResponseAsync().map(new Func1<ServiceResponse<List<LinkTargetInner>>, Page<LinkTargetInner>>() {
            @Override
            public Page<LinkTargetInner> call(ServiceResponse<List<LinkTargetInner>> response) {
                PageImpl1<LinkTargetInner> page = new PageImpl1<>();
                page.setItems(response.body());
                return page;
            }
        });
    }

    /**
     * Get a list of workspaces which the current user has administrator privileges and are not associated with an Azure Subscription. The subscriptionId parameter in the Url is ignored.
     *
     * @return the observable to the List&lt;LinkTargetInner&gt; object
     */
    public Observable<ServiceResponse<List<LinkTargetInner>>> listWithServiceResponseAsync() {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.list(this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<LinkTargetInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<LinkTargetInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<LinkTargetInner>> result = listDelegate(response);
                        List<LinkTargetInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<LinkTargetInner>> clientResponse = new ServiceResponse<List<LinkTargetInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl1<LinkTargetInner>> listDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl1<LinkTargetInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl1<LinkTargetInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the schema for a given workspace.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SearchGetSchemaResponseInner object if successful.
     */
    public SearchGetSchemaResponseInner getSchema(String resourceGroupName, String workspaceName) {
        return getSchemaWithServiceResponseAsync(resourceGroupName, workspaceName).toBlocking().single().body();
    }

    /**
     * Gets the schema for a given workspace.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SearchGetSchemaResponseInner> getSchemaAsync(String resourceGroupName, String workspaceName, final ServiceCallback<SearchGetSchemaResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSchemaWithServiceResponseAsync(resourceGroupName, workspaceName), serviceCallback);
    }

    /**
     * Gets the schema for a given workspace.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SearchGetSchemaResponseInner object
     */
    public Observable<SearchGetSchemaResponseInner> getSchemaAsync(String resourceGroupName, String workspaceName) {
        return getSchemaWithServiceResponseAsync(resourceGroupName, workspaceName).map(new Func1<ServiceResponse<SearchGetSchemaResponseInner>, SearchGetSchemaResponseInner>() {
            @Override
            public SearchGetSchemaResponseInner call(ServiceResponse<SearchGetSchemaResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the schema for a given workspace.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SearchGetSchemaResponseInner object
     */
    public Observable<ServiceResponse<SearchGetSchemaResponseInner>> getSchemaWithServiceResponseAsync(String resourceGroupName, String workspaceName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getSchema(resourceGroupName, workspaceName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SearchGetSchemaResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<SearchGetSchemaResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SearchGetSchemaResponseInner> clientResponse = getSchemaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SearchGetSchemaResponseInner> getSchemaDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SearchGetSchemaResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SearchGetSchemaResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Submit a search for a given workspace. The response will contain an id to track the search. User can use the id to poll the search status and get the full search result later if the search takes long time to finish.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param parameters The parameters required to execute a search query.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SearchResultsResponseInner object if successful.
     */
    public SearchResultsResponseInner getSearchResults(String resourceGroupName, String workspaceName, SearchParameters parameters) {
        return getSearchResultsWithServiceResponseAsync(resourceGroupName, workspaceName, parameters).toBlocking().last().body();
    }

    /**
     * Submit a search for a given workspace. The response will contain an id to track the search. User can use the id to poll the search status and get the full search result later if the search takes long time to finish.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param parameters The parameters required to execute a search query.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SearchResultsResponseInner> getSearchResultsAsync(String resourceGroupName, String workspaceName, SearchParameters parameters, final ServiceCallback<SearchResultsResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSearchResultsWithServiceResponseAsync(resourceGroupName, workspaceName, parameters), serviceCallback);
    }

    /**
     * Submit a search for a given workspace. The response will contain an id to track the search. User can use the id to poll the search status and get the full search result later if the search takes long time to finish.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param parameters The parameters required to execute a search query.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SearchResultsResponseInner> getSearchResultsAsync(String resourceGroupName, String workspaceName, SearchParameters parameters) {
        return getSearchResultsWithServiceResponseAsync(resourceGroupName, workspaceName, parameters).map(new Func1<ServiceResponse<SearchResultsResponseInner>, SearchResultsResponseInner>() {
            @Override
            public SearchResultsResponseInner call(ServiceResponse<SearchResultsResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Submit a search for a given workspace. The response will contain an id to track the search. User can use the id to poll the search status and get the full search result later if the search takes long time to finish.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param parameters The parameters required to execute a search query.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SearchResultsResponseInner>> getSearchResultsWithServiceResponseAsync(String resourceGroupName, String workspaceName, SearchParameters parameters) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(parameters);
        Observable<Response<ResponseBody>> observable = service.getSearchResults(resourceGroupName, workspaceName, this.client.subscriptionId(), parameters, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<SearchResultsResponseInner>() { }.getType());
    }

    /**
     * Submit a search for a given workspace. The response will contain an id to track the search. User can use the id to poll the search status and get the full search result later if the search takes long time to finish.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param parameters The parameters required to execute a search query.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SearchResultsResponseInner object if successful.
     */
    public SearchResultsResponseInner beginGetSearchResults(String resourceGroupName, String workspaceName, SearchParameters parameters) {
        return beginGetSearchResultsWithServiceResponseAsync(resourceGroupName, workspaceName, parameters).toBlocking().single().body();
    }

    /**
     * Submit a search for a given workspace. The response will contain an id to track the search. User can use the id to poll the search status and get the full search result later if the search takes long time to finish.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param parameters The parameters required to execute a search query.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SearchResultsResponseInner> beginGetSearchResultsAsync(String resourceGroupName, String workspaceName, SearchParameters parameters, final ServiceCallback<SearchResultsResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginGetSearchResultsWithServiceResponseAsync(resourceGroupName, workspaceName, parameters), serviceCallback);
    }

    /**
     * Submit a search for a given workspace. The response will contain an id to track the search. User can use the id to poll the search status and get the full search result later if the search takes long time to finish.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param parameters The parameters required to execute a search query.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SearchResultsResponseInner object
     */
    public Observable<SearchResultsResponseInner> beginGetSearchResultsAsync(String resourceGroupName, String workspaceName, SearchParameters parameters) {
        return beginGetSearchResultsWithServiceResponseAsync(resourceGroupName, workspaceName, parameters).map(new Func1<ServiceResponse<SearchResultsResponseInner>, SearchResultsResponseInner>() {
            @Override
            public SearchResultsResponseInner call(ServiceResponse<SearchResultsResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Submit a search for a given workspace. The response will contain an id to track the search. User can use the id to poll the search status and get the full search result later if the search takes long time to finish.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param parameters The parameters required to execute a search query.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SearchResultsResponseInner object
     */
    public Observable<ServiceResponse<SearchResultsResponseInner>> beginGetSearchResultsWithServiceResponseAsync(String resourceGroupName, String workspaceName, SearchParameters parameters) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(parameters);
        return service.beginGetSearchResults(resourceGroupName, workspaceName, this.client.subscriptionId(), parameters, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SearchResultsResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<SearchResultsResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SearchResultsResponseInner> clientResponse = beginGetSearchResultsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SearchResultsResponseInner> beginGetSearchResultsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SearchResultsResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SearchResultsResponseInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets updated search results for a given search query.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param id The id of the search that will have results updated. You can get the id from the response of the GetResults call.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SearchResultsResponseInner object if successful.
     */
    public SearchResultsResponseInner updateSearchResults(String resourceGroupName, String workspaceName, String id) {
        return updateSearchResultsWithServiceResponseAsync(resourceGroupName, workspaceName, id).toBlocking().single().body();
    }

    /**
     * Gets updated search results for a given search query.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param id The id of the search that will have results updated. You can get the id from the response of the GetResults call.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SearchResultsResponseInner> updateSearchResultsAsync(String resourceGroupName, String workspaceName, String id, final ServiceCallback<SearchResultsResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateSearchResultsWithServiceResponseAsync(resourceGroupName, workspaceName, id), serviceCallback);
    }

    /**
     * Gets updated search results for a given search query.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param id The id of the search that will have results updated. You can get the id from the response of the GetResults call.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SearchResultsResponseInner object
     */
    public Observable<SearchResultsResponseInner> updateSearchResultsAsync(String resourceGroupName, String workspaceName, String id) {
        return updateSearchResultsWithServiceResponseAsync(resourceGroupName, workspaceName, id).map(new Func1<ServiceResponse<SearchResultsResponseInner>, SearchResultsResponseInner>() {
            @Override
            public SearchResultsResponseInner call(ServiceResponse<SearchResultsResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets updated search results for a given search query.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param id The id of the search that will have results updated. You can get the id from the response of the GetResults call.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SearchResultsResponseInner object
     */
    public Observable<ServiceResponse<SearchResultsResponseInner>> updateSearchResultsWithServiceResponseAsync(String resourceGroupName, String workspaceName, String id) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.updateSearchResults(resourceGroupName, workspaceName, id, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SearchResultsResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<SearchResultsResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SearchResultsResponseInner> clientResponse = updateSearchResultsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SearchResultsResponseInner> updateSearchResultsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SearchResultsResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SearchResultsResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Purges data in an Log Analytics workspace by a set of user-defined filters.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param body Describes the body of a request to purge data in a single table of an Log Analytics Workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WorkspacePurgeResponseInner object if successful.
     */
    public WorkspacePurgeResponseInner purge(String resourceGroupName, String workspaceName, WorkspacePurgeBody body) {
        return purgeWithServiceResponseAsync(resourceGroupName, workspaceName, body).toBlocking().single().body();
    }

    /**
     * Purges data in an Log Analytics workspace by a set of user-defined filters.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param body Describes the body of a request to purge data in a single table of an Log Analytics Workspace
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WorkspacePurgeResponseInner> purgeAsync(String resourceGroupName, String workspaceName, WorkspacePurgeBody body, final ServiceCallback<WorkspacePurgeResponseInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(purgeWithServiceResponseAsync(resourceGroupName, workspaceName, body), serviceCallback);
    }

    /**
     * Purges data in an Log Analytics workspace by a set of user-defined filters.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param body Describes the body of a request to purge data in a single table of an Log Analytics Workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WorkspacePurgeResponseInner object
     */
    public Observable<WorkspacePurgeResponseInner> purgeAsync(String resourceGroupName, String workspaceName, WorkspacePurgeBody body) {
        return purgeWithServiceResponseAsync(resourceGroupName, workspaceName, body).map(new Func1<ServiceResponseWithHeaders<WorkspacePurgeResponseInner, WorkspacesPurgeHeaders>, WorkspacePurgeResponseInner>() {
            @Override
            public WorkspacePurgeResponseInner call(ServiceResponseWithHeaders<WorkspacePurgeResponseInner, WorkspacesPurgeHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Purges data in an Log Analytics workspace by a set of user-defined filters.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param body Describes the body of a request to purge data in a single table of an Log Analytics Workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WorkspacePurgeResponseInner object
     */
    public Observable<ServiceResponseWithHeaders<WorkspacePurgeResponseInner, WorkspacesPurgeHeaders>> purgeWithServiceResponseAsync(String resourceGroupName, String workspaceName, WorkspacePurgeBody body) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.purge(resourceGroupName, this.client.subscriptionId(), workspaceName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<WorkspacePurgeResponseInner, WorkspacesPurgeHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<WorkspacePurgeResponseInner, WorkspacesPurgeHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<WorkspacePurgeResponseInner, WorkspacesPurgeHeaders> clientResponse = purgeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<WorkspacePurgeResponseInner, WorkspacesPurgeHeaders> purgeDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<WorkspacePurgeResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(202, new TypeToken<WorkspacePurgeResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, WorkspacesPurgeHeaders.class);
    }

    /**
     * Gets status of an ongoing purge operation.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WorkspacePurgeStatusResponseInner object if successful.
     */
    public WorkspacePurgeStatusResponseInner getPurgeStatus(String resourceGroupName, String workspaceName) {
        return getPurgeStatusWithServiceResponseAsync(resourceGroupName, workspaceName).toBlocking().single().body();
    }

    /**
     * Gets status of an ongoing purge operation.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WorkspacePurgeStatusResponseInner> getPurgeStatusAsync(String resourceGroupName, String workspaceName, final ServiceCallback<WorkspacePurgeStatusResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPurgeStatusWithServiceResponseAsync(resourceGroupName, workspaceName), serviceCallback);
    }

    /**
     * Gets status of an ongoing purge operation.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WorkspacePurgeStatusResponseInner object
     */
    public Observable<WorkspacePurgeStatusResponseInner> getPurgeStatusAsync(String resourceGroupName, String workspaceName) {
        return getPurgeStatusWithServiceResponseAsync(resourceGroupName, workspaceName).map(new Func1<ServiceResponse<WorkspacePurgeStatusResponseInner>, WorkspacePurgeStatusResponseInner>() {
            @Override
            public WorkspacePurgeStatusResponseInner call(ServiceResponse<WorkspacePurgeStatusResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets status of an ongoing purge operation.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WorkspacePurgeStatusResponseInner object
     */
    public Observable<ServiceResponse<WorkspacePurgeStatusResponseInner>> getPurgeStatusWithServiceResponseAsync(String resourceGroupName, String workspaceName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (this.client.purgeId() == null) {
            throw new IllegalArgumentException("Parameter this.client.purgeId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getPurgeStatus(resourceGroupName, this.client.subscriptionId(), workspaceName, this.client.purgeId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WorkspacePurgeStatusResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<WorkspacePurgeStatusResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WorkspacePurgeStatusResponseInner> clientResponse = getPurgeStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<WorkspacePurgeStatusResponseInner> getPurgeStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<WorkspacePurgeStatusResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<WorkspacePurgeStatusResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the shared keys for a Log Analytics Workspace. These keys are used to connect Microsoft Operational Insights agents to the workspace.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SharedKeysInner object if successful.
     */
    public SharedKeysInner listKeys(String resourceGroupName, String workspaceName) {
        return listKeysWithServiceResponseAsync(resourceGroupName, workspaceName).toBlocking().single().body();
    }

    /**
     * Gets the shared keys for a Log Analytics Workspace. These keys are used to connect Microsoft Operational Insights agents to the workspace.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SharedKeysInner> listKeysAsync(String resourceGroupName, String workspaceName, final ServiceCallback<SharedKeysInner> serviceCallback) {
        return ServiceFuture.fromResponse(listKeysWithServiceResponseAsync(resourceGroupName, workspaceName), serviceCallback);
    }

    /**
     * Gets the shared keys for a Log Analytics Workspace. These keys are used to connect Microsoft Operational Insights agents to the workspace.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SharedKeysInner object
     */
    public Observable<SharedKeysInner> listKeysAsync(String resourceGroupName, String workspaceName) {
        return listKeysWithServiceResponseAsync(resourceGroupName, workspaceName).map(new Func1<ServiceResponse<SharedKeysInner>, SharedKeysInner>() {
            @Override
            public SharedKeysInner call(ServiceResponse<SharedKeysInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the shared keys for a Log Analytics Workspace. These keys are used to connect Microsoft Operational Insights agents to the workspace.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SharedKeysInner object
     */
    public Observable<ServiceResponse<SharedKeysInner>> listKeysWithServiceResponseAsync(String resourceGroupName, String workspaceName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listKeys(this.client.subscriptionId(), resourceGroupName, workspaceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SharedKeysInner>>>() {
                @Override
                public Observable<ServiceResponse<SharedKeysInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SharedKeysInner> clientResponse = listKeysDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SharedKeysInner> listKeysDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SharedKeysInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SharedKeysInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Regenerates the shared keys for a Log Analytics Workspace. These keys are used to connect Microsoft Operational Insights agents to the workspace.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SharedKeysInner object if successful.
     */
    public SharedKeysInner regenerateSharedKeys(String resourceGroupName, String workspaceName) {
        return regenerateSharedKeysWithServiceResponseAsync(resourceGroupName, workspaceName).toBlocking().single().body();
    }

    /**
     * Regenerates the shared keys for a Log Analytics Workspace. These keys are used to connect Microsoft Operational Insights agents to the workspace.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SharedKeysInner> regenerateSharedKeysAsync(String resourceGroupName, String workspaceName, final ServiceCallback<SharedKeysInner> serviceCallback) {
        return ServiceFuture.fromResponse(regenerateSharedKeysWithServiceResponseAsync(resourceGroupName, workspaceName), serviceCallback);
    }

    /**
     * Regenerates the shared keys for a Log Analytics Workspace. These keys are used to connect Microsoft Operational Insights agents to the workspace.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SharedKeysInner object
     */
    public Observable<SharedKeysInner> regenerateSharedKeysAsync(String resourceGroupName, String workspaceName) {
        return regenerateSharedKeysWithServiceResponseAsync(resourceGroupName, workspaceName).map(new Func1<ServiceResponse<SharedKeysInner>, SharedKeysInner>() {
            @Override
            public SharedKeysInner call(ServiceResponse<SharedKeysInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Regenerates the shared keys for a Log Analytics Workspace. These keys are used to connect Microsoft Operational Insights agents to the workspace.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SharedKeysInner object
     */
    public Observable<ServiceResponse<SharedKeysInner>> regenerateSharedKeysWithServiceResponseAsync(String resourceGroupName, String workspaceName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.regenerateSharedKeys(this.client.subscriptionId(), resourceGroupName, workspaceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SharedKeysInner>>>() {
                @Override
                public Observable<ServiceResponse<SharedKeysInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SharedKeysInner> clientResponse = regenerateSharedKeysDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SharedKeysInner> regenerateSharedKeysDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SharedKeysInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SharedKeysInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a Log Analytics gateway.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param gatewayId The Log Analytics gateway Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteGateways(String resourceGroupName, String workspaceName, String gatewayId) {
        deleteGatewaysWithServiceResponseAsync(resourceGroupName, workspaceName, gatewayId).toBlocking().single().body();
    }

    /**
     * Delete a Log Analytics gateway.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param gatewayId The Log Analytics gateway Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteGatewaysAsync(String resourceGroupName, String workspaceName, String gatewayId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteGatewaysWithServiceResponseAsync(resourceGroupName, workspaceName, gatewayId), serviceCallback);
    }

    /**
     * Delete a Log Analytics gateway.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param gatewayId The Log Analytics gateway Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteGatewaysAsync(String resourceGroupName, String workspaceName, String gatewayId) {
        return deleteGatewaysWithServiceResponseAsync(resourceGroupName, workspaceName, gatewayId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a Log Analytics gateway.
     *
     * @param resourceGroupName The Resource Group name.
     * @param workspaceName The Log Analytics Workspace name.
     * @param gatewayId The Log Analytics gateway Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteGatewaysWithServiceResponseAsync(String resourceGroupName, String workspaceName, String gatewayId) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (gatewayId == null) {
            throw new IllegalArgumentException("Parameter gatewayId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteGateways(this.client.subscriptionId(), resourceGroupName, workspaceName, gatewayId, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteGatewaysDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteGatewaysDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
