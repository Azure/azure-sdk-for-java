/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.subscription.v2019_10_01_preview.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.management.subscription.v2019_10_01_preview.ErrorResponseException;
import com.microsoft.azure.management.subscription.v2019_10_01_preview.ModernCspSubscriptionCreationParameters;
import com.microsoft.azure.management.subscription.v2019_10_01_preview.ModernSubscriptionCreationParameters;
import com.microsoft.azure.management.subscription.v2019_10_01_preview.SubscriptionCreateCspSubscriptionHeaders;
import com.microsoft.azure.management.subscription.v2019_10_01_preview.SubscriptionCreateSubscriptionHeaders;
import com.microsoft.azure.management.subscription.v2019_10_01_preview.SubscriptionCreateSubscriptionInEnrollmentAccountHeaders;
import com.microsoft.azure.management.subscription.v2019_10_01_preview.SubscriptionCreationParameters;
import com.microsoft.azure.management.subscription.v2019_10_01_preview.SubscriptionName;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Subscriptions.
 */
public class SubscriptionsInner {
    /** The Retrofit service to perform REST calls. */
    private SubscriptionsService service;
    /** The service client containing this operation class. */
    private SubscriptionClientImpl client;

    /**
     * Initializes an instance of SubscriptionsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public SubscriptionsInner(Retrofit retrofit, SubscriptionClientImpl client) {
        this.service = retrofit.create(SubscriptionsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Subscriptions to be
     * used by Retrofit to perform actually REST calls.
     */
    interface SubscriptionsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.subscription.v2019_10_01_preview.Subscriptions createSubscriptionInEnrollmentAccount" })
        @POST("providers/Microsoft.Billing/enrollmentAccounts/{enrollmentAccountName}/providers/Microsoft.Subscription/createSubscription")
        Observable<Response<ResponseBody>> createSubscriptionInEnrollmentAccount(@Path("enrollmentAccountName") String enrollmentAccountName, @Query("api-version") String apiVersion, @Body SubscriptionCreationParameters body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.subscription.v2019_10_01_preview.Subscriptions beginCreateSubscriptionInEnrollmentAccount" })
        @POST("providers/Microsoft.Billing/enrollmentAccounts/{enrollmentAccountName}/providers/Microsoft.Subscription/createSubscription")
        Observable<Response<ResponseBody>> beginCreateSubscriptionInEnrollmentAccount(@Path("enrollmentAccountName") String enrollmentAccountName, @Query("api-version") String apiVersion, @Body SubscriptionCreationParameters body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.subscription.v2019_10_01_preview.Subscriptions cancel" })
        @POST("subscriptions/{subscriptionId}/providers/Microsoft.Subscription/cancel")
        Observable<Response<ResponseBody>> cancel(@Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.subscription.v2019_10_01_preview.Subscriptions rename" })
        @POST("subscriptions/{subscriptionId}/providers/Microsoft.Subscription/rename")
        Observable<Response<ResponseBody>> rename(@Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body SubscriptionName body, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.subscription.v2019_10_01_preview.Subscriptions enable" })
        @POST("subscriptions/{subscriptionId}/providers/Microsoft.Subscription/enable")
        Observable<Response<ResponseBody>> enable(@Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.subscription.v2019_10_01_preview.Subscriptions createSubscription" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoiceSections/{invoiceSectionName}/providers/Microsoft.Subscription/createSubscription")
        Observable<Response<ResponseBody>> createSubscription(@Path("billingAccountName") String billingAccountName, @Path("billingProfileName") String billingProfileName, @Path("invoiceSectionName") String invoiceSectionName, @Query("api-version") String apiVersion, @Body ModernSubscriptionCreationParameters body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.subscription.v2019_10_01_preview.Subscriptions beginCreateSubscription" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoiceSections/{invoiceSectionName}/providers/Microsoft.Subscription/createSubscription")
        Observable<Response<ResponseBody>> beginCreateSubscription(@Path("billingAccountName") String billingAccountName, @Path("billingProfileName") String billingProfileName, @Path("invoiceSectionName") String invoiceSectionName, @Query("api-version") String apiVersion, @Body ModernSubscriptionCreationParameters body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.subscription.v2019_10_01_preview.Subscriptions createCspSubscription" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/customers/{customerName}/providers/Microsoft.Subscription/createSubscription")
        Observable<Response<ResponseBody>> createCspSubscription(@Path("billingAccountName") String billingAccountName, @Path("customerName") String customerName, @Query("api-version") String apiVersion, @Body ModernCspSubscriptionCreationParameters body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.subscription.v2019_10_01_preview.Subscriptions beginCreateCspSubscription" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/customers/{customerName}/providers/Microsoft.Subscription/createSubscription")
        Observable<Response<ResponseBody>> beginCreateCspSubscription(@Path("billingAccountName") String billingAccountName, @Path("customerName") String customerName, @Query("api-version") String apiVersion, @Body ModernCspSubscriptionCreationParameters body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Creates an Azure subscription.
     *
     * @param enrollmentAccountName The name of the enrollment account to which the subscription will be billed.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SubscriptionCreationResultInner object if successful.
     */
    public SubscriptionCreationResultInner createSubscriptionInEnrollmentAccount(String enrollmentAccountName, SubscriptionCreationParameters body) {
        return createSubscriptionInEnrollmentAccountWithServiceResponseAsync(enrollmentAccountName, body).toBlocking().last().body();
    }

    /**
     * Creates an Azure subscription.
     *
     * @param enrollmentAccountName The name of the enrollment account to which the subscription will be billed.
     * @param body The subscription creation parameters.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SubscriptionCreationResultInner> createSubscriptionInEnrollmentAccountAsync(String enrollmentAccountName, SubscriptionCreationParameters body, final ServiceCallback<SubscriptionCreationResultInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createSubscriptionInEnrollmentAccountWithServiceResponseAsync(enrollmentAccountName, body), serviceCallback);
    }

    /**
     * Creates an Azure subscription.
     *
     * @param enrollmentAccountName The name of the enrollment account to which the subscription will be billed.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SubscriptionCreationResultInner> createSubscriptionInEnrollmentAccountAsync(String enrollmentAccountName, SubscriptionCreationParameters body) {
        return createSubscriptionInEnrollmentAccountWithServiceResponseAsync(enrollmentAccountName, body).map(new Func1<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionInEnrollmentAccountHeaders>, SubscriptionCreationResultInner>() {
            @Override
            public SubscriptionCreationResultInner call(ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionInEnrollmentAccountHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates an Azure subscription.
     *
     * @param enrollmentAccountName The name of the enrollment account to which the subscription will be billed.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionInEnrollmentAccountHeaders>> createSubscriptionInEnrollmentAccountWithServiceResponseAsync(String enrollmentAccountName, SubscriptionCreationParameters body) {
        if (enrollmentAccountName == null) {
            throw new IllegalArgumentException("Parameter enrollmentAccountName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        Observable<Response<ResponseBody>> observable = service.createSubscriptionInEnrollmentAccount(enrollmentAccountName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultWithHeadersAsync(observable, new TypeToken<SubscriptionCreationResultInner>() { }.getType(), SubscriptionCreateSubscriptionInEnrollmentAccountHeaders.class);
    }

    /**
     * Creates an Azure subscription.
     *
     * @param enrollmentAccountName The name of the enrollment account to which the subscription will be billed.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SubscriptionCreationResultInner object if successful.
     */
    public SubscriptionCreationResultInner beginCreateSubscriptionInEnrollmentAccount(String enrollmentAccountName, SubscriptionCreationParameters body) {
        return beginCreateSubscriptionInEnrollmentAccountWithServiceResponseAsync(enrollmentAccountName, body).toBlocking().single().body();
    }

    /**
     * Creates an Azure subscription.
     *
     * @param enrollmentAccountName The name of the enrollment account to which the subscription will be billed.
     * @param body The subscription creation parameters.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SubscriptionCreationResultInner> beginCreateSubscriptionInEnrollmentAccountAsync(String enrollmentAccountName, SubscriptionCreationParameters body, final ServiceCallback<SubscriptionCreationResultInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(beginCreateSubscriptionInEnrollmentAccountWithServiceResponseAsync(enrollmentAccountName, body), serviceCallback);
    }

    /**
     * Creates an Azure subscription.
     *
     * @param enrollmentAccountName The name of the enrollment account to which the subscription will be billed.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SubscriptionCreationResultInner object
     */
    public Observable<SubscriptionCreationResultInner> beginCreateSubscriptionInEnrollmentAccountAsync(String enrollmentAccountName, SubscriptionCreationParameters body) {
        return beginCreateSubscriptionInEnrollmentAccountWithServiceResponseAsync(enrollmentAccountName, body).map(new Func1<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionInEnrollmentAccountHeaders>, SubscriptionCreationResultInner>() {
            @Override
            public SubscriptionCreationResultInner call(ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionInEnrollmentAccountHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates an Azure subscription.
     *
     * @param enrollmentAccountName The name of the enrollment account to which the subscription will be billed.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SubscriptionCreationResultInner object
     */
    public Observable<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionInEnrollmentAccountHeaders>> beginCreateSubscriptionInEnrollmentAccountWithServiceResponseAsync(String enrollmentAccountName, SubscriptionCreationParameters body) {
        if (enrollmentAccountName == null) {
            throw new IllegalArgumentException("Parameter enrollmentAccountName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.beginCreateSubscriptionInEnrollmentAccount(enrollmentAccountName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionInEnrollmentAccountHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionInEnrollmentAccountHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionInEnrollmentAccountHeaders> clientResponse = beginCreateSubscriptionInEnrollmentAccountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionInEnrollmentAccountHeaders> beginCreateSubscriptionInEnrollmentAccountDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SubscriptionCreationResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SubscriptionCreationResultInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, SubscriptionCreateSubscriptionInEnrollmentAccountHeaders.class);
    }

    /**
     * The operation to cancel a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CanceledSubscriptionIdInner object if successful.
     */
    public CanceledSubscriptionIdInner cancel(String subscriptionId) {
        return cancelWithServiceResponseAsync(subscriptionId).toBlocking().single().body();
    }

    /**
     * The operation to cancel a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CanceledSubscriptionIdInner> cancelAsync(String subscriptionId, final ServiceCallback<CanceledSubscriptionIdInner> serviceCallback) {
        return ServiceFuture.fromResponse(cancelWithServiceResponseAsync(subscriptionId), serviceCallback);
    }

    /**
     * The operation to cancel a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CanceledSubscriptionIdInner object
     */
    public Observable<CanceledSubscriptionIdInner> cancelAsync(String subscriptionId) {
        return cancelWithServiceResponseAsync(subscriptionId).map(new Func1<ServiceResponse<CanceledSubscriptionIdInner>, CanceledSubscriptionIdInner>() {
            @Override
            public CanceledSubscriptionIdInner call(ServiceResponse<CanceledSubscriptionIdInner> response) {
                return response.body();
            }
        });
    }

    /**
     * The operation to cancel a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CanceledSubscriptionIdInner object
     */
    public Observable<ServiceResponse<CanceledSubscriptionIdInner>> cancelWithServiceResponseAsync(String subscriptionId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.cancel(subscriptionId, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CanceledSubscriptionIdInner>>>() {
                @Override
                public Observable<ServiceResponse<CanceledSubscriptionIdInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CanceledSubscriptionIdInner> clientResponse = cancelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CanceledSubscriptionIdInner> cancelDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<CanceledSubscriptionIdInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<CanceledSubscriptionIdInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * The operation to rename a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RenamedSubscriptionIdInner object if successful.
     */
    public RenamedSubscriptionIdInner rename(String subscriptionId) {
        return renameWithServiceResponseAsync(subscriptionId).toBlocking().single().body();
    }

    /**
     * The operation to rename a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RenamedSubscriptionIdInner> renameAsync(String subscriptionId, final ServiceCallback<RenamedSubscriptionIdInner> serviceCallback) {
        return ServiceFuture.fromResponse(renameWithServiceResponseAsync(subscriptionId), serviceCallback);
    }

    /**
     * The operation to rename a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RenamedSubscriptionIdInner object
     */
    public Observable<RenamedSubscriptionIdInner> renameAsync(String subscriptionId) {
        return renameWithServiceResponseAsync(subscriptionId).map(new Func1<ServiceResponse<RenamedSubscriptionIdInner>, RenamedSubscriptionIdInner>() {
            @Override
            public RenamedSubscriptionIdInner call(ServiceResponse<RenamedSubscriptionIdInner> response) {
                return response.body();
            }
        });
    }

    /**
     * The operation to rename a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RenamedSubscriptionIdInner object
     */
    public Observable<ServiceResponse<RenamedSubscriptionIdInner>> renameWithServiceResponseAsync(String subscriptionId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String subscriptionName = null;
        SubscriptionName body = new SubscriptionName();
        body.withSubscriptionName(null);
        return service.rename(subscriptionId, this.client.apiVersion(), this.client.acceptLanguage(), body, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RenamedSubscriptionIdInner>>>() {
                @Override
                public Observable<ServiceResponse<RenamedSubscriptionIdInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RenamedSubscriptionIdInner> clientResponse = renameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * The operation to rename a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @param subscriptionName New subscription name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RenamedSubscriptionIdInner object if successful.
     */
    public RenamedSubscriptionIdInner rename(String subscriptionId, String subscriptionName) {
        return renameWithServiceResponseAsync(subscriptionId, subscriptionName).toBlocking().single().body();
    }

    /**
     * The operation to rename a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @param subscriptionName New subscription name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RenamedSubscriptionIdInner> renameAsync(String subscriptionId, String subscriptionName, final ServiceCallback<RenamedSubscriptionIdInner> serviceCallback) {
        return ServiceFuture.fromResponse(renameWithServiceResponseAsync(subscriptionId, subscriptionName), serviceCallback);
    }

    /**
     * The operation to rename a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @param subscriptionName New subscription name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RenamedSubscriptionIdInner object
     */
    public Observable<RenamedSubscriptionIdInner> renameAsync(String subscriptionId, String subscriptionName) {
        return renameWithServiceResponseAsync(subscriptionId, subscriptionName).map(new Func1<ServiceResponse<RenamedSubscriptionIdInner>, RenamedSubscriptionIdInner>() {
            @Override
            public RenamedSubscriptionIdInner call(ServiceResponse<RenamedSubscriptionIdInner> response) {
                return response.body();
            }
        });
    }

    /**
     * The operation to rename a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @param subscriptionName New subscription name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RenamedSubscriptionIdInner object
     */
    public Observable<ServiceResponse<RenamedSubscriptionIdInner>> renameWithServiceResponseAsync(String subscriptionId, String subscriptionName) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        SubscriptionName body = new SubscriptionName();
        body.withSubscriptionName(subscriptionName);
        return service.rename(subscriptionId, this.client.apiVersion(), this.client.acceptLanguage(), body, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RenamedSubscriptionIdInner>>>() {
                @Override
                public Observable<ServiceResponse<RenamedSubscriptionIdInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RenamedSubscriptionIdInner> clientResponse = renameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RenamedSubscriptionIdInner> renameDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RenamedSubscriptionIdInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RenamedSubscriptionIdInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * The operation to enable a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EnabledSubscriptionIdInner object if successful.
     */
    public EnabledSubscriptionIdInner enable(String subscriptionId) {
        return enableWithServiceResponseAsync(subscriptionId).toBlocking().single().body();
    }

    /**
     * The operation to enable a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EnabledSubscriptionIdInner> enableAsync(String subscriptionId, final ServiceCallback<EnabledSubscriptionIdInner> serviceCallback) {
        return ServiceFuture.fromResponse(enableWithServiceResponseAsync(subscriptionId), serviceCallback);
    }

    /**
     * The operation to enable a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EnabledSubscriptionIdInner object
     */
    public Observable<EnabledSubscriptionIdInner> enableAsync(String subscriptionId) {
        return enableWithServiceResponseAsync(subscriptionId).map(new Func1<ServiceResponse<EnabledSubscriptionIdInner>, EnabledSubscriptionIdInner>() {
            @Override
            public EnabledSubscriptionIdInner call(ServiceResponse<EnabledSubscriptionIdInner> response) {
                return response.body();
            }
        });
    }

    /**
     * The operation to enable a subscription.
     *
     * @param subscriptionId Subscription Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EnabledSubscriptionIdInner object
     */
    public Observable<ServiceResponse<EnabledSubscriptionIdInner>> enableWithServiceResponseAsync(String subscriptionId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.enable(subscriptionId, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EnabledSubscriptionIdInner>>>() {
                @Override
                public Observable<ServiceResponse<EnabledSubscriptionIdInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EnabledSubscriptionIdInner> clientResponse = enableDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EnabledSubscriptionIdInner> enableDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<EnabledSubscriptionIdInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<EnabledSubscriptionIdInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * The operation to create a new WebDirect or EA Azure subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param billingProfileName The name of the billing profile in the billing account for which you want to create the subscription.
     * @param invoiceSectionName The name of the invoice section in the billing account for which you want to create the subscription.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SubscriptionCreationResultInner object if successful.
     */
    public SubscriptionCreationResultInner createSubscription(String billingAccountName, String billingProfileName, String invoiceSectionName, ModernSubscriptionCreationParameters body) {
        return createSubscriptionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, body).toBlocking().last().body();
    }

    /**
     * The operation to create a new WebDirect or EA Azure subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param billingProfileName The name of the billing profile in the billing account for which you want to create the subscription.
     * @param invoiceSectionName The name of the invoice section in the billing account for which you want to create the subscription.
     * @param body The subscription creation parameters.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SubscriptionCreationResultInner> createSubscriptionAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, ModernSubscriptionCreationParameters body, final ServiceCallback<SubscriptionCreationResultInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createSubscriptionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, body), serviceCallback);
    }

    /**
     * The operation to create a new WebDirect or EA Azure subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param billingProfileName The name of the billing profile in the billing account for which you want to create the subscription.
     * @param invoiceSectionName The name of the invoice section in the billing account for which you want to create the subscription.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SubscriptionCreationResultInner> createSubscriptionAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, ModernSubscriptionCreationParameters body) {
        return createSubscriptionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, body).map(new Func1<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionHeaders>, SubscriptionCreationResultInner>() {
            @Override
            public SubscriptionCreationResultInner call(ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * The operation to create a new WebDirect or EA Azure subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param billingProfileName The name of the billing profile in the billing account for which you want to create the subscription.
     * @param invoiceSectionName The name of the invoice section in the billing account for which you want to create the subscription.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionHeaders>> createSubscriptionWithServiceResponseAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, ModernSubscriptionCreationParameters body) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        Observable<Response<ResponseBody>> observable = service.createSubscription(billingAccountName, billingProfileName, invoiceSectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultWithHeadersAsync(observable, new TypeToken<SubscriptionCreationResultInner>() { }.getType(), SubscriptionCreateSubscriptionHeaders.class);
    }

    /**
     * The operation to create a new WebDirect or EA Azure subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param billingProfileName The name of the billing profile in the billing account for which you want to create the subscription.
     * @param invoiceSectionName The name of the invoice section in the billing account for which you want to create the subscription.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SubscriptionCreationResultInner object if successful.
     */
    public SubscriptionCreationResultInner beginCreateSubscription(String billingAccountName, String billingProfileName, String invoiceSectionName, ModernSubscriptionCreationParameters body) {
        return beginCreateSubscriptionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, body).toBlocking().single().body();
    }

    /**
     * The operation to create a new WebDirect or EA Azure subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param billingProfileName The name of the billing profile in the billing account for which you want to create the subscription.
     * @param invoiceSectionName The name of the invoice section in the billing account for which you want to create the subscription.
     * @param body The subscription creation parameters.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SubscriptionCreationResultInner> beginCreateSubscriptionAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, ModernSubscriptionCreationParameters body, final ServiceCallback<SubscriptionCreationResultInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(beginCreateSubscriptionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, body), serviceCallback);
    }

    /**
     * The operation to create a new WebDirect or EA Azure subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param billingProfileName The name of the billing profile in the billing account for which you want to create the subscription.
     * @param invoiceSectionName The name of the invoice section in the billing account for which you want to create the subscription.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SubscriptionCreationResultInner object
     */
    public Observable<SubscriptionCreationResultInner> beginCreateSubscriptionAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, ModernSubscriptionCreationParameters body) {
        return beginCreateSubscriptionWithServiceResponseAsync(billingAccountName, billingProfileName, invoiceSectionName, body).map(new Func1<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionHeaders>, SubscriptionCreationResultInner>() {
            @Override
            public SubscriptionCreationResultInner call(ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * The operation to create a new WebDirect or EA Azure subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param billingProfileName The name of the billing profile in the billing account for which you want to create the subscription.
     * @param invoiceSectionName The name of the invoice section in the billing account for which you want to create the subscription.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SubscriptionCreationResultInner object
     */
    public Observable<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionHeaders>> beginCreateSubscriptionWithServiceResponseAsync(String billingAccountName, String billingProfileName, String invoiceSectionName, ModernSubscriptionCreationParameters body) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.beginCreateSubscription(billingAccountName, billingProfileName, invoiceSectionName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionHeaders> clientResponse = beginCreateSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateSubscriptionHeaders> beginCreateSubscriptionDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SubscriptionCreationResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SubscriptionCreationResultInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, SubscriptionCreateSubscriptionHeaders.class);
    }

    /**
     * The operation to create a new CSP subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param customerName The name of the customer.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SubscriptionCreationResultInner object if successful.
     */
    public SubscriptionCreationResultInner createCspSubscription(String billingAccountName, String customerName, ModernCspSubscriptionCreationParameters body) {
        return createCspSubscriptionWithServiceResponseAsync(billingAccountName, customerName, body).toBlocking().last().body();
    }

    /**
     * The operation to create a new CSP subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param customerName The name of the customer.
     * @param body The subscription creation parameters.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SubscriptionCreationResultInner> createCspSubscriptionAsync(String billingAccountName, String customerName, ModernCspSubscriptionCreationParameters body, final ServiceCallback<SubscriptionCreationResultInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createCspSubscriptionWithServiceResponseAsync(billingAccountName, customerName, body), serviceCallback);
    }

    /**
     * The operation to create a new CSP subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param customerName The name of the customer.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SubscriptionCreationResultInner> createCspSubscriptionAsync(String billingAccountName, String customerName, ModernCspSubscriptionCreationParameters body) {
        return createCspSubscriptionWithServiceResponseAsync(billingAccountName, customerName, body).map(new Func1<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateCspSubscriptionHeaders>, SubscriptionCreationResultInner>() {
            @Override
            public SubscriptionCreationResultInner call(ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateCspSubscriptionHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * The operation to create a new CSP subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param customerName The name of the customer.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateCspSubscriptionHeaders>> createCspSubscriptionWithServiceResponseAsync(String billingAccountName, String customerName, ModernCspSubscriptionCreationParameters body) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (customerName == null) {
            throw new IllegalArgumentException("Parameter customerName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        Observable<Response<ResponseBody>> observable = service.createCspSubscription(billingAccountName, customerName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultWithHeadersAsync(observable, new TypeToken<SubscriptionCreationResultInner>() { }.getType(), SubscriptionCreateCspSubscriptionHeaders.class);
    }

    /**
     * The operation to create a new CSP subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param customerName The name of the customer.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SubscriptionCreationResultInner object if successful.
     */
    public SubscriptionCreationResultInner beginCreateCspSubscription(String billingAccountName, String customerName, ModernCspSubscriptionCreationParameters body) {
        return beginCreateCspSubscriptionWithServiceResponseAsync(billingAccountName, customerName, body).toBlocking().single().body();
    }

    /**
     * The operation to create a new CSP subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param customerName The name of the customer.
     * @param body The subscription creation parameters.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SubscriptionCreationResultInner> beginCreateCspSubscriptionAsync(String billingAccountName, String customerName, ModernCspSubscriptionCreationParameters body, final ServiceCallback<SubscriptionCreationResultInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(beginCreateCspSubscriptionWithServiceResponseAsync(billingAccountName, customerName, body), serviceCallback);
    }

    /**
     * The operation to create a new CSP subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param customerName The name of the customer.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SubscriptionCreationResultInner object
     */
    public Observable<SubscriptionCreationResultInner> beginCreateCspSubscriptionAsync(String billingAccountName, String customerName, ModernCspSubscriptionCreationParameters body) {
        return beginCreateCspSubscriptionWithServiceResponseAsync(billingAccountName, customerName, body).map(new Func1<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateCspSubscriptionHeaders>, SubscriptionCreationResultInner>() {
            @Override
            public SubscriptionCreationResultInner call(ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateCspSubscriptionHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * The operation to create a new CSP subscription.
     *
     * @param billingAccountName The name of the Microsoft Customer Agreement billing account for which you want to create the subscription.
     * @param customerName The name of the customer.
     * @param body The subscription creation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SubscriptionCreationResultInner object
     */
    public Observable<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateCspSubscriptionHeaders>> beginCreateCspSubscriptionWithServiceResponseAsync(String billingAccountName, String customerName, ModernCspSubscriptionCreationParameters body) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (customerName == null) {
            throw new IllegalArgumentException("Parameter customerName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.beginCreateCspSubscription(billingAccountName, customerName, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateCspSubscriptionHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateCspSubscriptionHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateCspSubscriptionHeaders> clientResponse = beginCreateCspSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<SubscriptionCreationResultInner, SubscriptionCreateCspSubscriptionHeaders> beginCreateCspSubscriptionDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SubscriptionCreationResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SubscriptionCreationResultInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, SubscriptionCreateCspSubscriptionHeaders.class);
    }

}
