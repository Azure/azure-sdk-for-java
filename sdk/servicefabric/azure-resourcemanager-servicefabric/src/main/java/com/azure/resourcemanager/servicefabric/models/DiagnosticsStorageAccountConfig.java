// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.servicefabric.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.fasterxml.jackson.annotation.JsonProperty;

/** The storage account information for storing Service Fabric diagnostic logs. */
@Fluent
public final class DiagnosticsStorageAccountConfig {
    /*
     * The Azure storage account name.
     */
    @JsonProperty(value = "storageAccountName", required = true)
    private String storageAccountName;

    /*
     * The protected diagnostics storage key name.
     */
    @JsonProperty(value = "protectedAccountKeyName", required = true)
    private String protectedAccountKeyName;

    /*
     * The secondary protected diagnostics storage key name. If one of the storage account keys is rotated the cluster
     * will fallback to using the other.
     */
    @JsonProperty(value = "protectedAccountKeyName2")
    private String protectedAccountKeyName2;

    /*
     * The blob endpoint of the azure storage account.
     */
    @JsonProperty(value = "blobEndpoint", required = true)
    private String blobEndpoint;

    /*
     * The queue endpoint of the azure storage account.
     */
    @JsonProperty(value = "queueEndpoint", required = true)
    private String queueEndpoint;

    /*
     * The table endpoint of the azure storage account.
     */
    @JsonProperty(value = "tableEndpoint", required = true)
    private String tableEndpoint;

    /**
     * Get the storageAccountName property: The Azure storage account name.
     *
     * @return the storageAccountName value.
     */
    public String storageAccountName() {
        return this.storageAccountName;
    }

    /**
     * Set the storageAccountName property: The Azure storage account name.
     *
     * @param storageAccountName the storageAccountName value to set.
     * @return the DiagnosticsStorageAccountConfig object itself.
     */
    public DiagnosticsStorageAccountConfig withStorageAccountName(String storageAccountName) {
        this.storageAccountName = storageAccountName;
        return this;
    }

    /**
     * Get the protectedAccountKeyName property: The protected diagnostics storage key name.
     *
     * @return the protectedAccountKeyName value.
     */
    public String protectedAccountKeyName() {
        return this.protectedAccountKeyName;
    }

    /**
     * Set the protectedAccountKeyName property: The protected diagnostics storage key name.
     *
     * @param protectedAccountKeyName the protectedAccountKeyName value to set.
     * @return the DiagnosticsStorageAccountConfig object itself.
     */
    public DiagnosticsStorageAccountConfig withProtectedAccountKeyName(String protectedAccountKeyName) {
        this.protectedAccountKeyName = protectedAccountKeyName;
        return this;
    }

    /**
     * Get the protectedAccountKeyName2 property: The secondary protected diagnostics storage key name. If one of the
     * storage account keys is rotated the cluster will fallback to using the other.
     *
     * @return the protectedAccountKeyName2 value.
     */
    public String protectedAccountKeyName2() {
        return this.protectedAccountKeyName2;
    }

    /**
     * Set the protectedAccountKeyName2 property: The secondary protected diagnostics storage key name. If one of the
     * storage account keys is rotated the cluster will fallback to using the other.
     *
     * @param protectedAccountKeyName2 the protectedAccountKeyName2 value to set.
     * @return the DiagnosticsStorageAccountConfig object itself.
     */
    public DiagnosticsStorageAccountConfig withProtectedAccountKeyName2(String protectedAccountKeyName2) {
        this.protectedAccountKeyName2 = protectedAccountKeyName2;
        return this;
    }

    /**
     * Get the blobEndpoint property: The blob endpoint of the azure storage account.
     *
     * @return the blobEndpoint value.
     */
    public String blobEndpoint() {
        return this.blobEndpoint;
    }

    /**
     * Set the blobEndpoint property: The blob endpoint of the azure storage account.
     *
     * @param blobEndpoint the blobEndpoint value to set.
     * @return the DiagnosticsStorageAccountConfig object itself.
     */
    public DiagnosticsStorageAccountConfig withBlobEndpoint(String blobEndpoint) {
        this.blobEndpoint = blobEndpoint;
        return this;
    }

    /**
     * Get the queueEndpoint property: The queue endpoint of the azure storage account.
     *
     * @return the queueEndpoint value.
     */
    public String queueEndpoint() {
        return this.queueEndpoint;
    }

    /**
     * Set the queueEndpoint property: The queue endpoint of the azure storage account.
     *
     * @param queueEndpoint the queueEndpoint value to set.
     * @return the DiagnosticsStorageAccountConfig object itself.
     */
    public DiagnosticsStorageAccountConfig withQueueEndpoint(String queueEndpoint) {
        this.queueEndpoint = queueEndpoint;
        return this;
    }

    /**
     * Get the tableEndpoint property: The table endpoint of the azure storage account.
     *
     * @return the tableEndpoint value.
     */
    public String tableEndpoint() {
        return this.tableEndpoint;
    }

    /**
     * Set the tableEndpoint property: The table endpoint of the azure storage account.
     *
     * @param tableEndpoint the tableEndpoint value to set.
     * @return the DiagnosticsStorageAccountConfig object itself.
     */
    public DiagnosticsStorageAccountConfig withTableEndpoint(String tableEndpoint) {
        this.tableEndpoint = tableEndpoint;
        return this;
    }

    /**
     * Validates the instance.
     *
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (storageAccountName() == null) {
            throw LOGGER
                .logExceptionAsError(
                    new IllegalArgumentException(
                        "Missing required property storageAccountName in model DiagnosticsStorageAccountConfig"));
        }
        if (protectedAccountKeyName() == null) {
            throw LOGGER
                .logExceptionAsError(
                    new IllegalArgumentException(
                        "Missing required property protectedAccountKeyName in model DiagnosticsStorageAccountConfig"));
        }
        if (blobEndpoint() == null) {
            throw LOGGER
                .logExceptionAsError(
                    new IllegalArgumentException(
                        "Missing required property blobEndpoint in model DiagnosticsStorageAccountConfig"));
        }
        if (queueEndpoint() == null) {
            throw LOGGER
                .logExceptionAsError(
                    new IllegalArgumentException(
                        "Missing required property queueEndpoint in model DiagnosticsStorageAccountConfig"));
        }
        if (tableEndpoint() == null) {
            throw LOGGER
                .logExceptionAsError(
                    new IllegalArgumentException(
                        "Missing required property tableEndpoint in model DiagnosticsStorageAccountConfig"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(DiagnosticsStorageAccountConfig.class);
}
