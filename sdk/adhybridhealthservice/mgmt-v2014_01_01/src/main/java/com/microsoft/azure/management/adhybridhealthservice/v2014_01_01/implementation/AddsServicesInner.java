/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import java.util.UUID;
import okhttp3.ResponseBody;
import org.joda.time.DateTime;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in AddsServices.
 */
public class AddsServicesInner {
    /** The Retrofit service to perform REST calls. */
    private AddsServicesService service;
    /** The service client containing this operation class. */
    private ADHybridHealthServiceImpl client;

    /**
     * Initializes an instance of AddsServicesInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public AddsServicesInner(Retrofit retrofit, ADHybridHealthServiceImpl client) {
        this.service = retrofit.create(AddsServicesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for AddsServices to be
     * used by Retrofit to perform actually REST calls.
     */
    interface AddsServicesService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices list" })
        @GET("providers/Microsoft.ADHybridHealthService/addsservices")
        Observable<Response<ResponseBody>> list(@Query("$filter") String filter, @Query("serviceType") String serviceType, @Query("skipCount") Integer skipCount, @Query("takeCount") Integer takeCount, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices add" })
        @POST("providers/Microsoft.ADHybridHealthService/addsservices")
        Observable<Response<ResponseBody>> add(@Query("api-version") String apiVersion, @Body ServicePropertiesInner service, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices get" })
        @GET("providers/Microsoft.ADHybridHealthService/addsservices/{serviceName}")
        Observable<Response<ResponseBody>> get(@Path("serviceName") String serviceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices delete" })
        @HTTP(path = "providers/Microsoft.ADHybridHealthService/addsservices/{serviceName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("serviceName") String serviceName, @Query("confirm") Boolean confirm, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices update" })
        @PATCH("providers/Microsoft.ADHybridHealthService/addsservices/{serviceName}")
        Observable<Response<ResponseBody>> update(@Path("serviceName") String serviceName, @Body ServicePropertiesInner service, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices getForestSummary" })
        @GET("providers/Microsoft.ADHybridHealthService/addsservices/{serviceName}/forestsummary")
        Observable<Response<ResponseBody>> getForestSummary(@Path("serviceName") String serviceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices getMetrics" })
        @GET("providers/Microsoft.ADHybridHealthService/addsservices/{serviceName}/metrics/{metricName}/groups/{groupName}")
        Observable<Response<ResponseBody>> getMetrics(@Path("serviceName") String serviceName, @Path("metricName") String metricName, @Path("groupName") String groupName, @Query("groupKey") String groupKey, @Query("fromDate") DateTime fromDate, @Query("toDate") DateTime toDate, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices listMetricsAverage" })
        @GET("providers/Microsoft.ADHybridHealthService/addsservices/{serviceName}/metrics/{metricName}/groups/{groupName}/average")
        Observable<Response<ResponseBody>> listMetricsAverage(@Path("serviceName") String serviceName, @Path("metricName") String metricName, @Path("groupName") String groupName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices listMetricsSum" })
        @GET("providers/Microsoft.ADHybridHealthService/addsservices/{serviceName}/metrics/{metricName}/groups/{groupName}/sum")
        Observable<Response<ResponseBody>> listMetricsSum(@Path("serviceName") String serviceName, @Path("metricName") String metricName, @Path("groupName") String groupName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices listMetricMetadata" })
        @GET("providers/Microsoft.ADHybridHealthService/addsservices/{serviceName}/metricmetadata")
        Observable<Response<ResponseBody>> listMetricMetadata(@Path("serviceName") String serviceName, @Query("$filter") String filter, @Query("perfCounter") Boolean perfCounter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices getMetricMetadata" })
        @GET("providers/Microsoft.ADHybridHealthService/addsservices/{serviceName}/metricmetadata/{metricName}")
        Observable<Response<ResponseBody>> getMetricMetadata(@Path("serviceName") String serviceName, @Path("metricName") String metricName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices getMetricMetadataForGroup" })
        @GET("providers/Microsoft.ADHybridHealthService/addsservices/{serviceName}/metricmetadata/{metricName}/groups/{groupName}")
        Observable<Response<ResponseBody>> getMetricMetadataForGroup(@Path("serviceName") String serviceName, @Path("metricName") String metricName, @Path("groupName") String groupName, @Query("groupKey") String groupKey, @Query("fromDate") DateTime fromDate, @Query("toDate") DateTime toDate, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices listReplicationDetails" })
        @GET("providers/Microsoft.ADHybridHealthService/addsservices/{serviceName}/replicationdetails")
        Observable<Response<ResponseBody>> listReplicationDetails(@Path("serviceName") String serviceName, @Query("$filter") String filter, @Query("withDetails") Boolean withDetails, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices listReplicationSummary" })
        @GET("providers/Microsoft.ADHybridHealthService/addsservices/{serviceName}/replicationsummary")
        Observable<Response<ResponseBody>> listReplicationSummary(@Path("serviceName") String serviceName, @Query("$filter") String filter, @Query("isGroupbySite") boolean isGroupbySite, @Query("query") String query, @Query("nextPartitionKey") String nextPartitionKey, @Query("nextRowKey") String nextRowKey, @Query("takeCount") Integer takeCount, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices listServerAlerts" })
        @GET("providers/Microsoft.ADHybridHealthService/addsservices/{serviceName}/servicemembers/{serviceMemberId}/alerts")
        Observable<Response<ResponseBody>> listServerAlerts(@Path("serviceMemberId") UUID serviceMemberId, @Path("serviceName") String serviceName, @Query("$filter") String filter, @Query("state") String state, @Query("from") DateTime from, @Query("to") DateTime to, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices listPremiumServices" })
        @GET("providers/Microsoft.ADHybridHealthService/addsservices/premiumCheck")
        Observable<Response<ResponseBody>> listPremiumServices(@Query("$filter") String filter, @Query("serviceType") String serviceType, @Query("skipCount") Integer skipCount, @Query("takeCount") Integer takeCount, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices listNext" })
        @GET
        Observable<Response<ResponseBody>> listNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices listMetricsAverageNext" })
        @GET
        Observable<Response<ResponseBody>> listMetricsAverageNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices listMetricsSumNext" })
        @GET
        Observable<Response<ResponseBody>> listMetricsSumNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices listMetricMetadataNext" })
        @GET
        Observable<Response<ResponseBody>> listMetricMetadataNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices listServerAlertsNext" })
        @GET
        Observable<Response<ResponseBody>> listServerAlertsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.adhybridhealthservice.v2014_01_01.AddsServices listPremiumServicesNext" })
        @GET
        Observable<Response<ResponseBody>> listPremiumServicesNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Gets the details of Active Directory Domain Service, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ServicePropertiesInner&gt; object if successful.
     */
    public PagedList<ServicePropertiesInner> list() {
        ServiceResponse<Page<ServicePropertiesInner>> response = listSinglePageAsync().toBlocking().single();
        return new PagedList<ServicePropertiesInner>(response.body()) {
            @Override
            public Page<ServicePropertiesInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of Active Directory Domain Service, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServicePropertiesInner>> listAsync(final ListOperationCallback<ServicePropertiesInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of Active Directory Domain Service, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<Page<ServicePropertiesInner>> listAsync() {
        return listWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Page<ServicePropertiesInner>>() {
                @Override
                public Page<ServicePropertiesInner> call(ServiceResponse<Page<ServicePropertiesInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of Active Directory Domain Service, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listWithServiceResponseAsync() {
        return listSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(ServiceResponse<Page<ServicePropertiesInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of Active Directory Domain Service, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ServicePropertiesInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listSinglePageAsync() {
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final String serviceType = null;
        final Integer skipCount = null;
        final Integer takeCount = null;
        return service.list(filter, serviceType, skipCount, takeCount, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServicePropertiesInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ServicePropertiesInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the details of Active Directory Domain Service, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ServicePropertiesInner&gt; object if successful.
     */
    public PagedList<ServicePropertiesInner> list(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        ServiceResponse<Page<ServicePropertiesInner>> response = listSinglePageAsync(filter, serviceType, skipCount, takeCount).toBlocking().single();
        return new PagedList<ServicePropertiesInner>(response.body()) {
            @Override
            public Page<ServicePropertiesInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of Active Directory Domain Service, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServicePropertiesInner>> listAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount, final ListOperationCallback<ServicePropertiesInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(filter, serviceType, skipCount, takeCount),
            new Func1<String, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of Active Directory Domain Service, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<Page<ServicePropertiesInner>> listAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        return listWithServiceResponseAsync(filter, serviceType, skipCount, takeCount)
            .map(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Page<ServicePropertiesInner>>() {
                @Override
                public Page<ServicePropertiesInner> call(ServiceResponse<Page<ServicePropertiesInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of Active Directory Domain Service, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listWithServiceResponseAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        return listSinglePageAsync(filter, serviceType, skipCount, takeCount)
            .concatMap(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(ServiceResponse<Page<ServicePropertiesInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of Active Directory Domain Service, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param filter The service property filter to apply.
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ServicePropertiesInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listSinglePageAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.list(filter, serviceType, skipCount, takeCount, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServicePropertiesInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ServicePropertiesInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ServicePropertiesInner>> listDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ServicePropertiesInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ServicePropertiesInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Onboards a service for a given tenant in Azure Active Directory Connect Health.
     *
     * @param service The service object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServicePropertiesInner object if successful.
     */
    public ServicePropertiesInner add(ServicePropertiesInner service) {
        return addWithServiceResponseAsync(service).toBlocking().single().body();
    }

    /**
     * Onboards a service for a given tenant in Azure Active Directory Connect Health.
     *
     * @param service The service object.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServicePropertiesInner> addAsync(ServicePropertiesInner service, final ServiceCallback<ServicePropertiesInner> serviceCallback) {
        return ServiceFuture.fromResponse(addWithServiceResponseAsync(service), serviceCallback);
    }

    /**
     * Onboards a service for a given tenant in Azure Active Directory Connect Health.
     *
     * @param service The service object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePropertiesInner object
     */
    public Observable<ServicePropertiesInner> addAsync(ServicePropertiesInner service) {
        return addWithServiceResponseAsync(service).map(new Func1<ServiceResponse<ServicePropertiesInner>, ServicePropertiesInner>() {
            @Override
            public ServicePropertiesInner call(ServiceResponse<ServicePropertiesInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Onboards a service for a given tenant in Azure Active Directory Connect Health.
     *
     * @param service The service object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePropertiesInner object
     */
    public Observable<ServiceResponse<ServicePropertiesInner>> addWithServiceResponseAsync(ServicePropertiesInner service) {
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (service == null) {
            throw new IllegalArgumentException("Parameter service is required and cannot be null.");
        }
        Validator.validate(service);
        return service.add(this.client.apiVersion(), service, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServicePropertiesInner>>>() {
                @Override
                public Observable<ServiceResponse<ServicePropertiesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServicePropertiesInner> clientResponse = addDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServicePropertiesInner> addDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ServicePropertiesInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ServicePropertiesInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of an Active Directory Domain Service for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServicePropertiesInner object if successful.
     */
    public ServicePropertiesInner get(String serviceName) {
        return getWithServiceResponseAsync(serviceName).toBlocking().single().body();
    }

    /**
     * Gets the details of an Active Directory Domain Service for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServicePropertiesInner> getAsync(String serviceName, final ServiceCallback<ServicePropertiesInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(serviceName), serviceCallback);
    }

    /**
     * Gets the details of an Active Directory Domain Service for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePropertiesInner object
     */
    public Observable<ServicePropertiesInner> getAsync(String serviceName) {
        return getWithServiceResponseAsync(serviceName).map(new Func1<ServiceResponse<ServicePropertiesInner>, ServicePropertiesInner>() {
            @Override
            public ServicePropertiesInner call(ServiceResponse<ServicePropertiesInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the details of an Active Directory Domain Service for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePropertiesInner object
     */
    public Observable<ServiceResponse<ServicePropertiesInner>> getWithServiceResponseAsync(String serviceName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(serviceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServicePropertiesInner>>>() {
                @Override
                public Observable<ServiceResponse<ServicePropertiesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServicePropertiesInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServicePropertiesInner> getDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ServicePropertiesInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ServicePropertiesInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes an Active Directory Domain Service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String serviceName) {
        deleteWithServiceResponseAsync(serviceName).toBlocking().single().body();
    }

    /**
     * Deletes an Active Directory Domain Service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String serviceName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(serviceName), serviceCallback);
    }

    /**
     * Deletes an Active Directory Domain Service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String serviceName) {
        return deleteWithServiceResponseAsync(serviceName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an Active Directory Domain Service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String serviceName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean confirm = null;
        return service.delete(serviceName, confirm, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes an Active Directory Domain Service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param confirm Indicates if the service will be permanently deleted or disabled. True indicates that the service will be permanently deleted and False indicates that the service will be marked disabled and then deleted after 30 days, if it is not re-registered.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String serviceName, Boolean confirm) {
        deleteWithServiceResponseAsync(serviceName, confirm).toBlocking().single().body();
    }

    /**
     * Deletes an Active Directory Domain Service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param confirm Indicates if the service will be permanently deleted or disabled. True indicates that the service will be permanently deleted and False indicates that the service will be marked disabled and then deleted after 30 days, if it is not re-registered.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String serviceName, Boolean confirm, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(serviceName, confirm), serviceCallback);
    }

    /**
     * Deletes an Active Directory Domain Service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param confirm Indicates if the service will be permanently deleted or disabled. True indicates that the service will be permanently deleted and False indicates that the service will be marked disabled and then deleted after 30 days, if it is not re-registered.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String serviceName, Boolean confirm) {
        return deleteWithServiceResponseAsync(serviceName, confirm).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an Active Directory Domain Service which is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param confirm Indicates if the service will be permanently deleted or disabled. True indicates that the service will be permanently deleted and False indicates that the service will be marked disabled and then deleted after 30 days, if it is not re-registered.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String serviceName, Boolean confirm) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.delete(serviceName, confirm, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates an Active Directory Domain Service properties of an onboarded service.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param service The service object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServicePropertiesInner object if successful.
     */
    public ServicePropertiesInner update(String serviceName, ServicePropertiesInner service) {
        return updateWithServiceResponseAsync(serviceName, service).toBlocking().single().body();
    }

    /**
     * Updates an Active Directory Domain Service properties of an onboarded service.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param service The service object.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServicePropertiesInner> updateAsync(String serviceName, ServicePropertiesInner service, final ServiceCallback<ServicePropertiesInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(serviceName, service), serviceCallback);
    }

    /**
     * Updates an Active Directory Domain Service properties of an onboarded service.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param service The service object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePropertiesInner object
     */
    public Observable<ServicePropertiesInner> updateAsync(String serviceName, ServicePropertiesInner service) {
        return updateWithServiceResponseAsync(serviceName, service).map(new Func1<ServiceResponse<ServicePropertiesInner>, ServicePropertiesInner>() {
            @Override
            public ServicePropertiesInner call(ServiceResponse<ServicePropertiesInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an Active Directory Domain Service properties of an onboarded service.
     *
     * @param serviceName The name of the service which needs to be deleted.
     * @param service The service object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePropertiesInner object
     */
    public Observable<ServiceResponse<ServicePropertiesInner>> updateWithServiceResponseAsync(String serviceName, ServicePropertiesInner service) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (service == null) {
            throw new IllegalArgumentException("Parameter service is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(service);
        return service.update(serviceName, service, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServicePropertiesInner>>>() {
                @Override
                public Observable<ServiceResponse<ServicePropertiesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServicePropertiesInner> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServicePropertiesInner> updateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ServicePropertiesInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ServicePropertiesInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the forest summary for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ForestSummaryInner object if successful.
     */
    public ForestSummaryInner getForestSummary(String serviceName) {
        return getForestSummaryWithServiceResponseAsync(serviceName).toBlocking().single().body();
    }

    /**
     * Gets the forest summary for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ForestSummaryInner> getForestSummaryAsync(String serviceName, final ServiceCallback<ForestSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(getForestSummaryWithServiceResponseAsync(serviceName), serviceCallback);
    }

    /**
     * Gets the forest summary for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ForestSummaryInner object
     */
    public Observable<ForestSummaryInner> getForestSummaryAsync(String serviceName) {
        return getForestSummaryWithServiceResponseAsync(serviceName).map(new Func1<ServiceResponse<ForestSummaryInner>, ForestSummaryInner>() {
            @Override
            public ForestSummaryInner call(ServiceResponse<ForestSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the forest summary for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ForestSummaryInner object
     */
    public Observable<ServiceResponse<ForestSummaryInner>> getForestSummaryWithServiceResponseAsync(String serviceName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getForestSummary(serviceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ForestSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ForestSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ForestSummaryInner> clientResponse = getForestSummaryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ForestSummaryInner> getForestSummaryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ForestSummaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ForestSummaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MetricSetsInner object if successful.
     */
    public MetricSetsInner getMetrics(String serviceName, String metricName, String groupName) {
        return getMetricsWithServiceResponseAsync(serviceName, metricName, groupName).toBlocking().single().body();
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MetricSetsInner> getMetricsAsync(String serviceName, String metricName, String groupName, final ServiceCallback<MetricSetsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMetricsWithServiceResponseAsync(serviceName, metricName, groupName), serviceCallback);
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<MetricSetsInner> getMetricsAsync(String serviceName, String metricName, String groupName) {
        return getMetricsWithServiceResponseAsync(serviceName, metricName, groupName).map(new Func1<ServiceResponse<MetricSetsInner>, MetricSetsInner>() {
            @Override
            public MetricSetsInner call(ServiceResponse<MetricSetsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<ServiceResponse<MetricSetsInner>> getMetricsWithServiceResponseAsync(String serviceName, String metricName, String groupName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String groupKey = null;
        final DateTime fromDate = null;
        final DateTime toDate = null;
        return service.getMetrics(serviceName, metricName, groupName, groupKey, fromDate, toDate, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MetricSetsInner>>>() {
                @Override
                public Observable<ServiceResponse<MetricSetsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MetricSetsInner> clientResponse = getMetricsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MetricSetsInner object if successful.
     */
    public MetricSetsInner getMetrics(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate) {
        return getMetricsWithServiceResponseAsync(serviceName, metricName, groupName, groupKey, fromDate, toDate).toBlocking().single().body();
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MetricSetsInner> getMetricsAsync(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate, final ServiceCallback<MetricSetsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMetricsWithServiceResponseAsync(serviceName, metricName, groupName, groupKey, fromDate, toDate), serviceCallback);
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<MetricSetsInner> getMetricsAsync(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate) {
        return getMetricsWithServiceResponseAsync(serviceName, metricName, groupName, groupKey, fromDate, toDate).map(new Func1<ServiceResponse<MetricSetsInner>, MetricSetsInner>() {
            @Override
            public MetricSetsInner call(ServiceResponse<MetricSetsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the server related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<ServiceResponse<MetricSetsInner>> getMetricsWithServiceResponseAsync(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getMetrics(serviceName, metricName, groupName, groupKey, fromDate, toDate, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MetricSetsInner>>>() {
                @Override
                public Observable<ServiceResponse<MetricSetsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MetricSetsInner> clientResponse = getMetricsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MetricSetsInner> getMetricsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MetricSetsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MetricSetsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ItemInner&gt; object if successful.
     */
    public PagedList<ItemInner> listMetricsAverage(final String serviceName, final String metricName, final String groupName) {
        ServiceResponse<Page<ItemInner>> response = listMetricsAverageSinglePageAsync(serviceName, metricName, groupName).toBlocking().single();
        return new PagedList<ItemInner>(response.body()) {
            @Override
            public Page<ItemInner> nextPage(String nextPageLink) {
                return listMetricsAverageNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ItemInner>> listMetricsAverageAsync(final String serviceName, final String metricName, final String groupName, final ListOperationCallback<ItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsAverageSinglePageAsync(serviceName, metricName, groupName),
            new Func1<String, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(String nextPageLink) {
                    return listMetricsAverageNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<Page<ItemInner>> listMetricsAverageAsync(final String serviceName, final String metricName, final String groupName) {
        return listMetricsAverageWithServiceResponseAsync(serviceName, metricName, groupName)
            .map(new Func1<ServiceResponse<Page<ItemInner>>, Page<ItemInner>>() {
                @Override
                public Page<ItemInner> call(ServiceResponse<Page<ItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsAverageWithServiceResponseAsync(final String serviceName, final String metricName, final String groupName) {
        return listMetricsAverageSinglePageAsync(serviceName, metricName, groupName)
            .concatMap(new Func1<ServiceResponse<Page<ItemInner>>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(ServiceResponse<Page<ItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsAverageNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
    ServiceResponse<PageImpl<ItemInner>> * @param serviceName The name of the service.
    ServiceResponse<PageImpl<ItemInner>> * @param metricName The metric name
    ServiceResponse<PageImpl<ItemInner>> * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsAverageSinglePageAsync(final String serviceName, final String metricName, final String groupName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listMetricsAverage(serviceName, metricName, groupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ItemInner>> result = listMetricsAverageDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ItemInner>> listMetricsAverageDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ItemInner&gt; object if successful.
     */
    public PagedList<ItemInner> listMetricsSum(final String serviceName, final String metricName, final String groupName) {
        ServiceResponse<Page<ItemInner>> response = listMetricsSumSinglePageAsync(serviceName, metricName, groupName).toBlocking().single();
        return new PagedList<ItemInner>(response.body()) {
            @Override
            public Page<ItemInner> nextPage(String nextPageLink) {
                return listMetricsSumNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ItemInner>> listMetricsSumAsync(final String serviceName, final String metricName, final String groupName, final ListOperationCallback<ItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsSumSinglePageAsync(serviceName, metricName, groupName),
            new Func1<String, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(String nextPageLink) {
                    return listMetricsSumNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<Page<ItemInner>> listMetricsSumAsync(final String serviceName, final String metricName, final String groupName) {
        return listMetricsSumWithServiceResponseAsync(serviceName, metricName, groupName)
            .map(new Func1<ServiceResponse<Page<ItemInner>>, Page<ItemInner>>() {
                @Override
                public Page<ItemInner> call(ServiceResponse<Page<ItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsSumWithServiceResponseAsync(final String serviceName, final String metricName, final String groupName) {
        return listMetricsSumSinglePageAsync(serviceName, metricName, groupName)
            .concatMap(new Func1<ServiceResponse<Page<ItemInner>>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(ServiceResponse<Page<ItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsSumNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
    ServiceResponse<PageImpl<ItemInner>> * @param serviceName The name of the service.
    ServiceResponse<PageImpl<ItemInner>> * @param metricName The metric name
    ServiceResponse<PageImpl<ItemInner>> * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsSumSinglePageAsync(final String serviceName, final String metricName, final String groupName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listMetricsSum(serviceName, metricName, groupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ItemInner>> result = listMetricsSumDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ItemInner>> listMetricsSumDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;MetricMetadataInner&gt; object if successful.
     */
    public PagedList<MetricMetadataInner> listMetricMetadata(final String serviceName) {
        ServiceResponse<Page<MetricMetadataInner>> response = listMetricMetadataSinglePageAsync(serviceName).toBlocking().single();
        return new PagedList<MetricMetadataInner>(response.body()) {
            @Override
            public Page<MetricMetadataInner> nextPage(String nextPageLink) {
                return listMetricMetadataNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<MetricMetadataInner>> listMetricMetadataAsync(final String serviceName, final ListOperationCallback<MetricMetadataInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricMetadataSinglePageAsync(serviceName),
            new Func1<String, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(String nextPageLink) {
                    return listMetricMetadataNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MetricMetadataInner&gt; object
     */
    public Observable<Page<MetricMetadataInner>> listMetricMetadataAsync(final String serviceName) {
        return listMetricMetadataWithServiceResponseAsync(serviceName)
            .map(new Func1<ServiceResponse<Page<MetricMetadataInner>>, Page<MetricMetadataInner>>() {
                @Override
                public Page<MetricMetadataInner> call(ServiceResponse<Page<MetricMetadataInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MetricMetadataInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricMetadataInner>>> listMetricMetadataWithServiceResponseAsync(final String serviceName) {
        return listMetricMetadataSinglePageAsync(serviceName)
            .concatMap(new Func1<ServiceResponse<Page<MetricMetadataInner>>, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(ServiceResponse<Page<MetricMetadataInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricMetadataNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;MetricMetadataInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricMetadataInner>>> listMetricMetadataSinglePageAsync(final String serviceName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Boolean perfCounter = null;
        return service.listMetricMetadata(serviceName, filter, perfCounter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricMetadataInner>> result = listMetricMetadataDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricMetadataInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @param filter The metric metadata property filter to apply.
     * @param perfCounter Indicates if only performance counter metrics are requested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;MetricMetadataInner&gt; object if successful.
     */
    public PagedList<MetricMetadataInner> listMetricMetadata(final String serviceName, final String filter, final Boolean perfCounter) {
        ServiceResponse<Page<MetricMetadataInner>> response = listMetricMetadataSinglePageAsync(serviceName, filter, perfCounter).toBlocking().single();
        return new PagedList<MetricMetadataInner>(response.body()) {
            @Override
            public Page<MetricMetadataInner> nextPage(String nextPageLink) {
                return listMetricMetadataNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @param filter The metric metadata property filter to apply.
     * @param perfCounter Indicates if only performance counter metrics are requested.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<MetricMetadataInner>> listMetricMetadataAsync(final String serviceName, final String filter, final Boolean perfCounter, final ListOperationCallback<MetricMetadataInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricMetadataSinglePageAsync(serviceName, filter, perfCounter),
            new Func1<String, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(String nextPageLink) {
                    return listMetricMetadataNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @param filter The metric metadata property filter to apply.
     * @param perfCounter Indicates if only performance counter metrics are requested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MetricMetadataInner&gt; object
     */
    public Observable<Page<MetricMetadataInner>> listMetricMetadataAsync(final String serviceName, final String filter, final Boolean perfCounter) {
        return listMetricMetadataWithServiceResponseAsync(serviceName, filter, perfCounter)
            .map(new Func1<ServiceResponse<Page<MetricMetadataInner>>, Page<MetricMetadataInner>>() {
                @Override
                public Page<MetricMetadataInner> call(ServiceResponse<Page<MetricMetadataInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the service related metrics information.
     *
     * @param serviceName The name of the service.
     * @param filter The metric metadata property filter to apply.
     * @param perfCounter Indicates if only performance counter metrics are requested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MetricMetadataInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricMetadataInner>>> listMetricMetadataWithServiceResponseAsync(final String serviceName, final String filter, final Boolean perfCounter) {
        return listMetricMetadataSinglePageAsync(serviceName, filter, perfCounter)
            .concatMap(new Func1<ServiceResponse<Page<MetricMetadataInner>>, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(ServiceResponse<Page<MetricMetadataInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricMetadataNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the service related metrics information.
     *
    ServiceResponse<PageImpl<MetricMetadataInner>> * @param serviceName The name of the service.
    ServiceResponse<PageImpl<MetricMetadataInner>> * @param filter The metric metadata property filter to apply.
    ServiceResponse<PageImpl<MetricMetadataInner>> * @param perfCounter Indicates if only performance counter metrics are requested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;MetricMetadataInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricMetadataInner>>> listMetricMetadataSinglePageAsync(final String serviceName, final String filter, final Boolean perfCounter) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listMetricMetadata(serviceName, filter, perfCounter, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricMetadataInner>> result = listMetricMetadataDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricMetadataInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricMetadataInner>> listMetricMetadataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<MetricMetadataInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<MetricMetadataInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the service related metric information.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MetricMetadataInner object if successful.
     */
    public MetricMetadataInner getMetricMetadata(String serviceName, String metricName) {
        return getMetricMetadataWithServiceResponseAsync(serviceName, metricName).toBlocking().single().body();
    }

    /**
     * Gets the service related metric information.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MetricMetadataInner> getMetricMetadataAsync(String serviceName, String metricName, final ServiceCallback<MetricMetadataInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMetricMetadataWithServiceResponseAsync(serviceName, metricName), serviceCallback);
    }

    /**
     * Gets the service related metric information.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricMetadataInner object
     */
    public Observable<MetricMetadataInner> getMetricMetadataAsync(String serviceName, String metricName) {
        return getMetricMetadataWithServiceResponseAsync(serviceName, metricName).map(new Func1<ServiceResponse<MetricMetadataInner>, MetricMetadataInner>() {
            @Override
            public MetricMetadataInner call(ServiceResponse<MetricMetadataInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the service related metric information.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricMetadataInner object
     */
    public Observable<ServiceResponse<MetricMetadataInner>> getMetricMetadataWithServiceResponseAsync(String serviceName, String metricName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getMetricMetadata(serviceName, metricName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MetricMetadataInner>>>() {
                @Override
                public Observable<ServiceResponse<MetricMetadataInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MetricMetadataInner> clientResponse = getMetricMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MetricMetadataInner> getMetricMetadataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MetricMetadataInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MetricMetadataInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MetricSetsInner object if successful.
     */
    public MetricSetsInner getMetricMetadataForGroup(String serviceName, String metricName, String groupName) {
        return getMetricMetadataForGroupWithServiceResponseAsync(serviceName, metricName, groupName).toBlocking().single().body();
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MetricSetsInner> getMetricMetadataForGroupAsync(String serviceName, String metricName, String groupName, final ServiceCallback<MetricSetsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMetricMetadataForGroupWithServiceResponseAsync(serviceName, metricName, groupName), serviceCallback);
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<MetricSetsInner> getMetricMetadataForGroupAsync(String serviceName, String metricName, String groupName) {
        return getMetricMetadataForGroupWithServiceResponseAsync(serviceName, metricName, groupName).map(new Func1<ServiceResponse<MetricSetsInner>, MetricSetsInner>() {
            @Override
            public MetricSetsInner call(ServiceResponse<MetricSetsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<ServiceResponse<MetricSetsInner>> getMetricMetadataForGroupWithServiceResponseAsync(String serviceName, String metricName, String groupName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String groupKey = null;
        final DateTime fromDate = null;
        final DateTime toDate = null;
        return service.getMetricMetadataForGroup(serviceName, metricName, groupName, groupKey, fromDate, toDate, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MetricSetsInner>>>() {
                @Override
                public Observable<ServiceResponse<MetricSetsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MetricSetsInner> clientResponse = getMetricMetadataForGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MetricSetsInner object if successful.
     */
    public MetricSetsInner getMetricMetadataForGroup(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate) {
        return getMetricMetadataForGroupWithServiceResponseAsync(serviceName, metricName, groupName, groupKey, fromDate, toDate).toBlocking().single().body();
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MetricSetsInner> getMetricMetadataForGroupAsync(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate, final ServiceCallback<MetricSetsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMetricMetadataForGroupWithServiceResponseAsync(serviceName, metricName, groupName, groupKey, fromDate, toDate), serviceCallback);
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<MetricSetsInner> getMetricMetadataForGroupAsync(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate) {
        return getMetricMetadataForGroupWithServiceResponseAsync(serviceName, metricName, groupName, groupKey, fromDate, toDate).map(new Func1<ServiceResponse<MetricSetsInner>, MetricSetsInner>() {
            @Override
            public MetricSetsInner call(ServiceResponse<MetricSetsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the service related metrics for a given metric and group combination.
     *
     * @param serviceName The name of the service.
     * @param metricName The metric name
     * @param groupName The group name
     * @param groupKey The group key
     * @param fromDate The start date.
     * @param toDate The end date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MetricSetsInner object
     */
    public Observable<ServiceResponse<MetricSetsInner>> getMetricMetadataForGroupWithServiceResponseAsync(String serviceName, String metricName, String groupName, String groupKey, DateTime fromDate, DateTime toDate) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (metricName == null) {
            throw new IllegalArgumentException("Parameter metricName is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getMetricMetadataForGroup(serviceName, metricName, groupName, groupKey, fromDate, toDate, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MetricSetsInner>>>() {
                @Override
                public Observable<ServiceResponse<MetricSetsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MetricSetsInner> clientResponse = getMetricMetadataForGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MetricSetsInner> getMetricMetadataForGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MetricSetsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MetricSetsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ReplicationSummaryInner&gt; object if successful.
     */
    public List<ReplicationSummaryInner> listReplicationDetails(String serviceName) {
        return listReplicationDetailsWithServiceResponseAsync(serviceName).toBlocking().single().body();
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReplicationSummaryInner>> listReplicationDetailsAsync(String serviceName, final ServiceCallback<List<ReplicationSummaryInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listReplicationDetailsWithServiceResponseAsync(serviceName), serviceCallback);
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicationSummaryInner&gt; object
     */
    public Observable<List<ReplicationSummaryInner>> listReplicationDetailsAsync(String serviceName) {
        return listReplicationDetailsWithServiceResponseAsync(serviceName).map(new Func1<ServiceResponse<List<ReplicationSummaryInner>>, List<ReplicationSummaryInner>>() {
            @Override
            public List<ReplicationSummaryInner> call(ServiceResponse<List<ReplicationSummaryInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicationSummaryInner&gt; object
     */
    public Observable<ServiceResponse<List<ReplicationSummaryInner>>> listReplicationDetailsWithServiceResponseAsync(String serviceName) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final Boolean withDetails = null;
        return service.listReplicationDetails(serviceName, filter, withDetails, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ReplicationSummaryInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ReplicationSummaryInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<ReplicationSummaryInner>> result = listReplicationDetailsDelegate(response);
                        List<ReplicationSummaryInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<ReplicationSummaryInner>> clientResponse = new ServiceResponse<List<ReplicationSummaryInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param filter The server property filter to apply.
     * @param withDetails Indicates if InboundReplicationNeighbor details are required or not.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ReplicationSummaryInner&gt; object if successful.
     */
    public List<ReplicationSummaryInner> listReplicationDetails(String serviceName, String filter, Boolean withDetails) {
        return listReplicationDetailsWithServiceResponseAsync(serviceName, filter, withDetails).toBlocking().single().body();
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param filter The server property filter to apply.
     * @param withDetails Indicates if InboundReplicationNeighbor details are required or not.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReplicationSummaryInner>> listReplicationDetailsAsync(String serviceName, String filter, Boolean withDetails, final ServiceCallback<List<ReplicationSummaryInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listReplicationDetailsWithServiceResponseAsync(serviceName, filter, withDetails), serviceCallback);
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param filter The server property filter to apply.
     * @param withDetails Indicates if InboundReplicationNeighbor details are required or not.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicationSummaryInner&gt; object
     */
    public Observable<List<ReplicationSummaryInner>> listReplicationDetailsAsync(String serviceName, String filter, Boolean withDetails) {
        return listReplicationDetailsWithServiceResponseAsync(serviceName, filter, withDetails).map(new Func1<ServiceResponse<List<ReplicationSummaryInner>>, List<ReplicationSummaryInner>>() {
            @Override
            public List<ReplicationSummaryInner> call(ServiceResponse<List<ReplicationSummaryInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param filter The server property filter to apply.
     * @param withDetails Indicates if InboundReplicationNeighbor details are required or not.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicationSummaryInner&gt; object
     */
    public Observable<ServiceResponse<List<ReplicationSummaryInner>>> listReplicationDetailsWithServiceResponseAsync(String serviceName, String filter, Boolean withDetails) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listReplicationDetails(serviceName, filter, withDetails, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ReplicationSummaryInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ReplicationSummaryInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<ReplicationSummaryInner>> result = listReplicationDetailsDelegate(response);
                        List<ReplicationSummaryInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<ReplicationSummaryInner>> clientResponse = new ServiceResponse<List<ReplicationSummaryInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl1<ReplicationSummaryInner>> listReplicationDetailsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl1<ReplicationSummaryInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl1<ReplicationSummaryInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param isGroupbySite Indicates if the result should be grouped by site or not.
     * @param query The custom query.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ReplicationSummaryInner&gt; object if successful.
     */
    public List<ReplicationSummaryInner> listReplicationSummary(String serviceName, boolean isGroupbySite, String query) {
        return listReplicationSummaryWithServiceResponseAsync(serviceName, isGroupbySite, query).toBlocking().single().body();
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param isGroupbySite Indicates if the result should be grouped by site or not.
     * @param query The custom query.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReplicationSummaryInner>> listReplicationSummaryAsync(String serviceName, boolean isGroupbySite, String query, final ServiceCallback<List<ReplicationSummaryInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listReplicationSummaryWithServiceResponseAsync(serviceName, isGroupbySite, query), serviceCallback);
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param isGroupbySite Indicates if the result should be grouped by site or not.
     * @param query The custom query.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicationSummaryInner&gt; object
     */
    public Observable<List<ReplicationSummaryInner>> listReplicationSummaryAsync(String serviceName, boolean isGroupbySite, String query) {
        return listReplicationSummaryWithServiceResponseAsync(serviceName, isGroupbySite, query).map(new Func1<ServiceResponse<List<ReplicationSummaryInner>>, List<ReplicationSummaryInner>>() {
            @Override
            public List<ReplicationSummaryInner> call(ServiceResponse<List<ReplicationSummaryInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param isGroupbySite Indicates if the result should be grouped by site or not.
     * @param query The custom query.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicationSummaryInner&gt; object
     */
    public Observable<ServiceResponse<List<ReplicationSummaryInner>>> listReplicationSummaryWithServiceResponseAsync(String serviceName, boolean isGroupbySite, String query) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (query == null) {
            throw new IllegalArgumentException("Parameter query is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String nextPartitionKey = "";
        final String nextRowKey = "";
        final String filter = null;
        final Integer takeCount = null;
        return service.listReplicationSummary(serviceName, filter, isGroupbySite, query, nextPartitionKey, nextRowKey, takeCount, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ReplicationSummaryInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ReplicationSummaryInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<ReplicationSummaryInner>> result = listReplicationSummaryDelegate(response);
                        List<ReplicationSummaryInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<ReplicationSummaryInner>> clientResponse = new ServiceResponse<List<ReplicationSummaryInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param isGroupbySite Indicates if the result should be grouped by site or not.
     * @param query The custom query.
     * @param filter The server property filter to apply.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ReplicationSummaryInner&gt; object if successful.
     */
    public List<ReplicationSummaryInner> listReplicationSummary(String serviceName, boolean isGroupbySite, String query, String filter, Integer takeCount) {
        return listReplicationSummaryWithServiceResponseAsync(serviceName, isGroupbySite, query, filter, takeCount).toBlocking().single().body();
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param isGroupbySite Indicates if the result should be grouped by site or not.
     * @param query The custom query.
     * @param filter The server property filter to apply.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReplicationSummaryInner>> listReplicationSummaryAsync(String serviceName, boolean isGroupbySite, String query, String filter, Integer takeCount, final ServiceCallback<List<ReplicationSummaryInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listReplicationSummaryWithServiceResponseAsync(serviceName, isGroupbySite, query, filter, takeCount), serviceCallback);
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param isGroupbySite Indicates if the result should be grouped by site or not.
     * @param query The custom query.
     * @param filter The server property filter to apply.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicationSummaryInner&gt; object
     */
    public Observable<List<ReplicationSummaryInner>> listReplicationSummaryAsync(String serviceName, boolean isGroupbySite, String query, String filter, Integer takeCount) {
        return listReplicationSummaryWithServiceResponseAsync(serviceName, isGroupbySite, query, filter, takeCount).map(new Func1<ServiceResponse<List<ReplicationSummaryInner>>, List<ReplicationSummaryInner>>() {
            @Override
            public List<ReplicationSummaryInner> call(ServiceResponse<List<ReplicationSummaryInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets complete domain controller list along with replication details for a given Active Directory Domain Service, that is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceName The name of the service.
     * @param isGroupbySite Indicates if the result should be grouped by site or not.
     * @param query The custom query.
     * @param filter The server property filter to apply.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicationSummaryInner&gt; object
     */
    public Observable<ServiceResponse<List<ReplicationSummaryInner>>> listReplicationSummaryWithServiceResponseAsync(String serviceName, boolean isGroupbySite, String query, String filter, Integer takeCount) {
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (query == null) {
            throw new IllegalArgumentException("Parameter query is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String nextPartitionKey = "";
        final String nextRowKey = "";
        return service.listReplicationSummary(serviceName, filter, isGroupbySite, query, nextPartitionKey, nextRowKey, takeCount, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ReplicationSummaryInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ReplicationSummaryInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl1<ReplicationSummaryInner>> result = listReplicationSummaryDelegate(response);
                        List<ReplicationSummaryInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<ReplicationSummaryInner>> clientResponse = new ServiceResponse<List<ReplicationSummaryInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl1<ReplicationSummaryInner>> listReplicationSummaryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl1<ReplicationSummaryInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl1<ReplicationSummaryInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of an alert for a given Active Directory Domain Controller service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;AlertInner&gt; object if successful.
     */
    public PagedList<AlertInner> listServerAlerts(final UUID serviceMemberId, final String serviceName) {
        ServiceResponse<Page<AlertInner>> response = listServerAlertsSinglePageAsync(serviceMemberId, serviceName).toBlocking().single();
        return new PagedList<AlertInner>(response.body()) {
            @Override
            public Page<AlertInner> nextPage(String nextPageLink) {
                return listServerAlertsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of an alert for a given Active Directory Domain Controller service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AlertInner>> listServerAlertsAsync(final UUID serviceMemberId, final String serviceName, final ListOperationCallback<AlertInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listServerAlertsSinglePageAsync(serviceMemberId, serviceName),
            new Func1<String, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(String nextPageLink) {
                    return listServerAlertsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of an alert for a given Active Directory Domain Controller service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<Page<AlertInner>> listServerAlertsAsync(final UUID serviceMemberId, final String serviceName) {
        return listServerAlertsWithServiceResponseAsync(serviceMemberId, serviceName)
            .map(new Func1<ServiceResponse<Page<AlertInner>>, Page<AlertInner>>() {
                @Override
                public Page<AlertInner> call(ServiceResponse<Page<AlertInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of an alert for a given Active Directory Domain Controller service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listServerAlertsWithServiceResponseAsync(final UUID serviceMemberId, final String serviceName) {
        return listServerAlertsSinglePageAsync(serviceMemberId, serviceName)
            .concatMap(new Func1<ServiceResponse<Page<AlertInner>>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(ServiceResponse<Page<AlertInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listServerAlertsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of an alert for a given Active Directory Domain Controller service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;AlertInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listServerAlertsSinglePageAsync(final UUID serviceMemberId, final String serviceName) {
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final String state = null;
        final DateTime from = null;
        final DateTime to = null;
        return service.listServerAlerts(serviceMemberId, serviceName, filter, state, from, to, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AlertInner>> result = listServerAlertsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AlertInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the details of an alert for a given Active Directory Domain Controller service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @param filter The alert property filter to apply.
     * @param state The alert state to query for.
     * @param from The start date to query for.
     * @param to The end date till when to query for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;AlertInner&gt; object if successful.
     */
    public PagedList<AlertInner> listServerAlerts(final UUID serviceMemberId, final String serviceName, final String filter, final String state, final DateTime from, final DateTime to) {
        ServiceResponse<Page<AlertInner>> response = listServerAlertsSinglePageAsync(serviceMemberId, serviceName, filter, state, from, to).toBlocking().single();
        return new PagedList<AlertInner>(response.body()) {
            @Override
            public Page<AlertInner> nextPage(String nextPageLink) {
                return listServerAlertsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of an alert for a given Active Directory Domain Controller service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @param filter The alert property filter to apply.
     * @param state The alert state to query for.
     * @param from The start date to query for.
     * @param to The end date till when to query for.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AlertInner>> listServerAlertsAsync(final UUID serviceMemberId, final String serviceName, final String filter, final String state, final DateTime from, final DateTime to, final ListOperationCallback<AlertInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listServerAlertsSinglePageAsync(serviceMemberId, serviceName, filter, state, from, to),
            new Func1<String, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(String nextPageLink) {
                    return listServerAlertsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of an alert for a given Active Directory Domain Controller service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @param filter The alert property filter to apply.
     * @param state The alert state to query for.
     * @param from The start date to query for.
     * @param to The end date till when to query for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<Page<AlertInner>> listServerAlertsAsync(final UUID serviceMemberId, final String serviceName, final String filter, final String state, final DateTime from, final DateTime to) {
        return listServerAlertsWithServiceResponseAsync(serviceMemberId, serviceName, filter, state, from, to)
            .map(new Func1<ServiceResponse<Page<AlertInner>>, Page<AlertInner>>() {
                @Override
                public Page<AlertInner> call(ServiceResponse<Page<AlertInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of an alert for a given Active Directory Domain Controller service and server combination.
     *
     * @param serviceMemberId The server Id for which the alert details needs to be queried.
     * @param serviceName The name of the service.
     * @param filter The alert property filter to apply.
     * @param state The alert state to query for.
     * @param from The start date to query for.
     * @param to The end date till when to query for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listServerAlertsWithServiceResponseAsync(final UUID serviceMemberId, final String serviceName, final String filter, final String state, final DateTime from, final DateTime to) {
        return listServerAlertsSinglePageAsync(serviceMemberId, serviceName, filter, state, from, to)
            .concatMap(new Func1<ServiceResponse<Page<AlertInner>>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(ServiceResponse<Page<AlertInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listServerAlertsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of an alert for a given Active Directory Domain Controller service and server combination.
     *
    ServiceResponse<PageImpl<AlertInner>> * @param serviceMemberId The server Id for which the alert details needs to be queried.
    ServiceResponse<PageImpl<AlertInner>> * @param serviceName The name of the service.
    ServiceResponse<PageImpl<AlertInner>> * @param filter The alert property filter to apply.
    ServiceResponse<PageImpl<AlertInner>> * @param state The alert state to query for.
    ServiceResponse<PageImpl<AlertInner>> * @param from The start date to query for.
    ServiceResponse<PageImpl<AlertInner>> * @param to The end date till when to query for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;AlertInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listServerAlertsSinglePageAsync(final UUID serviceMemberId, final String serviceName, final String filter, final String state, final DateTime from, final DateTime to) {
        if (serviceMemberId == null) {
            throw new IllegalArgumentException("Parameter serviceMemberId is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listServerAlerts(serviceMemberId, serviceName, filter, state, from, to, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AlertInner>> result = listServerAlertsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AlertInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<AlertInner>> listServerAlertsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<AlertInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<AlertInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of Active Directory Domain Services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ServicePropertiesInner&gt; object if successful.
     */
    public PagedList<ServicePropertiesInner> listPremiumServices() {
        ServiceResponse<Page<ServicePropertiesInner>> response = listPremiumServicesSinglePageAsync().toBlocking().single();
        return new PagedList<ServicePropertiesInner>(response.body()) {
            @Override
            public Page<ServicePropertiesInner> nextPage(String nextPageLink) {
                return listPremiumServicesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of Active Directory Domain Services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServicePropertiesInner>> listPremiumServicesAsync(final ListOperationCallback<ServicePropertiesInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPremiumServicesSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(String nextPageLink) {
                    return listPremiumServicesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of Active Directory Domain Services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<Page<ServicePropertiesInner>> listPremiumServicesAsync() {
        return listPremiumServicesWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Page<ServicePropertiesInner>>() {
                @Override
                public Page<ServicePropertiesInner> call(ServiceResponse<Page<ServicePropertiesInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of Active Directory Domain Services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listPremiumServicesWithServiceResponseAsync() {
        return listPremiumServicesSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(ServiceResponse<Page<ServicePropertiesInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPremiumServicesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of Active Directory Domain Services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ServicePropertiesInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listPremiumServicesSinglePageAsync() {
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String filter = null;
        final String serviceType = null;
        final Integer skipCount = null;
        final Integer takeCount = null;
        return service.listPremiumServices(filter, serviceType, skipCount, takeCount, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServicePropertiesInner>> result = listPremiumServicesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ServicePropertiesInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the details of Active Directory Domain Services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ServicePropertiesInner&gt; object if successful.
     */
    public PagedList<ServicePropertiesInner> listPremiumServices(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        ServiceResponse<Page<ServicePropertiesInner>> response = listPremiumServicesSinglePageAsync(filter, serviceType, skipCount, takeCount).toBlocking().single();
        return new PagedList<ServicePropertiesInner>(response.body()) {
            @Override
            public Page<ServicePropertiesInner> nextPage(String nextPageLink) {
                return listPremiumServicesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of Active Directory Domain Services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServicePropertiesInner>> listPremiumServicesAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount, final ListOperationCallback<ServicePropertiesInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPremiumServicesSinglePageAsync(filter, serviceType, skipCount, takeCount),
            new Func1<String, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(String nextPageLink) {
                    return listPremiumServicesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of Active Directory Domain Services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<Page<ServicePropertiesInner>> listPremiumServicesAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        return listPremiumServicesWithServiceResponseAsync(filter, serviceType, skipCount, takeCount)
            .map(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Page<ServicePropertiesInner>>() {
                @Override
                public Page<ServicePropertiesInner> call(ServiceResponse<Page<ServicePropertiesInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of Active Directory Domain Services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param filter The service property filter to apply.
     * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
     * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
     * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listPremiumServicesWithServiceResponseAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        return listPremiumServicesSinglePageAsync(filter, serviceType, skipCount, takeCount)
            .concatMap(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(ServiceResponse<Page<ServicePropertiesInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPremiumServicesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of Active Directory Domain Services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param filter The service property filter to apply.
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param serviceType The service type for the services onboarded to Azure Active Directory Connect Health. Depending on whether the service is monitoring, ADFS, Sync or ADDS roles, the service type can either be AdFederationService or AadSyncService or AdDomainService.
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param skipCount The skip count, which specifies the number of elements that can be bypassed from a sequence and then return the remaining elements.
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param takeCount The take count , which specifies the number of elements that can be returned from a sequence.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ServicePropertiesInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listPremiumServicesSinglePageAsync(final String filter, final String serviceType, final Integer skipCount, final Integer takeCount) {
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listPremiumServices(filter, serviceType, skipCount, takeCount, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServicePropertiesInner>> result = listPremiumServicesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ServicePropertiesInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ServicePropertiesInner>> listPremiumServicesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ServicePropertiesInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ServicePropertiesInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of Active Directory Domain Service, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ServicePropertiesInner&gt; object if successful.
     */
    public PagedList<ServicePropertiesInner> listNext(final String nextPageLink) {
        ServiceResponse<Page<ServicePropertiesInner>> response = listNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ServicePropertiesInner>(response.body()) {
            @Override
            public Page<ServicePropertiesInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of Active Directory Domain Service, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServicePropertiesInner>> listNextAsync(final String nextPageLink, final ServiceFuture<List<ServicePropertiesInner>> serviceFuture, final ListOperationCallback<ServicePropertiesInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of Active Directory Domain Service, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<Page<ServicePropertiesInner>> listNextAsync(final String nextPageLink) {
        return listNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Page<ServicePropertiesInner>>() {
                @Override
                public Page<ServicePropertiesInner> call(ServiceResponse<Page<ServicePropertiesInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of Active Directory Domain Service, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listNextWithServiceResponseAsync(final String nextPageLink) {
        return listNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(ServiceResponse<Page<ServicePropertiesInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of Active Directory Domain Service, for a tenant, that are onboarded to Azure Active Directory Connect Health.
     *
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ServicePropertiesInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServicePropertiesInner>> result = listNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ServicePropertiesInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ServicePropertiesInner>> listNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ServicePropertiesInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ServicePropertiesInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ItemInner&gt; object if successful.
     */
    public PagedList<ItemInner> listMetricsAverageNext(final String nextPageLink) {
        ServiceResponse<Page<ItemInner>> response = listMetricsAverageNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ItemInner>(response.body()) {
            @Override
            public Page<ItemInner> nextPage(String nextPageLink) {
                return listMetricsAverageNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ItemInner>> listMetricsAverageNextAsync(final String nextPageLink, final ServiceFuture<List<ItemInner>> serviceFuture, final ListOperationCallback<ItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsAverageNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(String nextPageLink) {
                    return listMetricsAverageNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<Page<ItemInner>> listMetricsAverageNextAsync(final String nextPageLink) {
        return listMetricsAverageNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ItemInner>>, Page<ItemInner>>() {
                @Override
                public Page<ItemInner> call(ServiceResponse<Page<ItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsAverageNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricsAverageNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ItemInner>>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(ServiceResponse<Page<ItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsAverageNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the average of the metric values for a given metric and group combination.
     *
    ServiceResponse<PageImpl<ItemInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsAverageNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listMetricsAverageNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ItemInner>> result = listMetricsAverageNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ItemInner>> listMetricsAverageNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ItemInner&gt; object if successful.
     */
    public PagedList<ItemInner> listMetricsSumNext(final String nextPageLink) {
        ServiceResponse<Page<ItemInner>> response = listMetricsSumNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ItemInner>(response.body()) {
            @Override
            public Page<ItemInner> nextPage(String nextPageLink) {
                return listMetricsSumNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ItemInner>> listMetricsSumNextAsync(final String nextPageLink, final ServiceFuture<List<ItemInner>> serviceFuture, final ListOperationCallback<ItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsSumNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(String nextPageLink) {
                    return listMetricsSumNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<Page<ItemInner>> listMetricsSumNextAsync(final String nextPageLink) {
        return listMetricsSumNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ItemInner>>, Page<ItemInner>>() {
                @Override
                public Page<ItemInner> call(ServiceResponse<Page<ItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsSumNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricsSumNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ItemInner>>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(ServiceResponse<Page<ItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsSumNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the sum of the metric values for a given metric and group combination.
     *
    ServiceResponse<PageImpl<ItemInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ItemInner>>> listMetricsSumNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listMetricsSumNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ItemInner>> result = listMetricsSumNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ItemInner>> listMetricsSumNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the service related metrics information.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;MetricMetadataInner&gt; object if successful.
     */
    public PagedList<MetricMetadataInner> listMetricMetadataNext(final String nextPageLink) {
        ServiceResponse<Page<MetricMetadataInner>> response = listMetricMetadataNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<MetricMetadataInner>(response.body()) {
            @Override
            public Page<MetricMetadataInner> nextPage(String nextPageLink) {
                return listMetricMetadataNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the service related metrics information.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<MetricMetadataInner>> listMetricMetadataNextAsync(final String nextPageLink, final ServiceFuture<List<MetricMetadataInner>> serviceFuture, final ListOperationCallback<MetricMetadataInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricMetadataNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(String nextPageLink) {
                    return listMetricMetadataNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the service related metrics information.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MetricMetadataInner&gt; object
     */
    public Observable<Page<MetricMetadataInner>> listMetricMetadataNextAsync(final String nextPageLink) {
        return listMetricMetadataNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<MetricMetadataInner>>, Page<MetricMetadataInner>>() {
                @Override
                public Page<MetricMetadataInner> call(ServiceResponse<Page<MetricMetadataInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the service related metrics information.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;MetricMetadataInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricMetadataInner>>> listMetricMetadataNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricMetadataNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<MetricMetadataInner>>, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(ServiceResponse<Page<MetricMetadataInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricMetadataNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the service related metrics information.
     *
    ServiceResponse<PageImpl<MetricMetadataInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;MetricMetadataInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricMetadataInner>>> listMetricMetadataNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listMetricMetadataNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricMetadataInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricMetadataInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricMetadataInner>> result = listMetricMetadataNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricMetadataInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricMetadataInner>> listMetricMetadataNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<MetricMetadataInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<MetricMetadataInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of an alert for a given Active Directory Domain Controller service and server combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;AlertInner&gt; object if successful.
     */
    public PagedList<AlertInner> listServerAlertsNext(final String nextPageLink) {
        ServiceResponse<Page<AlertInner>> response = listServerAlertsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<AlertInner>(response.body()) {
            @Override
            public Page<AlertInner> nextPage(String nextPageLink) {
                return listServerAlertsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of an alert for a given Active Directory Domain Controller service and server combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AlertInner>> listServerAlertsNextAsync(final String nextPageLink, final ServiceFuture<List<AlertInner>> serviceFuture, final ListOperationCallback<AlertInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listServerAlertsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(String nextPageLink) {
                    return listServerAlertsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of an alert for a given Active Directory Domain Controller service and server combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<Page<AlertInner>> listServerAlertsNextAsync(final String nextPageLink) {
        return listServerAlertsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<AlertInner>>, Page<AlertInner>>() {
                @Override
                public Page<AlertInner> call(ServiceResponse<Page<AlertInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of an alert for a given Active Directory Domain Controller service and server combination.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AlertInner&gt; object
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listServerAlertsNextWithServiceResponseAsync(final String nextPageLink) {
        return listServerAlertsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<AlertInner>>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(ServiceResponse<Page<AlertInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listServerAlertsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of an alert for a given Active Directory Domain Controller service and server combination.
     *
    ServiceResponse<PageImpl<AlertInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;AlertInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AlertInner>>> listServerAlertsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listServerAlertsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AlertInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AlertInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AlertInner>> result = listServerAlertsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AlertInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<AlertInner>> listServerAlertsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<AlertInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<AlertInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of Active Directory Domain Services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ServicePropertiesInner&gt; object if successful.
     */
    public PagedList<ServicePropertiesInner> listPremiumServicesNext(final String nextPageLink) {
        ServiceResponse<Page<ServicePropertiesInner>> response = listPremiumServicesNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ServicePropertiesInner>(response.body()) {
            @Override
            public Page<ServicePropertiesInner> nextPage(String nextPageLink) {
                return listPremiumServicesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the details of Active Directory Domain Services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServicePropertiesInner>> listPremiumServicesNextAsync(final String nextPageLink, final ServiceFuture<List<ServicePropertiesInner>> serviceFuture, final ListOperationCallback<ServicePropertiesInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPremiumServicesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(String nextPageLink) {
                    return listPremiumServicesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the details of Active Directory Domain Services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<Page<ServicePropertiesInner>> listPremiumServicesNextAsync(final String nextPageLink) {
        return listPremiumServicesNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Page<ServicePropertiesInner>>() {
                @Override
                public Page<ServicePropertiesInner> call(ServiceResponse<Page<ServicePropertiesInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the details of Active Directory Domain Services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ServicePropertiesInner&gt; object
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listPremiumServicesNextWithServiceResponseAsync(final String nextPageLink) {
        return listPremiumServicesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ServicePropertiesInner>>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(ServiceResponse<Page<ServicePropertiesInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPremiumServicesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the details of Active Directory Domain Services for a tenant having Azure AD Premium license and is onboarded to Azure Active Directory Connect Health.
     *
    ServiceResponse<PageImpl<ServicePropertiesInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ServicePropertiesInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ServicePropertiesInner>>> listPremiumServicesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listPremiumServicesNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ServicePropertiesInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ServicePropertiesInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ServicePropertiesInner>> result = listPremiumServicesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ServicePropertiesInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ServicePropertiesInner>> listPremiumServicesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ServicePropertiesInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ServicePropertiesInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
