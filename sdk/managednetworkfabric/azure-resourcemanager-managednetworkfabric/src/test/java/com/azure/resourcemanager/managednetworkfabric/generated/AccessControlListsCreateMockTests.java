// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.managednetworkfabric.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.AzureEnvironment;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.managednetworkfabric.ManagedNetworkFabricManager;
import com.azure.resourcemanager.managednetworkfabric.models.AccessControlList;
import com.azure.resourcemanager.managednetworkfabric.models.AccessControlListAction;
import com.azure.resourcemanager.managednetworkfabric.models.AccessControlListMatchCondition;
import com.azure.resourcemanager.managednetworkfabric.models.AccessControlListMatchConfiguration;
import com.azure.resourcemanager.managednetworkfabric.models.CommonDynamicMatchConfiguration;
import com.azure.resourcemanager.managednetworkfabric.models.CommunityActionTypes;
import com.azure.resourcemanager.managednetworkfabric.models.ConfigurationType;
import com.azure.resourcemanager.managednetworkfabric.models.IpAddressType;
import com.azure.resourcemanager.managednetworkfabric.models.IpGroupProperties;
import com.azure.resourcemanager.managednetworkfabric.models.PortGroupProperties;
import com.azure.resourcemanager.managednetworkfabric.models.VlanGroupProperties;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class AccessControlListsCreateMockTests {
    @Test
    public void testCreate() throws Exception {
        String responseStr
            = "{\"properties\":{\"lastSyncedTime\":\"2021-01-14T10:52:54Z\",\"configurationState\":\"Deprovisioning\",\"provisioningState\":\"Succeeded\",\"administrativeState\":\"Disabled\",\"configurationType\":\"Inline\",\"aclsUrl\":\"jkjqpizdnuehxwlt\",\"defaultAction\":\"Permit\",\"matchConfigurations\":[{\"matchConfigurationName\":\"bnklgerxac\",\"sequenceNumber\":1385317157229113948,\"ipAddressType\":\"IPv4\",\"matchConditions\":[{},{}],\"actions\":[{}]},{\"matchConfigurationName\":\"hjrmp\",\"sequenceNumber\":5198363061422888849,\"ipAddressType\":\"IPv4\",\"matchConditions\":[{}],\"actions\":[{},{},{}]}],\"dynamicMatchConfigurations\":[{\"ipGroups\":[{}],\"vlanGroups\":[{},{},{},{}],\"portGroups\":[{},{},{},{}]},{\"ipGroups\":[{},{},{}],\"vlanGroups\":[{},{},{},{}],\"portGroups\":[{},{},{},{}]}],\"annotation\":\"armyb\"},\"location\":\"rotgeysyq\",\"tags\":{\"xia\":\"ehfwwcbf\"},\"id\":\"uvjucfjisosfzlnr\",\"name\":\"xnfyzgu\",\"type\":\"xfh\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        ManagedNetworkFabricManager manager = ManagedNetworkFabricManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureEnvironment.AZURE));

        AccessControlList response
            = manager.accessControlLists()
                .define("vbmnhtwofx")
                .withRegion("cynbu")
                .withExistingResourceGroup("tebjkjgeecwtfma")
                .withTags(mapOf("voneey", "iehedm"))
                .withConfigurationType(ConfigurationType.FILE)
                .withAclsUrl("rml")
                .withDefaultAction(CommunityActionTypes.PERMIT)
                .withMatchConfigurations(
                    Arrays.asList(
                        new AccessControlListMatchConfiguration().withMatchConfigurationName("jgqqrugwesps")
                            .withSequenceNumber(5755899523459666377L)
                            .withIpAddressType(IpAddressType.IPV6)
                            .withMatchConditions(Arrays.asList(new AccessControlListMatchCondition(),
                                new AccessControlListMatchCondition()))
                            .withActions(Arrays.asList(new AccessControlListAction(), new AccessControlListAction())),
                        new AccessControlListMatchConfiguration().withMatchConfigurationName("zfvzasupcv")
                            .withSequenceNumber(214884224548552199L)
                            .withIpAddressType(IpAddressType.IPV4)
                            .withMatchConditions(Arrays.asList(new AccessControlListMatchCondition()))
                            .withActions(Arrays.asList(new AccessControlListAction(), new AccessControlListAction())),
                        new AccessControlListMatchConfiguration().withMatchConfigurationName("m")
                            .withSequenceNumber(2567619873631405084L)
                            .withIpAddressType(IpAddressType.IPV6)
                            .withMatchConditions(Arrays.asList(new AccessControlListMatchCondition(),
                                new AccessControlListMatchCondition(), new AccessControlListMatchCondition(),
                                new AccessControlListMatchCondition()))
                            .withActions(Arrays.asList(new AccessControlListAction()))))
                .withDynamicMatchConfigurations(Arrays.asList(
                    new CommonDynamicMatchConfiguration()
                        .withIpGroups(Arrays.asList(new IpGroupProperties(), new IpGroupProperties(),
                            new IpGroupProperties(), new IpGroupProperties()))
                        .withVlanGroups(Arrays.asList(new VlanGroupProperties()))
                        .withPortGroups(Arrays.asList(new PortGroupProperties(), new PortGroupProperties())),
                    new CommonDynamicMatchConfiguration()
                        .withIpGroups(
                            Arrays.asList(new IpGroupProperties(), new IpGroupProperties(), new IpGroupProperties()))
                        .withVlanGroups(Arrays.asList(new VlanGroupProperties()))
                        .withPortGroups(Arrays.asList(new PortGroupProperties(), new PortGroupProperties(),
                            new PortGroupProperties(), new PortGroupProperties()))))
                .withAnnotation("lmajpuyxoafrmz")
                .create();

        Assertions.assertEquals("rotgeysyq", response.location());
        Assertions.assertEquals("ehfwwcbf", response.tags().get("xia"));
        Assertions.assertEquals(ConfigurationType.INLINE, response.configurationType());
        Assertions.assertEquals("jkjqpizdnuehxwlt", response.aclsUrl());
        Assertions.assertEquals(CommunityActionTypes.PERMIT, response.defaultAction());
        Assertions.assertEquals("bnklgerxac", response.matchConfigurations().get(0).matchConfigurationName());
        Assertions.assertEquals(1385317157229113948L, response.matchConfigurations().get(0).sequenceNumber());
        Assertions.assertEquals(IpAddressType.IPV4, response.matchConfigurations().get(0).ipAddressType());
        Assertions.assertEquals("armyb", response.annotation());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
