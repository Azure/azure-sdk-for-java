// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.ai.metricsadvisor.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.CookiePolicy;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.serializer.JacksonAdapter;
import com.azure.core.util.serializer.SerializerAdapter;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import reactor.core.publisher.Mono;

/** Initializes a new instance of the MetricsAdvisorClient type. */
public final class MetricsAdvisorClientImpl {
    /** The proxy service used to perform REST calls. */
    private final MetricsAdvisorClientService service;

    /**
     * Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     */
    private final String endpoint;

    /**
     * Gets Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     *
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /** The HTTP pipeline to send requests through. */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     *
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /** The serializer to serialize an object into a string. */
    private final SerializerAdapter serializerAdapter;

    /**
     * Gets The serializer to serialize an object into a string.
     *
     * @return the serializerAdapter value.
     */
    public SerializerAdapter getSerializerAdapter() {
        return this.serializerAdapter;
    }

    /**
     * Initializes an instance of MetricsAdvisorClient client.
     *
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *     https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     */
    public MetricsAdvisorClientImpl(String endpoint) {
        this(
                new HttpPipelineBuilder()
                        .policies(new UserAgentPolicy(), new RetryPolicy(), new CookiePolicy())
                        .build(),
                JacksonAdapter.createDefaultSerializerAdapter(),
                endpoint);
    }

    /**
     * Initializes an instance of MetricsAdvisorClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *     https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     */
    public MetricsAdvisorClientImpl(HttpPipeline httpPipeline, String endpoint) {
        this(httpPipeline, JacksonAdapter.createDefaultSerializerAdapter(), endpoint);
    }

    /**
     * Initializes an instance of MetricsAdvisorClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param serializerAdapter The serializer to serialize an object into a string.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *     https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     */
    public MetricsAdvisorClientImpl(HttpPipeline httpPipeline, SerializerAdapter serializerAdapter, String endpoint) {
        this.httpPipeline = httpPipeline;
        this.serializerAdapter = serializerAdapter;
        this.endpoint = endpoint;
        this.service =
                RestProxy.create(MetricsAdvisorClientService.class, this.httpPipeline, this.getSerializerAdapter());
    }

    /**
     * The interface defining all the services for MetricsAdvisorClient to be used by the proxy service to perform REST
     * calls.
     */
    @Host("{endpoint}/metricsadvisor/v1.0")
    @ServiceInterface(name = "MetricsAdvisorClient")
    private interface MetricsAdvisorClientService {
        @Get("/stats/latest")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getActiveSeriesCount(
                @HostParam("endpoint") String endpoint, RequestOptions requestOptions, Context context);

        @Get("/alert/anomaly/configurations/{configurationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                RequestOptions requestOptions,
                Context context);

        @Patch("/alert/anomaly/configurations/{configurationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> updateAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                @BodyParam("application/merge-patch+json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Delete("/alert/anomaly/configurations/{configurationId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                RequestOptions requestOptions,
                Context context);

        @Post("/alert/anomaly/configurations")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> createAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/alert/anomaly/configurations/{configurationId}/alerts/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getAlertsByAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Get("/alert/anomaly/configurations/{configurationId}/alerts/{alertId}/anomalies")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getAnomaliesFromAlertByAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                @PathParam("alertId") String alertId,
                RequestOptions requestOptions,
                Context context);

        @Get("/alert/anomaly/configurations/{configurationId}/alerts/{alertId}/incidents")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getIncidentsFromAlertByAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                @PathParam("alertId") String alertId,
                RequestOptions requestOptions,
                Context context);

        @Get("/enrichment/anomalyDetection/configurations/{configurationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                RequestOptions requestOptions,
                Context context);

        @Patch("/enrichment/anomalyDetection/configurations/{configurationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> updateAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                @BodyParam("application/merge-patch+json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Delete("/enrichment/anomalyDetection/configurations/{configurationId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                RequestOptions requestOptions,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> createAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Get("/enrichment/anomalyDetection/configurations/{configurationId}/alert/anomaly/configurations")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                RequestOptions requestOptions,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/series/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getSeriesByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/anomalies/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getAnomaliesByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/anomalies/dimension/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getDimensionOfAnomaliesByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/incidents/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getIncidentsByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Get("/enrichment/anomalyDetection/configurations/{configurationId}/incidents/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getIncidentsByAnomalyDetectionConfigurationNextPages(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                RequestOptions requestOptions,
                Context context);

        @Get("/enrichment/anomalyDetection/configurations/{configurationId}/incidents/{incidentId}/rootCause")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getRootCauseOfIncidentByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") String configurationId,
                @PathParam("incidentId") String incidentId,
                RequestOptions requestOptions,
                Context context);

        @Post("/credentials")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> createCredential(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Get("/credentials")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listCredentials(
                @HostParam("endpoint") String endpoint, RequestOptions requestOptions, Context context);

        @Patch("/credentials/{credentialId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> updateCredential(
                @HostParam("endpoint") String endpoint,
                @PathParam("credentialId") String credentialId,
                @BodyParam("application/merge-patch+json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Delete("/credentials/{credentialId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteCredential(
                @HostParam("endpoint") String endpoint,
                @PathParam("credentialId") String credentialId,
                RequestOptions requestOptions,
                Context context);

        @Get("/credentials/{credentialId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getCredential(
                @HostParam("endpoint") String endpoint,
                @PathParam("credentialId") String credentialId,
                RequestOptions requestOptions,
                Context context);

        @Get("/dataFeeds")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listDataFeeds(
                @HostParam("endpoint") String endpoint, RequestOptions requestOptions, Context context);

        @Post("/dataFeeds")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> createDataFeed(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Get("/dataFeeds/{dataFeedId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getDataFeedById(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") String dataFeedId,
                RequestOptions requestOptions,
                Context context);

        @Patch("/dataFeeds/{dataFeedId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> updateDataFeed(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") String dataFeedId,
                @BodyParam("application/merge-patch+json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Delete("/dataFeeds/{dataFeedId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteDataFeed(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") String dataFeedId,
                RequestOptions requestOptions,
                Context context);

        @Get("/feedback/metric/{feedbackId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getMetricFeedback(
                @HostParam("endpoint") String endpoint,
                @PathParam("feedbackId") String feedbackId,
                RequestOptions requestOptions,
                Context context);

        @Post("/feedback/metric/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listMetricFeedbacks(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/feedback/metric")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> createMetricFeedback(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Get("/hooks")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listHooks(
                @HostParam("endpoint") String endpoint, RequestOptions requestOptions, Context context);

        @Post("/hooks")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> createHook(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Get("/hooks/{hookId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getHook(
                @HostParam("endpoint") String endpoint,
                @PathParam("hookId") String hookId,
                RequestOptions requestOptions,
                Context context);

        @Patch("/hooks/{hookId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> updateHook(
                @HostParam("endpoint") String endpoint,
                @PathParam("hookId") String hookId,
                @BodyParam("application/merge-patch+json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Delete("/hooks/{hookId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> deleteHook(
                @HostParam("endpoint") String endpoint,
                @PathParam("hookId") String hookId,
                RequestOptions requestOptions,
                Context context);

        @Post("/dataFeeds/{dataFeedId}/ingestionStatus/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getDataFeedIngestionStatus(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") String dataFeedId,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/dataFeeds/{dataFeedId}/ingestionProgress/reset")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> resetDataFeedIngestionStatus(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") String dataFeedId,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Get("/dataFeeds/{dataFeedId}/ingestionProgress")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getIngestionProgress(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") String dataFeedId,
                RequestOptions requestOptions,
                Context context);

        @Post("/metrics/{metricId}/data/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getMetricData(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") String metricId,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/metrics/{metricId}/series/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getMetricSeries(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") String metricId,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/metrics/{metricId}/dimension/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getMetricDimension(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") String metricId,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Get("/metrics/{metricId}/enrichment/anomalyDetection/configurations")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getAnomalyDetectionConfigurationsByMetric(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") String metricId,
                RequestOptions requestOptions,
                Context context);

        @Post("/metrics/{metricId}/status/enrichment/anomalyDetection/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getEnrichmentStatusByMetric(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") String metricId,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/{nextlink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getAlertsByAnomalyAlertingConfigurationNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/{nextlink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getAnomaliesByAnomalyDetectionConfigurationNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/{nextlink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/{nextlink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listMetricFeedbacksNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/{nextlink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getDataFeedIngestionStatusNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/{nextlink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getMetricSeriesNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/{nextlink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getMetricDimensionNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Post("/{nextlink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getEnrichmentStatusByMetricNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") BinaryData body,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getAnomaliesFromAlertByAnomalyAlertingConfigurationNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getIncidentsFromAlertByAnomalyAlertingConfigurationNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getIncidentsByAnomalyDetectionConfigurationNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getIncidentsByAnomalyDetectionConfigurationNextPagesNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listCredentialsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listDataFeedsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listHooksNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getAnomalyDetectionConfigurationsByMetricNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                RequestOptions requestOptions,
                Context context);
    }

    /**
     * Get latest usage stats.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     timestamp: String
     *     activeSeriesCount: Integer
     *     allSeriesCount: Integer
     *     metricsCount: Integer
     *     dataFeedCount: Integer
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return latest usage stats along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getActiveSeriesCountWithResponseAsync(RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.getActiveSeriesCount(this.getEndpoint(), requestOptions, context));
    }

    /**
     * Get latest usage stats.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     timestamp: String
     *     activeSeriesCount: Integer
     *     allSeriesCount: Integer
     *     metricsCount: Integer
     *     dataFeedCount: Integer
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return latest usage stats along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getActiveSeriesCountWithResponseAsync(
            RequestOptions requestOptions, Context context) {
        return service.getActiveSeriesCount(this.getEndpoint(), requestOptions, context);
    }

    /**
     * Get latest usage stats.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     timestamp: String
     *     activeSeriesCount: Integer
     *     allSeriesCount: Integer
     *     metricsCount: Integer
     *     dataFeedCount: Integer
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return latest usage stats along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getActiveSeriesCountWithResponse(RequestOptions requestOptions) {
        return getActiveSeriesCountWithResponseAsync(requestOptions).block();
    }

    /**
     * Query a single anomaly alerting configuration.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyAlertingConfigurationId: String
     *     name: String
     *     description: String
     *     crossMetricsOperator: String(AND/OR/XOR)
     *     splitAlertByDimensions: [
     *         String
     *     ]
     *     hookIds: [
     *         String
     *     ]
     *     metricAlertingConfigurations: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             anomalyScopeType: String(All/Dimension/TopN)
     *             negationOperation: Boolean
     *             dimensionAnomalyScope: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             topNAnomalyScope: {
     *                 top: int
     *                 period: int
     *                 minTopCount: int
     *             }
     *             severityFilter: {
     *                 minAlertSeverity: String(Low/Medium/High)
     *                 maxAlertSeverity: String(Low/Medium/High)
     *             }
     *             snoozeFilter: {
     *                 autoSnooze: int
     *                 snoozeScope: String(Metric/Series)
     *                 onlyForSuccessive: boolean
     *             }
     *             valueFilter: {
     *                 lower: Double
     *                 upper: Double
     *                 direction: String(Both/Down/Up)
     *                 type: String(Value/Mean)
     *                 metricId: String
     *                 triggerForMissing: Boolean
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAnomalyAlertingConfigurationWithResponseAsync(
            String configurationId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.getAnomalyAlertingConfiguration(
                                this.getEndpoint(), configurationId, requestOptions, context));
    }

    /**
     * Query a single anomaly alerting configuration.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyAlertingConfigurationId: String
     *     name: String
     *     description: String
     *     crossMetricsOperator: String(AND/OR/XOR)
     *     splitAlertByDimensions: [
     *         String
     *     ]
     *     hookIds: [
     *         String
     *     ]
     *     metricAlertingConfigurations: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             anomalyScopeType: String(All/Dimension/TopN)
     *             negationOperation: Boolean
     *             dimensionAnomalyScope: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             topNAnomalyScope: {
     *                 top: int
     *                 period: int
     *                 minTopCount: int
     *             }
     *             severityFilter: {
     *                 minAlertSeverity: String(Low/Medium/High)
     *                 maxAlertSeverity: String(Low/Medium/High)
     *             }
     *             snoozeFilter: {
     *                 autoSnooze: int
     *                 snoozeScope: String(Metric/Series)
     *                 onlyForSuccessive: boolean
     *             }
     *             valueFilter: {
     *                 lower: Double
     *                 upper: Double
     *                 direction: String(Both/Down/Up)
     *                 type: String(Value/Mean)
     *                 metricId: String
     *                 triggerForMissing: Boolean
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAnomalyAlertingConfigurationWithResponseAsync(
            String configurationId, RequestOptions requestOptions, Context context) {
        return service.getAnomalyAlertingConfiguration(this.getEndpoint(), configurationId, requestOptions, context);
    }

    /**
     * Query a single anomaly alerting configuration.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyAlertingConfigurationId: String
     *     name: String
     *     description: String
     *     crossMetricsOperator: String(AND/OR/XOR)
     *     splitAlertByDimensions: [
     *         String
     *     ]
     *     hookIds: [
     *         String
     *     ]
     *     metricAlertingConfigurations: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             anomalyScopeType: String(All/Dimension/TopN)
     *             negationOperation: Boolean
     *             dimensionAnomalyScope: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             topNAnomalyScope: {
     *                 top: int
     *                 period: int
     *                 minTopCount: int
     *             }
     *             severityFilter: {
     *                 minAlertSeverity: String(Low/Medium/High)
     *                 maxAlertSeverity: String(Low/Medium/High)
     *             }
     *             snoozeFilter: {
     *                 autoSnooze: int
     *                 snoozeScope: String(Metric/Series)
     *                 onlyForSuccessive: boolean
     *             }
     *             valueFilter: {
     *                 lower: Double
     *                 upper: Double
     *                 direction: String(Both/Down/Up)
     *                 type: String(Value/Mean)
     *                 metricId: String
     *                 triggerForMissing: Boolean
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getAnomalyAlertingConfigurationWithResponse(
            String configurationId, RequestOptions requestOptions) {
        return getAnomalyAlertingConfigurationWithResponseAsync(configurationId, requestOptions).block();
    }

    /**
     * Update anomaly alerting configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     name: String
     *     description: String
     *     crossMetricsOperator: String(AND/OR/XOR)
     *     splitAlertByDimensions: [
     *         String
     *     ]
     *     hookIds: [
     *         String
     *     ]
     *     metricAlertingConfigurations: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             anomalyScopeType: String(All/Dimension/TopN)
     *             negationOperation: Boolean
     *             dimensionAnomalyScope: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             topNAnomalyScope: {
     *                 top: int
     *                 period: int
     *                 minTopCount: int
     *             }
     *             severityFilter: {
     *                 minAlertSeverity: String(Low/Medium/High)
     *                 maxAlertSeverity: String(Low/Medium/High)
     *             }
     *             snoozeFilter: {
     *                 autoSnooze: int
     *                 snoozeScope: String(Metric/Series)
     *                 onlyForSuccessive: boolean
     *             }
     *             valueFilter: {
     *                 lower: Double
     *                 upper: Double
     *                 direction: String(Both/Down/Up)
     *                 type: String(Value/Mean)
     *                 metricId: String
     *                 triggerForMissing: Boolean
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyAlertingConfigurationId: String
     *     name: String
     *     description: String
     *     crossMetricsOperator: String(AND/OR/XOR)
     *     splitAlertByDimensions: [
     *         String
     *     ]
     *     hookIds: [
     *         String
     *     ]
     *     metricAlertingConfigurations: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             anomalyScopeType: String(All/Dimension/TopN)
     *             negationOperation: Boolean
     *             dimensionAnomalyScope: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             topNAnomalyScope: {
     *                 top: int
     *                 period: int
     *                 minTopCount: int
     *             }
     *             severityFilter: {
     *                 minAlertSeverity: String(Low/Medium/High)
     *                 maxAlertSeverity: String(Low/Medium/High)
     *             }
     *             snoozeFilter: {
     *                 autoSnooze: int
     *                 snoozeScope: String(Metric/Series)
     *                 onlyForSuccessive: boolean
     *             }
     *             valueFilter: {
     *                 lower: Double
     *                 upper: Double
     *                 direction: String(Both/Down/Up)
     *                 type: String(Value/Mean)
     *                 metricId: String
     *                 triggerForMissing: Boolean
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> updateAnomalyAlertingConfigurationWithResponseAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.updateAnomalyAlertingConfiguration(
                                this.getEndpoint(), configurationId, body, requestOptions, context));
    }

    /**
     * Update anomaly alerting configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     name: String
     *     description: String
     *     crossMetricsOperator: String(AND/OR/XOR)
     *     splitAlertByDimensions: [
     *         String
     *     ]
     *     hookIds: [
     *         String
     *     ]
     *     metricAlertingConfigurations: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             anomalyScopeType: String(All/Dimension/TopN)
     *             negationOperation: Boolean
     *             dimensionAnomalyScope: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             topNAnomalyScope: {
     *                 top: int
     *                 period: int
     *                 minTopCount: int
     *             }
     *             severityFilter: {
     *                 minAlertSeverity: String(Low/Medium/High)
     *                 maxAlertSeverity: String(Low/Medium/High)
     *             }
     *             snoozeFilter: {
     *                 autoSnooze: int
     *                 snoozeScope: String(Metric/Series)
     *                 onlyForSuccessive: boolean
     *             }
     *             valueFilter: {
     *                 lower: Double
     *                 upper: Double
     *                 direction: String(Both/Down/Up)
     *                 type: String(Value/Mean)
     *                 metricId: String
     *                 triggerForMissing: Boolean
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyAlertingConfigurationId: String
     *     name: String
     *     description: String
     *     crossMetricsOperator: String(AND/OR/XOR)
     *     splitAlertByDimensions: [
     *         String
     *     ]
     *     hookIds: [
     *         String
     *     ]
     *     metricAlertingConfigurations: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             anomalyScopeType: String(All/Dimension/TopN)
     *             negationOperation: Boolean
     *             dimensionAnomalyScope: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             topNAnomalyScope: {
     *                 top: int
     *                 period: int
     *                 minTopCount: int
     *             }
     *             severityFilter: {
     *                 minAlertSeverity: String(Low/Medium/High)
     *                 maxAlertSeverity: String(Low/Medium/High)
     *             }
     *             snoozeFilter: {
     *                 autoSnooze: int
     *                 snoozeScope: String(Metric/Series)
     *                 onlyForSuccessive: boolean
     *             }
     *             valueFilter: {
     *                 lower: Double
     *                 upper: Double
     *                 direction: String(Both/Down/Up)
     *                 type: String(Value/Mean)
     *                 metricId: String
     *                 triggerForMissing: Boolean
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> updateAnomalyAlertingConfigurationWithResponseAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.updateAnomalyAlertingConfiguration(
                this.getEndpoint(), configurationId, body, requestOptions, context);
    }

    /**
     * Update anomaly alerting configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     name: String
     *     description: String
     *     crossMetricsOperator: String(AND/OR/XOR)
     *     splitAlertByDimensions: [
     *         String
     *     ]
     *     hookIds: [
     *         String
     *     ]
     *     metricAlertingConfigurations: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             anomalyScopeType: String(All/Dimension/TopN)
     *             negationOperation: Boolean
     *             dimensionAnomalyScope: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             topNAnomalyScope: {
     *                 top: int
     *                 period: int
     *                 minTopCount: int
     *             }
     *             severityFilter: {
     *                 minAlertSeverity: String(Low/Medium/High)
     *                 maxAlertSeverity: String(Low/Medium/High)
     *             }
     *             snoozeFilter: {
     *                 autoSnooze: int
     *                 snoozeScope: String(Metric/Series)
     *                 onlyForSuccessive: boolean
     *             }
     *             valueFilter: {
     *                 lower: Double
     *                 upper: Double
     *                 direction: String(Both/Down/Up)
     *                 type: String(Value/Mean)
     *                 metricId: String
     *                 triggerForMissing: Boolean
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyAlertingConfigurationId: String
     *     name: String
     *     description: String
     *     crossMetricsOperator: String(AND/OR/XOR)
     *     splitAlertByDimensions: [
     *         String
     *     ]
     *     hookIds: [
     *         String
     *     ]
     *     metricAlertingConfigurations: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             anomalyScopeType: String(All/Dimension/TopN)
     *             negationOperation: Boolean
     *             dimensionAnomalyScope: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             topNAnomalyScope: {
     *                 top: int
     *                 period: int
     *                 minTopCount: int
     *             }
     *             severityFilter: {
     *                 minAlertSeverity: String(Low/Medium/High)
     *                 maxAlertSeverity: String(Low/Medium/High)
     *             }
     *             snoozeFilter: {
     *                 autoSnooze: int
     *                 snoozeScope: String(Metric/Series)
     *                 onlyForSuccessive: boolean
     *             }
     *             valueFilter: {
     *                 lower: Double
     *                 upper: Double
     *                 direction: String(Both/Down/Up)
     *                 type: String(Value/Mean)
     *                 metricId: String
     *                 triggerForMissing: Boolean
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> updateAnomalyAlertingConfigurationWithResponse(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return updateAnomalyAlertingConfigurationWithResponseAsync(configurationId, body, requestOptions).block();
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAnomalyAlertingConfigurationWithResponseAsync(
            String configurationId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.deleteAnomalyAlertingConfiguration(
                                this.getEndpoint(), configurationId, requestOptions, context));
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAnomalyAlertingConfigurationWithResponseAsync(
            String configurationId, RequestOptions requestOptions, Context context) {
        return service.deleteAnomalyAlertingConfiguration(this.getEndpoint(), configurationId, requestOptions, context);
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteAnomalyAlertingConfigurationWithResponse(
            String configurationId, RequestOptions requestOptions) {
        return deleteAnomalyAlertingConfigurationWithResponseAsync(configurationId, requestOptions).block();
    }

    /**
     * Create anomaly alerting configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyAlertingConfigurationId: String
     *     name: String
     *     description: String
     *     crossMetricsOperator: String(AND/OR/XOR)
     *     splitAlertByDimensions: [
     *         String
     *     ]
     *     hookIds: [
     *         String
     *     ]
     *     metricAlertingConfigurations: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             anomalyScopeType: String(All/Dimension/TopN)
     *             negationOperation: Boolean
     *             dimensionAnomalyScope: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             topNAnomalyScope: {
     *                 top: int
     *                 period: int
     *                 minTopCount: int
     *             }
     *             severityFilter: {
     *                 minAlertSeverity: String(Low/Medium/High)
     *                 maxAlertSeverity: String(Low/Medium/High)
     *             }
     *             snoozeFilter: {
     *                 autoSnooze: int
     *                 snoozeScope: String(Metric/Series)
     *                 onlyForSuccessive: boolean
     *             }
     *             valueFilter: {
     *                 lower: Double
     *                 upper: Double
     *                 direction: String(Both/Down/Up)
     *                 type: String(Value/Mean)
     *                 metricId: String
     *                 triggerForMissing: Boolean
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param body anomaly alerting configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createAnomalyAlertingConfigurationWithResponseAsync(
            BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.createAnomalyAlertingConfiguration(this.getEndpoint(), body, requestOptions, context));
    }

    /**
     * Create anomaly alerting configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyAlertingConfigurationId: String
     *     name: String
     *     description: String
     *     crossMetricsOperator: String(AND/OR/XOR)
     *     splitAlertByDimensions: [
     *         String
     *     ]
     *     hookIds: [
     *         String
     *     ]
     *     metricAlertingConfigurations: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             anomalyScopeType: String(All/Dimension/TopN)
     *             negationOperation: Boolean
     *             dimensionAnomalyScope: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             topNAnomalyScope: {
     *                 top: int
     *                 period: int
     *                 minTopCount: int
     *             }
     *             severityFilter: {
     *                 minAlertSeverity: String(Low/Medium/High)
     *                 maxAlertSeverity: String(Low/Medium/High)
     *             }
     *             snoozeFilter: {
     *                 autoSnooze: int
     *                 snoozeScope: String(Metric/Series)
     *                 onlyForSuccessive: boolean
     *             }
     *             valueFilter: {
     *                 lower: Double
     *                 upper: Double
     *                 direction: String(Both/Down/Up)
     *                 type: String(Value/Mean)
     *                 metricId: String
     *                 triggerForMissing: Boolean
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param body anomaly alerting configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createAnomalyAlertingConfigurationWithResponseAsync(
            BinaryData body, RequestOptions requestOptions, Context context) {
        return service.createAnomalyAlertingConfiguration(this.getEndpoint(), body, requestOptions, context);
    }

    /**
     * Create anomaly alerting configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyAlertingConfigurationId: String
     *     name: String
     *     description: String
     *     crossMetricsOperator: String(AND/OR/XOR)
     *     splitAlertByDimensions: [
     *         String
     *     ]
     *     hookIds: [
     *         String
     *     ]
     *     metricAlertingConfigurations: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             anomalyScopeType: String(All/Dimension/TopN)
     *             negationOperation: Boolean
     *             dimensionAnomalyScope: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             topNAnomalyScope: {
     *                 top: int
     *                 period: int
     *                 minTopCount: int
     *             }
     *             severityFilter: {
     *                 minAlertSeverity: String(Low/Medium/High)
     *                 maxAlertSeverity: String(Low/Medium/High)
     *             }
     *             snoozeFilter: {
     *                 autoSnooze: int
     *                 snoozeScope: String(Metric/Series)
     *                 onlyForSuccessive: boolean
     *             }
     *             valueFilter: {
     *                 lower: Double
     *                 upper: Double
     *                 direction: String(Both/Down/Up)
     *                 type: String(Value/Mean)
     *                 metricId: String
     *                 triggerForMissing: Boolean
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param body anomaly alerting configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createAnomalyAlertingConfigurationWithResponse(
            BinaryData body, RequestOptions requestOptions) {
        return createAnomalyAlertingConfigurationWithResponseAsync(body, requestOptions).block();
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     timeMode: String(AnomalyTime/CreatedTime/ModifiedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             alertId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAlertsByAnomalyAlertingConfigurationSinglePageAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getAlertsByAnomalyAlertingConfiguration(
                                        this.getEndpoint(), configurationId, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     timeMode: String(AnomalyTime/CreatedTime/ModifiedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             alertId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAlertsByAnomalyAlertingConfigurationSinglePageAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getAlertsByAnomalyAlertingConfiguration(
                        this.getEndpoint(), configurationId, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     timeMode: String(AnomalyTime/CreatedTime/ModifiedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             alertId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getAlertsByAnomalyAlertingConfigurationAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return new PagedFlux<>(
                () -> getAlertsByAnomalyAlertingConfigurationSinglePageAsync(configurationId, body, requestOptions),
                nextLink -> getAlertsByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink, body, null));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     timeMode: String(AnomalyTime/CreatedTime/ModifiedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             alertId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getAlertsByAnomalyAlertingConfigurationAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () ->
                        getAlertsByAnomalyAlertingConfigurationSinglePageAsync(
                                configurationId, body, requestOptions, context),
                nextLink -> getAlertsByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink, body, null, context));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     timeMode: String(AnomalyTime/CreatedTime/ModifiedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             alertId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getAlertsByAnomalyAlertingConfiguration(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return new PagedIterable<>(getAlertsByAnomalyAlertingConfigurationAsync(configurationId, body, requestOptions));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
            String configurationId, String alertId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getAnomaliesFromAlertByAnomalyAlertingConfiguration(
                                        this.getEndpoint(), configurationId, alertId, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
            String configurationId, String alertId, RequestOptions requestOptions, Context context) {
        return service.getAnomaliesFromAlertByAnomalyAlertingConfiguration(
                        this.getEndpoint(), configurationId, alertId, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getAnomaliesFromAlertByAnomalyAlertingConfigurationAsync(
            String configurationId, String alertId, RequestOptions requestOptions) {
        return new PagedFlux<>(
                () ->
                        getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
                                configurationId, alertId, requestOptions),
                nextLink -> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink, null));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getAnomaliesFromAlertByAnomalyAlertingConfigurationAsync(
            String configurationId, String alertId, RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () ->
                        getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
                                configurationId, alertId, requestOptions, context),
                nextLink ->
                        getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(
                                nextLink, null, context));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getAnomaliesFromAlertByAnomalyAlertingConfiguration(
            String configurationId, String alertId, RequestOptions requestOptions) {
        return new PagedIterable<>(
                getAnomaliesFromAlertByAnomalyAlertingConfigurationAsync(configurationId, alertId, requestOptions));
    }

    /**
     * Query incidents under a specific alert.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
            String configurationId, String alertId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getIncidentsFromAlertByAnomalyAlertingConfiguration(
                                        this.getEndpoint(), configurationId, alertId, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query incidents under a specific alert.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
            String configurationId, String alertId, RequestOptions requestOptions, Context context) {
        return service.getIncidentsFromAlertByAnomalyAlertingConfiguration(
                        this.getEndpoint(), configurationId, alertId, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query incidents under a specific alert.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getIncidentsFromAlertByAnomalyAlertingConfigurationAsync(
            String configurationId, String alertId, RequestOptions requestOptions) {
        return new PagedFlux<>(
                () ->
                        getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
                                configurationId, alertId, requestOptions),
                nextLink -> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink, null));
    }

    /**
     * Query incidents under a specific alert.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getIncidentsFromAlertByAnomalyAlertingConfigurationAsync(
            String configurationId, String alertId, RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () ->
                        getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
                                configurationId, alertId, requestOptions, context),
                nextLink ->
                        getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(
                                nextLink, null, context));
    }

    /**
     * Query incidents under a specific alert.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getIncidentsFromAlertByAnomalyAlertingConfiguration(
            String configurationId, String alertId, RequestOptions requestOptions) {
        return new PagedIterable<>(
                getIncidentsFromAlertByAnomalyAlertingConfigurationAsync(configurationId, alertId, requestOptions));
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyDetectionConfigurationId: String
     *     name: String
     *     description: String
     *     metricId: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: int
     *                 minRatio: double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: double
     *             shiftPoint: int
     *             withinRange: boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAnomalyDetectionConfigurationWithResponseAsync(
            String configurationId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.getAnomalyDetectionConfiguration(
                                this.getEndpoint(), configurationId, requestOptions, context));
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyDetectionConfigurationId: String
     *     name: String
     *     description: String
     *     metricId: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: int
     *                 minRatio: double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: double
     *             shiftPoint: int
     *             withinRange: boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAnomalyDetectionConfigurationWithResponseAsync(
            String configurationId, RequestOptions requestOptions, Context context) {
        return service.getAnomalyDetectionConfiguration(this.getEndpoint(), configurationId, requestOptions, context);
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyDetectionConfigurationId: String
     *     name: String
     *     description: String
     *     metricId: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: int
     *                 minRatio: double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: double
     *             shiftPoint: int
     *             withinRange: boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getAnomalyDetectionConfigurationWithResponse(
            String configurationId, RequestOptions requestOptions) {
        return getAnomalyDetectionConfigurationWithResponseAsync(configurationId, requestOptions).block();
    }

    /**
     * Update anomaly detection configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     name: String
     *     description: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: Integer
     *                 minRatio: Double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: Double
     *             shiftPoint: Integer
     *             withinRange: Boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: {
     *                 sensitivity: double
     *                 anomalyDetectorDirection: String(Both/Down/Up)
     *                 suppressCondition: {
     *                     minNumber: int
     *                     minRatio: double
     *                 }
     *             }
     *             hardThresholdCondition: {
     *                 lowerBound: Double
     *                 upperBound: Double
     *                 anomalyDetectorDirection: String(Both/Down/Up)
     *                 suppressCondition: (recursive schema, see suppressCondition above)
     *             }
     *             changeThresholdCondition: {
     *                 changePercentage: double
     *                 shiftPoint: int
     *                 withinRange: boolean
     *                 anomalyDetectorDirection: String(Both/Down/Up)
     *                 suppressCondition: (recursive schema, see suppressCondition above)
     *             }
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyDetectionConfigurationId: String
     *     name: String
     *     description: String
     *     metricId: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: int
     *                 minRatio: double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: double
     *             shiftPoint: int
     *             withinRange: boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> updateAnomalyDetectionConfigurationWithResponseAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.updateAnomalyDetectionConfiguration(
                                this.getEndpoint(), configurationId, body, requestOptions, context));
    }

    /**
     * Update anomaly detection configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     name: String
     *     description: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: Integer
     *                 minRatio: Double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: Double
     *             shiftPoint: Integer
     *             withinRange: Boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: {
     *                 sensitivity: double
     *                 anomalyDetectorDirection: String(Both/Down/Up)
     *                 suppressCondition: {
     *                     minNumber: int
     *                     minRatio: double
     *                 }
     *             }
     *             hardThresholdCondition: {
     *                 lowerBound: Double
     *                 upperBound: Double
     *                 anomalyDetectorDirection: String(Both/Down/Up)
     *                 suppressCondition: (recursive schema, see suppressCondition above)
     *             }
     *             changeThresholdCondition: {
     *                 changePercentage: double
     *                 shiftPoint: int
     *                 withinRange: boolean
     *                 anomalyDetectorDirection: String(Both/Down/Up)
     *                 suppressCondition: (recursive schema, see suppressCondition above)
     *             }
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyDetectionConfigurationId: String
     *     name: String
     *     description: String
     *     metricId: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: int
     *                 minRatio: double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: double
     *             shiftPoint: int
     *             withinRange: boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> updateAnomalyDetectionConfigurationWithResponseAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.updateAnomalyDetectionConfiguration(
                this.getEndpoint(), configurationId, body, requestOptions, context);
    }

    /**
     * Update anomaly detection configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     name: String
     *     description: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: Integer
     *                 minRatio: Double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: Double
     *             shiftPoint: Integer
     *             withinRange: Boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: {
     *                 sensitivity: double
     *                 anomalyDetectorDirection: String(Both/Down/Up)
     *                 suppressCondition: {
     *                     minNumber: int
     *                     minRatio: double
     *                 }
     *             }
     *             hardThresholdCondition: {
     *                 lowerBound: Double
     *                 upperBound: Double
     *                 anomalyDetectorDirection: String(Both/Down/Up)
     *                 suppressCondition: (recursive schema, see suppressCondition above)
     *             }
     *             changeThresholdCondition: {
     *                 changePercentage: double
     *                 shiftPoint: int
     *                 withinRange: boolean
     *                 anomalyDetectorDirection: String(Both/Down/Up)
     *                 suppressCondition: (recursive schema, see suppressCondition above)
     *             }
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyDetectionConfigurationId: String
     *     name: String
     *     description: String
     *     metricId: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: int
     *                 minRatio: double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: double
     *             shiftPoint: int
     *             withinRange: boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> updateAnomalyDetectionConfigurationWithResponse(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return updateAnomalyDetectionConfigurationWithResponseAsync(configurationId, body, requestOptions).block();
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAnomalyDetectionConfigurationWithResponseAsync(
            String configurationId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.deleteAnomalyDetectionConfiguration(
                                this.getEndpoint(), configurationId, requestOptions, context));
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAnomalyDetectionConfigurationWithResponseAsync(
            String configurationId, RequestOptions requestOptions, Context context) {
        return service.deleteAnomalyDetectionConfiguration(
                this.getEndpoint(), configurationId, requestOptions, context);
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteAnomalyDetectionConfigurationWithResponse(
            String configurationId, RequestOptions requestOptions) {
        return deleteAnomalyDetectionConfigurationWithResponseAsync(configurationId, requestOptions).block();
    }

    /**
     * Create anomaly detection configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyDetectionConfigurationId: String
     *     name: String
     *     description: String
     *     metricId: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: int
     *                 minRatio: double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: double
     *             shiftPoint: int
     *             withinRange: boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param body anomaly detection configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createAnomalyDetectionConfigurationWithResponseAsync(
            BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.createAnomalyDetectionConfiguration(this.getEndpoint(), body, requestOptions, context));
    }

    /**
     * Create anomaly detection configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyDetectionConfigurationId: String
     *     name: String
     *     description: String
     *     metricId: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: int
     *                 minRatio: double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: double
     *             shiftPoint: int
     *             withinRange: boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param body anomaly detection configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createAnomalyDetectionConfigurationWithResponseAsync(
            BinaryData body, RequestOptions requestOptions, Context context) {
        return service.createAnomalyDetectionConfiguration(this.getEndpoint(), body, requestOptions, context);
    }

    /**
     * Create anomaly detection configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     anomalyDetectionConfigurationId: String
     *     name: String
     *     description: String
     *     metricId: String
     *     wholeMetricConfiguration: {
     *         conditionOperator: String(AND/OR)
     *         smartDetectionCondition: {
     *             sensitivity: double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: {
     *                 minNumber: int
     *                 minRatio: double
     *             }
     *         }
     *         hardThresholdCondition: {
     *             lowerBound: Double
     *             upperBound: Double
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *         changeThresholdCondition: {
     *             changePercentage: double
     *             shiftPoint: int
     *             withinRange: boolean
     *             anomalyDetectorDirection: String(Both/Down/Up)
     *             suppressCondition: (recursive schema, see suppressCondition above)
     *         }
     *     }
     *     dimensionGroupOverrideConfigurations: [
     *         {
     *             group: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     *     seriesOverrideConfigurations: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             conditionOperator: String(AND/OR)
     *             smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *             hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *             changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param body anomaly detection configuration.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createAnomalyDetectionConfigurationWithResponse(
            BinaryData body, RequestOptions requestOptions) {
        return createAnomalyDetectionConfigurationWithResponseAsync(body, requestOptions).block();
    }

    /**
     * List all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyAlertingConfigurationId: String
     *             name: String
     *             description: String
     *             crossMetricsOperator: String(AND/OR/XOR)
     *             splitAlertByDimensions: [
     *                 String
     *             ]
     *             hookIds: [
     *                 String
     *             ]
     *             metricAlertingConfigurations: [
     *                 {
     *                     anomalyDetectionConfigurationId: String
     *                     anomalyScopeType: String(All/Dimension/TopN)
     *                     negationOperation: Boolean
     *                     dimensionAnomalyScope: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     topNAnomalyScope: {
     *                         top: int
     *                         period: int
     *                         minTopCount: int
     *                     }
     *                     severityFilter: {
     *                         minAlertSeverity: String(Low/Medium/High)
     *                         maxAlertSeverity: String(Low/Medium/High)
     *                     }
     *                     snoozeFilter: {
     *                         autoSnooze: int
     *                         snoozeScope: String(Metric/Series)
     *                         onlyForSuccessive: boolean
     *                     }
     *                     valueFilter: {
     *                         lower: Double
     *                         upper: Double
     *                         direction: String(Both/Down/Up)
     *                         type: String(Value/Mean)
     *                         metricId: String
     *                         triggerForMissing: Boolean
     *                     }
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>>
            getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationSinglePageAsync(
                    String configurationId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
                                        this.getEndpoint(), configurationId, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyAlertingConfigurationId: String
     *             name: String
     *             description: String
     *             crossMetricsOperator: String(AND/OR/XOR)
     *             splitAlertByDimensions: [
     *                 String
     *             ]
     *             hookIds: [
     *                 String
     *             ]
     *             metricAlertingConfigurations: [
     *                 {
     *                     anomalyDetectionConfigurationId: String
     *                     anomalyScopeType: String(All/Dimension/TopN)
     *                     negationOperation: Boolean
     *                     dimensionAnomalyScope: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     topNAnomalyScope: {
     *                         top: int
     *                         period: int
     *                         minTopCount: int
     *                     }
     *                     severityFilter: {
     *                         minAlertSeverity: String(Low/Medium/High)
     *                         maxAlertSeverity: String(Low/Medium/High)
     *                     }
     *                     snoozeFilter: {
     *                         autoSnooze: int
     *                         snoozeScope: String(Metric/Series)
     *                         onlyForSuccessive: boolean
     *                     }
     *                     valueFilter: {
     *                         lower: Double
     *                         upper: Double
     *                         direction: String(Both/Down/Up)
     *                         type: String(Value/Mean)
     *                         metricId: String
     *                         triggerForMissing: Boolean
     *                     }
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>>
            getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationSinglePageAsync(
                    String configurationId, RequestOptions requestOptions, Context context) {
        return service.getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
                        this.getEndpoint(), configurationId, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyAlertingConfigurationId: String
     *             name: String
     *             description: String
     *             crossMetricsOperator: String(AND/OR/XOR)
     *             splitAlertByDimensions: [
     *                 String
     *             ]
     *             hookIds: [
     *                 String
     *             ]
     *             metricAlertingConfigurations: [
     *                 {
     *                     anomalyDetectionConfigurationId: String
     *                     anomalyScopeType: String(All/Dimension/TopN)
     *                     negationOperation: Boolean
     *                     dimensionAnomalyScope: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     topNAnomalyScope: {
     *                         top: int
     *                         period: int
     *                         minTopCount: int
     *                     }
     *                     severityFilter: {
     *                         minAlertSeverity: String(Low/Medium/High)
     *                         maxAlertSeverity: String(Low/Medium/High)
     *                     }
     *                     snoozeFilter: {
     *                         autoSnooze: int
     *                         snoozeScope: String(Metric/Series)
     *                         onlyForSuccessive: boolean
     *                     }
     *                     valueFilter: {
     *                         lower: Double
     *                         upper: Double
     *                         direction: String(Both/Down/Up)
     *                         type: String(Value/Mean)
     *                         metricId: String
     *                         triggerForMissing: Boolean
     *                     }
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationAsync(
            String configurationId, RequestOptions requestOptions) {
        return new PagedFlux<>(
                () ->
                        getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, requestOptions),
                nextLink ->
                        getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNextSinglePageAsync(
                                nextLink, null));
    }

    /**
     * List all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyAlertingConfigurationId: String
     *             name: String
     *             description: String
     *             crossMetricsOperator: String(AND/OR/XOR)
     *             splitAlertByDimensions: [
     *                 String
     *             ]
     *             hookIds: [
     *                 String
     *             ]
     *             metricAlertingConfigurations: [
     *                 {
     *                     anomalyDetectionConfigurationId: String
     *                     anomalyScopeType: String(All/Dimension/TopN)
     *                     negationOperation: Boolean
     *                     dimensionAnomalyScope: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     topNAnomalyScope: {
     *                         top: int
     *                         period: int
     *                         minTopCount: int
     *                     }
     *                     severityFilter: {
     *                         minAlertSeverity: String(Low/Medium/High)
     *                         maxAlertSeverity: String(Low/Medium/High)
     *                     }
     *                     snoozeFilter: {
     *                         autoSnooze: int
     *                         snoozeScope: String(Metric/Series)
     *                         onlyForSuccessive: boolean
     *                     }
     *                     valueFilter: {
     *                         lower: Double
     *                         upper: Double
     *                         direction: String(Both/Down/Up)
     *                         type: String(Value/Mean)
     *                         metricId: String
     *                         triggerForMissing: Boolean
     *                     }
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationAsync(
            String configurationId, RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () ->
                        getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, requestOptions, context),
                nextLink ->
                        getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNextSinglePageAsync(
                                nextLink, null, context));
    }

    /**
     * List all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyAlertingConfigurationId: String
     *             name: String
     *             description: String
     *             crossMetricsOperator: String(AND/OR/XOR)
     *             splitAlertByDimensions: [
     *                 String
     *             ]
     *             hookIds: [
     *                 String
     *             ]
     *             metricAlertingConfigurations: [
     *                 {
     *                     anomalyDetectionConfigurationId: String
     *                     anomalyScopeType: String(All/Dimension/TopN)
     *                     negationOperation: Boolean
     *                     dimensionAnomalyScope: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     topNAnomalyScope: {
     *                         top: int
     *                         period: int
     *                         minTopCount: int
     *                     }
     *                     severityFilter: {
     *                         minAlertSeverity: String(Low/Medium/High)
     *                         maxAlertSeverity: String(Low/Medium/High)
     *                     }
     *                     snoozeFilter: {
     *                         autoSnooze: int
     *                         snoozeScope: String(Metric/Series)
     *                         onlyForSuccessive: boolean
     *                     }
     *                     valueFilter: {
     *                         lower: Double
     *                         upper: Double
     *                         direction: String(Both/Down/Up)
     *                         type: String(Value/Mean)
     *                         metricId: String
     *                         triggerForMissing: Boolean
     *                     }
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
            String configurationId, RequestOptions requestOptions) {
        return new PagedIterable<>(
                getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationAsync(configurationId, requestOptions));
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     series: [
     *         {
     *             dimension: {
     *                 String: String
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             timestampList: [
     *                 String
     *             ]
     *             valueList: [
     *                 double
     *             ]
     *             isAnomalyList: [
     *                 boolean
     *             ]
     *             periodList: [
     *                 int
     *             ]
     *             expectedValueList: [
     *                 double
     *             ]
     *             lowerBoundaryList: [
     *                 double
     *             ]
     *             upperBoundaryList: [
     *                 double
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query series detection result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getSeriesByAnomalyDetectionConfigurationWithResponseAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.getSeriesByAnomalyDetectionConfiguration(
                                this.getEndpoint(), configurationId, body, requestOptions, context));
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     series: [
     *         {
     *             dimension: {
     *                 String: String
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             timestampList: [
     *                 String
     *             ]
     *             valueList: [
     *                 double
     *             ]
     *             isAnomalyList: [
     *                 boolean
     *             ]
     *             periodList: [
     *                 int
     *             ]
     *             expectedValueList: [
     *                 double
     *             ]
     *             lowerBoundaryList: [
     *                 double
     *             ]
     *             upperBoundaryList: [
     *                 double
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query series detection result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getSeriesByAnomalyDetectionConfigurationWithResponseAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getSeriesByAnomalyDetectionConfiguration(
                this.getEndpoint(), configurationId, body, requestOptions, context);
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     series: [
     *         {
     *             dimension: {
     *                 String: String
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             series: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             timestampList: [
     *                 String
     *             ]
     *             valueList: [
     *                 double
     *             ]
     *             isAnomalyList: [
     *                 boolean
     *             ]
     *             periodList: [
     *                 int
     *             ]
     *             expectedValueList: [
     *                 double
     *             ]
     *             lowerBoundaryList: [
     *                 double
     *             ]
     *             upperBoundaryList: [
     *                 double
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query series detection result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getSeriesByAnomalyDetectionConfigurationWithResponse(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return getSeriesByAnomalyDetectionConfigurationWithResponseAsync(configurationId, body, requestOptions).block();
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     filter: {
     *         dimensionFilter: [
     *             {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         ]
     *         severityFilter: {
     *             min: String(Low/Medium/High)
     *             max: String(Low/Medium/High)
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getAnomaliesByAnomalyDetectionConfiguration(
                                        this.getEndpoint(), configurationId, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     filter: {
     *         dimensionFilter: [
     *             {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         ]
     *         severityFilter: {
     *             min: String(Low/Medium/High)
     *             max: String(Low/Medium/High)
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getAnomaliesByAnomalyDetectionConfiguration(
                        this.getEndpoint(), configurationId, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     filter: {
     *         dimensionFilter: [
     *             {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         ]
     *         severityFilter: {
     *             min: String(Low/Medium/High)
     *             max: String(Low/Medium/High)
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getAnomaliesByAnomalyDetectionConfigurationAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return new PagedFlux<>(
                () -> getAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(configurationId, body, requestOptions),
                nextLink -> getAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink, body, null));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     filter: {
     *         dimensionFilter: [
     *             {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         ]
     *         severityFilter: {
     *             min: String(Low/Medium/High)
     *             max: String(Low/Medium/High)
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getAnomaliesByAnomalyDetectionConfigurationAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () ->
                        getAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, body, requestOptions, context),
                nextLink ->
                        getAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink, body, null, context));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     filter: {
     *         dimensionFilter: [
     *             {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         ]
     *         severityFilter: {
     *             min: String(Low/Medium/High)
     *             max: String(Low/Medium/High)
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getAnomaliesByAnomalyDetectionConfiguration(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return new PagedIterable<>(
                getAnomaliesByAnomalyDetectionConfigurationAsync(configurationId, body, requestOptions));
    }

    /**
     * Query dimension values of anomalies.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     dimensionName: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getDimensionOfAnomaliesByAnomalyDetectionConfiguration(
                                        this.getEndpoint(), configurationId, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query dimension values of anomalies.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     dimensionName: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getDimensionOfAnomaliesByAnomalyDetectionConfiguration(
                        this.getEndpoint(), configurationId, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query dimension values of anomalies.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     dimensionName: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getDimensionOfAnomaliesByAnomalyDetectionConfigurationAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return new PagedFlux<>(
                () ->
                        getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, body, requestOptions),
                nextLink ->
                        getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(
                                nextLink, body, null));
    }

    /**
     * Query dimension values of anomalies.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     dimensionName: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getDimensionOfAnomaliesByAnomalyDetectionConfigurationAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () ->
                        getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, body, requestOptions, context),
                nextLink ->
                        getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(
                                nextLink, body, null, context));
    }

    /**
     * Query dimension values of anomalies.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     dimensionName: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getDimensionOfAnomaliesByAnomalyDetectionConfiguration(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return new PagedIterable<>(
                getDimensionOfAnomaliesByAnomalyDetectionConfigurationAsync(configurationId, body, requestOptions));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     filter: {
     *         dimensionFilter: [
     *             {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         ]
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getIncidentsByAnomalyDetectionConfigurationSinglePageAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getIncidentsByAnomalyDetectionConfiguration(
                                        this.getEndpoint(), configurationId, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     filter: {
     *         dimensionFilter: [
     *             {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         ]
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getIncidentsByAnomalyDetectionConfigurationSinglePageAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getIncidentsByAnomalyDetectionConfiguration(
                        this.getEndpoint(), configurationId, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     filter: {
     *         dimensionFilter: [
     *             {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         ]
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getIncidentsByAnomalyDetectionConfigurationAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return new PagedFlux<>(
                () -> getIncidentsByAnomalyDetectionConfigurationSinglePageAsync(configurationId, body, requestOptions),
                nextLink -> getIncidentsByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink, null));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     filter: {
     *         dimensionFilter: [
     *             {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         ]
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getIncidentsByAnomalyDetectionConfigurationAsync(
            String configurationId, BinaryData body, RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () ->
                        getIncidentsByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, body, requestOptions, context),
                nextLink -> getIncidentsByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink, null, context));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     filter: {
     *         dimensionFilter: [
     *             {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         ]
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getIncidentsByAnomalyDetectionConfiguration(
            String configurationId, BinaryData body, RequestOptions requestOptions) {
        return new PagedIterable<>(
                getIncidentsByAnomalyDetectionConfigurationAsync(configurationId, body, requestOptions));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     *     <tr><td>$token</td><td>String</td><td>No</td><td>the token for getting the next page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getIncidentsByAnomalyDetectionConfigurationNextPagesSinglePageAsync(
            String configurationId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getIncidentsByAnomalyDetectionConfigurationNextPages(
                                        this.getEndpoint(), configurationId, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     *     <tr><td>$token</td><td>String</td><td>No</td><td>the token for getting the next page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getIncidentsByAnomalyDetectionConfigurationNextPagesSinglePageAsync(
            String configurationId, RequestOptions requestOptions, Context context) {
        return service.getIncidentsByAnomalyDetectionConfigurationNextPages(
                        this.getEndpoint(), configurationId, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     *     <tr><td>$token</td><td>String</td><td>No</td><td>the token for getting the next page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getIncidentsByAnomalyDetectionConfigurationNextPagesAsync(
            String configurationId, RequestOptions requestOptions) {
        return new PagedFlux<>(
                () ->
                        getIncidentsByAnomalyDetectionConfigurationNextPagesSinglePageAsync(
                                configurationId, requestOptions),
                nextLink -> getIncidentsByAnomalyDetectionConfigurationNextPagesNextSinglePageAsync(nextLink, null));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     *     <tr><td>$token</td><td>String</td><td>No</td><td>the token for getting the next page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getIncidentsByAnomalyDetectionConfigurationNextPagesAsync(
            String configurationId, RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () ->
                        getIncidentsByAnomalyDetectionConfigurationNextPagesSinglePageAsync(
                                configurationId, requestOptions, context),
                nextLink ->
                        getIncidentsByAnomalyDetectionConfigurationNextPagesNextSinglePageAsync(
                                nextLink, null, context));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     *     <tr><td>$token</td><td>String</td><td>No</td><td>the token for getting the next page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getIncidentsByAnomalyDetectionConfigurationNextPages(
            String configurationId, RequestOptions requestOptions) {
        return new PagedIterable<>(
                getIncidentsByAnomalyDetectionConfigurationNextPagesAsync(configurationId, requestOptions));
    }

    /**
     * Query root cause for incident.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             rootCause: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             path: [
     *                 String
     *             ]
     *             score: double
     *             description: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId incident id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponseAsync(
            String configurationId, String incidentId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.getRootCauseOfIncidentByAnomalyDetectionConfiguration(
                                this.getEndpoint(), configurationId, incidentId, requestOptions, context));
    }

    /**
     * Query root cause for incident.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             rootCause: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             path: [
     *                 String
     *             ]
     *             score: double
     *             description: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId incident id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponseAsync(
            String configurationId, String incidentId, RequestOptions requestOptions, Context context) {
        return service.getRootCauseOfIncidentByAnomalyDetectionConfiguration(
                this.getEndpoint(), configurationId, incidentId, requestOptions, context);
    }

    /**
     * Query root cause for incident.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             rootCause: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             path: [
     *                 String
     *             ]
     *             score: double
     *             description: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId incident id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponse(
            String configurationId, String incidentId, RequestOptions requestOptions) {
        return getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponseAsync(
                        configurationId, incidentId, requestOptions)
                .block();
    }

    /**
     * Create a new data source credential.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialId: String
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * @param body Create data source credential request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createCredentialWithResponseAsync(BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.createCredential(this.getEndpoint(), body, requestOptions, context));
    }

    /**
     * Create a new data source credential.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialId: String
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * @param body Create data source credential request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createCredentialWithResponseAsync(
            BinaryData body, RequestOptions requestOptions, Context context) {
        return service.createCredential(this.getEndpoint(), body, requestOptions, context);
    }

    /**
     * Create a new data source credential.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialId: String
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * @param body Create data source credential request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createCredentialWithResponse(BinaryData body, RequestOptions requestOptions) {
        return createCredentialWithResponseAsync(body, requestOptions).block();
    }

    /**
     * List all credentials.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataSourceCredentialId: String
     *             dataSourceCredentialName: String
     *             dataSourceCredentialDescription: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listCredentialsSinglePageAsync(RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> service.listCredentials(this.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List all credentials.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataSourceCredentialId: String
     *             dataSourceCredentialName: String
     *             dataSourceCredentialDescription: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listCredentialsSinglePageAsync(
            RequestOptions requestOptions, Context context) {
        return service.listCredentials(this.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List all credentials.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataSourceCredentialId: String
     *             dataSourceCredentialName: String
     *             dataSourceCredentialDescription: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listCredentialsAsync(RequestOptions requestOptions) {
        return new PagedFlux<>(
                () -> listCredentialsSinglePageAsync(requestOptions),
                nextLink -> listCredentialsNextSinglePageAsync(nextLink, null));
    }

    /**
     * List all credentials.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataSourceCredentialId: String
     *             dataSourceCredentialName: String
     *             dataSourceCredentialDescription: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listCredentialsAsync(RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () -> listCredentialsSinglePageAsync(requestOptions, context),
                nextLink -> listCredentialsNextSinglePageAsync(nextLink, null, context));
    }

    /**
     * List all credentials.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataSourceCredentialId: String
     *             dataSourceCredentialName: String
     *             dataSourceCredentialDescription: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listCredentials(RequestOptions requestOptions) {
        return new PagedIterable<>(listCredentialsAsync(requestOptions));
    }

    /**
     * Update a data source credential.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialId: String
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * @param credentialId Data source credential unique ID.
     * @param body Update data source credential request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> updateCredentialWithResponseAsync(
            String credentialId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.updateCredential(this.getEndpoint(), credentialId, body, requestOptions, context));
    }

    /**
     * Update a data source credential.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialId: String
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * @param credentialId Data source credential unique ID.
     * @param body Update data source credential request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> updateCredentialWithResponseAsync(
            String credentialId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.updateCredential(this.getEndpoint(), credentialId, body, requestOptions, context);
    }

    /**
     * Update a data source credential.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialId: String
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * @param credentialId Data source credential unique ID.
     * @param body Update data source credential request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> updateCredentialWithResponse(
            String credentialId, BinaryData body, RequestOptions requestOptions) {
        return updateCredentialWithResponseAsync(credentialId, body, requestOptions).block();
    }

    /**
     * Delete a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteCredentialWithResponseAsync(String credentialId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.deleteCredential(this.getEndpoint(), credentialId, requestOptions, context));
    }

    /**
     * Delete a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteCredentialWithResponseAsync(
            String credentialId, RequestOptions requestOptions, Context context) {
        return service.deleteCredential(this.getEndpoint(), credentialId, requestOptions, context);
    }

    /**
     * Delete a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteCredentialWithResponse(String credentialId, RequestOptions requestOptions) {
        return deleteCredentialWithResponseAsync(credentialId, requestOptions).block();
    }

    /**
     * Get a data source credential.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialId: String
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * @param credentialId Data source credential unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a data source credential along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getCredentialWithResponseAsync(
            String credentialId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.getCredential(this.getEndpoint(), credentialId, requestOptions, context));
    }

    /**
     * Get a data source credential.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialId: String
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * @param credentialId Data source credential unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a data source credential along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getCredentialWithResponseAsync(
            String credentialId, RequestOptions requestOptions, Context context) {
        return service.getCredential(this.getEndpoint(), credentialId, requestOptions, context);
    }

    /**
     * Get a data source credential.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataSourceCredentialId: String
     *     dataSourceCredentialName: String
     *     dataSourceCredentialDescription: String
     * }
     * }</pre>
     *
     * @param credentialId Data source credential unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a data source credential along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getCredentialWithResponse(String credentialId, RequestOptions requestOptions) {
        return getCredentialWithResponseAsync(credentialId, requestOptions).block();
    }

    /**
     * List all data feeds.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>dataFeedName</td><td>String</td><td>No</td><td>filter data feed by its name</td></tr>
     *     <tr><td>dataSourceType</td><td>String</td><td>No</td><td>filter data feed by its source type</td></tr>
     *     <tr><td>granularityName</td><td>String</td><td>No</td><td>filter data feed by its granularity</td></tr>
     *     <tr><td>status</td><td>String</td><td>No</td><td>filter data feed by its status</td></tr>
     *     <tr><td>creator</td><td>String</td><td>No</td><td>filter data feed by its creator</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             dataFeedName: String
     *             dataFeedDescription: String
     *             granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *             granularityAmount: Integer
     *             metrics: [
     *                 {
     *                     metricId: String
     *                     metricName: String
     *                     metricDisplayName: String
     *                     metricDescription: String
     *                 }
     *             ]
     *             dimension: [
     *                 {
     *                     dimensionName: String
     *                     dimensionDisplayName: String
     *                 }
     *             ]
     *             timestampColumn: String
     *             dataStartFrom: String
     *             startOffsetInSeconds: Long
     *             maxConcurrency: Integer
     *             minRetryIntervalInSeconds: Long
     *             stopRetryAfterInSeconds: Long
     *             needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *             rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *             rollUpColumns: [
     *                 String
     *             ]
     *             allUpIdentification: String
     *             fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *             fillMissingPointValue: Double
     *             viewMode: String(Private/Public)
     *             admins: [
     *                 String
     *             ]
     *             viewers: [
     *                 String
     *             ]
     *             isAdmin: Boolean
     *             creator: String
     *             status: String(Active/Paused)
     *             createdTime: String
     *             actionLinkTemplate: String
     *             authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *             credentialId: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listDataFeedsSinglePageAsync(RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> service.listDataFeeds(this.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List all data feeds.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>dataFeedName</td><td>String</td><td>No</td><td>filter data feed by its name</td></tr>
     *     <tr><td>dataSourceType</td><td>String</td><td>No</td><td>filter data feed by its source type</td></tr>
     *     <tr><td>granularityName</td><td>String</td><td>No</td><td>filter data feed by its granularity</td></tr>
     *     <tr><td>status</td><td>String</td><td>No</td><td>filter data feed by its status</td></tr>
     *     <tr><td>creator</td><td>String</td><td>No</td><td>filter data feed by its creator</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             dataFeedName: String
     *             dataFeedDescription: String
     *             granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *             granularityAmount: Integer
     *             metrics: [
     *                 {
     *                     metricId: String
     *                     metricName: String
     *                     metricDisplayName: String
     *                     metricDescription: String
     *                 }
     *             ]
     *             dimension: [
     *                 {
     *                     dimensionName: String
     *                     dimensionDisplayName: String
     *                 }
     *             ]
     *             timestampColumn: String
     *             dataStartFrom: String
     *             startOffsetInSeconds: Long
     *             maxConcurrency: Integer
     *             minRetryIntervalInSeconds: Long
     *             stopRetryAfterInSeconds: Long
     *             needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *             rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *             rollUpColumns: [
     *                 String
     *             ]
     *             allUpIdentification: String
     *             fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *             fillMissingPointValue: Double
     *             viewMode: String(Private/Public)
     *             admins: [
     *                 String
     *             ]
     *             viewers: [
     *                 String
     *             ]
     *             isAdmin: Boolean
     *             creator: String
     *             status: String(Active/Paused)
     *             createdTime: String
     *             actionLinkTemplate: String
     *             authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *             credentialId: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listDataFeedsSinglePageAsync(
            RequestOptions requestOptions, Context context) {
        return service.listDataFeeds(this.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List all data feeds.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>dataFeedName</td><td>String</td><td>No</td><td>filter data feed by its name</td></tr>
     *     <tr><td>dataSourceType</td><td>String</td><td>No</td><td>filter data feed by its source type</td></tr>
     *     <tr><td>granularityName</td><td>String</td><td>No</td><td>filter data feed by its granularity</td></tr>
     *     <tr><td>status</td><td>String</td><td>No</td><td>filter data feed by its status</td></tr>
     *     <tr><td>creator</td><td>String</td><td>No</td><td>filter data feed by its creator</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             dataFeedName: String
     *             dataFeedDescription: String
     *             granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *             granularityAmount: Integer
     *             metrics: [
     *                 {
     *                     metricId: String
     *                     metricName: String
     *                     metricDisplayName: String
     *                     metricDescription: String
     *                 }
     *             ]
     *             dimension: [
     *                 {
     *                     dimensionName: String
     *                     dimensionDisplayName: String
     *                 }
     *             ]
     *             timestampColumn: String
     *             dataStartFrom: String
     *             startOffsetInSeconds: Long
     *             maxConcurrency: Integer
     *             minRetryIntervalInSeconds: Long
     *             stopRetryAfterInSeconds: Long
     *             needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *             rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *             rollUpColumns: [
     *                 String
     *             ]
     *             allUpIdentification: String
     *             fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *             fillMissingPointValue: Double
     *             viewMode: String(Private/Public)
     *             admins: [
     *                 String
     *             ]
     *             viewers: [
     *                 String
     *             ]
     *             isAdmin: Boolean
     *             creator: String
     *             status: String(Active/Paused)
     *             createdTime: String
     *             actionLinkTemplate: String
     *             authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *             credentialId: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listDataFeedsAsync(RequestOptions requestOptions) {
        return new PagedFlux<>(
                () -> listDataFeedsSinglePageAsync(requestOptions),
                nextLink -> listDataFeedsNextSinglePageAsync(nextLink, null));
    }

    /**
     * List all data feeds.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>dataFeedName</td><td>String</td><td>No</td><td>filter data feed by its name</td></tr>
     *     <tr><td>dataSourceType</td><td>String</td><td>No</td><td>filter data feed by its source type</td></tr>
     *     <tr><td>granularityName</td><td>String</td><td>No</td><td>filter data feed by its granularity</td></tr>
     *     <tr><td>status</td><td>String</td><td>No</td><td>filter data feed by its status</td></tr>
     *     <tr><td>creator</td><td>String</td><td>No</td><td>filter data feed by its creator</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             dataFeedName: String
     *             dataFeedDescription: String
     *             granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *             granularityAmount: Integer
     *             metrics: [
     *                 {
     *                     metricId: String
     *                     metricName: String
     *                     metricDisplayName: String
     *                     metricDescription: String
     *                 }
     *             ]
     *             dimension: [
     *                 {
     *                     dimensionName: String
     *                     dimensionDisplayName: String
     *                 }
     *             ]
     *             timestampColumn: String
     *             dataStartFrom: String
     *             startOffsetInSeconds: Long
     *             maxConcurrency: Integer
     *             minRetryIntervalInSeconds: Long
     *             stopRetryAfterInSeconds: Long
     *             needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *             rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *             rollUpColumns: [
     *                 String
     *             ]
     *             allUpIdentification: String
     *             fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *             fillMissingPointValue: Double
     *             viewMode: String(Private/Public)
     *             admins: [
     *                 String
     *             ]
     *             viewers: [
     *                 String
     *             ]
     *             isAdmin: Boolean
     *             creator: String
     *             status: String(Active/Paused)
     *             createdTime: String
     *             actionLinkTemplate: String
     *             authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *             credentialId: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listDataFeedsAsync(RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () -> listDataFeedsSinglePageAsync(requestOptions, context),
                nextLink -> listDataFeedsNextSinglePageAsync(nextLink, null, context));
    }

    /**
     * List all data feeds.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>dataFeedName</td><td>String</td><td>No</td><td>filter data feed by its name</td></tr>
     *     <tr><td>dataSourceType</td><td>String</td><td>No</td><td>filter data feed by its source type</td></tr>
     *     <tr><td>granularityName</td><td>String</td><td>No</td><td>filter data feed by its granularity</td></tr>
     *     <tr><td>status</td><td>String</td><td>No</td><td>filter data feed by its status</td></tr>
     *     <tr><td>creator</td><td>String</td><td>No</td><td>filter data feed by its creator</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             dataFeedName: String
     *             dataFeedDescription: String
     *             granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *             granularityAmount: Integer
     *             metrics: [
     *                 {
     *                     metricId: String
     *                     metricName: String
     *                     metricDisplayName: String
     *                     metricDescription: String
     *                 }
     *             ]
     *             dimension: [
     *                 {
     *                     dimensionName: String
     *                     dimensionDisplayName: String
     *                 }
     *             ]
     *             timestampColumn: String
     *             dataStartFrom: String
     *             startOffsetInSeconds: Long
     *             maxConcurrency: Integer
     *             minRetryIntervalInSeconds: Long
     *             stopRetryAfterInSeconds: Long
     *             needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *             rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *             rollUpColumns: [
     *                 String
     *             ]
     *             allUpIdentification: String
     *             fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *             fillMissingPointValue: Double
     *             viewMode: String(Private/Public)
     *             admins: [
     *                 String
     *             ]
     *             viewers: [
     *                 String
     *             ]
     *             isAdmin: Boolean
     *             creator: String
     *             status: String(Active/Paused)
     *             createdTime: String
     *             actionLinkTemplate: String
     *             authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *             credentialId: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listDataFeeds(RequestOptions requestOptions) {
        return new PagedIterable<>(listDataFeedsAsync(requestOptions));
    }

    /**
     * Create a new data feed.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedId: String
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *     granularityAmount: Integer
     *     metrics: [
     *         {
     *             metricId: String
     *             metricName: String
     *             metricDisplayName: String
     *             metricDescription: String
     *         }
     *     ]
     *     dimension: [
     *         {
     *             dimensionName: String
     *             dimensionDisplayName: String
     *         }
     *     ]
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     isAdmin: Boolean
     *     creator: String
     *     status: String(Active/Paused)
     *     createdTime: String
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * @param body parameters to create a data feed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createDataFeedWithResponseAsync(BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.createDataFeed(this.getEndpoint(), body, requestOptions, context));
    }

    /**
     * Create a new data feed.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedId: String
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *     granularityAmount: Integer
     *     metrics: [
     *         {
     *             metricId: String
     *             metricName: String
     *             metricDisplayName: String
     *             metricDescription: String
     *         }
     *     ]
     *     dimension: [
     *         {
     *             dimensionName: String
     *             dimensionDisplayName: String
     *         }
     *     ]
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     isAdmin: Boolean
     *     creator: String
     *     status: String(Active/Paused)
     *     createdTime: String
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * @param body parameters to create a data feed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createDataFeedWithResponseAsync(
            BinaryData body, RequestOptions requestOptions, Context context) {
        return service.createDataFeed(this.getEndpoint(), body, requestOptions, context);
    }

    /**
     * Create a new data feed.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedId: String
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *     granularityAmount: Integer
     *     metrics: [
     *         {
     *             metricId: String
     *             metricName: String
     *             metricDisplayName: String
     *             metricDescription: String
     *         }
     *     ]
     *     dimension: [
     *         {
     *             dimensionName: String
     *             dimensionDisplayName: String
     *         }
     *     ]
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     isAdmin: Boolean
     *     creator: String
     *     status: String(Active/Paused)
     *     createdTime: String
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * @param body parameters to create a data feed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createDataFeedWithResponse(BinaryData body, RequestOptions requestOptions) {
        return createDataFeedWithResponseAsync(body, requestOptions).block();
    }

    /**
     * Get a data feed by its id.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedId: String
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *     granularityAmount: Integer
     *     metrics: [
     *         {
     *             metricId: String
     *             metricName: String
     *             metricDisplayName: String
     *             metricDescription: String
     *         }
     *     ]
     *     dimension: [
     *         {
     *             dimensionName: String
     *             dimensionDisplayName: String
     *         }
     *     ]
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     isAdmin: Boolean
     *     creator: String
     *     status: String(Active/Paused)
     *     createdTime: String
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a data feed by its id along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getDataFeedByIdWithResponseAsync(
            String dataFeedId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.getDataFeedById(this.getEndpoint(), dataFeedId, requestOptions, context));
    }

    /**
     * Get a data feed by its id.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedId: String
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *     granularityAmount: Integer
     *     metrics: [
     *         {
     *             metricId: String
     *             metricName: String
     *             metricDisplayName: String
     *             metricDescription: String
     *         }
     *     ]
     *     dimension: [
     *         {
     *             dimensionName: String
     *             dimensionDisplayName: String
     *         }
     *     ]
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     isAdmin: Boolean
     *     creator: String
     *     status: String(Active/Paused)
     *     createdTime: String
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a data feed by its id along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getDataFeedByIdWithResponseAsync(
            String dataFeedId, RequestOptions requestOptions, Context context) {
        return service.getDataFeedById(this.getEndpoint(), dataFeedId, requestOptions, context);
    }

    /**
     * Get a data feed by its id.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedId: String
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *     granularityAmount: Integer
     *     metrics: [
     *         {
     *             metricId: String
     *             metricName: String
     *             metricDisplayName: String
     *             metricDescription: String
     *         }
     *     ]
     *     dimension: [
     *         {
     *             dimensionName: String
     *             dimensionDisplayName: String
     *         }
     *     ]
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     isAdmin: Boolean
     *     creator: String
     *     status: String(Active/Paused)
     *     createdTime: String
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a data feed by its id along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDataFeedByIdWithResponse(String dataFeedId, RequestOptions requestOptions) {
        return getDataFeedByIdWithResponseAsync(dataFeedId, requestOptions).block();
    }

    /**
     * Update a data feed.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     status: String(Active/Paused)
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedId: String
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *     granularityAmount: Integer
     *     metrics: [
     *         {
     *             metricId: String
     *             metricName: String
     *             metricDisplayName: String
     *             metricDescription: String
     *         }
     *     ]
     *     dimension: [
     *         {
     *             dimensionName: String
     *             dimensionDisplayName: String
     *         }
     *     ]
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     isAdmin: Boolean
     *     creator: String
     *     status: String(Active/Paused)
     *     createdTime: String
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> updateDataFeedWithResponseAsync(
            String dataFeedId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.updateDataFeed(this.getEndpoint(), dataFeedId, body, requestOptions, context));
    }

    /**
     * Update a data feed.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     status: String(Active/Paused)
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedId: String
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *     granularityAmount: Integer
     *     metrics: [
     *         {
     *             metricId: String
     *             metricName: String
     *             metricDisplayName: String
     *             metricDescription: String
     *         }
     *     ]
     *     dimension: [
     *         {
     *             dimensionName: String
     *             dimensionDisplayName: String
     *         }
     *     ]
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     isAdmin: Boolean
     *     creator: String
     *     status: String(Active/Paused)
     *     createdTime: String
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> updateDataFeedWithResponseAsync(
            String dataFeedId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.updateDataFeed(this.getEndpoint(), dataFeedId, body, requestOptions, context);
    }

    /**
     * Update a data feed.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     status: String(Active/Paused)
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dataFeedId: String
     *     dataFeedName: String
     *     dataFeedDescription: String
     *     granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *     granularityAmount: Integer
     *     metrics: [
     *         {
     *             metricId: String
     *             metricName: String
     *             metricDisplayName: String
     *             metricDescription: String
     *         }
     *     ]
     *     dimension: [
     *         {
     *             dimensionName: String
     *             dimensionDisplayName: String
     *         }
     *     ]
     *     timestampColumn: String
     *     dataStartFrom: String
     *     startOffsetInSeconds: Long
     *     maxConcurrency: Integer
     *     minRetryIntervalInSeconds: Long
     *     stopRetryAfterInSeconds: Long
     *     needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *     rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *     rollUpColumns: [
     *         String
     *     ]
     *     allUpIdentification: String
     *     fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *     fillMissingPointValue: Double
     *     viewMode: String(Private/Public)
     *     admins: [
     *         String
     *     ]
     *     viewers: [
     *         String
     *     ]
     *     isAdmin: Boolean
     *     creator: String
     *     status: String(Active/Paused)
     *     createdTime: String
     *     actionLinkTemplate: String
     *     authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *     credentialId: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> updateDataFeedWithResponse(
            String dataFeedId, BinaryData body, RequestOptions requestOptions) {
        return updateDataFeedWithResponseAsync(dataFeedId, body, requestOptions).block();
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteDataFeedWithResponseAsync(String dataFeedId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.deleteDataFeed(this.getEndpoint(), dataFeedId, requestOptions, context));
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteDataFeedWithResponseAsync(
            String dataFeedId, RequestOptions requestOptions, Context context) {
        return service.deleteDataFeed(this.getEndpoint(), dataFeedId, requestOptions, context);
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDataFeedWithResponse(String dataFeedId, RequestOptions requestOptions) {
        return deleteDataFeedWithResponseAsync(dataFeedId, requestOptions).block();
    }

    /**
     * Get a metric feedback by its id.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     feedbackId: String
     *     createdTime: String
     *     userPrincipal: String
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param feedbackId the unique feedback ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a metric feedback by its id along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMetricFeedbackWithResponseAsync(
            String feedbackId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.getMetricFeedback(this.getEndpoint(), feedbackId, requestOptions, context));
    }

    /**
     * Get a metric feedback by its id.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     feedbackId: String
     *     createdTime: String
     *     userPrincipal: String
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param feedbackId the unique feedback ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a metric feedback by its id along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMetricFeedbackWithResponseAsync(
            String feedbackId, RequestOptions requestOptions, Context context) {
        return service.getMetricFeedback(this.getEndpoint(), feedbackId, requestOptions, context);
    }

    /**
     * Get a metric feedback by its id.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     feedbackId: String
     *     createdTime: String
     *     userPrincipal: String
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param feedbackId the unique feedback ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a metric feedback by its id along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getMetricFeedbackWithResponse(String feedbackId, RequestOptions requestOptions) {
        return getMetricFeedbackWithResponseAsync(feedbackId, requestOptions).block();
    }

    /**
     * List feedback on the given metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     *     feedbackType: String(Anomaly/ChangePoint/Period/Comment)
     *     startTime: String
     *     endTime: String
     *     timeMode: String(MetricTimestamp/FeedbackCreatedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             feedbackId: String
     *             createdTime: String
     *             userPrincipal: String
     *             metricId: String
     *             dimensionFilter: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param body metric feedback filter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listMetricFeedbacksSinglePageAsync(
            BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context -> service.listMetricFeedbacks(this.getEndpoint(), body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List feedback on the given metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     *     feedbackType: String(Anomaly/ChangePoint/Period/Comment)
     *     startTime: String
     *     endTime: String
     *     timeMode: String(MetricTimestamp/FeedbackCreatedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             feedbackId: String
     *             createdTime: String
     *             userPrincipal: String
     *             metricId: String
     *             dimensionFilter: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param body metric feedback filter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listMetricFeedbacksSinglePageAsync(
            BinaryData body, RequestOptions requestOptions, Context context) {
        return service.listMetricFeedbacks(this.getEndpoint(), body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List feedback on the given metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     *     feedbackType: String(Anomaly/ChangePoint/Period/Comment)
     *     startTime: String
     *     endTime: String
     *     timeMode: String(MetricTimestamp/FeedbackCreatedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             feedbackId: String
     *             createdTime: String
     *             userPrincipal: String
     *             metricId: String
     *             dimensionFilter: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param body metric feedback filter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listMetricFeedbacksAsync(BinaryData body, RequestOptions requestOptions) {
        return new PagedFlux<>(
                () -> listMetricFeedbacksSinglePageAsync(body, requestOptions),
                nextLink -> listMetricFeedbacksNextSinglePageAsync(nextLink, body, null));
    }

    /**
     * List feedback on the given metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     *     feedbackType: String(Anomaly/ChangePoint/Period/Comment)
     *     startTime: String
     *     endTime: String
     *     timeMode: String(MetricTimestamp/FeedbackCreatedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             feedbackId: String
     *             createdTime: String
     *             userPrincipal: String
     *             metricId: String
     *             dimensionFilter: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param body metric feedback filter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listMetricFeedbacksAsync(
            BinaryData body, RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () -> listMetricFeedbacksSinglePageAsync(body, requestOptions, context),
                nextLink -> listMetricFeedbacksNextSinglePageAsync(nextLink, body, null, context));
    }

    /**
     * List feedback on the given metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     *     feedbackType: String(Anomaly/ChangePoint/Period/Comment)
     *     startTime: String
     *     endTime: String
     *     timeMode: String(MetricTimestamp/FeedbackCreatedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             feedbackId: String
     *             createdTime: String
     *             userPrincipal: String
     *             metricId: String
     *             dimensionFilter: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param body metric feedback filter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listMetricFeedbacks(BinaryData body, RequestOptions requestOptions) {
        return new PagedIterable<>(listMetricFeedbacksAsync(body, requestOptions));
    }

    /**
     * Create a new metric feedback.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     feedbackId: String
     *     createdTime: String
     *     userPrincipal: String
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param body metric feedback.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createMetricFeedbackWithResponseAsync(BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.createMetricFeedback(this.getEndpoint(), body, requestOptions, context));
    }

    /**
     * Create a new metric feedback.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     feedbackId: String
     *     createdTime: String
     *     userPrincipal: String
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param body metric feedback.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createMetricFeedbackWithResponseAsync(
            BinaryData body, RequestOptions requestOptions, Context context) {
        return service.createMetricFeedback(this.getEndpoint(), body, requestOptions, context);
    }

    /**
     * Create a new metric feedback.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     feedbackId: String
     *     createdTime: String
     *     userPrincipal: String
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param body metric feedback.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createMetricFeedbackWithResponse(BinaryData body, RequestOptions requestOptions) {
        return createMetricFeedbackWithResponseAsync(body, requestOptions).block();
    }

    /**
     * List all hooks.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>hookName</td><td>String</td><td>No</td><td>filter hook by its name</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             hookId: String
     *             hookName: String
     *             description: String
     *             externalLink: String
     *             admins: [
     *                 String
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listHooksSinglePageAsync(RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> service.listHooks(this.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List all hooks.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>hookName</td><td>String</td><td>No</td><td>filter hook by its name</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             hookId: String
     *             hookName: String
     *             description: String
     *             externalLink: String
     *             admins: [
     *                 String
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listHooksSinglePageAsync(RequestOptions requestOptions, Context context) {
        return service.listHooks(this.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List all hooks.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>hookName</td><td>String</td><td>No</td><td>filter hook by its name</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             hookId: String
     *             hookName: String
     *             description: String
     *             externalLink: String
     *             admins: [
     *                 String
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listHooksAsync(RequestOptions requestOptions) {
        return new PagedFlux<>(
                () -> listHooksSinglePageAsync(requestOptions),
                nextLink -> listHooksNextSinglePageAsync(nextLink, null));
    }

    /**
     * List all hooks.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>hookName</td><td>String</td><td>No</td><td>filter hook by its name</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             hookId: String
     *             hookName: String
     *             description: String
     *             externalLink: String
     *             admins: [
     *                 String
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listHooksAsync(RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () -> listHooksSinglePageAsync(requestOptions, context),
                nextLink -> listHooksNextSinglePageAsync(nextLink, null, context));
    }

    /**
     * List all hooks.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>hookName</td><td>String</td><td>No</td><td>filter hook by its name</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             hookId: String
     *             hookName: String
     *             description: String
     *             externalLink: String
     *             admins: [
     *                 String
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listHooks(RequestOptions requestOptions) {
        return new PagedIterable<>(listHooksAsync(requestOptions));
    }

    /**
     * Create a new hook.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookId: String
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param body Create hook request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createHookWithResponseAsync(BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> service.createHook(this.getEndpoint(), body, requestOptions, context));
    }

    /**
     * Create a new hook.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookId: String
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param body Create hook request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createHookWithResponseAsync(
            BinaryData body, RequestOptions requestOptions, Context context) {
        return service.createHook(this.getEndpoint(), body, requestOptions, context);
    }

    /**
     * Create a new hook.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookId: String
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param body Create hook request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createHookWithResponse(BinaryData body, RequestOptions requestOptions) {
        return createHookWithResponseAsync(body, requestOptions).block();
    }

    /**
     * Get a hook by its id.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookId: String
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param hookId Hook unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a hook by its id along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getHookWithResponseAsync(String hookId, RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> service.getHook(this.getEndpoint(), hookId, requestOptions, context));
    }

    /**
     * Get a hook by its id.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookId: String
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param hookId Hook unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a hook by its id along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getHookWithResponseAsync(
            String hookId, RequestOptions requestOptions, Context context) {
        return service.getHook(this.getEndpoint(), hookId, requestOptions, context);
    }

    /**
     * Get a hook by its id.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookId: String
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param hookId Hook unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a hook by its id along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getHookWithResponse(String hookId, RequestOptions requestOptions) {
        return getHookWithResponseAsync(hookId, requestOptions).block();
    }

    /**
     * Update a hook.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookId: String
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> updateHookWithResponseAsync(
            String hookId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.updateHook(this.getEndpoint(), hookId, body, requestOptions, context));
    }

    /**
     * Update a hook.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookId: String
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> updateHookWithResponseAsync(
            String hookId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.updateHook(this.getEndpoint(), hookId, body, requestOptions, context);
    }

    /**
     * Update a hook.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     hookId: String
     *     hookName: String
     *     description: String
     *     externalLink: String
     *     admins: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> updateHookWithResponse(String hookId, BinaryData body, RequestOptions requestOptions) {
        return updateHookWithResponseAsync(hookId, body, requestOptions).block();
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteHookWithResponseAsync(String hookId, RequestOptions requestOptions) {
        return FluxUtil.withContext(context -> service.deleteHook(this.getEndpoint(), hookId, requestOptions, context));
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteHookWithResponseAsync(
            String hookId, RequestOptions requestOptions, Context context) {
        return service.deleteHook(this.getEndpoint(), hookId, requestOptions, context);
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteHookWithResponse(String hookId, RequestOptions requestOptions) {
        return deleteHookWithResponseAsync(hookId, requestOptions).block();
    }

    /**
     * Get data ingestion status by data feed.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String(NotStarted/Scheduled/Running/Succeeded/Failed/NoData/Error/Paused)
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return data ingestion status by data feed along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getDataFeedIngestionStatusSinglePageAsync(
            String dataFeedId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getDataFeedIngestionStatus(
                                        this.getEndpoint(), dataFeedId, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String(NotStarted/Scheduled/Running/Succeeded/Failed/NoData/Error/Paused)
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return data ingestion status by data feed along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getDataFeedIngestionStatusSinglePageAsync(
            String dataFeedId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getDataFeedIngestionStatus(this.getEndpoint(), dataFeedId, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String(NotStarted/Scheduled/Running/Succeeded/Failed/NoData/Error/Paused)
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return data ingestion status by data feed as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getDataFeedIngestionStatusAsync(
            String dataFeedId, BinaryData body, RequestOptions requestOptions) {
        return new PagedFlux<>(
                () -> getDataFeedIngestionStatusSinglePageAsync(dataFeedId, body, requestOptions),
                nextLink -> getDataFeedIngestionStatusNextSinglePageAsync(nextLink, body, null));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String(NotStarted/Scheduled/Running/Succeeded/Failed/NoData/Error/Paused)
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return data ingestion status by data feed as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getDataFeedIngestionStatusAsync(
            String dataFeedId, BinaryData body, RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () -> getDataFeedIngestionStatusSinglePageAsync(dataFeedId, body, requestOptions, context),
                nextLink -> getDataFeedIngestionStatusNextSinglePageAsync(nextLink, body, null, context));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String(NotStarted/Scheduled/Running/Succeeded/Failed/NoData/Error/Paused)
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return data ingestion status by data feed as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getDataFeedIngestionStatus(
            String dataFeedId, BinaryData body, RequestOptions requestOptions) {
        return new PagedIterable<>(getDataFeedIngestionStatusAsync(dataFeedId, body, requestOptions));
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> resetDataFeedIngestionStatusWithResponseAsync(
            String dataFeedId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.resetDataFeedIngestionStatus(
                                this.getEndpoint(), dataFeedId, body, requestOptions, context));
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> resetDataFeedIngestionStatusWithResponseAsync(
            String dataFeedId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.resetDataFeedIngestionStatus(this.getEndpoint(), dataFeedId, body, requestOptions, context);
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> resetDataFeedIngestionStatusWithResponse(
            String dataFeedId, BinaryData body, RequestOptions requestOptions) {
        return resetDataFeedIngestionStatusWithResponseAsync(dataFeedId, body, requestOptions).block();
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     latestSuccessTimestamp: String
     *     latestActiveTimestamp: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return data last success ingestion job timestamp by data feed along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getIngestionProgressWithResponseAsync(
            String dataFeedId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.getIngestionProgress(this.getEndpoint(), dataFeedId, requestOptions, context));
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     latestSuccessTimestamp: String
     *     latestActiveTimestamp: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return data last success ingestion job timestamp by data feed along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getIngestionProgressWithResponseAsync(
            String dataFeedId, RequestOptions requestOptions, Context context) {
        return service.getIngestionProgress(this.getEndpoint(), dataFeedId, requestOptions, context);
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     latestSuccessTimestamp: String
     *     latestActiveTimestamp: String
     * }
     * }</pre>
     *
     * @param dataFeedId The data feed unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return data last success ingestion job timestamp by data feed along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getIngestionProgressWithResponse(String dataFeedId, RequestOptions requestOptions) {
        return getIngestionProgressWithResponseAsync(dataFeedId, requestOptions).block();
    }

    /**
     * Get time series data from metric.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     series: [
     *         {
     *             String: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             id: {
     *                 metricId: String
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             timestampList: [
     *                 String
     *             ]
     *             valueList: [
     *                 double
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body query time series data condition.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return time series data from metric along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMetricDataWithResponseAsync(
            String metricId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.getMetricData(this.getEndpoint(), metricId, body, requestOptions, context));
    }

    /**
     * Get time series data from metric.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     series: [
     *         {
     *             String: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             id: {
     *                 metricId: String
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             timestampList: [
     *                 String
     *             ]
     *             valueList: [
     *                 double
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body query time series data condition.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return time series data from metric along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getMetricDataWithResponseAsync(
            String metricId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getMetricData(this.getEndpoint(), metricId, body, requestOptions, context);
    }

    /**
     * Get time series data from metric.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     series: [
     *         {
     *             String: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             id: {
     *                 metricId: String
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             timestampList: [
     *                 String
     *             ]
     *             valueList: [
     *                 double
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body query time series data condition.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return time series data from metric along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getMetricDataWithResponse(
            String metricId, BinaryData body, RequestOptions requestOptions) {
        return getMetricDataWithResponseAsync(metricId, body, requestOptions).block();
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     activeSince: String
     *     dimensionFilter: {
     *         String: [
     *             String
     *         ]
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             metricId: String
     *             dimension: {
     *                 String: String
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getMetricSeriesSinglePageAsync(
            String metricId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context -> service.getMetricSeries(this.getEndpoint(), metricId, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     activeSince: String
     *     dimensionFilter: {
     *         String: [
     *             String
     *         ]
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             metricId: String
     *             dimension: {
     *                 String: String
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getMetricSeriesSinglePageAsync(
            String metricId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getMetricSeries(this.getEndpoint(), metricId, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     activeSince: String
     *     dimensionFilter: {
     *         String: [
     *             String
     *         ]
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             metricId: String
     *             dimension: {
     *                 String: String
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getMetricSeriesAsync(String metricId, BinaryData body, RequestOptions requestOptions) {
        return new PagedFlux<>(
                () -> getMetricSeriesSinglePageAsync(metricId, body, requestOptions),
                nextLink -> getMetricSeriesNextSinglePageAsync(nextLink, body, null));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     activeSince: String
     *     dimensionFilter: {
     *         String: [
     *             String
     *         ]
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             metricId: String
     *             dimension: {
     *                 String: String
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getMetricSeriesAsync(
            String metricId, BinaryData body, RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () -> getMetricSeriesSinglePageAsync(metricId, body, requestOptions, context),
                nextLink -> getMetricSeriesNextSinglePageAsync(nextLink, body, null, context));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     activeSince: String
     *     dimensionFilter: {
     *         String: [
     *             String
     *         ]
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             metricId: String
     *             dimension: {
     *                 String: String
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getMetricSeries(String metricId, BinaryData body, RequestOptions requestOptions) {
        return new PagedIterable<>(getMetricSeriesAsync(metricId, body, requestOptions));
    }

    /**
     * List dimension from certain metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dimensionName: String
     *     dimensionValueFilter: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getMetricDimensionSinglePageAsync(
            String metricId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getMetricDimension(this.getEndpoint(), metricId, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List dimension from certain metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dimensionName: String
     *     dimensionValueFilter: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getMetricDimensionSinglePageAsync(
            String metricId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getMetricDimension(this.getEndpoint(), metricId, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List dimension from certain metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dimensionName: String
     *     dimensionValueFilter: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getMetricDimensionAsync(
            String metricId, BinaryData body, RequestOptions requestOptions) {
        return new PagedFlux<>(
                () -> getMetricDimensionSinglePageAsync(metricId, body, requestOptions),
                nextLink -> getMetricDimensionNextSinglePageAsync(nextLink, body, null));
    }

    /**
     * List dimension from certain metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dimensionName: String
     *     dimensionValueFilter: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getMetricDimensionAsync(
            String metricId, BinaryData body, RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () -> getMetricDimensionSinglePageAsync(metricId, body, requestOptions, context),
                nextLink -> getMetricDimensionNextSinglePageAsync(nextLink, body, null, context));
    }

    /**
     * List dimension from certain metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dimensionName: String
     *     dimensionValueFilter: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getMetricDimension(
            String metricId, BinaryData body, RequestOptions requestOptions) {
        return new PagedIterable<>(getMetricDimensionAsync(metricId, body, requestOptions));
    }

    /**
     * List all anomaly detection configurations for specific metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             name: String
     *             description: String
     *             metricId: String
     *             wholeMetricConfiguration: {
     *                 conditionOperator: String(AND/OR)
     *                 smartDetectionCondition: {
     *                     sensitivity: double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: {
     *                         minNumber: int
     *                         minRatio: double
     *                     }
     *                 }
     *                 hardThresholdCondition: {
     *                     lowerBound: Double
     *                     upperBound: Double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *                 changeThresholdCondition: {
     *                     changePercentage: double
     *                     shiftPoint: int
     *                     withinRange: boolean
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *             }
     *             dimensionGroupOverrideConfigurations: [
     *                 {
     *                     group: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *             seriesOverrideConfigurations: [
     *                 {
     *                     series: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAnomalyDetectionConfigurationsByMetricSinglePageAsync(
            String metricId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getAnomalyDetectionConfigurationsByMetric(
                                        this.getEndpoint(), metricId, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List all anomaly detection configurations for specific metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             name: String
     *             description: String
     *             metricId: String
     *             wholeMetricConfiguration: {
     *                 conditionOperator: String(AND/OR)
     *                 smartDetectionCondition: {
     *                     sensitivity: double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: {
     *                         minNumber: int
     *                         minRatio: double
     *                     }
     *                 }
     *                 hardThresholdCondition: {
     *                     lowerBound: Double
     *                     upperBound: Double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *                 changeThresholdCondition: {
     *                     changePercentage: double
     *                     shiftPoint: int
     *                     withinRange: boolean
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *             }
     *             dimensionGroupOverrideConfigurations: [
     *                 {
     *                     group: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *             seriesOverrideConfigurations: [
     *                 {
     *                     series: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAnomalyDetectionConfigurationsByMetricSinglePageAsync(
            String metricId, RequestOptions requestOptions, Context context) {
        return service.getAnomalyDetectionConfigurationsByMetric(this.getEndpoint(), metricId, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * List all anomaly detection configurations for specific metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             name: String
     *             description: String
     *             metricId: String
     *             wholeMetricConfiguration: {
     *                 conditionOperator: String(AND/OR)
     *                 smartDetectionCondition: {
     *                     sensitivity: double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: {
     *                         minNumber: int
     *                         minRatio: double
     *                     }
     *                 }
     *                 hardThresholdCondition: {
     *                     lowerBound: Double
     *                     upperBound: Double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *                 changeThresholdCondition: {
     *                     changePercentage: double
     *                     shiftPoint: int
     *                     withinRange: boolean
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *             }
     *             dimensionGroupOverrideConfigurations: [
     *                 {
     *                     group: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *             seriesOverrideConfigurations: [
     *                 {
     *                     series: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getAnomalyDetectionConfigurationsByMetricAsync(
            String metricId, RequestOptions requestOptions) {
        return new PagedFlux<>(
                () -> getAnomalyDetectionConfigurationsByMetricSinglePageAsync(metricId, requestOptions),
                nextLink -> getAnomalyDetectionConfigurationsByMetricNextSinglePageAsync(nextLink, null));
    }

    /**
     * List all anomaly detection configurations for specific metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             name: String
     *             description: String
     *             metricId: String
     *             wholeMetricConfiguration: {
     *                 conditionOperator: String(AND/OR)
     *                 smartDetectionCondition: {
     *                     sensitivity: double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: {
     *                         minNumber: int
     *                         minRatio: double
     *                     }
     *                 }
     *                 hardThresholdCondition: {
     *                     lowerBound: Double
     *                     upperBound: Double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *                 changeThresholdCondition: {
     *                     changePercentage: double
     *                     shiftPoint: int
     *                     withinRange: boolean
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *             }
     *             dimensionGroupOverrideConfigurations: [
     *                 {
     *                     group: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *             seriesOverrideConfigurations: [
     *                 {
     *                     series: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getAnomalyDetectionConfigurationsByMetricAsync(
            String metricId, RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () -> getAnomalyDetectionConfigurationsByMetricSinglePageAsync(metricId, requestOptions, context),
                nextLink -> getAnomalyDetectionConfigurationsByMetricNextSinglePageAsync(nextLink, null, context));
    }

    /**
     * List all anomaly detection configurations for specific metric.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             name: String
     *             description: String
     *             metricId: String
     *             wholeMetricConfiguration: {
     *                 conditionOperator: String(AND/OR)
     *                 smartDetectionCondition: {
     *                     sensitivity: double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: {
     *                         minNumber: int
     *                         minRatio: double
     *                     }
     *                 }
     *                 hardThresholdCondition: {
     *                     lowerBound: Double
     *                     upperBound: Double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *                 changeThresholdCondition: {
     *                     changePercentage: double
     *                     shiftPoint: int
     *                     withinRange: boolean
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *             }
     *             dimensionGroupOverrideConfigurations: [
     *                 {
     *                     group: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *             seriesOverrideConfigurations: [
     *                 {
     *                     series: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getAnomalyDetectionConfigurationsByMetric(
            String metricId, RequestOptions requestOptions) {
        return new PagedIterable<>(getAnomalyDetectionConfigurationsByMetricAsync(metricId, requestOptions));
    }

    /**
     * Query anomaly detection status.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getEnrichmentStatusByMetricSinglePageAsync(
            String metricId, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getEnrichmentStatusByMetric(
                                        this.getEndpoint(), metricId, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query anomaly detection status.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getEnrichmentStatusByMetricSinglePageAsync(
            String metricId, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getEnrichmentStatusByMetric(this.getEndpoint(), metricId, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Query anomaly detection status.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getEnrichmentStatusByMetricAsync(
            String metricId, BinaryData body, RequestOptions requestOptions) {
        return new PagedFlux<>(
                () -> getEnrichmentStatusByMetricSinglePageAsync(metricId, body, requestOptions),
                nextLink -> getEnrichmentStatusByMetricNextSinglePageAsync(nextLink, body, null));
    }

    /**
     * Query anomaly detection status.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getEnrichmentStatusByMetricAsync(
            String metricId, BinaryData body, RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () -> getEnrichmentStatusByMetricSinglePageAsync(metricId, body, requestOptions, context),
                nextLink -> getEnrichmentStatusByMetricNextSinglePageAsync(nextLink, body, null, context));
    }

    /**
     * Query anomaly detection status.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>for paging, skipped number</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>the maximum number of items in one page</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getEnrichmentStatusByMetric(
            String metricId, BinaryData body, RequestOptions requestOptions) {
        return new PagedIterable<>(getEnrichmentStatusByMetricAsync(metricId, body, requestOptions));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     timeMode: String(AnomalyTime/CreatedTime/ModifiedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             alertId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body query alerting result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAlertsByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getAlertsByAnomalyAlertingConfigurationNext(
                                        this.getEndpoint(), nextLink, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     timeMode: String(AnomalyTime/CreatedTime/ModifiedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             alertId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body query alerting result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAlertsByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getAlertsByAnomalyAlertingConfigurationNext(
                        this.getEndpoint(), nextLink, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     filter: {
     *         dimensionFilter: [
     *             {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         ]
     *         severityFilter: {
     *             min: String(Low/Medium/High)
     *             max: String(Low/Medium/High)
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body query detection anomaly result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getAnomaliesByAnomalyDetectionConfigurationNext(
                                        this.getEndpoint(), nextLink, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     filter: {
     *         dimensionFilter: [
     *             {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         ]
     *         severityFilter: {
     *             min: String(Low/Medium/High)
     *             max: String(Low/Medium/High)
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body query detection anomaly result request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getAnomaliesByAnomalyDetectionConfigurationNext(
                        this.getEndpoint(), nextLink, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * Query dimension values of anomalies.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     dimensionName: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body query dimension values request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getDimensionOfAnomaliesByAnomalyDetectionConfigurationNext(
                                        this.getEndpoint(), nextLink, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * Query dimension values of anomalies.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     *     dimensionName: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body query dimension values request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getDimensionOfAnomaliesByAnomalyDetectionConfigurationNext(
                        this.getEndpoint(), nextLink, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * List feedback on the given metric.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     *     feedbackType: String(Anomaly/ChangePoint/Period/Comment)
     *     startTime: String
     *     endTime: String
     *     timeMode: String(MetricTimestamp/FeedbackCreatedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             feedbackId: String
     *             createdTime: String
     *             userPrincipal: String
     *             metricId: String
     *             dimensionFilter: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body metric feedback filter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listMetricFeedbacksNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.listMetricFeedbacksNext(
                                        this.getEndpoint(), nextLink, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * List feedback on the given metric.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     metricId: String
     *     dimensionFilter: {
     *         dimension: {
     *             String: String
     *         }
     *     }
     *     feedbackType: String(Anomaly/ChangePoint/Period/Comment)
     *     startTime: String
     *     endTime: String
     *     timeMode: String(MetricTimestamp/FeedbackCreatedTime)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             feedbackId: String
     *             createdTime: String
     *             userPrincipal: String
     *             metricId: String
     *             dimensionFilter: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body metric feedback filter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listMetricFeedbacksNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.listMetricFeedbacksNext(this.getEndpoint(), nextLink, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String(NotStarted/Scheduled/Running/Succeeded/Failed/NoData/Error/Paused)
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body The query time range.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return data ingestion status by data feed along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getDataFeedIngestionStatusNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getDataFeedIngestionStatusNext(
                                        this.getEndpoint(), nextLink, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String(NotStarted/Scheduled/Running/Succeeded/Failed/NoData/Error/Paused)
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body The query time range.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return data ingestion status by data feed along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getDataFeedIngestionStatusNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getDataFeedIngestionStatusNext(this.getEndpoint(), nextLink, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     activeSince: String
     *     dimensionFilter: {
     *         String: [
     *             String
     *         ]
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             metricId: String
     *             dimension: {
     *                 String: String
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body filter to query series.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getMetricSeriesNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getMetricSeriesNext(
                                        this.getEndpoint(), nextLink, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     activeSince: String
     *     dimensionFilter: {
     *         String: [
     *             String
     *         ]
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             metricId: String
     *             dimension: {
     *                 String: String
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body filter to query series.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getMetricSeriesNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getMetricSeriesNext(this.getEndpoint(), nextLink, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * List dimension from certain metric.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dimensionName: String
     *     dimensionValueFilter: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body query dimension option.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getMetricDimensionNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getMetricDimensionNext(
                                        this.getEndpoint(), nextLink, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * List dimension from certain metric.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dimensionName: String
     *     dimensionValueFilter: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         String
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body query dimension option.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getMetricDimensionNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getMetricDimensionNext(this.getEndpoint(), nextLink, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * Query anomaly detection status.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body query options.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getEnrichmentStatusByMetricNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getEnrichmentStatusByMetricNext(
                                        this.getEndpoint(), nextLink, body, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * Query anomaly detection status.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTime: String
     *     endTime: String
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             timestamp: String
     *             status: String
     *             message: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink the next link.
     * @param body query options.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getEnrichmentStatusByMetricNextSinglePageAsync(
            String nextLink, BinaryData body, RequestOptions requestOptions, Context context) {
        return service.getEnrichmentStatusByMetricNext(this.getEndpoint(), nextLink, body, requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getAnomaliesFromAlertByAnomalyAlertingConfigurationNext(
                                        nextLink, this.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             timestamp: String
     *             createdTime: String
     *             modifiedTime: String
     *             dimension: {
     *                 String: String
     *             }
     *             property: {
     *                 anomalySeverity: String(Low/Medium/High)
     *                 anomalyStatus: String(Active/Resolved)
     *                 value: Double
     *                 expectedValue: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions, Context context) {
        return service.getAnomaliesFromAlertByAnomalyAlertingConfigurationNext(
                        nextLink, this.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getIncidentsFromAlertByAnomalyAlertingConfigurationNext(
                                        nextLink, this.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions, Context context) {
        return service.getIncidentsFromAlertByAnomalyAlertingConfigurationNext(
                        nextLink, this.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyAlertingConfigurationId: String
     *             name: String
     *             description: String
     *             crossMetricsOperator: String(AND/OR/XOR)
     *             splitAlertByDimensions: [
     *                 String
     *             ]
     *             hookIds: [
     *                 String
     *             ]
     *             metricAlertingConfigurations: [
     *                 {
     *                     anomalyDetectionConfigurationId: String
     *                     anomalyScopeType: String(All/Dimension/TopN)
     *                     negationOperation: Boolean
     *                     dimensionAnomalyScope: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     topNAnomalyScope: {
     *                         top: int
     *                         period: int
     *                         minTopCount: int
     *                     }
     *                     severityFilter: {
     *                         minAlertSeverity: String(Low/Medium/High)
     *                         maxAlertSeverity: String(Low/Medium/High)
     *                     }
     *                     snoozeFilter: {
     *                         autoSnooze: int
     *                         snoozeScope: String(Metric/Series)
     *                         onlyForSuccessive: boolean
     *                     }
     *                     valueFilter: {
     *                         lower: Double
     *                         upper: Double
     *                         direction: String(Both/Down/Up)
     *                         type: String(Value/Mean)
     *                         metricId: String
     *                         triggerForMissing: Boolean
     *                     }
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>>
            getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNextSinglePageAsync(
                    String nextLink, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNext(
                                        nextLink, this.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyAlertingConfigurationId: String
     *             name: String
     *             description: String
     *             crossMetricsOperator: String(AND/OR/XOR)
     *             splitAlertByDimensions: [
     *                 String
     *             ]
     *             hookIds: [
     *                 String
     *             ]
     *             metricAlertingConfigurations: [
     *                 {
     *                     anomalyDetectionConfigurationId: String
     *                     anomalyScopeType: String(All/Dimension/TopN)
     *                     negationOperation: Boolean
     *                     dimensionAnomalyScope: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     topNAnomalyScope: {
     *                         top: int
     *                         period: int
     *                         minTopCount: int
     *                     }
     *                     severityFilter: {
     *                         minAlertSeverity: String(Low/Medium/High)
     *                         maxAlertSeverity: String(Low/Medium/High)
     *                     }
     *                     snoozeFilter: {
     *                         autoSnooze: int
     *                         snoozeScope: String(Metric/Series)
     *                         onlyForSuccessive: boolean
     *                     }
     *                     valueFilter: {
     *                         lower: Double
     *                         upper: Double
     *                         direction: String(Both/Down/Up)
     *                         type: String(Value/Mean)
     *                         metricId: String
     *                         triggerForMissing: Boolean
     *                     }
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>>
            getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNextSinglePageAsync(
                    String nextLink, RequestOptions requestOptions, Context context) {
        return service.getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNext(
                        nextLink, this.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getIncidentsByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getIncidentsByAnomalyDetectionConfigurationNext(
                                        nextLink, this.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getIncidentsByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions, Context context) {
        return service.getIncidentsByAnomalyDetectionConfigurationNext(
                        nextLink, this.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getIncidentsByAnomalyDetectionConfigurationNextPagesNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getIncidentsByAnomalyDetectionConfigurationNextPagesNext(
                                        nextLink, this.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             metricId: String
     *             anomalyDetectionConfigurationId: String
     *             incidentId: String
     *             startTime: String
     *             lastTime: String
     *             rootNode: {
     *                 dimension: {
     *                     String: String
     *                 }
     *             }
     *             property: {
     *                 maxSeverity: String(Low/Medium/High)
     *                 incidentStatus: String(Active/Resolved)
     *                 valueOfRootNode: Double
     *                 expectedValueOfRootNode: Double
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getIncidentsByAnomalyDetectionConfigurationNextPagesNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions, Context context) {
        return service.getIncidentsByAnomalyDetectionConfigurationNextPagesNext(
                        nextLink, this.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataSourceCredentialId: String
     *             dataSourceCredentialName: String
     *             dataSourceCredentialDescription: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listCredentialsNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context -> service.listCredentialsNext(nextLink, this.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataSourceCredentialId: String
     *             dataSourceCredentialName: String
     *             dataSourceCredentialDescription: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listCredentialsNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions, Context context) {
        return service.listCredentialsNext(nextLink, this.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             dataFeedName: String
     *             dataFeedDescription: String
     *             granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *             granularityAmount: Integer
     *             metrics: [
     *                 {
     *                     metricId: String
     *                     metricName: String
     *                     metricDisplayName: String
     *                     metricDescription: String
     *                 }
     *             ]
     *             dimension: [
     *                 {
     *                     dimensionName: String
     *                     dimensionDisplayName: String
     *                 }
     *             ]
     *             timestampColumn: String
     *             dataStartFrom: String
     *             startOffsetInSeconds: Long
     *             maxConcurrency: Integer
     *             minRetryIntervalInSeconds: Long
     *             stopRetryAfterInSeconds: Long
     *             needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *             rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *             rollUpColumns: [
     *                 String
     *             ]
     *             allUpIdentification: String
     *             fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *             fillMissingPointValue: Double
     *             viewMode: String(Private/Public)
     *             admins: [
     *                 String
     *             ]
     *             viewers: [
     *                 String
     *             ]
     *             isAdmin: Boolean
     *             creator: String
     *             status: String(Active/Paused)
     *             createdTime: String
     *             actionLinkTemplate: String
     *             authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *             credentialId: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listDataFeedsNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context -> service.listDataFeedsNext(nextLink, this.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             dataFeedId: String
     *             dataFeedName: String
     *             dataFeedDescription: String
     *             granularityName: String(Yearly/Monthly/Weekly/Daily/Hourly/Minutely/Custom)
     *             granularityAmount: Integer
     *             metrics: [
     *                 {
     *                     metricId: String
     *                     metricName: String
     *                     metricDisplayName: String
     *                     metricDescription: String
     *                 }
     *             ]
     *             dimension: [
     *                 {
     *                     dimensionName: String
     *                     dimensionDisplayName: String
     *                 }
     *             ]
     *             timestampColumn: String
     *             dataStartFrom: String
     *             startOffsetInSeconds: Long
     *             maxConcurrency: Integer
     *             minRetryIntervalInSeconds: Long
     *             stopRetryAfterInSeconds: Long
     *             needRollup: String(NoRollup/NeedRollup/AlreadyRollup)
     *             rollUpMethod: String(None/Sum/Max/Min/Avg/Count)
     *             rollUpColumns: [
     *                 String
     *             ]
     *             allUpIdentification: String
     *             fillMissingPointType: String(SmartFilling/PreviousValue/CustomValue/NoFilling)
     *             fillMissingPointValue: Double
     *             viewMode: String(Private/Public)
     *             admins: [
     *                 String
     *             ]
     *             viewers: [
     *                 String
     *             ]
     *             isAdmin: Boolean
     *             creator: String
     *             status: String(Active/Paused)
     *             createdTime: String
     *             actionLinkTemplate: String
     *             authenticationType: String(Basic/ManagedIdentity/AzureSQLConnectionString/DataLakeGen2SharedKey/ServicePrincipal/ServicePrincipalInKV)
     *             credentialId: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listDataFeedsNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions, Context context) {
        return service.listDataFeedsNext(nextLink, this.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             hookId: String
     *             hookName: String
     *             description: String
     *             externalLink: String
     *             admins: [
     *                 String
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listHooksNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context -> service.listHooksNext(nextLink, this.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nextLink: String
     *     value: [
     *         {
     *             hookId: String
     *             hookName: String
     *             description: String
     *             externalLink: String
     *             admins: [
     *                 String
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> listHooksNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions, Context context) {
        return service.listHooksNext(nextLink, this.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             name: String
     *             description: String
     *             metricId: String
     *             wholeMetricConfiguration: {
     *                 conditionOperator: String(AND/OR)
     *                 smartDetectionCondition: {
     *                     sensitivity: double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: {
     *                         minNumber: int
     *                         minRatio: double
     *                     }
     *                 }
     *                 hardThresholdCondition: {
     *                     lowerBound: Double
     *                     upperBound: Double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *                 changeThresholdCondition: {
     *                     changePercentage: double
     *                     shiftPoint: int
     *                     withinRange: boolean
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *             }
     *             dimensionGroupOverrideConfigurations: [
     *                 {
     *                     group: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *             seriesOverrideConfigurations: [
     *                 {
     *                     series: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAnomalyDetectionConfigurationsByMetricNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getAnomalyDetectionConfigurationsByMetricNext(
                                        nextLink, this.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             anomalyDetectionConfigurationId: String
     *             name: String
     *             description: String
     *             metricId: String
     *             wholeMetricConfiguration: {
     *                 conditionOperator: String(AND/OR)
     *                 smartDetectionCondition: {
     *                     sensitivity: double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: {
     *                         minNumber: int
     *                         minRatio: double
     *                     }
     *                 }
     *                 hardThresholdCondition: {
     *                     lowerBound: Double
     *                     upperBound: Double
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *                 changeThresholdCondition: {
     *                     changePercentage: double
     *                     shiftPoint: int
     *                     withinRange: boolean
     *                     anomalyDetectorDirection: String(Both/Down/Up)
     *                     suppressCondition: (recursive schema, see suppressCondition above)
     *                 }
     *             }
     *             dimensionGroupOverrideConfigurations: [
     *                 {
     *                     group: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *             seriesOverrideConfigurations: [
     *                 {
     *                     series: {
     *                         dimension: {
     *                             String: String
     *                         }
     *                     }
     *                     conditionOperator: String(AND/OR)
     *                     smartDetectionCondition: (recursive schema, see smartDetectionCondition above)
     *                     hardThresholdCondition: (recursive schema, see hardThresholdCondition above)
     *                     changeThresholdCondition: (recursive schema, see changeThresholdCondition above)
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getAnomalyDetectionConfigurationsByMetricNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions, Context context) {
        return service.getAnomalyDetectionConfigurationsByMetricNext(
                        nextLink, this.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    private List<BinaryData> getValues(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            List<?> values = (List<?>) obj.get(path);
            return values.stream().map(BinaryData::fromObject).collect(Collectors.toList());
        } catch (RuntimeException e) {
            return null;
        }
    }

    private String getNextLink(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            return (String) obj.get(path);
        } catch (RuntimeException e) {
            return null;
        }
    }
}
