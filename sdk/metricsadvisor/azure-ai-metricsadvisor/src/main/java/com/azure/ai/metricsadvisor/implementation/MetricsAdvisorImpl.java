// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.ai.metricsadvisor.implementation;

import com.azure.ai.metricsadvisor.implementation.models.AlertResultList;
import com.azure.ai.metricsadvisor.implementation.models.AlertingResultQuery;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyAlertingConfiguration;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyAlertingConfigurationList;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyAlertingConfigurationPatch;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyDetectionConfiguration;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyDetectionConfigurationList;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyDetectionConfigurationPatch;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyDimensionList;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyDimensionQuery;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyResult;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyResultList;
import com.azure.ai.metricsadvisor.implementation.models.CreateAnomalyAlertingConfigurationResponse;
import com.azure.ai.metricsadvisor.implementation.models.CreateAnomalyDetectionConfigurationResponse;
import com.azure.ai.metricsadvisor.implementation.models.CreateCredentialResponse;
import com.azure.ai.metricsadvisor.implementation.models.CreateDataFeedResponse;
import com.azure.ai.metricsadvisor.implementation.models.CreateHookResponse;
import com.azure.ai.metricsadvisor.implementation.models.CreateMetricFeedbackResponse;
import com.azure.ai.metricsadvisor.implementation.models.DataFeedDetail;
import com.azure.ai.metricsadvisor.implementation.models.DataFeedDetailPatch;
import com.azure.ai.metricsadvisor.implementation.models.DataFeedIngestionProgress;
import com.azure.ai.metricsadvisor.implementation.models.DataFeedIngestionStatus;
import com.azure.ai.metricsadvisor.implementation.models.DataFeedList;
import com.azure.ai.metricsadvisor.implementation.models.DataSourceCredential;
import com.azure.ai.metricsadvisor.implementation.models.DataSourceCredentialList;
import com.azure.ai.metricsadvisor.implementation.models.DataSourceCredentialPatch;
import com.azure.ai.metricsadvisor.implementation.models.DataSourceType;
import com.azure.ai.metricsadvisor.implementation.models.DetectionAnomalyResultQuery;
import com.azure.ai.metricsadvisor.implementation.models.DetectionIncidentResultQuery;
import com.azure.ai.metricsadvisor.implementation.models.DetectionSeriesQuery;
import com.azure.ai.metricsadvisor.implementation.models.EnrichmentStatusList;
import com.azure.ai.metricsadvisor.implementation.models.EnrichmentStatusQueryOption;
import com.azure.ai.metricsadvisor.implementation.models.EntityStatus;
import com.azure.ai.metricsadvisor.implementation.models.Granularity;
import com.azure.ai.metricsadvisor.implementation.models.HookInfo;
import com.azure.ai.metricsadvisor.implementation.models.HookInfoPatch;
import com.azure.ai.metricsadvisor.implementation.models.HookList;
import com.azure.ai.metricsadvisor.implementation.models.IncidentResult;
import com.azure.ai.metricsadvisor.implementation.models.IncidentResultList;
import com.azure.ai.metricsadvisor.implementation.models.IngestionProgressResetOptions;
import com.azure.ai.metricsadvisor.implementation.models.IngestionStatusList;
import com.azure.ai.metricsadvisor.implementation.models.IngestionStatusQueryOptions;
import com.azure.ai.metricsadvisor.implementation.models.MetricDataList;
import com.azure.ai.metricsadvisor.implementation.models.MetricDataQueryOptions;
import com.azure.ai.metricsadvisor.implementation.models.MetricDimensionList;
import com.azure.ai.metricsadvisor.implementation.models.MetricDimensionQueryOptions;
import com.azure.ai.metricsadvisor.implementation.models.MetricFeedback;
import com.azure.ai.metricsadvisor.implementation.models.MetricFeedbackFilter;
import com.azure.ai.metricsadvisor.implementation.models.MetricFeedbackList;
import com.azure.ai.metricsadvisor.implementation.models.MetricSeriesItem;
import com.azure.ai.metricsadvisor.implementation.models.MetricSeriesList;
import com.azure.ai.metricsadvisor.implementation.models.MetricSeriesQueryOptions;
import com.azure.ai.metricsadvisor.implementation.models.RootCauseList;
import com.azure.ai.metricsadvisor.implementation.models.SeriesResultList;
import com.azure.ai.metricsadvisor.implementation.models.UsageStats;
import com.azure.ai.metricsadvisor.models.AnomalyAlert;
import com.azure.ai.metricsadvisor.models.EnrichmentStatus;
import com.azure.ai.metricsadvisor.models.MetricsAdvisorResponseException;
import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.CookiePolicy;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.serializer.JacksonAdapter;
import com.azure.core.util.serializer.SerializerAdapter;
import java.util.UUID;
import reactor.core.publisher.Mono;

/** Initializes a new instance of the MetricsAdvisor type. */
public final class MetricsAdvisorImpl {
    /** The proxy service used to perform REST calls. */
    private final MetricsAdvisorService service;

    /**
     * Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     */
    private final String endpoint;

    /**
     * Gets Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     *
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /** The HTTP pipeline to send requests through. */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     *
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /** The serializer to serialize an object into a string. */
    private final SerializerAdapter serializerAdapter;

    /**
     * Gets The serializer to serialize an object into a string.
     *
     * @return the serializerAdapter value.
     */
    public SerializerAdapter getSerializerAdapter() {
        return this.serializerAdapter;
    }

    /**
     * Initializes an instance of MetricsAdvisor client.
     *
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *     https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     */
    MetricsAdvisorImpl(String endpoint) {
        this(
                new HttpPipelineBuilder()
                        .policies(new UserAgentPolicy(), new RetryPolicy(), new CookiePolicy())
                        .build(),
                JacksonAdapter.createDefaultSerializerAdapter(),
                endpoint);
    }

    /**
     * Initializes an instance of MetricsAdvisor client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *     https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     */
    MetricsAdvisorImpl(HttpPipeline httpPipeline, String endpoint) {
        this(httpPipeline, JacksonAdapter.createDefaultSerializerAdapter(), endpoint);
    }

    /**
     * Initializes an instance of MetricsAdvisor client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param serializerAdapter The serializer to serialize an object into a string.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *     https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     */
    MetricsAdvisorImpl(HttpPipeline httpPipeline, SerializerAdapter serializerAdapter, String endpoint) {
        this.httpPipeline = httpPipeline;
        this.serializerAdapter = serializerAdapter;
        this.endpoint = endpoint;
        this.service = RestProxy.create(MetricsAdvisorService.class, this.httpPipeline, this.getSerializerAdapter());
    }

    /**
     * The interface defining all the services for MetricsAdvisor to be used by the proxy service to perform REST calls.
     */
    @Host("{endpoint}/metricsadvisor/v1.0")
    @ServiceInterface(name = "MetricsAdvisor")
    public interface MetricsAdvisorService {
        @Get("/stats/latest")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<UsageStats>> getActiveSeriesCount(
                @HostParam("endpoint") String endpoint, @HeaderParam("Accept") String accept, Context context);

        @Get("/stats/latest")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<UsageStats> getActiveSeriesCountSync(
                @HostParam("endpoint") String endpoint, @HeaderParam("Accept") String accept, Context context);

        @Get("/alert/anomaly/configurations/{configurationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AnomalyAlertingConfiguration>> getAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/alert/anomaly/configurations/{configurationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AnomalyAlertingConfiguration> getAnomalyAlertingConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/alert/anomaly/configurations/{configurationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AnomalyAlertingConfiguration>> updateAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @BodyParam("application/merge-patch+json") AnomalyAlertingConfigurationPatch body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/alert/anomaly/configurations/{configurationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AnomalyAlertingConfiguration> updateAnomalyAlertingConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @BodyParam("application/merge-patch+json") AnomalyAlertingConfigurationPatch body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/alert/anomaly/configurations/{configurationId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<Void>> deleteAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/alert/anomaly/configurations/{configurationId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<Void> deleteAnomalyAlertingConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/alert/anomaly/configurations")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<CreateAnomalyAlertingConfigurationResponse> createAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") AnomalyAlertingConfiguration body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/alert/anomaly/configurations")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        CreateAnomalyAlertingConfigurationResponse createAnomalyAlertingConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") AnomalyAlertingConfiguration body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/alert/anomaly/configurations/{configurationId}/alerts/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AlertResultList>> getAlertsByAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") AlertingResultQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/alert/anomaly/configurations/{configurationId}/alerts/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AlertResultList> getAlertsByAnomalyAlertingConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") AlertingResultQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/alert/anomaly/configurations/{configurationId}/alerts/{alertId}/anomalies")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AnomalyResultList>> getAnomaliesFromAlertByAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @PathParam("alertId") String alertId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/alert/anomaly/configurations/{configurationId}/alerts/{alertId}/anomalies")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AnomalyResultList> getAnomaliesFromAlertByAnomalyAlertingConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @PathParam("alertId") String alertId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/alert/anomaly/configurations/{configurationId}/alerts/{alertId}/incidents")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<IncidentResultList>> getIncidentsFromAlertByAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @PathParam("alertId") String alertId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/alert/anomaly/configurations/{configurationId}/alerts/{alertId}/incidents")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<IncidentResultList> getIncidentsFromAlertByAnomalyAlertingConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @PathParam("alertId") String alertId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/enrichment/anomalyDetection/configurations/{configurationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AnomalyDetectionConfiguration>> getAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/enrichment/anomalyDetection/configurations/{configurationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AnomalyDetectionConfiguration> getAnomalyDetectionConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/enrichment/anomalyDetection/configurations/{configurationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AnomalyDetectionConfiguration>> updateAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @BodyParam("application/merge-patch+json") AnomalyDetectionConfigurationPatch body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/enrichment/anomalyDetection/configurations/{configurationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AnomalyDetectionConfiguration> updateAnomalyDetectionConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @BodyParam("application/merge-patch+json") AnomalyDetectionConfigurationPatch body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/enrichment/anomalyDetection/configurations/{configurationId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<Void>> deleteAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/enrichment/anomalyDetection/configurations/{configurationId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<Void> deleteAnomalyDetectionConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<CreateAnomalyDetectionConfigurationResponse> createAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") AnomalyDetectionConfiguration body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        CreateAnomalyDetectionConfigurationResponse createAnomalyDetectionConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") AnomalyDetectionConfiguration body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/enrichment/anomalyDetection/configurations/{configurationId}/alert/anomaly/configurations")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AnomalyAlertingConfigurationList>>
                getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
                        @HostParam("endpoint") String endpoint,
                        @PathParam("configurationId") UUID configurationId,
                        @QueryParam("$skip") Integer skip,
                        @QueryParam("$maxpagesize") Integer maxpagesize,
                        @HeaderParam("Accept") String accept,
                        Context context);

        @Get("/enrichment/anomalyDetection/configurations/{configurationId}/alert/anomaly/configurations")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AnomalyAlertingConfigurationList> getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/series/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<SeriesResultList>> getSeriesByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @BodyParam("application/json") DetectionSeriesQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/series/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<SeriesResultList> getSeriesByAnomalyDetectionConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @BodyParam("application/json") DetectionSeriesQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/anomalies/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AnomalyResultList>> getAnomaliesByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") DetectionAnomalyResultQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/anomalies/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AnomalyResultList> getAnomaliesByAnomalyDetectionConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") DetectionAnomalyResultQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/anomalies/dimension/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AnomalyDimensionList>> getDimensionOfAnomaliesByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") AnomalyDimensionQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/anomalies/dimension/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AnomalyDimensionList> getDimensionOfAnomaliesByAnomalyDetectionConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") AnomalyDimensionQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/incidents/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<IncidentResultList>> getIncidentsByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") DetectionIncidentResultQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/incidents/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<IncidentResultList> getIncidentsByAnomalyDetectionConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") DetectionIncidentResultQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/enrichment/anomalyDetection/configurations/{configurationId}/incidents/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<IncidentResultList>> getIncidentsByAnomalyDetectionConfigurationNextPages(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @QueryParam("$token") String token,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/enrichment/anomalyDetection/configurations/{configurationId}/incidents/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<IncidentResultList> getIncidentsByAnomalyDetectionConfigurationNextPagesSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @QueryParam("$token") String token,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/enrichment/anomalyDetection/configurations/{configurationId}/incidents/{incidentId}/rootCause")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<RootCauseList>> getRootCauseOfIncidentByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @PathParam("incidentId") String incidentId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/enrichment/anomalyDetection/configurations/{configurationId}/incidents/{incidentId}/rootCause")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<RootCauseList> getRootCauseOfIncidentByAnomalyDetectionConfigurationSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @PathParam("incidentId") String incidentId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/credentials")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<CreateCredentialResponse> createCredential(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") DataSourceCredential body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/credentials")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        CreateCredentialResponse createCredentialSync(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") DataSourceCredential body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/credentials")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<DataSourceCredentialList>> listCredentials(
                @HostParam("endpoint") String endpoint,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/credentials")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<DataSourceCredentialList> listCredentialsSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/credentials/{credentialId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<DataSourceCredential>> updateCredential(
                @HostParam("endpoint") String endpoint,
                @PathParam("credentialId") UUID credentialId,
                @BodyParam("application/merge-patch+json") DataSourceCredentialPatch body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/credentials/{credentialId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<DataSourceCredential> updateCredentialSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("credentialId") UUID credentialId,
                @BodyParam("application/merge-patch+json") DataSourceCredentialPatch body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/credentials/{credentialId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<Void>> deleteCredential(
                @HostParam("endpoint") String endpoint,
                @PathParam("credentialId") UUID credentialId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/credentials/{credentialId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<Void> deleteCredentialSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("credentialId") UUID credentialId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/credentials/{credentialId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<DataSourceCredential>> getCredential(
                @HostParam("endpoint") String endpoint,
                @PathParam("credentialId") UUID credentialId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/credentials/{credentialId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<DataSourceCredential> getCredentialSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("credentialId") UUID credentialId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/dataFeeds")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<DataFeedList>> listDataFeeds(
                @HostParam("endpoint") String endpoint,
                @QueryParam("dataFeedName") String dataFeedName,
                @QueryParam("dataSourceType") DataSourceType dataSourceType,
                @QueryParam("granularityName") Granularity granularityName,
                @QueryParam("status") EntityStatus status,
                @QueryParam("creator") String creator,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/dataFeeds")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<DataFeedList> listDataFeedsSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("dataFeedName") String dataFeedName,
                @QueryParam("dataSourceType") DataSourceType dataSourceType,
                @QueryParam("granularityName") Granularity granularityName,
                @QueryParam("status") EntityStatus status,
                @QueryParam("creator") String creator,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/dataFeeds")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<CreateDataFeedResponse> createDataFeed(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") DataFeedDetail body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/dataFeeds")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        CreateDataFeedResponse createDataFeedSync(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") DataFeedDetail body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/dataFeeds/{dataFeedId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<DataFeedDetail>> getDataFeedById(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") UUID dataFeedId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/dataFeeds/{dataFeedId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<DataFeedDetail> getDataFeedByIdSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") UUID dataFeedId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/dataFeeds/{dataFeedId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<DataFeedDetail>> updateDataFeed(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") UUID dataFeedId,
                @BodyParam("application/merge-patch+json") DataFeedDetailPatch body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/dataFeeds/{dataFeedId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<DataFeedDetail> updateDataFeedSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") UUID dataFeedId,
                @BodyParam("application/merge-patch+json") DataFeedDetailPatch body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/dataFeeds/{dataFeedId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<Void>> deleteDataFeed(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") UUID dataFeedId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/dataFeeds/{dataFeedId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<Void> deleteDataFeedSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") UUID dataFeedId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/feedback/metric/{feedbackId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<MetricFeedback>> getMetricFeedback(
                @HostParam("endpoint") String endpoint,
                @PathParam("feedbackId") UUID feedbackId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/feedback/metric/{feedbackId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<MetricFeedback> getMetricFeedbackSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("feedbackId") UUID feedbackId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/feedback/metric/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<MetricFeedbackList>> listMetricFeedbacks(
                @HostParam("endpoint") String endpoint,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") MetricFeedbackFilter body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/feedback/metric/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<MetricFeedbackList> listMetricFeedbacksSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") MetricFeedbackFilter body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/feedback/metric")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<CreateMetricFeedbackResponse> createMetricFeedback(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") MetricFeedback body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/feedback/metric")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        CreateMetricFeedbackResponse createMetricFeedbackSync(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") MetricFeedback body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/hooks")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<HookList>> listHooks(
                @HostParam("endpoint") String endpoint,
                @QueryParam("hookName") String hookName,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/hooks")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<HookList> listHooksSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("hookName") String hookName,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/hooks")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<CreateHookResponse> createHook(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") HookInfo body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/hooks")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        CreateHookResponse createHookSync(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") HookInfo body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/hooks/{hookId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<HookInfo>> getHook(
                @HostParam("endpoint") String endpoint,
                @PathParam("hookId") UUID hookId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/hooks/{hookId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<HookInfo> getHookSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("hookId") UUID hookId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/hooks/{hookId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<HookInfo>> updateHook(
                @HostParam("endpoint") String endpoint,
                @PathParam("hookId") UUID hookId,
                @BodyParam("application/merge-patch+json") HookInfoPatch body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/hooks/{hookId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<HookInfo> updateHookSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("hookId") UUID hookId,
                @BodyParam("application/merge-patch+json") HookInfoPatch body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/hooks/{hookId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<Void>> deleteHook(
                @HostParam("endpoint") String endpoint,
                @PathParam("hookId") UUID hookId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/hooks/{hookId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<Void> deleteHookSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("hookId") UUID hookId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/dataFeeds/{dataFeedId}/ingestionStatus/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<IngestionStatusList>> getDataFeedIngestionStatus(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") UUID dataFeedId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") IngestionStatusQueryOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/dataFeeds/{dataFeedId}/ingestionStatus/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<IngestionStatusList> getDataFeedIngestionStatusSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") UUID dataFeedId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") IngestionStatusQueryOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/dataFeeds/{dataFeedId}/ingestionProgress/reset")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<Void>> resetDataFeedIngestionStatus(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") UUID dataFeedId,
                @BodyParam("application/json") IngestionProgressResetOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/dataFeeds/{dataFeedId}/ingestionProgress/reset")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<Void> resetDataFeedIngestionStatusSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") UUID dataFeedId,
                @BodyParam("application/json") IngestionProgressResetOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/dataFeeds/{dataFeedId}/ingestionProgress")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<DataFeedIngestionProgress>> getIngestionProgress(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") UUID dataFeedId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/dataFeeds/{dataFeedId}/ingestionProgress")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<DataFeedIngestionProgress> getIngestionProgressSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") UUID dataFeedId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/metrics/{metricId}/data/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<MetricDataList>> getMetricData(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") UUID metricId,
                @BodyParam("application/json") MetricDataQueryOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/metrics/{metricId}/data/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<MetricDataList> getMetricDataSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") UUID metricId,
                @BodyParam("application/json") MetricDataQueryOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/metrics/{metricId}/series/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<MetricSeriesList>> getMetricSeries(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") UUID metricId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") MetricSeriesQueryOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/metrics/{metricId}/series/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<MetricSeriesList> getMetricSeriesSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") UUID metricId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") MetricSeriesQueryOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/metrics/{metricId}/dimension/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<MetricDimensionList>> getMetricDimension(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") UUID metricId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") MetricDimensionQueryOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/metrics/{metricId}/dimension/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<MetricDimensionList> getMetricDimensionSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") UUID metricId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") MetricDimensionQueryOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/metrics/{metricId}/enrichment/anomalyDetection/configurations")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AnomalyDetectionConfigurationList>> getAnomalyDetectionConfigurationsByMetric(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") UUID metricId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/metrics/{metricId}/enrichment/anomalyDetection/configurations")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AnomalyDetectionConfigurationList> getAnomalyDetectionConfigurationsByMetricSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") UUID metricId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/metrics/{metricId}/status/enrichment/anomalyDetection/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<EnrichmentStatusList>> getEnrichmentStatusByMetric(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") UUID metricId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") EnrichmentStatusQueryOption body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/metrics/{metricId}/status/enrichment/anomalyDetection/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<EnrichmentStatusList> getEnrichmentStatusByMetricSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") UUID metricId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$maxpagesize") Integer maxpagesize,
                @BodyParam("application/json") EnrichmentStatusQueryOption body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AlertResultList>> getAlertsByAnomalyAlertingConfigurationNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") AlertingResultQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AlertResultList> getAlertsByAnomalyAlertingConfigurationNextSync(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") AlertingResultQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AnomalyResultList>> getAnomaliesByAnomalyDetectionConfigurationNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") DetectionAnomalyResultQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AnomalyResultList> getAnomaliesByAnomalyDetectionConfigurationNextSync(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") DetectionAnomalyResultQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AnomalyDimensionList>> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") AnomalyDimensionQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AnomalyDimensionList> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSync(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") AnomalyDimensionQuery body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<MetricFeedbackList>> listMetricFeedbacksNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") MetricFeedbackFilter body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<MetricFeedbackList> listMetricFeedbacksNextSync(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") MetricFeedbackFilter body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<IngestionStatusList>> getDataFeedIngestionStatusNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") IngestionStatusQueryOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<IngestionStatusList> getDataFeedIngestionStatusNextSync(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") IngestionStatusQueryOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<MetricSeriesList>> getMetricSeriesNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") MetricSeriesQueryOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<MetricSeriesList> getMetricSeriesNextSync(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") MetricSeriesQueryOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<MetricDimensionList>> getMetricDimensionNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") MetricDimensionQueryOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<MetricDimensionList> getMetricDimensionNextSync(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") MetricDimensionQueryOptions body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<EnrichmentStatusList>> getEnrichmentStatusByMetricNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") EnrichmentStatusQueryOption body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<EnrichmentStatusList> getEnrichmentStatusByMetricNextSync(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") EnrichmentStatusQueryOption body,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AnomalyResultList>> getAnomaliesFromAlertByAnomalyAlertingConfigurationNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AnomalyResultList> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSync(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<IncidentResultList>> getIncidentsFromAlertByAnomalyAlertingConfigurationNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<IncidentResultList> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSync(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AnomalyAlertingConfigurationList>>
                getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNext(
                        @PathParam(value = "nextLink", encoded = true) String nextLink,
                        @HostParam("endpoint") String endpoint,
                        @HeaderParam("Accept") String accept,
                        Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AnomalyAlertingConfigurationList>
                getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNextSync(
                        @PathParam(value = "nextLink", encoded = true) String nextLink,
                        @HostParam("endpoint") String endpoint,
                        @HeaderParam("Accept") String accept,
                        Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<IncidentResultList>> getIncidentsByAnomalyDetectionConfigurationNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<IncidentResultList> getIncidentsByAnomalyDetectionConfigurationNextSync(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<IncidentResultList>> getIncidentsByAnomalyDetectionConfigurationNextPagesNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<IncidentResultList> getIncidentsByAnomalyDetectionConfigurationNextPagesNextSync(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<DataSourceCredentialList>> listCredentialsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<DataSourceCredentialList> listCredentialsNextSync(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<DataFeedList>> listDataFeedsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<DataFeedList> listDataFeedsNextSync(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<HookList>> listHooksNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<HookList> listHooksNextSync(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Mono<Response<AnomalyDetectionConfigurationList>> getAnomalyDetectionConfigurationsByMetricNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(MetricsAdvisorResponseException.class)
        Response<AnomalyDetectionConfigurationList> getAnomalyDetectionConfigurationsByMetricNextSync(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);
    }

    /**
     * Get latest usage stats.
     *
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return latest usage stats along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<UsageStats>> getActiveSeriesCountWithResponseAsync() {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getActiveSeriesCount(this.getEndpoint(), accept, context));
    }

    /**
     * Get latest usage stats.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return latest usage stats along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<UsageStats>> getActiveSeriesCountWithResponseAsync(Context context) {
        final String accept = "application/json";
        return service.getActiveSeriesCount(this.getEndpoint(), accept, context);
    }

    /**
     * Get latest usage stats.
     *
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return latest usage stats on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<UsageStats> getActiveSeriesCountAsync() {
        return getActiveSeriesCountWithResponseAsync().flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get latest usage stats.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return latest usage stats on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<UsageStats> getActiveSeriesCountAsync(Context context) {
        return getActiveSeriesCountWithResponseAsync(context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get latest usage stats.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return latest usage stats along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<UsageStats> getActiveSeriesCountWithResponse(Context context) {
        final String accept = "application/json";
        return service.getActiveSeriesCountSync(this.getEndpoint(), accept, context);
    }

    /**
     * Get latest usage stats.
     *
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return latest usage stats.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public UsageStats getActiveSeriesCount() {
        return getActiveSeriesCountWithResponse(Context.NONE).getValue();
    }

    /**
     * Query a single anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyAlertingConfiguration>> getAnomalyAlertingConfigurationWithResponseAsync(
            UUID configurationId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getAnomalyAlertingConfiguration(this.getEndpoint(), configurationId, accept, context));
    }

    /**
     * Query a single anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyAlertingConfiguration>> getAnomalyAlertingConfigurationWithResponseAsync(
            UUID configurationId, Context context) {
        final String accept = "application/json";
        return service.getAnomalyAlertingConfiguration(this.getEndpoint(), configurationId, accept, context);
    }

    /**
     * Query a single anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyAlertingConfiguration> getAnomalyAlertingConfigurationAsync(UUID configurationId) {
        return getAnomalyAlertingConfigurationWithResponseAsync(configurationId)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Query a single anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyAlertingConfiguration> getAnomalyAlertingConfigurationAsync(
            UUID configurationId, Context context) {
        return getAnomalyAlertingConfigurationWithResponseAsync(configurationId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Query a single anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnomalyAlertingConfiguration> getAnomalyAlertingConfigurationWithResponse(
            UUID configurationId, Context context) {
        final String accept = "application/json";
        return service.getAnomalyAlertingConfigurationSync(this.getEndpoint(), configurationId, accept, context);
    }

    /**
     * Query a single anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnomalyAlertingConfiguration getAnomalyAlertingConfiguration(UUID configurationId) {
        return getAnomalyAlertingConfigurationWithResponse(configurationId, Context.NONE).getValue();
    }

    /**
     * Update anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyAlertingConfiguration>> updateAnomalyAlertingConfigurationWithResponseAsync(
            UUID configurationId, AnomalyAlertingConfigurationPatch body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.updateAnomalyAlertingConfiguration(
                                this.getEndpoint(), configurationId, body, accept, context));
    }

    /**
     * Update anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyAlertingConfiguration>> updateAnomalyAlertingConfigurationWithResponseAsync(
            UUID configurationId, AnomalyAlertingConfigurationPatch body, Context context) {
        final String accept = "application/json";
        return service.updateAnomalyAlertingConfiguration(this.getEndpoint(), configurationId, body, accept, context);
    }

    /**
     * Update anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyAlertingConfiguration> updateAnomalyAlertingConfigurationAsync(
            UUID configurationId, AnomalyAlertingConfigurationPatch body) {
        return updateAnomalyAlertingConfigurationWithResponseAsync(configurationId, body)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Update anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyAlertingConfiguration> updateAnomalyAlertingConfigurationAsync(
            UUID configurationId, AnomalyAlertingConfigurationPatch body, Context context) {
        return updateAnomalyAlertingConfigurationWithResponseAsync(configurationId, body, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Update anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnomalyAlertingConfiguration> updateAnomalyAlertingConfigurationWithResponse(
            UUID configurationId, AnomalyAlertingConfigurationPatch body, Context context) {
        final String accept = "application/json";
        return service.updateAnomalyAlertingConfigurationSync(
                this.getEndpoint(), configurationId, body, accept, context);
    }

    /**
     * Update anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnomalyAlertingConfiguration updateAnomalyAlertingConfiguration(
            UUID configurationId, AnomalyAlertingConfigurationPatch body) {
        return updateAnomalyAlertingConfigurationWithResponse(configurationId, body, Context.NONE).getValue();
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAnomalyAlertingConfigurationWithResponseAsync(UUID configurationId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteAnomalyAlertingConfiguration(
                                this.getEndpoint(), configurationId, accept, context));
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAnomalyAlertingConfigurationWithResponseAsync(
            UUID configurationId, Context context) {
        final String accept = "application/json";
        return service.deleteAnomalyAlertingConfiguration(this.getEndpoint(), configurationId, accept, context);
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAnomalyAlertingConfigurationAsync(UUID configurationId) {
        return deleteAnomalyAlertingConfigurationWithResponseAsync(configurationId).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAnomalyAlertingConfigurationAsync(UUID configurationId, Context context) {
        return deleteAnomalyAlertingConfigurationWithResponseAsync(configurationId, context)
                .flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteAnomalyAlertingConfigurationWithResponse(UUID configurationId, Context context) {
        final String accept = "application/json";
        return service.deleteAnomalyAlertingConfigurationSync(this.getEndpoint(), configurationId, accept, context);
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteAnomalyAlertingConfiguration(UUID configurationId) {
        deleteAnomalyAlertingConfigurationWithResponse(configurationId, Context.NONE);
    }

    /**
     * Create anomaly alerting configuration.
     *
     * @param body anomaly alerting configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateAnomalyAlertingConfigurationResponse> createAnomalyAlertingConfigurationWithResponseAsync(
            AnomalyAlertingConfiguration body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.createAnomalyAlertingConfiguration(this.getEndpoint(), body, accept, context));
    }

    /**
     * Create anomaly alerting configuration.
     *
     * @param body anomaly alerting configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateAnomalyAlertingConfigurationResponse> createAnomalyAlertingConfigurationWithResponseAsync(
            AnomalyAlertingConfiguration body, Context context) {
        final String accept = "application/json";
        return service.createAnomalyAlertingConfiguration(this.getEndpoint(), body, accept, context);
    }

    /**
     * Create anomaly alerting configuration.
     *
     * @param body anomaly alerting configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createAnomalyAlertingConfigurationAsync(AnomalyAlertingConfiguration body) {
        return createAnomalyAlertingConfigurationWithResponseAsync(body).flatMap(ignored -> Mono.empty());
    }

    /**
     * Create anomaly alerting configuration.
     *
     * @param body anomaly alerting configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createAnomalyAlertingConfigurationAsync(AnomalyAlertingConfiguration body, Context context) {
        return createAnomalyAlertingConfigurationWithResponseAsync(body, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Create anomaly alerting configuration.
     *
     * @param body anomaly alerting configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public CreateAnomalyAlertingConfigurationResponse createAnomalyAlertingConfigurationWithResponse(
            AnomalyAlertingConfiguration body, Context context) {
        final String accept = "application/json";
        return service.createAnomalyAlertingConfigurationSync(this.getEndpoint(), body, accept, context);
    }

    /**
     * Create anomaly alerting configuration.
     *
     * @param body anomaly alerting configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createAnomalyAlertingConfiguration(AnomalyAlertingConfiguration body) {
        createAnomalyAlertingConfigurationWithResponse(body, Context.NONE);
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyAlert>> getAlertsByAnomalyAlertingConfigurationSinglePageAsync(
            UUID configurationId, AlertingResultQuery body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getAlertsByAnomalyAlertingConfiguration(
                                        this.getEndpoint(), configurationId, skip, maxpagesize, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyAlert>> getAlertsByAnomalyAlertingConfigurationSinglePageAsync(
            UUID configurationId, AlertingResultQuery body, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.getAlertsByAnomalyAlertingConfiguration(
                        this.getEndpoint(), configurationId, skip, maxpagesize, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnomalyAlert> getAlertsByAnomalyAlertingConfigurationAsync(
            UUID configurationId, AlertingResultQuery body, Integer skip, Integer maxpagesize) {
        return new PagedFlux<>(
                () -> getAlertsByAnomalyAlertingConfigurationSinglePageAsync(configurationId, body, skip, maxpagesize),
                nextLink -> getAlertsByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink, body));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnomalyAlert> getAlertsByAnomalyAlertingConfigurationAsync(
            UUID configurationId, AlertingResultQuery body, Integer skip, Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () ->
                        getAlertsByAnomalyAlertingConfigurationSinglePageAsync(
                                configurationId, body, skip, maxpagesize, context),
                nextLink -> getAlertsByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink, body, context));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyAlert> getAlertsByAnomalyAlertingConfigurationSinglePage(
            UUID configurationId, AlertingResultQuery body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        Response<AlertResultList> res =
                service.getAlertsByAnomalyAlertingConfigurationSync(
                        this.getEndpoint(), configurationId, skip, maxpagesize, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyAlert> getAlertsByAnomalyAlertingConfigurationSinglePage(
            UUID configurationId, AlertingResultQuery body, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        Response<AlertResultList> res =
                service.getAlertsByAnomalyAlertingConfigurationSync(
                        this.getEndpoint(), configurationId, skip, maxpagesize, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnomalyAlert> getAlertsByAnomalyAlertingConfiguration(
            UUID configurationId, AlertingResultQuery body, Integer skip, Integer maxpagesize) {
        return new PagedIterable<>(
                () ->
                        getAlertsByAnomalyAlertingConfigurationSinglePage(
                                configurationId, body, skip, maxpagesize, Context.NONE),
                nextLink -> getAlertsByAnomalyAlertingConfigurationNextSinglePage(nextLink, body));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnomalyAlert> getAlertsByAnomalyAlertingConfiguration(
            UUID configurationId, AlertingResultQuery body, Integer skip, Integer maxpagesize, Context context) {
        return new PagedIterable<>(
                () ->
                        getAlertsByAnomalyAlertingConfigurationSinglePage(
                                configurationId, body, skip, maxpagesize, context),
                nextLink -> getAlertsByAnomalyAlertingConfigurationNextSinglePage(nextLink, body, context));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getAnomaliesFromAlertByAnomalyAlertingConfiguration(
                                        this.getEndpoint(),
                                        configurationId,
                                        alertId,
                                        skip,
                                        maxpagesize,
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.getAnomaliesFromAlertByAnomalyAlertingConfiguration(
                        this.getEndpoint(), configurationId, alertId, skip, maxpagesize, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnomalyResult> getAnomaliesFromAlertByAnomalyAlertingConfigurationAsync(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize) {
        return new PagedFlux<>(
                () ->
                        getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
                                configurationId, alertId, skip, maxpagesize),
                nextLink -> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnomalyResult> getAnomaliesFromAlertByAnomalyAlertingConfigurationAsync(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () ->
                        getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
                                configurationId, alertId, skip, maxpagesize, context),
                nextLink -> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink, context));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyResult> getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePage(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        Response<AnomalyResultList> res =
                service.getAnomaliesFromAlertByAnomalyAlertingConfigurationSync(
                        this.getEndpoint(), configurationId, alertId, skip, maxpagesize, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query anomalies under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyResult> getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePage(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        Response<AnomalyResultList> res =
                service.getAnomaliesFromAlertByAnomalyAlertingConfigurationSync(
                        this.getEndpoint(), configurationId, alertId, skip, maxpagesize, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query anomalies under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnomalyResult> getAnomaliesFromAlertByAnomalyAlertingConfiguration(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize) {
        return new PagedIterable<>(
                () ->
                        getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePage(
                                configurationId, alertId, skip, maxpagesize, Context.NONE),
                nextLink -> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePage(nextLink));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnomalyResult> getAnomaliesFromAlertByAnomalyAlertingConfiguration(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize, Context context) {
        return new PagedIterable<>(
                () ->
                        getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePage(
                                configurationId, alertId, skip, maxpagesize, context),
                nextLink -> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePage(nextLink, context));
    }

    /**
     * Query incidents under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getIncidentsFromAlertByAnomalyAlertingConfiguration(
                                        this.getEndpoint(),
                                        configurationId,
                                        alertId,
                                        skip,
                                        maxpagesize,
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query incidents under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.getIncidentsFromAlertByAnomalyAlertingConfiguration(
                        this.getEndpoint(), configurationId, alertId, skip, maxpagesize, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query incidents under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<IncidentResult> getIncidentsFromAlertByAnomalyAlertingConfigurationAsync(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize) {
        return new PagedFlux<>(
                () ->
                        getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
                                configurationId, alertId, skip, maxpagesize),
                nextLink -> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink));
    }

    /**
     * Query incidents under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<IncidentResult> getIncidentsFromAlertByAnomalyAlertingConfigurationAsync(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () ->
                        getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
                                configurationId, alertId, skip, maxpagesize, context),
                nextLink -> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink, context));
    }

    /**
     * Query incidents under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<IncidentResult> getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePage(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        Response<IncidentResultList> res =
                service.getIncidentsFromAlertByAnomalyAlertingConfigurationSync(
                        this.getEndpoint(), configurationId, alertId, skip, maxpagesize, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query incidents under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<IncidentResult> getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePage(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        Response<IncidentResultList> res =
                service.getIncidentsFromAlertByAnomalyAlertingConfigurationSync(
                        this.getEndpoint(), configurationId, alertId, skip, maxpagesize, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query incidents under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<IncidentResult> getIncidentsFromAlertByAnomalyAlertingConfiguration(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize) {
        return new PagedIterable<>(
                () ->
                        getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePage(
                                configurationId, alertId, skip, maxpagesize, Context.NONE),
                nextLink -> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePage(nextLink));
    }

    /**
     * Query incidents under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<IncidentResult> getIncidentsFromAlertByAnomalyAlertingConfiguration(
            UUID configurationId, String alertId, Integer skip, Integer maxpagesize, Context context) {
        return new PagedIterable<>(
                () ->
                        getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePage(
                                configurationId, alertId, skip, maxpagesize, context),
                nextLink -> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePage(nextLink, context));
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyDetectionConfiguration>> getAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getAnomalyDetectionConfiguration(this.getEndpoint(), configurationId, accept, context));
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyDetectionConfiguration>> getAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, Context context) {
        final String accept = "application/json";
        return service.getAnomalyDetectionConfiguration(this.getEndpoint(), configurationId, accept, context);
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyDetectionConfiguration> getAnomalyDetectionConfigurationAsync(UUID configurationId) {
        return getAnomalyDetectionConfigurationWithResponseAsync(configurationId)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyDetectionConfiguration> getAnomalyDetectionConfigurationAsync(
            UUID configurationId, Context context) {
        return getAnomalyDetectionConfigurationWithResponseAsync(configurationId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnomalyDetectionConfiguration> getAnomalyDetectionConfigurationWithResponse(
            UUID configurationId, Context context) {
        final String accept = "application/json";
        return service.getAnomalyDetectionConfigurationSync(this.getEndpoint(), configurationId, accept, context);
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnomalyDetectionConfiguration getAnomalyDetectionConfiguration(UUID configurationId) {
        return getAnomalyDetectionConfigurationWithResponse(configurationId, Context.NONE).getValue();
    }

    /**
     * Update anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyDetectionConfiguration>> updateAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, AnomalyDetectionConfigurationPatch body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.updateAnomalyDetectionConfiguration(
                                this.getEndpoint(), configurationId, body, accept, context));
    }

    /**
     * Update anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyDetectionConfiguration>> updateAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, AnomalyDetectionConfigurationPatch body, Context context) {
        final String accept = "application/json";
        return service.updateAnomalyDetectionConfiguration(this.getEndpoint(), configurationId, body, accept, context);
    }

    /**
     * Update anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyDetectionConfiguration> updateAnomalyDetectionConfigurationAsync(
            UUID configurationId, AnomalyDetectionConfigurationPatch body) {
        return updateAnomalyDetectionConfigurationWithResponseAsync(configurationId, body)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Update anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyDetectionConfiguration> updateAnomalyDetectionConfigurationAsync(
            UUID configurationId, AnomalyDetectionConfigurationPatch body, Context context) {
        return updateAnomalyDetectionConfigurationWithResponseAsync(configurationId, body, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Update anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnomalyDetectionConfiguration> updateAnomalyDetectionConfigurationWithResponse(
            UUID configurationId, AnomalyDetectionConfigurationPatch body, Context context) {
        final String accept = "application/json";
        return service.updateAnomalyDetectionConfigurationSync(
                this.getEndpoint(), configurationId, body, accept, context);
    }

    /**
     * Update anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnomalyDetectionConfiguration updateAnomalyDetectionConfiguration(
            UUID configurationId, AnomalyDetectionConfigurationPatch body) {
        return updateAnomalyDetectionConfigurationWithResponse(configurationId, body, Context.NONE).getValue();
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAnomalyDetectionConfigurationWithResponseAsync(UUID configurationId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteAnomalyDetectionConfiguration(
                                this.getEndpoint(), configurationId, accept, context));
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, Context context) {
        final String accept = "application/json";
        return service.deleteAnomalyDetectionConfiguration(this.getEndpoint(), configurationId, accept, context);
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAnomalyDetectionConfigurationAsync(UUID configurationId) {
        return deleteAnomalyDetectionConfigurationWithResponseAsync(configurationId).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAnomalyDetectionConfigurationAsync(UUID configurationId, Context context) {
        return deleteAnomalyDetectionConfigurationWithResponseAsync(configurationId, context)
                .flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteAnomalyDetectionConfigurationWithResponse(UUID configurationId, Context context) {
        final String accept = "application/json";
        return service.deleteAnomalyDetectionConfigurationSync(this.getEndpoint(), configurationId, accept, context);
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteAnomalyDetectionConfiguration(UUID configurationId) {
        deleteAnomalyDetectionConfigurationWithResponse(configurationId, Context.NONE);
    }

    /**
     * Create anomaly detection configuration.
     *
     * @param body anomaly detection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateAnomalyDetectionConfigurationResponse> createAnomalyDetectionConfigurationWithResponseAsync(
            AnomalyDetectionConfiguration body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.createAnomalyDetectionConfiguration(this.getEndpoint(), body, accept, context));
    }

    /**
     * Create anomaly detection configuration.
     *
     * @param body anomaly detection configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateAnomalyDetectionConfigurationResponse> createAnomalyDetectionConfigurationWithResponseAsync(
            AnomalyDetectionConfiguration body, Context context) {
        final String accept = "application/json";
        return service.createAnomalyDetectionConfiguration(this.getEndpoint(), body, accept, context);
    }

    /**
     * Create anomaly detection configuration.
     *
     * @param body anomaly detection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createAnomalyDetectionConfigurationAsync(AnomalyDetectionConfiguration body) {
        return createAnomalyDetectionConfigurationWithResponseAsync(body).flatMap(ignored -> Mono.empty());
    }

    /**
     * Create anomaly detection configuration.
     *
     * @param body anomaly detection configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createAnomalyDetectionConfigurationAsync(AnomalyDetectionConfiguration body, Context context) {
        return createAnomalyDetectionConfigurationWithResponseAsync(body, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Create anomaly detection configuration.
     *
     * @param body anomaly detection configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public CreateAnomalyDetectionConfigurationResponse createAnomalyDetectionConfigurationWithResponse(
            AnomalyDetectionConfiguration body, Context context) {
        final String accept = "application/json";
        return service.createAnomalyDetectionConfigurationSync(this.getEndpoint(), body, accept, context);
    }

    /**
     * Create anomaly detection configuration.
     *
     * @param body anomaly detection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createAnomalyDetectionConfiguration(AnomalyDetectionConfiguration body) {
        createAnomalyDetectionConfigurationWithResponse(body, Context.NONE);
    }

    /**
     * List all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyAlertingConfiguration>>
            getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationSinglePageAsync(
                    UUID configurationId, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
                                        this.getEndpoint(), configurationId, skip, maxpagesize, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyAlertingConfiguration>>
            getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationSinglePageAsync(
                    UUID configurationId, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
                        this.getEndpoint(), configurationId, skip, maxpagesize, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnomalyAlertingConfiguration> getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationAsync(
            UUID configurationId, Integer skip, Integer maxpagesize) {
        return new PagedFlux<>(
                () ->
                        getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, skip, maxpagesize),
                nextLink ->
                        getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink));
    }

    /**
     * List all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnomalyAlertingConfiguration> getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationAsync(
            UUID configurationId, Integer skip, Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () ->
                        getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, skip, maxpagesize, context),
                nextLink ->
                        getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNextSinglePageAsync(
                                nextLink, context));
    }

    /**
     * List all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyAlertingConfiguration>
            getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationSinglePage(
                    UUID configurationId, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        Response<AnomalyAlertingConfigurationList> res =
                service.getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationSync(
                        this.getEndpoint(), configurationId, skip, maxpagesize, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyAlertingConfiguration>
            getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationSinglePage(
                    UUID configurationId, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        Response<AnomalyAlertingConfigurationList> res =
                service.getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationSync(
                        this.getEndpoint(), configurationId, skip, maxpagesize, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnomalyAlertingConfiguration> getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
            UUID configurationId, Integer skip, Integer maxpagesize) {
        return new PagedIterable<>(
                () ->
                        getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationSinglePage(
                                configurationId, skip, maxpagesize, Context.NONE),
                nextLink -> getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNextSinglePage(nextLink));
    }

    /**
     * List all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnomalyAlertingConfiguration> getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
            UUID configurationId, Integer skip, Integer maxpagesize, Context context) {
        return new PagedIterable<>(
                () ->
                        getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationSinglePage(
                                configurationId, skip, maxpagesize, context),
                nextLink ->
                        getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNextSinglePage(
                                nextLink, context));
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query series detection result request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SeriesResultList>> getSeriesByAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, DetectionSeriesQuery body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getSeriesByAnomalyDetectionConfiguration(
                                this.getEndpoint(), configurationId, body, accept, context));
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query series detection result request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SeriesResultList>> getSeriesByAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, DetectionSeriesQuery body, Context context) {
        final String accept = "application/json";
        return service.getSeriesByAnomalyDetectionConfiguration(
                this.getEndpoint(), configurationId, body, accept, context);
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query series detection result request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SeriesResultList> getSeriesByAnomalyDetectionConfigurationAsync(
            UUID configurationId, DetectionSeriesQuery body) {
        return getSeriesByAnomalyDetectionConfigurationWithResponseAsync(configurationId, body)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query series detection result request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SeriesResultList> getSeriesByAnomalyDetectionConfigurationAsync(
            UUID configurationId, DetectionSeriesQuery body, Context context) {
        return getSeriesByAnomalyDetectionConfigurationWithResponseAsync(configurationId, body, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query series detection result request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SeriesResultList> getSeriesByAnomalyDetectionConfigurationWithResponse(
            UUID configurationId, DetectionSeriesQuery body, Context context) {
        final String accept = "application/json";
        return service.getSeriesByAnomalyDetectionConfigurationSync(
                this.getEndpoint(), configurationId, body, accept, context);
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query series detection result request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SeriesResultList getSeriesByAnomalyDetectionConfiguration(UUID configurationId, DetectionSeriesQuery body) {
        return getSeriesByAnomalyDetectionConfigurationWithResponse(configurationId, body, Context.NONE).getValue();
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
            UUID configurationId, DetectionAnomalyResultQuery body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getAnomaliesByAnomalyDetectionConfiguration(
                                        this.getEndpoint(), configurationId, skip, maxpagesize, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
            UUID configurationId,
            DetectionAnomalyResultQuery body,
            Integer skip,
            Integer maxpagesize,
            Context context) {
        final String accept = "application/json";
        return service.getAnomaliesByAnomalyDetectionConfiguration(
                        this.getEndpoint(), configurationId, skip, maxpagesize, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnomalyResult> getAnomaliesByAnomalyDetectionConfigurationAsync(
            UUID configurationId, DetectionAnomalyResultQuery body, Integer skip, Integer maxpagesize) {
        return new PagedFlux<>(
                () ->
                        getAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, body, skip, maxpagesize),
                nextLink -> getAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink, body));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnomalyResult> getAnomaliesByAnomalyDetectionConfigurationAsync(
            UUID configurationId,
            DetectionAnomalyResultQuery body,
            Integer skip,
            Integer maxpagesize,
            Context context) {
        return new PagedFlux<>(
                () ->
                        getAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, body, skip, maxpagesize, context),
                nextLink -> getAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink, body, context));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyResult> getAnomaliesByAnomalyDetectionConfigurationSinglePage(
            UUID configurationId, DetectionAnomalyResultQuery body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        Response<AnomalyResultList> res =
                service.getAnomaliesByAnomalyDetectionConfigurationSync(
                        this.getEndpoint(), configurationId, skip, maxpagesize, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyResult> getAnomaliesByAnomalyDetectionConfigurationSinglePage(
            UUID configurationId,
            DetectionAnomalyResultQuery body,
            Integer skip,
            Integer maxpagesize,
            Context context) {
        final String accept = "application/json";
        Response<AnomalyResultList> res =
                service.getAnomaliesByAnomalyDetectionConfigurationSync(
                        this.getEndpoint(), configurationId, skip, maxpagesize, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnomalyResult> getAnomaliesByAnomalyDetectionConfiguration(
            UUID configurationId, DetectionAnomalyResultQuery body, Integer skip, Integer maxpagesize) {
        return new PagedIterable<>(
                () ->
                        getAnomaliesByAnomalyDetectionConfigurationSinglePage(
                                configurationId, body, skip, maxpagesize, Context.NONE),
                nextLink -> getAnomaliesByAnomalyDetectionConfigurationNextSinglePage(nextLink, body));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnomalyResult> getAnomaliesByAnomalyDetectionConfiguration(
            UUID configurationId,
            DetectionAnomalyResultQuery body,
            Integer skip,
            Integer maxpagesize,
            Context context) {
        return new PagedIterable<>(
                () ->
                        getAnomaliesByAnomalyDetectionConfigurationSinglePage(
                                configurationId, body, skip, maxpagesize, context),
                nextLink -> getAnomaliesByAnomalyDetectionConfigurationNextSinglePage(nextLink, body, context));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
            UUID configurationId, AnomalyDimensionQuery body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getDimensionOfAnomaliesByAnomalyDetectionConfiguration(
                                        this.getEndpoint(), configurationId, skip, maxpagesize, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
            UUID configurationId, AnomalyDimensionQuery body, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.getDimensionOfAnomaliesByAnomalyDetectionConfiguration(
                        this.getEndpoint(), configurationId, skip, maxpagesize, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<String> getDimensionOfAnomaliesByAnomalyDetectionConfigurationAsync(
            UUID configurationId, AnomalyDimensionQuery body, Integer skip, Integer maxpagesize) {
        return new PagedFlux<>(
                () ->
                        getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, body, skip, maxpagesize),
                nextLink -> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink, body));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<String> getDimensionOfAnomaliesByAnomalyDetectionConfigurationAsync(
            UUID configurationId, AnomalyDimensionQuery body, Integer skip, Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () ->
                        getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, body, skip, maxpagesize, context),
                nextLink ->
                        getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(
                                nextLink, body, context));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<String> getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePage(
            UUID configurationId, AnomalyDimensionQuery body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        Response<AnomalyDimensionList> res =
                service.getDimensionOfAnomaliesByAnomalyDetectionConfigurationSync(
                        this.getEndpoint(), configurationId, skip, maxpagesize, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<String> getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePage(
            UUID configurationId, AnomalyDimensionQuery body, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        Response<AnomalyDimensionList> res =
                service.getDimensionOfAnomaliesByAnomalyDetectionConfigurationSync(
                        this.getEndpoint(), configurationId, skip, maxpagesize, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<String> getDimensionOfAnomaliesByAnomalyDetectionConfiguration(
            UUID configurationId, AnomalyDimensionQuery body, Integer skip, Integer maxpagesize) {
        return new PagedIterable<>(
                () ->
                        getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePage(
                                configurationId, body, skip, maxpagesize, Context.NONE),
                nextLink -> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePage(nextLink, body));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<String> getDimensionOfAnomaliesByAnomalyDetectionConfiguration(
            UUID configurationId, AnomalyDimensionQuery body, Integer skip, Integer maxpagesize, Context context) {
        return new PagedIterable<>(
                () ->
                        getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePage(
                                configurationId, body, skip, maxpagesize, context),
                nextLink ->
                        getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePage(nextLink, body, context));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsByAnomalyDetectionConfigurationSinglePageAsync(
            UUID configurationId, DetectionIncidentResultQuery body, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getIncidentsByAnomalyDetectionConfiguration(
                                        this.getEndpoint(), configurationId, maxpagesize, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsByAnomalyDetectionConfigurationSinglePageAsync(
            UUID configurationId, DetectionIncidentResultQuery body, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.getIncidentsByAnomalyDetectionConfiguration(
                        this.getEndpoint(), configurationId, maxpagesize, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<IncidentResult> getIncidentsByAnomalyDetectionConfigurationAsync(
            UUID configurationId, DetectionIncidentResultQuery body, Integer maxpagesize) {
        return new PagedFlux<>(
                () -> getIncidentsByAnomalyDetectionConfigurationSinglePageAsync(configurationId, body, maxpagesize),
                nextLink -> getIncidentsByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<IncidentResult> getIncidentsByAnomalyDetectionConfigurationAsync(
            UUID configurationId, DetectionIncidentResultQuery body, Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () ->
                        getIncidentsByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, body, maxpagesize, context),
                nextLink -> getIncidentsByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink, context));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<IncidentResult> getIncidentsByAnomalyDetectionConfigurationSinglePage(
            UUID configurationId, DetectionIncidentResultQuery body, Integer maxpagesize) {
        final String accept = "application/json";
        Response<IncidentResultList> res =
                service.getIncidentsByAnomalyDetectionConfigurationSync(
                        this.getEndpoint(), configurationId, maxpagesize, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<IncidentResult> getIncidentsByAnomalyDetectionConfigurationSinglePage(
            UUID configurationId, DetectionIncidentResultQuery body, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        Response<IncidentResultList> res =
                service.getIncidentsByAnomalyDetectionConfigurationSync(
                        this.getEndpoint(), configurationId, maxpagesize, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<IncidentResult> getIncidentsByAnomalyDetectionConfiguration(
            UUID configurationId, DetectionIncidentResultQuery body, Integer maxpagesize) {
        return new PagedIterable<>(
                () ->
                        getIncidentsByAnomalyDetectionConfigurationSinglePage(
                                configurationId, body, maxpagesize, Context.NONE),
                nextLink -> getIncidentsByAnomalyDetectionConfigurationNextSinglePage(nextLink));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<IncidentResult> getIncidentsByAnomalyDetectionConfiguration(
            UUID configurationId, DetectionIncidentResultQuery body, Integer maxpagesize, Context context) {
        return new PagedIterable<>(
                () ->
                        getIncidentsByAnomalyDetectionConfigurationSinglePage(
                                configurationId, body, maxpagesize, context),
                nextLink -> getIncidentsByAnomalyDetectionConfigurationNextSinglePage(nextLink, context));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param maxpagesize the maximum number of items in one page.
     * @param token the token for getting the next page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsByAnomalyDetectionConfigurationNextPagesSinglePageAsync(
            UUID configurationId, Integer maxpagesize, String token) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getIncidentsByAnomalyDetectionConfigurationNextPages(
                                        this.getEndpoint(), configurationId, maxpagesize, token, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param maxpagesize the maximum number of items in one page.
     * @param token the token for getting the next page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsByAnomalyDetectionConfigurationNextPagesSinglePageAsync(
            UUID configurationId, Integer maxpagesize, String token, Context context) {
        final String accept = "application/json";
        return service.getIncidentsByAnomalyDetectionConfigurationNextPages(
                        this.getEndpoint(), configurationId, maxpagesize, token, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param maxpagesize the maximum number of items in one page.
     * @param token the token for getting the next page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<IncidentResult> getIncidentsByAnomalyDetectionConfigurationNextPagesAsync(
            UUID configurationId, Integer maxpagesize, String token) {
        return new PagedFlux<>(
                () ->
                        getIncidentsByAnomalyDetectionConfigurationNextPagesSinglePageAsync(
                                configurationId, maxpagesize, token),
                nextLink -> getIncidentsByAnomalyDetectionConfigurationNextPagesNextSinglePageAsync(nextLink));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param maxpagesize the maximum number of items in one page.
     * @param token the token for getting the next page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<IncidentResult> getIncidentsByAnomalyDetectionConfigurationNextPagesAsync(
            UUID configurationId, Integer maxpagesize, String token, Context context) {
        return new PagedFlux<>(
                () ->
                        getIncidentsByAnomalyDetectionConfigurationNextPagesSinglePageAsync(
                                configurationId, maxpagesize, token, context),
                nextLink -> getIncidentsByAnomalyDetectionConfigurationNextPagesNextSinglePageAsync(nextLink, context));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param maxpagesize the maximum number of items in one page.
     * @param token the token for getting the next page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<IncidentResult> getIncidentsByAnomalyDetectionConfigurationNextPagesSinglePage(
            UUID configurationId, Integer maxpagesize, String token) {
        final String accept = "application/json";
        Response<IncidentResultList> res =
                service.getIncidentsByAnomalyDetectionConfigurationNextPagesSync(
                        this.getEndpoint(), configurationId, maxpagesize, token, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param maxpagesize the maximum number of items in one page.
     * @param token the token for getting the next page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<IncidentResult> getIncidentsByAnomalyDetectionConfigurationNextPagesSinglePage(
            UUID configurationId, Integer maxpagesize, String token, Context context) {
        final String accept = "application/json";
        Response<IncidentResultList> res =
                service.getIncidentsByAnomalyDetectionConfigurationNextPagesSync(
                        this.getEndpoint(), configurationId, maxpagesize, token, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param maxpagesize the maximum number of items in one page.
     * @param token the token for getting the next page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<IncidentResult> getIncidentsByAnomalyDetectionConfigurationNextPages(
            UUID configurationId, Integer maxpagesize, String token) {
        return new PagedIterable<>(
                () ->
                        getIncidentsByAnomalyDetectionConfigurationNextPagesSinglePage(
                                configurationId, maxpagesize, token, Context.NONE),
                nextLink -> getIncidentsByAnomalyDetectionConfigurationNextPagesNextSinglePage(nextLink));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param maxpagesize the maximum number of items in one page.
     * @param token the token for getting the next page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<IncidentResult> getIncidentsByAnomalyDetectionConfigurationNextPages(
            UUID configurationId, Integer maxpagesize, String token, Context context) {
        return new PagedIterable<>(
                () ->
                        getIncidentsByAnomalyDetectionConfigurationNextPagesSinglePage(
                                configurationId, maxpagesize, token, context),
                nextLink -> getIncidentsByAnomalyDetectionConfigurationNextPagesNextSinglePage(nextLink, context));
    }

    /**
     * Query root cause for incident.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId incident id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RootCauseList>> getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, String incidentId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getRootCauseOfIncidentByAnomalyDetectionConfiguration(
                                this.getEndpoint(), configurationId, incidentId, accept, context));
    }

    /**
     * Query root cause for incident.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId incident id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RootCauseList>> getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, String incidentId, Context context) {
        final String accept = "application/json";
        return service.getRootCauseOfIncidentByAnomalyDetectionConfiguration(
                this.getEndpoint(), configurationId, incidentId, accept, context);
    }

    /**
     * Query root cause for incident.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId incident id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RootCauseList> getRootCauseOfIncidentByAnomalyDetectionConfigurationAsync(
            UUID configurationId, String incidentId) {
        return getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponseAsync(configurationId, incidentId)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Query root cause for incident.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId incident id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RootCauseList> getRootCauseOfIncidentByAnomalyDetectionConfigurationAsync(
            UUID configurationId, String incidentId, Context context) {
        return getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponseAsync(
                        configurationId, incidentId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Query root cause for incident.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId incident id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RootCauseList> getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponse(
            UUID configurationId, String incidentId, Context context) {
        final String accept = "application/json";
        return service.getRootCauseOfIncidentByAnomalyDetectionConfigurationSync(
                this.getEndpoint(), configurationId, incidentId, accept, context);
    }

    /**
     * Query root cause for incident.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId incident id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RootCauseList getRootCauseOfIncidentByAnomalyDetectionConfiguration(
            UUID configurationId, String incidentId) {
        return getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponse(
                        configurationId, incidentId, Context.NONE)
                .getValue();
    }

    /**
     * Create a new data source credential.
     *
     * @param body Create data source credential request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateCredentialResponse> createCredentialWithResponseAsync(DataSourceCredential body) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createCredential(this.getEndpoint(), body, accept, context));
    }

    /**
     * Create a new data source credential.
     *
     * @param body Create data source credential request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateCredentialResponse> createCredentialWithResponseAsync(
            DataSourceCredential body, Context context) {
        final String accept = "application/json";
        return service.createCredential(this.getEndpoint(), body, accept, context);
    }

    /**
     * Create a new data source credential.
     *
     * @param body Create data source credential request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createCredentialAsync(DataSourceCredential body) {
        return createCredentialWithResponseAsync(body).flatMap(ignored -> Mono.empty());
    }

    /**
     * Create a new data source credential.
     *
     * @param body Create data source credential request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createCredentialAsync(DataSourceCredential body, Context context) {
        return createCredentialWithResponseAsync(body, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Create a new data source credential.
     *
     * @param body Create data source credential request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public CreateCredentialResponse createCredentialWithResponse(DataSourceCredential body, Context context) {
        final String accept = "application/json";
        return service.createCredentialSync(this.getEndpoint(), body, accept, context);
    }

    /**
     * Create a new data source credential.
     *
     * @param body Create data source credential request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createCredential(DataSourceCredential body) {
        createCredentialWithResponse(body, Context.NONE);
    }

    /**
     * List all credentials.
     *
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataSourceCredential>> listCredentialsSinglePageAsync(Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context -> service.listCredentials(this.getEndpoint(), skip, maxpagesize, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List all credentials.
     *
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataSourceCredential>> listCredentialsSinglePageAsync(
            Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.listCredentials(this.getEndpoint(), skip, maxpagesize, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List all credentials.
     *
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DataSourceCredential> listCredentialsAsync(Integer skip, Integer maxpagesize) {
        return new PagedFlux<>(
                () -> listCredentialsSinglePageAsync(skip, maxpagesize),
                nextLink -> listCredentialsNextSinglePageAsync(nextLink));
    }

    /**
     * List all credentials.
     *
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DataSourceCredential> listCredentialsAsync(Integer skip, Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> listCredentialsSinglePageAsync(skip, maxpagesize, context),
                nextLink -> listCredentialsNextSinglePageAsync(nextLink, context));
    }

    /**
     * List all credentials.
     *
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DataSourceCredential> listCredentialsSinglePage(Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        Response<DataSourceCredentialList> res =
                service.listCredentialsSync(this.getEndpoint(), skip, maxpagesize, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List all credentials.
     *
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DataSourceCredential> listCredentialsSinglePage(
            Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        Response<DataSourceCredentialList> res =
                service.listCredentialsSync(this.getEndpoint(), skip, maxpagesize, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List all credentials.
     *
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DataSourceCredential> listCredentials(Integer skip, Integer maxpagesize) {
        return new PagedIterable<>(
                () -> listCredentialsSinglePage(skip, maxpagesize, Context.NONE),
                nextLink -> listCredentialsNextSinglePage(nextLink));
    }

    /**
     * List all credentials.
     *
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DataSourceCredential> listCredentials(Integer skip, Integer maxpagesize, Context context) {
        return new PagedIterable<>(
                () -> listCredentialsSinglePage(skip, maxpagesize, context),
                nextLink -> listCredentialsNextSinglePage(nextLink, context));
    }

    /**
     * Update a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param body Update data source credential request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataSourceCredential>> updateCredentialWithResponseAsync(
            UUID credentialId, DataSourceCredentialPatch body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.updateCredential(this.getEndpoint(), credentialId, body, accept, context));
    }

    /**
     * Update a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param body Update data source credential request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataSourceCredential>> updateCredentialWithResponseAsync(
            UUID credentialId, DataSourceCredentialPatch body, Context context) {
        final String accept = "application/json";
        return service.updateCredential(this.getEndpoint(), credentialId, body, accept, context);
    }

    /**
     * Update a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param body Update data source credential request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataSourceCredential> updateCredentialAsync(UUID credentialId, DataSourceCredentialPatch body) {
        return updateCredentialWithResponseAsync(credentialId, body).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Update a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param body Update data source credential request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataSourceCredential> updateCredentialAsync(
            UUID credentialId, DataSourceCredentialPatch body, Context context) {
        return updateCredentialWithResponseAsync(credentialId, body, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Update a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param body Update data source credential request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DataSourceCredential> updateCredentialWithResponse(
            UUID credentialId, DataSourceCredentialPatch body, Context context) {
        final String accept = "application/json";
        return service.updateCredentialSync(this.getEndpoint(), credentialId, body, accept, context);
    }

    /**
     * Update a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param body Update data source credential request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DataSourceCredential updateCredential(UUID credentialId, DataSourceCredentialPatch body) {
        return updateCredentialWithResponse(credentialId, body, Context.NONE).getValue();
    }

    /**
     * Delete a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteCredentialWithResponseAsync(UUID credentialId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.deleteCredential(this.getEndpoint(), credentialId, accept, context));
    }

    /**
     * Delete a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteCredentialWithResponseAsync(UUID credentialId, Context context) {
        final String accept = "application/json";
        return service.deleteCredential(this.getEndpoint(), credentialId, accept, context);
    }

    /**
     * Delete a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteCredentialAsync(UUID credentialId) {
        return deleteCredentialWithResponseAsync(credentialId).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteCredentialAsync(UUID credentialId, Context context) {
        return deleteCredentialWithResponseAsync(credentialId, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteCredentialWithResponse(UUID credentialId, Context context) {
        final String accept = "application/json";
        return service.deleteCredentialSync(this.getEndpoint(), credentialId, accept, context);
    }

    /**
     * Delete a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteCredential(UUID credentialId) {
        deleteCredentialWithResponse(credentialId, Context.NONE);
    }

    /**
     * Get a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data source credential along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataSourceCredential>> getCredentialWithResponseAsync(UUID credentialId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getCredential(this.getEndpoint(), credentialId, accept, context));
    }

    /**
     * Get a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data source credential along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataSourceCredential>> getCredentialWithResponseAsync(UUID credentialId, Context context) {
        final String accept = "application/json";
        return service.getCredential(this.getEndpoint(), credentialId, accept, context);
    }

    /**
     * Get a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data source credential on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataSourceCredential> getCredentialAsync(UUID credentialId) {
        return getCredentialWithResponseAsync(credentialId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data source credential on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataSourceCredential> getCredentialAsync(UUID credentialId, Context context) {
        return getCredentialWithResponseAsync(credentialId, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data source credential along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DataSourceCredential> getCredentialWithResponse(UUID credentialId, Context context) {
        final String accept = "application/json";
        return service.getCredentialSync(this.getEndpoint(), credentialId, accept, context);
    }

    /**
     * Get a data source credential.
     *
     * @param credentialId Data source credential unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data source credential.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DataSourceCredential getCredential(UUID credentialId) {
        return getCredentialWithResponse(credentialId, Context.NONE).getValue();
    }

    /**
     * List all data feeds.
     *
     * @param dataFeedName filter data feed by its name.
     * @param dataSourceType filter data feed by its source type.
     * @param granularityName filter data feed by its granularity.
     * @param status filter data feed by its status.
     * @param creator filter data feed by its creator.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedDetail>> listDataFeedsSinglePageAsync(
            String dataFeedName,
            DataSourceType dataSourceType,
            Granularity granularityName,
            EntityStatus status,
            String creator,
            Integer skip,
            Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listDataFeeds(
                                        this.getEndpoint(),
                                        dataFeedName,
                                        dataSourceType,
                                        granularityName,
                                        status,
                                        creator,
                                        skip,
                                        maxpagesize,
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List all data feeds.
     *
     * @param dataFeedName filter data feed by its name.
     * @param dataSourceType filter data feed by its source type.
     * @param granularityName filter data feed by its granularity.
     * @param status filter data feed by its status.
     * @param creator filter data feed by its creator.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedDetail>> listDataFeedsSinglePageAsync(
            String dataFeedName,
            DataSourceType dataSourceType,
            Granularity granularityName,
            EntityStatus status,
            String creator,
            Integer skip,
            Integer maxpagesize,
            Context context) {
        final String accept = "application/json";
        return service.listDataFeeds(
                        this.getEndpoint(),
                        dataFeedName,
                        dataSourceType,
                        granularityName,
                        status,
                        creator,
                        skip,
                        maxpagesize,
                        accept,
                        context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List all data feeds.
     *
     * @param dataFeedName filter data feed by its name.
     * @param dataSourceType filter data feed by its source type.
     * @param granularityName filter data feed by its granularity.
     * @param status filter data feed by its status.
     * @param creator filter data feed by its creator.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DataFeedDetail> listDataFeedsAsync(
            String dataFeedName,
            DataSourceType dataSourceType,
            Granularity granularityName,
            EntityStatus status,
            String creator,
            Integer skip,
            Integer maxpagesize) {
        return new PagedFlux<>(
                () ->
                        listDataFeedsSinglePageAsync(
                                dataFeedName, dataSourceType, granularityName, status, creator, skip, maxpagesize),
                nextLink -> listDataFeedsNextSinglePageAsync(nextLink));
    }

    /**
     * List all data feeds.
     *
     * @param dataFeedName filter data feed by its name.
     * @param dataSourceType filter data feed by its source type.
     * @param granularityName filter data feed by its granularity.
     * @param status filter data feed by its status.
     * @param creator filter data feed by its creator.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DataFeedDetail> listDataFeedsAsync(
            String dataFeedName,
            DataSourceType dataSourceType,
            Granularity granularityName,
            EntityStatus status,
            String creator,
            Integer skip,
            Integer maxpagesize,
            Context context) {
        return new PagedFlux<>(
                () ->
                        listDataFeedsSinglePageAsync(
                                dataFeedName,
                                dataSourceType,
                                granularityName,
                                status,
                                creator,
                                skip,
                                maxpagesize,
                                context),
                nextLink -> listDataFeedsNextSinglePageAsync(nextLink, context));
    }

    /**
     * List all data feeds.
     *
     * @param dataFeedName filter data feed by its name.
     * @param dataSourceType filter data feed by its source type.
     * @param granularityName filter data feed by its granularity.
     * @param status filter data feed by its status.
     * @param creator filter data feed by its creator.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DataFeedDetail> listDataFeedsSinglePage(
            String dataFeedName,
            DataSourceType dataSourceType,
            Granularity granularityName,
            EntityStatus status,
            String creator,
            Integer skip,
            Integer maxpagesize) {
        final String accept = "application/json";
        Response<DataFeedList> res =
                service.listDataFeedsSync(
                        this.getEndpoint(),
                        dataFeedName,
                        dataSourceType,
                        granularityName,
                        status,
                        creator,
                        skip,
                        maxpagesize,
                        accept,
                        Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List all data feeds.
     *
     * @param dataFeedName filter data feed by its name.
     * @param dataSourceType filter data feed by its source type.
     * @param granularityName filter data feed by its granularity.
     * @param status filter data feed by its status.
     * @param creator filter data feed by its creator.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DataFeedDetail> listDataFeedsSinglePage(
            String dataFeedName,
            DataSourceType dataSourceType,
            Granularity granularityName,
            EntityStatus status,
            String creator,
            Integer skip,
            Integer maxpagesize,
            Context context) {
        final String accept = "application/json";
        Response<DataFeedList> res =
                service.listDataFeedsSync(
                        this.getEndpoint(),
                        dataFeedName,
                        dataSourceType,
                        granularityName,
                        status,
                        creator,
                        skip,
                        maxpagesize,
                        accept,
                        context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List all data feeds.
     *
     * @param dataFeedName filter data feed by its name.
     * @param dataSourceType filter data feed by its source type.
     * @param granularityName filter data feed by its granularity.
     * @param status filter data feed by its status.
     * @param creator filter data feed by its creator.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DataFeedDetail> listDataFeeds(
            String dataFeedName,
            DataSourceType dataSourceType,
            Granularity granularityName,
            EntityStatus status,
            String creator,
            Integer skip,
            Integer maxpagesize) {
        return new PagedIterable<>(
                () ->
                        listDataFeedsSinglePage(
                                dataFeedName,
                                dataSourceType,
                                granularityName,
                                status,
                                creator,
                                skip,
                                maxpagesize,
                                Context.NONE),
                nextLink -> listDataFeedsNextSinglePage(nextLink));
    }

    /**
     * List all data feeds.
     *
     * @param dataFeedName filter data feed by its name.
     * @param dataSourceType filter data feed by its source type.
     * @param granularityName filter data feed by its granularity.
     * @param status filter data feed by its status.
     * @param creator filter data feed by its creator.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DataFeedDetail> listDataFeeds(
            String dataFeedName,
            DataSourceType dataSourceType,
            Granularity granularityName,
            EntityStatus status,
            String creator,
            Integer skip,
            Integer maxpagesize,
            Context context) {
        return new PagedIterable<>(
                () ->
                        listDataFeedsSinglePage(
                                dataFeedName,
                                dataSourceType,
                                granularityName,
                                status,
                                creator,
                                skip,
                                maxpagesize,
                                context),
                nextLink -> listDataFeedsNextSinglePage(nextLink, context));
    }

    /**
     * Create a new data feed.
     *
     * @param body parameters to create a data feed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateDataFeedResponse> createDataFeedWithResponseAsync(DataFeedDetail body) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createDataFeed(this.getEndpoint(), body, accept, context));
    }

    /**
     * Create a new data feed.
     *
     * @param body parameters to create a data feed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateDataFeedResponse> createDataFeedWithResponseAsync(DataFeedDetail body, Context context) {
        final String accept = "application/json";
        return service.createDataFeed(this.getEndpoint(), body, accept, context);
    }

    /**
     * Create a new data feed.
     *
     * @param body parameters to create a data feed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createDataFeedAsync(DataFeedDetail body) {
        return createDataFeedWithResponseAsync(body).flatMap(ignored -> Mono.empty());
    }

    /**
     * Create a new data feed.
     *
     * @param body parameters to create a data feed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createDataFeedAsync(DataFeedDetail body, Context context) {
        return createDataFeedWithResponseAsync(body, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Create a new data feed.
     *
     * @param body parameters to create a data feed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public CreateDataFeedResponse createDataFeedWithResponse(DataFeedDetail body, Context context) {
        final String accept = "application/json";
        return service.createDataFeedSync(this.getEndpoint(), body, accept, context);
    }

    /**
     * Create a new data feed.
     *
     * @param body parameters to create a data feed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createDataFeed(DataFeedDetail body) {
        createDataFeedWithResponse(body, Context.NONE);
    }

    /**
     * Get a data feed by its id.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data feed by its id along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataFeedDetail>> getDataFeedByIdWithResponseAsync(UUID dataFeedId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getDataFeedById(this.getEndpoint(), dataFeedId, accept, context));
    }

    /**
     * Get a data feed by its id.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data feed by its id along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataFeedDetail>> getDataFeedByIdWithResponseAsync(UUID dataFeedId, Context context) {
        final String accept = "application/json";
        return service.getDataFeedById(this.getEndpoint(), dataFeedId, accept, context);
    }

    /**
     * Get a data feed by its id.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data feed by its id on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataFeedDetail> getDataFeedByIdAsync(UUID dataFeedId) {
        return getDataFeedByIdWithResponseAsync(dataFeedId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a data feed by its id.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data feed by its id on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataFeedDetail> getDataFeedByIdAsync(UUID dataFeedId, Context context) {
        return getDataFeedByIdWithResponseAsync(dataFeedId, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a data feed by its id.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data feed by its id along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DataFeedDetail> getDataFeedByIdWithResponse(UUID dataFeedId, Context context) {
        final String accept = "application/json";
        return service.getDataFeedByIdSync(this.getEndpoint(), dataFeedId, accept, context);
    }

    /**
     * Get a data feed by its id.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data feed by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DataFeedDetail getDataFeedById(UUID dataFeedId) {
        return getDataFeedByIdWithResponse(dataFeedId, Context.NONE).getValue();
    }

    /**
     * Update a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataFeedDetail>> updateDataFeedWithResponseAsync(UUID dataFeedId, DataFeedDetailPatch body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.updateDataFeed(this.getEndpoint(), dataFeedId, body, accept, context));
    }

    /**
     * Update a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataFeedDetail>> updateDataFeedWithResponseAsync(
            UUID dataFeedId, DataFeedDetailPatch body, Context context) {
        final String accept = "application/json";
        return service.updateDataFeed(this.getEndpoint(), dataFeedId, body, accept, context);
    }

    /**
     * Update a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataFeedDetail> updateDataFeedAsync(UUID dataFeedId, DataFeedDetailPatch body) {
        return updateDataFeedWithResponseAsync(dataFeedId, body).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Update a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataFeedDetail> updateDataFeedAsync(UUID dataFeedId, DataFeedDetailPatch body, Context context) {
        return updateDataFeedWithResponseAsync(dataFeedId, body, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Update a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DataFeedDetail> updateDataFeedWithResponse(
            UUID dataFeedId, DataFeedDetailPatch body, Context context) {
        final String accept = "application/json";
        return service.updateDataFeedSync(this.getEndpoint(), dataFeedId, body, accept, context);
    }

    /**
     * Update a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DataFeedDetail updateDataFeed(UUID dataFeedId, DataFeedDetailPatch body) {
        return updateDataFeedWithResponse(dataFeedId, body, Context.NONE).getValue();
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteDataFeedWithResponseAsync(UUID dataFeedId) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.deleteDataFeed(this.getEndpoint(), dataFeedId, accept, context));
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteDataFeedWithResponseAsync(UUID dataFeedId, Context context) {
        final String accept = "application/json";
        return service.deleteDataFeed(this.getEndpoint(), dataFeedId, accept, context);
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteDataFeedAsync(UUID dataFeedId) {
        return deleteDataFeedWithResponseAsync(dataFeedId).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteDataFeedAsync(UUID dataFeedId, Context context) {
        return deleteDataFeedWithResponseAsync(dataFeedId, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDataFeedWithResponse(UUID dataFeedId, Context context) {
        final String accept = "application/json";
        return service.deleteDataFeedSync(this.getEndpoint(), dataFeedId, accept, context);
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteDataFeed(UUID dataFeedId) {
        deleteDataFeedWithResponse(dataFeedId, Context.NONE);
    }

    /**
     * Get a metric feedback by its id.
     *
     * @param feedbackId the unique feedback ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a metric feedback by its id along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<MetricFeedback>> getMetricFeedbackWithResponseAsync(UUID feedbackId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getMetricFeedback(this.getEndpoint(), feedbackId, accept, context));
    }

    /**
     * Get a metric feedback by its id.
     *
     * @param feedbackId the unique feedback ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a metric feedback by its id along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<MetricFeedback>> getMetricFeedbackWithResponseAsync(UUID feedbackId, Context context) {
        final String accept = "application/json";
        return service.getMetricFeedback(this.getEndpoint(), feedbackId, accept, context);
    }

    /**
     * Get a metric feedback by its id.
     *
     * @param feedbackId the unique feedback ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a metric feedback by its id on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<MetricFeedback> getMetricFeedbackAsync(UUID feedbackId) {
        return getMetricFeedbackWithResponseAsync(feedbackId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a metric feedback by its id.
     *
     * @param feedbackId the unique feedback ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a metric feedback by its id on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<MetricFeedback> getMetricFeedbackAsync(UUID feedbackId, Context context) {
        return getMetricFeedbackWithResponseAsync(feedbackId, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a metric feedback by its id.
     *
     * @param feedbackId the unique feedback ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a metric feedback by its id along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<MetricFeedback> getMetricFeedbackWithResponse(UUID feedbackId, Context context) {
        final String accept = "application/json";
        return service.getMetricFeedbackSync(this.getEndpoint(), feedbackId, accept, context);
    }

    /**
     * Get a metric feedback by its id.
     *
     * @param feedbackId the unique feedback ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a metric feedback by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public MetricFeedback getMetricFeedback(UUID feedbackId) {
        return getMetricFeedbackWithResponse(feedbackId, Context.NONE).getValue();
    }

    /**
     * List feedback on the given metric.
     *
     * @param body metric feedback filter.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricFeedback>> listMetricFeedbacksSinglePageAsync(
            MetricFeedbackFilter body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listMetricFeedbacks(
                                        this.getEndpoint(), skip, maxpagesize, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List feedback on the given metric.
     *
     * @param body metric feedback filter.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricFeedback>> listMetricFeedbacksSinglePageAsync(
            MetricFeedbackFilter body, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.listMetricFeedbacks(this.getEndpoint(), skip, maxpagesize, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List feedback on the given metric.
     *
     * @param body metric feedback filter.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<MetricFeedback> listMetricFeedbacksAsync(
            MetricFeedbackFilter body, Integer skip, Integer maxpagesize) {
        return new PagedFlux<>(
                () -> listMetricFeedbacksSinglePageAsync(body, skip, maxpagesize),
                nextLink -> listMetricFeedbacksNextSinglePageAsync(nextLink, body));
    }

    /**
     * List feedback on the given metric.
     *
     * @param body metric feedback filter.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<MetricFeedback> listMetricFeedbacksAsync(
            MetricFeedbackFilter body, Integer skip, Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> listMetricFeedbacksSinglePageAsync(body, skip, maxpagesize, context),
                nextLink -> listMetricFeedbacksNextSinglePageAsync(nextLink, body, context));
    }

    /**
     * List feedback on the given metric.
     *
     * @param body metric feedback filter.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<MetricFeedback> listMetricFeedbacksSinglePage(
            MetricFeedbackFilter body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        Response<MetricFeedbackList> res =
                service.listMetricFeedbacksSync(this.getEndpoint(), skip, maxpagesize, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List feedback on the given metric.
     *
     * @param body metric feedback filter.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<MetricFeedback> listMetricFeedbacksSinglePage(
            MetricFeedbackFilter body, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        Response<MetricFeedbackList> res =
                service.listMetricFeedbacksSync(this.getEndpoint(), skip, maxpagesize, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List feedback on the given metric.
     *
     * @param body metric feedback filter.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<MetricFeedback> listMetricFeedbacks(
            MetricFeedbackFilter body, Integer skip, Integer maxpagesize) {
        return new PagedIterable<>(
                () -> listMetricFeedbacksSinglePage(body, skip, maxpagesize, Context.NONE),
                nextLink -> listMetricFeedbacksNextSinglePage(nextLink, body));
    }

    /**
     * List feedback on the given metric.
     *
     * @param body metric feedback filter.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<MetricFeedback> listMetricFeedbacks(
            MetricFeedbackFilter body, Integer skip, Integer maxpagesize, Context context) {
        return new PagedIterable<>(
                () -> listMetricFeedbacksSinglePage(body, skip, maxpagesize, context),
                nextLink -> listMetricFeedbacksNextSinglePage(nextLink, body, context));
    }

    /**
     * Create a new metric feedback.
     *
     * @param body metric feedback.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateMetricFeedbackResponse> createMetricFeedbackWithResponseAsync(MetricFeedback body) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createMetricFeedback(this.getEndpoint(), body, accept, context));
    }

    /**
     * Create a new metric feedback.
     *
     * @param body metric feedback.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateMetricFeedbackResponse> createMetricFeedbackWithResponseAsync(
            MetricFeedback body, Context context) {
        final String accept = "application/json";
        return service.createMetricFeedback(this.getEndpoint(), body, accept, context);
    }

    /**
     * Create a new metric feedback.
     *
     * @param body metric feedback.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createMetricFeedbackAsync(MetricFeedback body) {
        return createMetricFeedbackWithResponseAsync(body).flatMap(ignored -> Mono.empty());
    }

    /**
     * Create a new metric feedback.
     *
     * @param body metric feedback.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createMetricFeedbackAsync(MetricFeedback body, Context context) {
        return createMetricFeedbackWithResponseAsync(body, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Create a new metric feedback.
     *
     * @param body metric feedback.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public CreateMetricFeedbackResponse createMetricFeedbackWithResponse(MetricFeedback body, Context context) {
        final String accept = "application/json";
        return service.createMetricFeedbackSync(this.getEndpoint(), body, accept, context);
    }

    /**
     * Create a new metric feedback.
     *
     * @param body metric feedback.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createMetricFeedback(MetricFeedback body) {
        createMetricFeedbackWithResponse(body, Context.NONE);
    }

    /**
     * List all hooks.
     *
     * @param hookName filter hook by its name.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<HookInfo>> listHooksSinglePageAsync(String hookName, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context -> service.listHooks(this.getEndpoint(), hookName, skip, maxpagesize, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List all hooks.
     *
     * @param hookName filter hook by its name.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<HookInfo>> listHooksSinglePageAsync(
            String hookName, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.listHooks(this.getEndpoint(), hookName, skip, maxpagesize, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List all hooks.
     *
     * @param hookName filter hook by its name.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<HookInfo> listHooksAsync(String hookName, Integer skip, Integer maxpagesize) {
        return new PagedFlux<>(
                () -> listHooksSinglePageAsync(hookName, skip, maxpagesize),
                nextLink -> listHooksNextSinglePageAsync(nextLink));
    }

    /**
     * List all hooks.
     *
     * @param hookName filter hook by its name.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<HookInfo> listHooksAsync(String hookName, Integer skip, Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> listHooksSinglePageAsync(hookName, skip, maxpagesize, context),
                nextLink -> listHooksNextSinglePageAsync(nextLink, context));
    }

    /**
     * List all hooks.
     *
     * @param hookName filter hook by its name.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<HookInfo> listHooksSinglePage(String hookName, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        Response<HookList> res =
                service.listHooksSync(this.getEndpoint(), hookName, skip, maxpagesize, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List all hooks.
     *
     * @param hookName filter hook by its name.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<HookInfo> listHooksSinglePage(
            String hookName, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        Response<HookList> res =
                service.listHooksSync(this.getEndpoint(), hookName, skip, maxpagesize, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List all hooks.
     *
     * @param hookName filter hook by its name.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<HookInfo> listHooks(String hookName, Integer skip, Integer maxpagesize) {
        return new PagedIterable<>(
                () -> listHooksSinglePage(hookName, skip, maxpagesize, Context.NONE),
                nextLink -> listHooksNextSinglePage(nextLink));
    }

    /**
     * List all hooks.
     *
     * @param hookName filter hook by its name.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<HookInfo> listHooks(String hookName, Integer skip, Integer maxpagesize, Context context) {
        return new PagedIterable<>(
                () -> listHooksSinglePage(hookName, skip, maxpagesize, context),
                nextLink -> listHooksNextSinglePage(nextLink, context));
    }

    /**
     * Create a new hook.
     *
     * @param body Create hook request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateHookResponse> createHookWithResponseAsync(HookInfo body) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.createHook(this.getEndpoint(), body, accept, context));
    }

    /**
     * Create a new hook.
     *
     * @param body Create hook request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateHookResponse> createHookWithResponseAsync(HookInfo body, Context context) {
        final String accept = "application/json";
        return service.createHook(this.getEndpoint(), body, accept, context);
    }

    /**
     * Create a new hook.
     *
     * @param body Create hook request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createHookAsync(HookInfo body) {
        return createHookWithResponseAsync(body).flatMap(ignored -> Mono.empty());
    }

    /**
     * Create a new hook.
     *
     * @param body Create hook request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createHookAsync(HookInfo body, Context context) {
        return createHookWithResponseAsync(body, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Create a new hook.
     *
     * @param body Create hook request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public CreateHookResponse createHookWithResponse(HookInfo body, Context context) {
        final String accept = "application/json";
        return service.createHookSync(this.getEndpoint(), body, accept, context);
    }

    /**
     * Create a new hook.
     *
     * @param body Create hook request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createHook(HookInfo body) {
        createHookWithResponse(body, Context.NONE);
    }

    /**
     * Get a hook by its id.
     *
     * @param hookId Hook unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a hook by its id along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<HookInfo>> getHookWithResponseAsync(UUID hookId) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getHook(this.getEndpoint(), hookId, accept, context));
    }

    /**
     * Get a hook by its id.
     *
     * @param hookId Hook unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a hook by its id along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<HookInfo>> getHookWithResponseAsync(UUID hookId, Context context) {
        final String accept = "application/json";
        return service.getHook(this.getEndpoint(), hookId, accept, context);
    }

    /**
     * Get a hook by its id.
     *
     * @param hookId Hook unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a hook by its id on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<HookInfo> getHookAsync(UUID hookId) {
        return getHookWithResponseAsync(hookId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a hook by its id.
     *
     * @param hookId Hook unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a hook by its id on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<HookInfo> getHookAsync(UUID hookId, Context context) {
        return getHookWithResponseAsync(hookId, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a hook by its id.
     *
     * @param hookId Hook unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a hook by its id along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<HookInfo> getHookWithResponse(UUID hookId, Context context) {
        final String accept = "application/json";
        return service.getHookSync(this.getEndpoint(), hookId, accept, context);
    }

    /**
     * Get a hook by its id.
     *
     * @param hookId Hook unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a hook by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public HookInfo getHook(UUID hookId) {
        return getHookWithResponse(hookId, Context.NONE).getValue();
    }

    /**
     * Update a hook.
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<HookInfo>> updateHookWithResponseAsync(UUID hookId, HookInfoPatch body) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.updateHook(this.getEndpoint(), hookId, body, accept, context));
    }

    /**
     * Update a hook.
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<HookInfo>> updateHookWithResponseAsync(UUID hookId, HookInfoPatch body, Context context) {
        final String accept = "application/json";
        return service.updateHook(this.getEndpoint(), hookId, body, accept, context);
    }

    /**
     * Update a hook.
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<HookInfo> updateHookAsync(UUID hookId, HookInfoPatch body) {
        return updateHookWithResponseAsync(hookId, body).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Update a hook.
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<HookInfo> updateHookAsync(UUID hookId, HookInfoPatch body, Context context) {
        return updateHookWithResponseAsync(hookId, body, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Update a hook.
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<HookInfo> updateHookWithResponse(UUID hookId, HookInfoPatch body, Context context) {
        final String accept = "application/json";
        return service.updateHookSync(this.getEndpoint(), hookId, body, accept, context);
    }

    /**
     * Update a hook.
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public HookInfo updateHook(UUID hookId, HookInfoPatch body) {
        return updateHookWithResponse(hookId, body, Context.NONE).getValue();
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteHookWithResponseAsync(UUID hookId) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.deleteHook(this.getEndpoint(), hookId, accept, context));
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteHookWithResponseAsync(UUID hookId, Context context) {
        final String accept = "application/json";
        return service.deleteHook(this.getEndpoint(), hookId, accept, context);
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteHookAsync(UUID hookId) {
        return deleteHookWithResponseAsync(hookId).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteHookAsync(UUID hookId, Context context) {
        return deleteHookWithResponseAsync(hookId, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteHookWithResponse(UUID hookId, Context context) {
        final String accept = "application/json";
        return service.deleteHookSync(this.getEndpoint(), hookId, accept, context);
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteHook(UUID hookId) {
        deleteHookWithResponse(hookId, Context.NONE);
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedIngestionStatus>> getDataFeedIngestionStatusSinglePageAsync(
            UUID dataFeedId, IngestionStatusQueryOptions body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getDataFeedIngestionStatus(
                                        this.getEndpoint(), dataFeedId, skip, maxpagesize, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedIngestionStatus>> getDataFeedIngestionStatusSinglePageAsync(
            UUID dataFeedId, IngestionStatusQueryOptions body, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.getDataFeedIngestionStatus(
                        this.getEndpoint(), dataFeedId, skip, maxpagesize, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DataFeedIngestionStatus> getDataFeedIngestionStatusAsync(
            UUID dataFeedId, IngestionStatusQueryOptions body, Integer skip, Integer maxpagesize) {
        return new PagedFlux<>(
                () -> getDataFeedIngestionStatusSinglePageAsync(dataFeedId, body, skip, maxpagesize),
                nextLink -> getDataFeedIngestionStatusNextSinglePageAsync(nextLink, body));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DataFeedIngestionStatus> getDataFeedIngestionStatusAsync(
            UUID dataFeedId, IngestionStatusQueryOptions body, Integer skip, Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> getDataFeedIngestionStatusSinglePageAsync(dataFeedId, body, skip, maxpagesize, context),
                nextLink -> getDataFeedIngestionStatusNextSinglePageAsync(nextLink, body, context));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DataFeedIngestionStatus> getDataFeedIngestionStatusSinglePage(
            UUID dataFeedId, IngestionStatusQueryOptions body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        Response<IngestionStatusList> res =
                service.getDataFeedIngestionStatusSync(
                        this.getEndpoint(), dataFeedId, skip, maxpagesize, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DataFeedIngestionStatus> getDataFeedIngestionStatusSinglePage(
            UUID dataFeedId, IngestionStatusQueryOptions body, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        Response<IngestionStatusList> res =
                service.getDataFeedIngestionStatusSync(
                        this.getEndpoint(), dataFeedId, skip, maxpagesize, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DataFeedIngestionStatus> getDataFeedIngestionStatus(
            UUID dataFeedId, IngestionStatusQueryOptions body, Integer skip, Integer maxpagesize) {
        return new PagedIterable<>(
                () -> getDataFeedIngestionStatusSinglePage(dataFeedId, body, skip, maxpagesize, Context.NONE),
                nextLink -> getDataFeedIngestionStatusNextSinglePage(nextLink, body));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DataFeedIngestionStatus> getDataFeedIngestionStatus(
            UUID dataFeedId, IngestionStatusQueryOptions body, Integer skip, Integer maxpagesize, Context context) {
        return new PagedIterable<>(
                () -> getDataFeedIngestionStatusSinglePage(dataFeedId, body, skip, maxpagesize, context),
                nextLink -> getDataFeedIngestionStatusNextSinglePage(nextLink, body, context));
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> resetDataFeedIngestionStatusWithResponseAsync(
            UUID dataFeedId, IngestionProgressResetOptions body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.resetDataFeedIngestionStatus(this.getEndpoint(), dataFeedId, body, accept, context));
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> resetDataFeedIngestionStatusWithResponseAsync(
            UUID dataFeedId, IngestionProgressResetOptions body, Context context) {
        final String accept = "application/json";
        return service.resetDataFeedIngestionStatus(this.getEndpoint(), dataFeedId, body, accept, context);
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> resetDataFeedIngestionStatusAsync(UUID dataFeedId, IngestionProgressResetOptions body) {
        return resetDataFeedIngestionStatusWithResponseAsync(dataFeedId, body).flatMap(ignored -> Mono.empty());
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> resetDataFeedIngestionStatusAsync(
            UUID dataFeedId, IngestionProgressResetOptions body, Context context) {
        return resetDataFeedIngestionStatusWithResponseAsync(dataFeedId, body, context)
                .flatMap(ignored -> Mono.empty());
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> resetDataFeedIngestionStatusWithResponse(
            UUID dataFeedId, IngestionProgressResetOptions body, Context context) {
        final String accept = "application/json";
        return service.resetDataFeedIngestionStatusSync(this.getEndpoint(), dataFeedId, body, accept, context);
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void resetDataFeedIngestionStatus(UUID dataFeedId, IngestionProgressResetOptions body) {
        resetDataFeedIngestionStatusWithResponse(dataFeedId, body, Context.NONE);
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data last success ingestion job timestamp by data feed along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataFeedIngestionProgress>> getIngestionProgressWithResponseAsync(UUID dataFeedId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getIngestionProgress(this.getEndpoint(), dataFeedId, accept, context));
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data last success ingestion job timestamp by data feed along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataFeedIngestionProgress>> getIngestionProgressWithResponseAsync(
            UUID dataFeedId, Context context) {
        final String accept = "application/json";
        return service.getIngestionProgress(this.getEndpoint(), dataFeedId, accept, context);
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data last success ingestion job timestamp by data feed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataFeedIngestionProgress> getIngestionProgressAsync(UUID dataFeedId) {
        return getIngestionProgressWithResponseAsync(dataFeedId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data last success ingestion job timestamp by data feed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataFeedIngestionProgress> getIngestionProgressAsync(UUID dataFeedId, Context context) {
        return getIngestionProgressWithResponseAsync(dataFeedId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data last success ingestion job timestamp by data feed along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DataFeedIngestionProgress> getIngestionProgressWithResponse(UUID dataFeedId, Context context) {
        final String accept = "application/json";
        return service.getIngestionProgressSync(this.getEndpoint(), dataFeedId, accept, context);
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data last success ingestion job timestamp by data feed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DataFeedIngestionProgress getIngestionProgress(UUID dataFeedId) {
        return getIngestionProgressWithResponse(dataFeedId, Context.NONE).getValue();
    }

    /**
     * Get time series data from metric.
     *
     * @param metricId metric unique id.
     * @param body query time series data condition.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return time series data from metric along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<MetricDataList>> getMetricDataWithResponseAsync(UUID metricId, MetricDataQueryOptions body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getMetricData(this.getEndpoint(), metricId, body, accept, context));
    }

    /**
     * Get time series data from metric.
     *
     * @param metricId metric unique id.
     * @param body query time series data condition.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return time series data from metric along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<MetricDataList>> getMetricDataWithResponseAsync(
            UUID metricId, MetricDataQueryOptions body, Context context) {
        final String accept = "application/json";
        return service.getMetricData(this.getEndpoint(), metricId, body, accept, context);
    }

    /**
     * Get time series data from metric.
     *
     * @param metricId metric unique id.
     * @param body query time series data condition.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return time series data from metric on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<MetricDataList> getMetricDataAsync(UUID metricId, MetricDataQueryOptions body) {
        return getMetricDataWithResponseAsync(metricId, body).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get time series data from metric.
     *
     * @param metricId metric unique id.
     * @param body query time series data condition.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return time series data from metric on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<MetricDataList> getMetricDataAsync(UUID metricId, MetricDataQueryOptions body, Context context) {
        return getMetricDataWithResponseAsync(metricId, body, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get time series data from metric.
     *
     * @param metricId metric unique id.
     * @param body query time series data condition.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return time series data from metric along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<MetricDataList> getMetricDataWithResponse(
            UUID metricId, MetricDataQueryOptions body, Context context) {
        final String accept = "application/json";
        return service.getMetricDataSync(this.getEndpoint(), metricId, body, accept, context);
    }

    /**
     * Get time series data from metric.
     *
     * @param metricId metric unique id.
     * @param body query time series data condition.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return time series data from metric.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public MetricDataList getMetricData(UUID metricId, MetricDataQueryOptions body) {
        return getMetricDataWithResponse(metricId, body, Context.NONE).getValue();
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricSeriesItem>> getMetricSeriesSinglePageAsync(
            UUID metricId, MetricSeriesQueryOptions body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getMetricSeries(
                                        this.getEndpoint(), metricId, skip, maxpagesize, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricSeriesItem>> getMetricSeriesSinglePageAsync(
            UUID metricId, MetricSeriesQueryOptions body, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.getMetricSeries(this.getEndpoint(), metricId, skip, maxpagesize, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<MetricSeriesItem> getMetricSeriesAsync(
            UUID metricId, MetricSeriesQueryOptions body, Integer skip, Integer maxpagesize) {
        return new PagedFlux<>(
                () -> getMetricSeriesSinglePageAsync(metricId, body, skip, maxpagesize),
                nextLink -> getMetricSeriesNextSinglePageAsync(nextLink, body));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<MetricSeriesItem> getMetricSeriesAsync(
            UUID metricId, MetricSeriesQueryOptions body, Integer skip, Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> getMetricSeriesSinglePageAsync(metricId, body, skip, maxpagesize, context),
                nextLink -> getMetricSeriesNextSinglePageAsync(nextLink, body, context));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<MetricSeriesItem> getMetricSeriesSinglePage(
            UUID metricId, MetricSeriesQueryOptions body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        Response<MetricSeriesList> res =
                service.getMetricSeriesSync(
                        this.getEndpoint(), metricId, skip, maxpagesize, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<MetricSeriesItem> getMetricSeriesSinglePage(
            UUID metricId, MetricSeriesQueryOptions body, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        Response<MetricSeriesList> res =
                service.getMetricSeriesSync(this.getEndpoint(), metricId, skip, maxpagesize, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<MetricSeriesItem> getMetricSeries(
            UUID metricId, MetricSeriesQueryOptions body, Integer skip, Integer maxpagesize) {
        return new PagedIterable<>(
                () -> getMetricSeriesSinglePage(metricId, body, skip, maxpagesize, Context.NONE),
                nextLink -> getMetricSeriesNextSinglePage(nextLink, body));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<MetricSeriesItem> getMetricSeries(
            UUID metricId, MetricSeriesQueryOptions body, Integer skip, Integer maxpagesize, Context context) {
        return new PagedIterable<>(
                () -> getMetricSeriesSinglePage(metricId, body, skip, maxpagesize, context),
                nextLink -> getMetricSeriesNextSinglePage(nextLink, body, context));
    }

    /**
     * List dimension from certain metric.
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getMetricDimensionSinglePageAsync(
            UUID metricId, MetricDimensionQueryOptions body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getMetricDimension(
                                        this.getEndpoint(), metricId, skip, maxpagesize, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List dimension from certain metric.
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getMetricDimensionSinglePageAsync(
            UUID metricId, MetricDimensionQueryOptions body, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.getMetricDimension(this.getEndpoint(), metricId, skip, maxpagesize, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List dimension from certain metric.
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<String> getMetricDimensionAsync(
            UUID metricId, MetricDimensionQueryOptions body, Integer skip, Integer maxpagesize) {
        return new PagedFlux<>(
                () -> getMetricDimensionSinglePageAsync(metricId, body, skip, maxpagesize),
                nextLink -> getMetricDimensionNextSinglePageAsync(nextLink, body));
    }

    /**
     * List dimension from certain metric.
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<String> getMetricDimensionAsync(
            UUID metricId, MetricDimensionQueryOptions body, Integer skip, Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> getMetricDimensionSinglePageAsync(metricId, body, skip, maxpagesize, context),
                nextLink -> getMetricDimensionNextSinglePageAsync(nextLink, body, context));
    }

    /**
     * List dimension from certain metric.
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<String> getMetricDimensionSinglePage(
            UUID metricId, MetricDimensionQueryOptions body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        Response<MetricDimensionList> res =
                service.getMetricDimensionSync(
                        this.getEndpoint(), metricId, skip, maxpagesize, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List dimension from certain metric.
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<String> getMetricDimensionSinglePage(
            UUID metricId, MetricDimensionQueryOptions body, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        Response<MetricDimensionList> res =
                service.getMetricDimensionSync(this.getEndpoint(), metricId, skip, maxpagesize, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List dimension from certain metric.
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<String> getMetricDimension(
            UUID metricId, MetricDimensionQueryOptions body, Integer skip, Integer maxpagesize) {
        return new PagedIterable<>(
                () -> getMetricDimensionSinglePage(metricId, body, skip, maxpagesize, Context.NONE),
                nextLink -> getMetricDimensionNextSinglePage(nextLink, body));
    }

    /**
     * List dimension from certain metric.
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<String> getMetricDimension(
            UUID metricId, MetricDimensionQueryOptions body, Integer skip, Integer maxpagesize, Context context) {
        return new PagedIterable<>(
                () -> getMetricDimensionSinglePage(metricId, body, skip, maxpagesize, context),
                nextLink -> getMetricDimensionNextSinglePage(nextLink, body, context));
    }

    /**
     * List all anomaly detection configurations for specific metric.
     *
     * @param metricId metric unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyDetectionConfiguration>> getAnomalyDetectionConfigurationsByMetricSinglePageAsync(
            UUID metricId, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getAnomalyDetectionConfigurationsByMetric(
                                        this.getEndpoint(), metricId, skip, maxpagesize, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List all anomaly detection configurations for specific metric.
     *
     * @param metricId metric unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyDetectionConfiguration>> getAnomalyDetectionConfigurationsByMetricSinglePageAsync(
            UUID metricId, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.getAnomalyDetectionConfigurationsByMetric(
                        this.getEndpoint(), metricId, skip, maxpagesize, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List all anomaly detection configurations for specific metric.
     *
     * @param metricId metric unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnomalyDetectionConfiguration> getAnomalyDetectionConfigurationsByMetricAsync(
            UUID metricId, Integer skip, Integer maxpagesize) {
        return new PagedFlux<>(
                () -> getAnomalyDetectionConfigurationsByMetricSinglePageAsync(metricId, skip, maxpagesize),
                nextLink -> getAnomalyDetectionConfigurationsByMetricNextSinglePageAsync(nextLink));
    }

    /**
     * List all anomaly detection configurations for specific metric.
     *
     * @param metricId metric unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnomalyDetectionConfiguration> getAnomalyDetectionConfigurationsByMetricAsync(
            UUID metricId, Integer skip, Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> getAnomalyDetectionConfigurationsByMetricSinglePageAsync(metricId, skip, maxpagesize, context),
                nextLink -> getAnomalyDetectionConfigurationsByMetricNextSinglePageAsync(nextLink, context));
    }

    /**
     * List all anomaly detection configurations for specific metric.
     *
     * @param metricId metric unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyDetectionConfiguration> getAnomalyDetectionConfigurationsByMetricSinglePage(
            UUID metricId, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        Response<AnomalyDetectionConfigurationList> res =
                service.getAnomalyDetectionConfigurationsByMetricSync(
                        this.getEndpoint(), metricId, skip, maxpagesize, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List all anomaly detection configurations for specific metric.
     *
     * @param metricId metric unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyDetectionConfiguration> getAnomalyDetectionConfigurationsByMetricSinglePage(
            UUID metricId, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        Response<AnomalyDetectionConfigurationList> res =
                service.getAnomalyDetectionConfigurationsByMetricSync(
                        this.getEndpoint(), metricId, skip, maxpagesize, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List all anomaly detection configurations for specific metric.
     *
     * @param metricId metric unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnomalyDetectionConfiguration> getAnomalyDetectionConfigurationsByMetric(
            UUID metricId, Integer skip, Integer maxpagesize) {
        return new PagedIterable<>(
                () -> getAnomalyDetectionConfigurationsByMetricSinglePage(metricId, skip, maxpagesize, Context.NONE),
                nextLink -> getAnomalyDetectionConfigurationsByMetricNextSinglePage(nextLink));
    }

    /**
     * List all anomaly detection configurations for specific metric.
     *
     * @param metricId metric unique id.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnomalyDetectionConfiguration> getAnomalyDetectionConfigurationsByMetric(
            UUID metricId, Integer skip, Integer maxpagesize, Context context) {
        return new PagedIterable<>(
                () -> getAnomalyDetectionConfigurationsByMetricSinglePage(metricId, skip, maxpagesize, context),
                nextLink -> getAnomalyDetectionConfigurationsByMetricNextSinglePage(nextLink, context));
    }

    /**
     * Query anomaly detection status.
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<EnrichmentStatus>> getEnrichmentStatusByMetricSinglePageAsync(
            UUID metricId, EnrichmentStatusQueryOption body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getEnrichmentStatusByMetric(
                                        this.getEndpoint(), metricId, skip, maxpagesize, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query anomaly detection status.
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<EnrichmentStatus>> getEnrichmentStatusByMetricSinglePageAsync(
            UUID metricId, EnrichmentStatusQueryOption body, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.getEnrichmentStatusByMetric(
                        this.getEndpoint(), metricId, skip, maxpagesize, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query anomaly detection status.
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<EnrichmentStatus> getEnrichmentStatusByMetricAsync(
            UUID metricId, EnrichmentStatusQueryOption body, Integer skip, Integer maxpagesize) {
        return new PagedFlux<>(
                () -> getEnrichmentStatusByMetricSinglePageAsync(metricId, body, skip, maxpagesize),
                nextLink -> getEnrichmentStatusByMetricNextSinglePageAsync(nextLink, body));
    }

    /**
     * Query anomaly detection status.
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<EnrichmentStatus> getEnrichmentStatusByMetricAsync(
            UUID metricId, EnrichmentStatusQueryOption body, Integer skip, Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> getEnrichmentStatusByMetricSinglePageAsync(metricId, body, skip, maxpagesize, context),
                nextLink -> getEnrichmentStatusByMetricNextSinglePageAsync(nextLink, body, context));
    }

    /**
     * Query anomaly detection status.
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<EnrichmentStatus> getEnrichmentStatusByMetricSinglePage(
            UUID metricId, EnrichmentStatusQueryOption body, Integer skip, Integer maxpagesize) {
        final String accept = "application/json";
        Response<EnrichmentStatusList> res =
                service.getEnrichmentStatusByMetricSync(
                        this.getEndpoint(), metricId, skip, maxpagesize, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query anomaly detection status.
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<EnrichmentStatus> getEnrichmentStatusByMetricSinglePage(
            UUID metricId, EnrichmentStatusQueryOption body, Integer skip, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        Response<EnrichmentStatusList> res =
                service.getEnrichmentStatusByMetricSync(
                        this.getEndpoint(), metricId, skip, maxpagesize, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Query anomaly detection status.
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<EnrichmentStatus> getEnrichmentStatusByMetric(
            UUID metricId, EnrichmentStatusQueryOption body, Integer skip, Integer maxpagesize) {
        return new PagedIterable<>(
                () -> getEnrichmentStatusByMetricSinglePage(metricId, body, skip, maxpagesize, Context.NONE),
                nextLink -> getEnrichmentStatusByMetricNextSinglePage(nextLink, body));
    }

    /**
     * Query anomaly detection status.
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param skip for paging, skipped number.
     * @param maxpagesize the maximum number of items in one page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<EnrichmentStatus> getEnrichmentStatusByMetric(
            UUID metricId, EnrichmentStatusQueryOption body, Integer skip, Integer maxpagesize, Context context) {
        return new PagedIterable<>(
                () -> getEnrichmentStatusByMetricSinglePage(metricId, body, skip, maxpagesize, context),
                nextLink -> getEnrichmentStatusByMetricNextSinglePage(nextLink, body, context));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param nextLink the next link.
     * @param body query alerting result request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyAlert>> getAlertsByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink, AlertingResultQuery body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getAlertsByAnomalyAlertingConfigurationNext(
                                        this.getEndpoint(), nextLink, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param nextLink the next link.
     * @param body query alerting result request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyAlert>> getAlertsByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink, AlertingResultQuery body, Context context) {
        final String accept = "application/json";
        return service.getAlertsByAnomalyAlertingConfigurationNext(this.getEndpoint(), nextLink, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param nextLink the next link.
     * @param body query alerting result request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyAlert> getAlertsByAnomalyAlertingConfigurationNextSinglePage(
            String nextLink, AlertingResultQuery body) {
        final String accept = "application/json";
        Response<AlertResultList> res =
                service.getAlertsByAnomalyAlertingConfigurationNextSync(
                        this.getEndpoint(), nextLink, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param nextLink the next link.
     * @param body query alerting result request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyAlert> getAlertsByAnomalyAlertingConfigurationNextSinglePage(
            String nextLink, AlertingResultQuery body, Context context) {
        final String accept = "application/json";
        Response<AlertResultList> res =
                service.getAlertsByAnomalyAlertingConfigurationNextSync(
                        this.getEndpoint(), nextLink, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param nextLink the next link.
     * @param body query detection anomaly result request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, DetectionAnomalyResultQuery body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getAnomaliesByAnomalyDetectionConfigurationNext(
                                        this.getEndpoint(), nextLink, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param nextLink the next link.
     * @param body query detection anomaly result request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, DetectionAnomalyResultQuery body, Context context) {
        final String accept = "application/json";
        return service.getAnomaliesByAnomalyDetectionConfigurationNext(
                        this.getEndpoint(), nextLink, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param nextLink the next link.
     * @param body query detection anomaly result request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyResult> getAnomaliesByAnomalyDetectionConfigurationNextSinglePage(
            String nextLink, DetectionAnomalyResultQuery body) {
        final String accept = "application/json";
        Response<AnomalyResultList> res =
                service.getAnomaliesByAnomalyDetectionConfigurationNextSync(
                        this.getEndpoint(), nextLink, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param nextLink the next link.
     * @param body query detection anomaly result request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyResult> getAnomaliesByAnomalyDetectionConfigurationNextSinglePage(
            String nextLink, DetectionAnomalyResultQuery body, Context context) {
        final String accept = "application/json";
        Response<AnomalyResultList> res =
                service.getAnomaliesByAnomalyDetectionConfigurationNextSync(
                        this.getEndpoint(), nextLink, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param nextLink the next link.
     * @param body query dimension values request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, AnomalyDimensionQuery body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getDimensionOfAnomaliesByAnomalyDetectionConfigurationNext(
                                        this.getEndpoint(), nextLink, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param nextLink the next link.
     * @param body query dimension values request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, AnomalyDimensionQuery body, Context context) {
        final String accept = "application/json";
        return service.getDimensionOfAnomaliesByAnomalyDetectionConfigurationNext(
                        this.getEndpoint(), nextLink, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param nextLink the next link.
     * @param body query dimension values request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<String> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePage(
            String nextLink, AnomalyDimensionQuery body) {
        final String accept = "application/json";
        Response<AnomalyDimensionList> res =
                service.getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSync(
                        this.getEndpoint(), nextLink, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param nextLink the next link.
     * @param body query dimension values request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<String> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePage(
            String nextLink, AnomalyDimensionQuery body, Context context) {
        final String accept = "application/json";
        Response<AnomalyDimensionList> res =
                service.getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSync(
                        this.getEndpoint(), nextLink, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * List feedback on the given metric.
     *
     * @param nextLink the next link.
     * @param body metric feedback filter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricFeedback>> listMetricFeedbacksNextSinglePageAsync(
            String nextLink, MetricFeedbackFilter body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context -> service.listMetricFeedbacksNext(this.getEndpoint(), nextLink, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * List feedback on the given metric.
     *
     * @param nextLink the next link.
     * @param body metric feedback filter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricFeedback>> listMetricFeedbacksNextSinglePageAsync(
            String nextLink, MetricFeedbackFilter body, Context context) {
        final String accept = "application/json";
        return service.listMetricFeedbacksNext(this.getEndpoint(), nextLink, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * List feedback on the given metric.
     *
     * @param nextLink the next link.
     * @param body metric feedback filter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<MetricFeedback> listMetricFeedbacksNextSinglePage(String nextLink, MetricFeedbackFilter body) {
        final String accept = "application/json";
        Response<MetricFeedbackList> res =
                service.listMetricFeedbacksNextSync(this.getEndpoint(), nextLink, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * List feedback on the given metric.
     *
     * @param nextLink the next link.
     * @param body metric feedback filter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<MetricFeedback> listMetricFeedbacksNextSinglePage(
            String nextLink, MetricFeedbackFilter body, Context context) {
        final String accept = "application/json";
        Response<MetricFeedbackList> res =
                service.listMetricFeedbacksNextSync(this.getEndpoint(), nextLink, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param nextLink the next link.
     * @param body The query time range.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedIngestionStatus>> getDataFeedIngestionStatusNextSinglePageAsync(
            String nextLink, IngestionStatusQueryOptions body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getDataFeedIngestionStatusNext(
                                        this.getEndpoint(), nextLink, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param nextLink the next link.
     * @param body The query time range.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedIngestionStatus>> getDataFeedIngestionStatusNextSinglePageAsync(
            String nextLink, IngestionStatusQueryOptions body, Context context) {
        final String accept = "application/json";
        return service.getDataFeedIngestionStatusNext(this.getEndpoint(), nextLink, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param nextLink the next link.
     * @param body The query time range.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DataFeedIngestionStatus> getDataFeedIngestionStatusNextSinglePage(
            String nextLink, IngestionStatusQueryOptions body) {
        final String accept = "application/json";
        Response<IngestionStatusList> res =
                service.getDataFeedIngestionStatusNextSync(this.getEndpoint(), nextLink, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param nextLink the next link.
     * @param body The query time range.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DataFeedIngestionStatus> getDataFeedIngestionStatusNextSinglePage(
            String nextLink, IngestionStatusQueryOptions body, Context context) {
        final String accept = "application/json";
        Response<IngestionStatusList> res =
                service.getDataFeedIngestionStatusNextSync(this.getEndpoint(), nextLink, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param nextLink the next link.
     * @param body filter to query series.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricSeriesItem>> getMetricSeriesNextSinglePageAsync(
            String nextLink, MetricSeriesQueryOptions body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context -> service.getMetricSeriesNext(this.getEndpoint(), nextLink, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param nextLink the next link.
     * @param body filter to query series.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricSeriesItem>> getMetricSeriesNextSinglePageAsync(
            String nextLink, MetricSeriesQueryOptions body, Context context) {
        final String accept = "application/json";
        return service.getMetricSeriesNext(this.getEndpoint(), nextLink, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param nextLink the next link.
     * @param body filter to query series.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<MetricSeriesItem> getMetricSeriesNextSinglePage(
            String nextLink, MetricSeriesQueryOptions body) {
        final String accept = "application/json";
        Response<MetricSeriesList> res =
                service.getMetricSeriesNextSync(this.getEndpoint(), nextLink, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param nextLink the next link.
     * @param body filter to query series.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<MetricSeriesItem> getMetricSeriesNextSinglePage(
            String nextLink, MetricSeriesQueryOptions body, Context context) {
        final String accept = "application/json";
        Response<MetricSeriesList> res =
                service.getMetricSeriesNextSync(this.getEndpoint(), nextLink, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * List dimension from certain metric.
     *
     * @param nextLink the next link.
     * @param body query dimension option.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getMetricDimensionNextSinglePageAsync(
            String nextLink, MetricDimensionQueryOptions body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context -> service.getMetricDimensionNext(this.getEndpoint(), nextLink, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * List dimension from certain metric.
     *
     * @param nextLink the next link.
     * @param body query dimension option.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getMetricDimensionNextSinglePageAsync(
            String nextLink, MetricDimensionQueryOptions body, Context context) {
        final String accept = "application/json";
        return service.getMetricDimensionNext(this.getEndpoint(), nextLink, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * List dimension from certain metric.
     *
     * @param nextLink the next link.
     * @param body query dimension option.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<String> getMetricDimensionNextSinglePage(String nextLink, MetricDimensionQueryOptions body) {
        final String accept = "application/json";
        Response<MetricDimensionList> res =
                service.getMetricDimensionNextSync(this.getEndpoint(), nextLink, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * List dimension from certain metric.
     *
     * @param nextLink the next link.
     * @param body query dimension option.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<String> getMetricDimensionNextSinglePage(
            String nextLink, MetricDimensionQueryOptions body, Context context) {
        final String accept = "application/json";
        Response<MetricDimensionList> res =
                service.getMetricDimensionNextSync(this.getEndpoint(), nextLink, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * Query anomaly detection status.
     *
     * @param nextLink the next link.
     * @param body query options.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<EnrichmentStatus>> getEnrichmentStatusByMetricNextSinglePageAsync(
            String nextLink, EnrichmentStatusQueryOption body) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getEnrichmentStatusByMetricNext(
                                        this.getEndpoint(), nextLink, body, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Query anomaly detection status.
     *
     * @param nextLink the next link.
     * @param body query options.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<EnrichmentStatus>> getEnrichmentStatusByMetricNextSinglePageAsync(
            String nextLink, EnrichmentStatusQueryOption body, Context context) {
        final String accept = "application/json";
        return service.getEnrichmentStatusByMetricNext(this.getEndpoint(), nextLink, body, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Query anomaly detection status.
     *
     * @param nextLink the next link.
     * @param body query options.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<EnrichmentStatus> getEnrichmentStatusByMetricNextSinglePage(
            String nextLink, EnrichmentStatusQueryOption body) {
        final String accept = "application/json";
        Response<EnrichmentStatusList> res =
                service.getEnrichmentStatusByMetricNextSync(this.getEndpoint(), nextLink, body, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * Query anomaly detection status.
     *
     * @param nextLink the next link.
     * @param body query options.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<EnrichmentStatus> getEnrichmentStatusByMetricNextSinglePage(
            String nextLink, EnrichmentStatusQueryOption body, Context context) {
        final String accept = "application/json";
        Response<EnrichmentStatusList> res =
                service.getEnrichmentStatusByMetricNextSync(this.getEndpoint(), nextLink, body, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().getValue(), null, null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getAnomaliesFromAlertByAnomalyAlertingConfigurationNext(
                                        nextLink, this.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink, Context context) {
        final String accept = "application/json";
        return service.getAnomaliesFromAlertByAnomalyAlertingConfigurationNext(
                        nextLink, this.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyResult> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePage(
            String nextLink) {
        final String accept = "application/json";
        Response<AnomalyResultList> res =
                service.getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSync(
                        nextLink, this.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyResult> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePage(
            String nextLink, Context context) {
        final String accept = "application/json";
        Response<AnomalyResultList> res =
                service.getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSync(
                        nextLink, this.getEndpoint(), accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getIncidentsFromAlertByAnomalyAlertingConfigurationNext(
                                        nextLink, this.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink, Context context) {
        final String accept = "application/json";
        return service.getIncidentsFromAlertByAnomalyAlertingConfigurationNext(
                        nextLink, this.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<IncidentResult> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePage(
            String nextLink) {
        final String accept = "application/json";
        Response<IncidentResultList> res =
                service.getIncidentsFromAlertByAnomalyAlertingConfigurationNextSync(
                        nextLink, this.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<IncidentResult> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePage(
            String nextLink, Context context) {
        final String accept = "application/json";
        Response<IncidentResultList> res =
                service.getIncidentsFromAlertByAnomalyAlertingConfigurationNextSync(
                        nextLink, this.getEndpoint(), accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyAlertingConfiguration>>
            getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNext(
                                        nextLink, this.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyAlertingConfiguration>>
            getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNextSinglePageAsync(
                    String nextLink, Context context) {
        final String accept = "application/json";
        return service.getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNext(
                        nextLink, this.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyAlertingConfiguration>
            getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNextSinglePage(String nextLink) {
        final String accept = "application/json";
        Response<AnomalyAlertingConfigurationList> res =
                service.getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNextSync(
                        nextLink, this.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyAlertingConfiguration>
            getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNextSinglePage(
                    String nextLink, Context context) {
        final String accept = "application/json";
        Response<AnomalyAlertingConfigurationList> res =
                service.getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationNextSync(
                        nextLink, this.getEndpoint(), accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getIncidentsByAnomalyDetectionConfigurationNext(
                                        nextLink, this.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, Context context) {
        final String accept = "application/json";
        return service.getIncidentsByAnomalyDetectionConfigurationNext(nextLink, this.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<IncidentResult> getIncidentsByAnomalyDetectionConfigurationNextSinglePage(String nextLink) {
        final String accept = "application/json";
        Response<IncidentResultList> res =
                service.getIncidentsByAnomalyDetectionConfigurationNextSync(
                        nextLink, this.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<IncidentResult> getIncidentsByAnomalyDetectionConfigurationNextSinglePage(
            String nextLink, Context context) {
        final String accept = "application/json";
        Response<IncidentResultList> res =
                service.getIncidentsByAnomalyDetectionConfigurationNextSync(
                        nextLink, this.getEndpoint(), accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsByAnomalyDetectionConfigurationNextPagesNextSinglePageAsync(
            String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getIncidentsByAnomalyDetectionConfigurationNextPagesNext(
                                        nextLink, this.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsByAnomalyDetectionConfigurationNextPagesNextSinglePageAsync(
            String nextLink, Context context) {
        final String accept = "application/json";
        return service.getIncidentsByAnomalyDetectionConfigurationNextPagesNext(
                        nextLink, this.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<IncidentResult> getIncidentsByAnomalyDetectionConfigurationNextPagesNextSinglePage(
            String nextLink) {
        final String accept = "application/json";
        Response<IncidentResultList> res =
                service.getIncidentsByAnomalyDetectionConfigurationNextPagesNextSync(
                        nextLink, this.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<IncidentResult> getIncidentsByAnomalyDetectionConfigurationNextPagesNextSinglePage(
            String nextLink, Context context) {
        final String accept = "application/json";
        Response<IncidentResultList> res =
                service.getIncidentsByAnomalyDetectionConfigurationNextPagesNextSync(
                        nextLink, this.getEndpoint(), accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataSourceCredential>> listCredentialsNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context -> service.listCredentialsNext(nextLink, this.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataSourceCredential>> listCredentialsNextSinglePageAsync(
            String nextLink, Context context) {
        final String accept = "application/json";
        return service.listCredentialsNext(nextLink, this.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DataSourceCredential> listCredentialsNextSinglePage(String nextLink) {
        final String accept = "application/json";
        Response<DataSourceCredentialList> res =
                service.listCredentialsNextSync(nextLink, this.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DataSourceCredential> listCredentialsNextSinglePage(String nextLink, Context context) {
        final String accept = "application/json";
        Response<DataSourceCredentialList> res =
                service.listCredentialsNextSync(nextLink, this.getEndpoint(), accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedDetail>> listDataFeedsNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.listDataFeedsNext(nextLink, this.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedDetail>> listDataFeedsNextSinglePageAsync(String nextLink, Context context) {
        final String accept = "application/json";
        return service.listDataFeedsNext(nextLink, this.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DataFeedDetail> listDataFeedsNextSinglePage(String nextLink) {
        final String accept = "application/json";
        Response<DataFeedList> res = service.listDataFeedsNextSync(nextLink, this.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<DataFeedDetail> listDataFeedsNextSinglePage(String nextLink, Context context) {
        final String accept = "application/json";
        Response<DataFeedList> res = service.listDataFeedsNextSync(nextLink, this.getEndpoint(), accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<HookInfo>> listHooksNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.listHooksNext(nextLink, this.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<HookInfo>> listHooksNextSinglePageAsync(String nextLink, Context context) {
        final String accept = "application/json";
        return service.listHooksNext(nextLink, this.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<HookInfo> listHooksNextSinglePage(String nextLink) {
        final String accept = "application/json";
        Response<HookList> res = service.listHooksNextSync(nextLink, this.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<HookInfo> listHooksNextSinglePage(String nextLink, Context context) {
        final String accept = "application/json";
        Response<HookList> res = service.listHooksNextSync(nextLink, this.getEndpoint(), accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyDetectionConfiguration>>
            getAnomalyDetectionConfigurationsByMetricNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.getAnomalyDetectionConfigurationsByMetricNext(
                                        nextLink, this.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyDetectionConfiguration>>
            getAnomalyDetectionConfigurationsByMetricNextSinglePageAsync(String nextLink, Context context) {
        final String accept = "application/json";
        return service.getAnomalyDetectionConfigurationsByMetricNext(nextLink, this.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyDetectionConfiguration> getAnomalyDetectionConfigurationsByMetricNextSinglePage(
            String nextLink) {
        final String accept = "application/json";
        Response<AnomalyDetectionConfigurationList> res =
                service.getAnomalyDetectionConfigurationsByMetricNextSync(
                        nextLink, this.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws MetricsAdvisorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<AnomalyDetectionConfiguration> getAnomalyDetectionConfigurationsByMetricNextSinglePage(
            String nextLink, Context context) {
        final String accept = "application/json";
        Response<AnomalyDetectionConfigurationList> res =
                service.getAnomalyDetectionConfigurationsByMetricNextSync(
                        nextLink, this.getEndpoint(), accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getValue(),
                res.getValue().getNextLink(),
                null);
    }
}
