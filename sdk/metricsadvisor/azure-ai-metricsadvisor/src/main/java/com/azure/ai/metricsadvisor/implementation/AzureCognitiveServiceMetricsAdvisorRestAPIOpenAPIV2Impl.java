// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.ai.metricsadvisor.implementation;

import com.azure.ai.metricsadvisor.implementation.models.AlertResultList;
import com.azure.ai.metricsadvisor.implementation.models.AlertingResultQuery;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyAlertingConfiguration;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyAlertingConfigurationList;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyAlertingConfigurationPatch;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyDetectionConfiguration;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyDetectionConfigurationList;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyDetectionConfigurationPatch;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyDimensionList;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyDimensionQuery;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyResult;
import com.azure.ai.metricsadvisor.implementation.models.AnomalyResultList;
import com.azure.ai.metricsadvisor.implementation.models.CreateAnomalyAlertingConfigurationResponse;
import com.azure.ai.metricsadvisor.implementation.models.CreateAnomalyDetectionConfigurationResponse;
import com.azure.ai.metricsadvisor.implementation.models.CreateDataFeedResponse;
import com.azure.ai.metricsadvisor.implementation.models.CreateHookResponse;
import com.azure.ai.metricsadvisor.implementation.models.CreateMetricFeedbackResponse;
import com.azure.ai.metricsadvisor.implementation.models.DataFeedDetail;
import com.azure.ai.metricsadvisor.implementation.models.DataFeedDetailPatch;
import com.azure.ai.metricsadvisor.implementation.models.DataFeedList;
import com.azure.ai.metricsadvisor.implementation.models.DataSourceType;
import com.azure.ai.metricsadvisor.implementation.models.DetectionAnomalyResultQuery;
import com.azure.ai.metricsadvisor.implementation.models.DetectionIncidentResultQuery;
import com.azure.ai.metricsadvisor.implementation.models.DetectionSeriesQuery;
import com.azure.ai.metricsadvisor.implementation.models.EnrichmentStatusList;
import com.azure.ai.metricsadvisor.implementation.models.EnrichmentStatusQueryOption;
import com.azure.ai.metricsadvisor.implementation.models.EntityStatus;
import com.azure.ai.metricsadvisor.models.ErrorCodeException;
import com.azure.ai.metricsadvisor.implementation.models.Granularity;
import com.azure.ai.metricsadvisor.implementation.models.HookInfo;
import com.azure.ai.metricsadvisor.implementation.models.HookInfoPatch;
import com.azure.ai.metricsadvisor.implementation.models.HookList;
import com.azure.ai.metricsadvisor.implementation.models.IncidentResult;
import com.azure.ai.metricsadvisor.implementation.models.IncidentResultList;
import com.azure.ai.metricsadvisor.implementation.models.IngestionProgressResetOptions;
import com.azure.ai.metricsadvisor.implementation.models.IngestionStatusList;
import com.azure.ai.metricsadvisor.implementation.models.IngestionStatusQueryOptions;
import com.azure.ai.metricsadvisor.implementation.models.MetricDataList;
import com.azure.ai.metricsadvisor.implementation.models.MetricDataQueryOptions;
import com.azure.ai.metricsadvisor.implementation.models.MetricDimensionList;
import com.azure.ai.metricsadvisor.implementation.models.MetricDimensionQueryOptions;
import com.azure.ai.metricsadvisor.implementation.models.MetricFeedback;
import com.azure.ai.metricsadvisor.implementation.models.MetricFeedbackFilter;
import com.azure.ai.metricsadvisor.implementation.models.MetricFeedbackList;
import com.azure.ai.metricsadvisor.implementation.models.MetricSeriesList;
import com.azure.ai.metricsadvisor.implementation.models.MetricSeriesQueryOptions;
import com.azure.ai.metricsadvisor.implementation.models.RootCauseList;
import com.azure.ai.metricsadvisor.implementation.models.SeriesResultList;
import com.azure.ai.metricsadvisor.implementation.models.UsageStats;
import com.azure.ai.metricsadvisor.models.Alert;
import com.azure.ai.metricsadvisor.models.DataFeedIngestionProgress;
import com.azure.ai.metricsadvisor.models.DataFeedIngestionStatus;
import com.azure.ai.metricsadvisor.models.EnrichmentStatus;
import com.azure.ai.metricsadvisor.implementation.models.MetricSeriesItem;
import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.CookiePolicy;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import java.util.UUID;
import reactor.core.publisher.Mono;

/** Initializes a new instance of the AzureCognitiveServiceMetricsAdvisorRestAPIOpenAPIV2 type. */
public final class AzureCognitiveServiceMetricsAdvisorRestAPIOpenAPIV2Impl {
    /** The proxy service used to perform REST calls. */
    private final AzureCognitiveServiceMetricsAdvisorRestAPIOpenAPIV2Service service;

    /**
     * Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     */
    private final String endpoint;

    /**
     * Gets Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     *
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /** The HTTP pipeline to send requests through. */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     *
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /** Initializes an instance of AzureCognitiveServiceMetricsAdvisorRestAPIOpenAPIV2 client. */
    AzureCognitiveServiceMetricsAdvisorRestAPIOpenAPIV2Impl(String endpoint) {
        this(
                new HttpPipelineBuilder()
                        .policies(new UserAgentPolicy(), new RetryPolicy(), new CookiePolicy())
                        .build(),
                endpoint);
    }

    /**
     * Initializes an instance of AzureCognitiveServiceMetricsAdvisorRestAPIOpenAPIV2 client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     */
    AzureCognitiveServiceMetricsAdvisorRestAPIOpenAPIV2Impl(HttpPipeline httpPipeline, String endpoint) {
        this.httpPipeline = httpPipeline;
        this.endpoint = endpoint;
        this.service =
                RestProxy.create(AzureCognitiveServiceMetricsAdvisorRestAPIOpenAPIV2Service.class, this.httpPipeline);
    }

    /**
     * The interface defining all the services for AzureCognitiveServiceMetricsAdvisorRestAPIOpenAPIV2 to be used by the
     * proxy service to perform REST calls.
     */
    @Host("{endpoint}/metricsadvisor/v1.0")
    @ServiceInterface(name = "AzureCognitiveServic")
    private interface AzureCognitiveServiceMetricsAdvisorRestAPIOpenAPIV2Service {
        @Get("/stats/latest")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<UsageStats>> getActiveSeriesCount(@HostParam("endpoint") String endpoint, Context context);

        @Get("/alert/anomaly/configurations/{configurationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<AnomalyAlertingConfiguration>> getAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                Context context);

        @Patch("/alert/anomaly/configurations/{configurationId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<Void>> updateAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @BodyParam("application/json") AnomalyAlertingConfigurationPatch body,
                Context context);

        @Delete("/alert/anomaly/configurations/{configurationId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<Void>> deleteAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                Context context);

        @Post("/alert/anomaly/configurations")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<CreateAnomalyAlertingConfigurationResponse> createAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") AnomalyAlertingConfiguration body,
                Context context);

        @Post("/alert/anomaly/configurations/{configurationId}/alerts/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<AlertResultList>> getAlertsByAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$top") Integer top,
                @BodyParam("application/json") AlertingResultQuery body,
                Context context);

        @Get("/alert/anomaly/configurations/{configurationId}/alerts/{alertId}/anomalies")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<AnomalyResultList>> getAnomaliesFromAlertByAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @PathParam("alertId") String alertId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$top") Integer top,
                Context context);

        @Get("/alert/anomaly/configurations/{configurationId}/alerts/{alertId}/incidents")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<IncidentResultList>> getIncidentsFromAlertByAnomalyAlertingConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @PathParam("alertId") String alertId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$top") Integer top,
                Context context);

        @Get("/enrichment/anomalyDetection/configurations/{configurationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<AnomalyDetectionConfiguration>> getAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                Context context);

        @Patch("/enrichment/anomalyDetection/configurations/{configurationId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<Void>> updateAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @BodyParam("application/json") AnomalyDetectionConfigurationPatch body,
                Context context);

        @Delete("/enrichment/anomalyDetection/configurations/{configurationId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<Void>> deleteAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<CreateAnomalyDetectionConfigurationResponse> createAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") AnomalyDetectionConfiguration body,
                Context context);

        @Get("/enrichment/anomalyDetection/configurations/{configurationId}/alert/anomaly/configurations")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<AnomalyAlertingConfigurationList>>
                getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
                        @HostParam("endpoint") String endpoint,
                        @PathParam("configurationId") UUID configurationId,
                        Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/series/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<SeriesResultList>> getSeriesByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @BodyParam("application/json") DetectionSeriesQuery body,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/anomalies/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<AnomalyResultList>> getAnomaliesByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$top") Integer top,
                @BodyParam("application/json") DetectionAnomalyResultQuery body,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/anomalies/dimension/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<AnomalyDimensionList>> getDimensionOfAnomaliesByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$top") Integer top,
                @BodyParam("application/json") AnomalyDimensionQuery body,
                Context context);

        @Post("/enrichment/anomalyDetection/configurations/{configurationId}/incidents/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<IncidentResultList>> getIncidentsByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @QueryParam("$top") Integer top,
                @BodyParam("application/json") DetectionIncidentResultQuery body,
                Context context);

        @Get("/enrichment/anomalyDetection/configurations/{configurationId}/incidents/{incidentId}/rootCause")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<RootCauseList>> getRootCauseOfIncidentByAnomalyDetectionConfiguration(
                @HostParam("endpoint") String endpoint,
                @PathParam("configurationId") UUID configurationId,
                @PathParam("incidentId") String incidentId,
                Context context);

        @Get("/dataFeeds")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<DataFeedList>> listDataFeeds(
                @HostParam("endpoint") String endpoint,
                @QueryParam("dataFeedName") String dataFeedName,
                @QueryParam("dataSourceType") DataSourceType dataSourceType,
                @QueryParam("granularityName") Granularity granularityName,
                @QueryParam("status") EntityStatus status,
                @QueryParam("creator") String creator,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$top") Integer top,
                Context context);

        @Post("/dataFeeds")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<CreateDataFeedResponse> createDataFeed(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") DataFeedDetail body,
                Context context);

        @Get("/dataFeeds/{dataFeedId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<DataFeedDetail>> getDataFeedById(
                @HostParam("endpoint") String endpoint, @PathParam("dataFeedId") UUID dataFeedId, Context context);

        @Patch("/dataFeeds/{dataFeedId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<Void>> updateDataFeed(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") UUID dataFeedId,
                @BodyParam("application/json") DataFeedDetailPatch body,
                Context context);

        @Delete("/dataFeeds/{dataFeedId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<Void>> deleteDataFeed(
                @HostParam("endpoint") String endpoint, @PathParam("dataFeedId") UUID dataFeedId, Context context);

        @Get("/feedback/metric/{feedbackId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<MetricFeedback>> getMetricFeedback(
                @HostParam("endpoint") String endpoint, @PathParam("feedbackId") UUID feedbackId, Context context);

        @Post("/feedback/metric/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<MetricFeedbackList>> listMetricFeedbacks(
                @HostParam("endpoint") String endpoint,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$top") Integer top,
                @BodyParam("application/json") MetricFeedbackFilter body,
                Context context);

        @Post("/feedback/metric")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<CreateMetricFeedbackResponse> createMetricFeedback(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") MetricFeedback body,
                Context context);

        @Get("/hooks")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<HookList>> listHooks(
                @HostParam("endpoint") String endpoint,
                @QueryParam("hookName") String hookName,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$top") Integer top,
                Context context);

        @Post("/hooks")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<CreateHookResponse> createHook(
                @HostParam("endpoint") String endpoint, @BodyParam("application/json") HookInfo body, Context context);

        @Get("/hooks/{hookId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<HookInfo>> getHook(
                @HostParam("endpoint") String endpoint, @PathParam("hookId") UUID hookId, Context context);

        @Patch("/hooks/{hookId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<Void>> updateHook(
                @HostParam("endpoint") String endpoint,
                @PathParam("hookId") UUID hookId,
                @BodyParam("application/json") HookInfoPatch body,
                Context context);

        @Delete("/hooks/{hookId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<Void>> deleteHook(
                @HostParam("endpoint") String endpoint, @PathParam("hookId") UUID hookId, Context context);

        @Post("/dataFeeds/{dataFeedId}/ingestionStatus/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<IngestionStatusList>> getDataFeedIngestionStatus(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") UUID dataFeedId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$top") Integer top,
                @BodyParam("application/json") IngestionStatusQueryOptions body,
                Context context);

        @Post("/dataFeeds/{dataFeedId}/ingestionProgress/reset")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<Void>> resetDataFeedIngestionStatus(
                @HostParam("endpoint") String endpoint,
                @PathParam("dataFeedId") UUID dataFeedId,
                @BodyParam("application/json") IngestionProgressResetOptions body,
                Context context);

        @Get("/dataFeeds/{dataFeedId}/ingestionProgress")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<DataFeedIngestionProgress>> getIngestionProgress(
                @HostParam("endpoint") String endpoint, @PathParam("dataFeedId") UUID dataFeedId, Context context);

        @Post("/metrics/{metricId}/data/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<MetricDataList>> getMetricData(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") UUID metricId,
                @BodyParam("application/json") MetricDataQueryOptions body,
                Context context);

        @Post("/metrics/{metricId}/series/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<MetricSeriesList>> getMetricSeries(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") UUID metricId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$top") Integer top,
                @BodyParam("application/json") MetricSeriesQueryOptions body,
                Context context);

        @Post("/metrics/{metricId}/dimension/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<MetricDimensionList>> getMetricDimension(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") UUID metricId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$top") Integer top,
                @BodyParam("application/json") MetricDimensionQueryOptions body,
                Context context);

        @Get("/metrics/{metricId}/enrichment/anomalyDetection/configurations")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<AnomalyDetectionConfigurationList>> getAnomalyDetectionConfigurationsByMetric(
                @HostParam("endpoint") String endpoint, @PathParam("metricId") UUID metricId, Context context);

        @Post("/metrics/{metricId}/status/enrichment/anomalyDetection/query")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<EnrichmentStatusList>> getEnrichmentStatusByMetric(
                @HostParam("endpoint") String endpoint,
                @PathParam("metricId") UUID metricId,
                @QueryParam("$skip") Integer skip,
                @QueryParam("$top") Integer top,
                @BodyParam("application/json") EnrichmentStatusQueryOption body,
                Context context);

        @Post("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<AlertResultList>> getAlertsByAnomalyAlertingConfigurationNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") AlertingResultQuery body,
                Context context);

        @Post("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<AnomalyResultList>> getAnomaliesByAnomalyDetectionConfigurationNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") DetectionAnomalyResultQuery body,
                Context context);

        @Post("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<AnomalyDimensionList>> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") AnomalyDimensionQuery body,
                Context context);

        @Post("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<MetricFeedbackList>> listMetricFeedbacksNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") MetricFeedbackFilter body,
                Context context);

        @Post("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<IngestionStatusList>> getDataFeedIngestionStatusNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") IngestionStatusQueryOptions body,
                Context context);

        @Post("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<MetricSeriesList>> getMetricSeriesNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") MetricSeriesQueryOptions body,
                Context context);

        @Post("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<MetricDimensionList>> getMetricDimensionNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") MetricDimensionQueryOptions body,
                Context context);

        @Post("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<EnrichmentStatusList>> getEnrichmentStatusByMetricNext(
                @HostParam("endpoint") String endpoint,
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @BodyParam("application/json") EnrichmentStatusQueryOption body,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<AnomalyResultList>> getAnomaliesFromAlertByAnomalyAlertingConfigurationNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<IncidentResultList>> getIncidentsFromAlertByAnomalyAlertingConfigurationNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<IncidentResultList>> getIncidentsByAnomalyDetectionConfigurationNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<DataFeedList>> listDataFeedsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorCodeException.class)
        Mono<Response<HookList>> listHooksNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);
    }

    /**
     * Get latest usage stats.
     *
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return latest usage stats.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<UsageStats>> getActiveSeriesCountWithResponseAsync() {
        return FluxUtil.withContext(context -> service.getActiveSeriesCount(this.getEndpoint(), context));
    }

    /**
     * Get latest usage stats.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return latest usage stats.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<UsageStats>> getActiveSeriesCountWithResponseAsync(Context context) {
        return service.getActiveSeriesCount(this.getEndpoint(), context);
    }

    /**
     * Get latest usage stats.
     *
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return latest usage stats.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<UsageStats> getActiveSeriesCountAsync() {
        return getActiveSeriesCountWithResponseAsync()
                .flatMap(
                        (Response<UsageStats> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get latest usage stats.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return latest usage stats.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<UsageStats> getActiveSeriesCountAsync(Context context) {
        return getActiveSeriesCountWithResponseAsync(context)
                .flatMap(
                        (Response<UsageStats> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get latest usage stats.
     *
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return latest usage stats.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public UsageStats getActiveSeriesCount() {
        return getActiveSeriesCountAsync().block();
    }

    /**
     * Get latest usage stats.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return latest usage stats.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public UsageStats getActiveSeriesCount(Context context) {
        return getActiveSeriesCountAsync(context).block();
    }

    /**
     * Query a single anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyAlertingConfiguration>> getAnomalyAlertingConfigurationWithResponseAsync(
            UUID configurationId) {
        return FluxUtil.withContext(
                context -> service.getAnomalyAlertingConfiguration(this.getEndpoint(), configurationId, context));
    }

    /**
     * Query a single anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyAlertingConfiguration>> getAnomalyAlertingConfigurationWithResponseAsync(
            UUID configurationId, Context context) {
        return service.getAnomalyAlertingConfiguration(this.getEndpoint(), configurationId, context);
    }

    /**
     * Query a single anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyAlertingConfiguration> getAnomalyAlertingConfigurationAsync(UUID configurationId) {
        return getAnomalyAlertingConfigurationWithResponseAsync(configurationId)
                .flatMap(
                        (Response<AnomalyAlertingConfiguration> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Query a single anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyAlertingConfiguration> getAnomalyAlertingConfigurationAsync(
            UUID configurationId, Context context) {
        return getAnomalyAlertingConfigurationWithResponseAsync(configurationId, context)
                .flatMap(
                        (Response<AnomalyAlertingConfiguration> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Query a single anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnomalyAlertingConfiguration getAnomalyAlertingConfiguration(UUID configurationId) {
        return getAnomalyAlertingConfigurationAsync(configurationId).block();
    }

    /**
     * Query a single anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnomalyAlertingConfiguration getAnomalyAlertingConfiguration(UUID configurationId, Context context) {
        return getAnomalyAlertingConfigurationAsync(configurationId, context).block();
    }

    /**
     * Update anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateAnomalyAlertingConfigurationWithResponseAsync(
            UUID configurationId, AnomalyAlertingConfigurationPatch body) {
        return FluxUtil.withContext(
                context ->
                        service.updateAnomalyAlertingConfiguration(this.getEndpoint(), configurationId, body, context));
    }

    /**
     * Update anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateAnomalyAlertingConfigurationWithResponseAsync(
            UUID configurationId, AnomalyAlertingConfigurationPatch body, Context context) {
        return service.updateAnomalyAlertingConfiguration(this.getEndpoint(), configurationId, body, context);
    }

    /**
     * Update anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateAnomalyAlertingConfigurationAsync(
            UUID configurationId, AnomalyAlertingConfigurationPatch body) {
        return updateAnomalyAlertingConfigurationWithResponseAsync(configurationId, body)
                .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Update anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateAnomalyAlertingConfigurationAsync(
            UUID configurationId, AnomalyAlertingConfigurationPatch body, Context context) {
        return updateAnomalyAlertingConfigurationWithResponseAsync(configurationId, body, context)
                .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Update anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updateAnomalyAlertingConfiguration(UUID configurationId, AnomalyAlertingConfigurationPatch body) {
        updateAnomalyAlertingConfigurationAsync(configurationId, body).block();
    }

    /**
     * Update anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body anomaly alerting configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updateAnomalyAlertingConfiguration(
            UUID configurationId, AnomalyAlertingConfigurationPatch body, Context context) {
        updateAnomalyAlertingConfigurationAsync(configurationId, body, context).block();
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAnomalyAlertingConfigurationWithResponseAsync(UUID configurationId) {
        return FluxUtil.withContext(
                context -> service.deleteAnomalyAlertingConfiguration(this.getEndpoint(), configurationId, context));
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAnomalyAlertingConfigurationWithResponseAsync(
            UUID configurationId, Context context) {
        return service.deleteAnomalyAlertingConfiguration(this.getEndpoint(), configurationId, context);
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAnomalyAlertingConfigurationAsync(UUID configurationId) {
        return deleteAnomalyAlertingConfigurationWithResponseAsync(configurationId)
                .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAnomalyAlertingConfigurationAsync(UUID configurationId, Context context) {
        return deleteAnomalyAlertingConfigurationWithResponseAsync(configurationId, context)
                .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteAnomalyAlertingConfiguration(UUID configurationId) {
        deleteAnomalyAlertingConfigurationAsync(configurationId).block();
    }

    /**
     * Delete anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteAnomalyAlertingConfiguration(UUID configurationId, Context context) {
        deleteAnomalyAlertingConfigurationAsync(configurationId, context).block();
    }

    /**
     * Create anomaly alerting configuration.
     *
     * @param body anomaly alerting configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateAnomalyAlertingConfigurationResponse> createAnomalyAlertingConfigurationWithResponseAsync(
            AnomalyAlertingConfiguration body) {
        return FluxUtil.withContext(
                context -> service.createAnomalyAlertingConfiguration(this.getEndpoint(), body, context));
    }

    /**
     * Create anomaly alerting configuration.
     *
     * @param body anomaly alerting configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateAnomalyAlertingConfigurationResponse> createAnomalyAlertingConfigurationWithResponseAsync(
            AnomalyAlertingConfiguration body, Context context) {
        return service.createAnomalyAlertingConfiguration(this.getEndpoint(), body, context);
    }

    /**
     * Create anomaly alerting configuration.
     *
     * @param body anomaly alerting configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createAnomalyAlertingConfigurationAsync(AnomalyAlertingConfiguration body) {
        return createAnomalyAlertingConfigurationWithResponseAsync(body)
                .flatMap((CreateAnomalyAlertingConfigurationResponse res) -> Mono.empty());
    }

    /**
     * Create anomaly alerting configuration.
     *
     * @param body anomaly alerting configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createAnomalyAlertingConfigurationAsync(AnomalyAlertingConfiguration body, Context context) {
        return createAnomalyAlertingConfigurationWithResponseAsync(body, context)
                .flatMap((CreateAnomalyAlertingConfigurationResponse res) -> Mono.empty());
    }

    /**
     * Create anomaly alerting configuration.
     *
     * @param body anomaly alerting configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createAnomalyAlertingConfiguration(AnomalyAlertingConfiguration body) {
        createAnomalyAlertingConfigurationAsync(body).block();
    }

    /**
     * Create anomaly alerting configuration.
     *
     * @param body anomaly alerting configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createAnomalyAlertingConfiguration(AnomalyAlertingConfiguration body, Context context) {
        createAnomalyAlertingConfigurationAsync(body, context).block();
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<Alert>> getAlertsByAnomalyAlertingConfigurationSinglePageAsync(
            UUID configurationId, AlertingResultQuery body, Integer skip, Integer top) {
        return FluxUtil.withContext(
                        context ->
                                service.getAlertsByAnomalyAlertingConfiguration(
                                        this.getEndpoint(), configurationId, skip, top, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<Alert>> getAlertsByAnomalyAlertingConfigurationSinglePageAsync(
            UUID configurationId, AlertingResultQuery body, Integer skip, Integer top, Context context) {
        return service.getAlertsByAnomalyAlertingConfiguration(
                        this.getEndpoint(), configurationId, skip, top, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<Alert> getAlertsByAnomalyAlertingConfigurationAsync(
            UUID configurationId, AlertingResultQuery body, Integer skip, Integer top) {
        return new PagedFlux<>(
                () -> getAlertsByAnomalyAlertingConfigurationSinglePageAsync(configurationId, body, skip, top),
                nextLink -> getAlertsByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink, body));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<Alert> getAlertsByAnomalyAlertingConfigurationAsync(
            UUID configurationId, AlertingResultQuery body, Integer skip, Integer top, Context context) {
        return new PagedFlux<>(
                () -> getAlertsByAnomalyAlertingConfigurationSinglePageAsync(configurationId, body, skip, top, context),
                nextLink -> getAlertsByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink, body));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<Alert> getAlertsByAnomalyAlertingConfiguration(
            UUID configurationId, AlertingResultQuery body, Integer skip, Integer top) {
        return new PagedIterable<>(getAlertsByAnomalyAlertingConfigurationAsync(configurationId, body, skip, top));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param body query alerting result request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<Alert> getAlertsByAnomalyAlertingConfiguration(
            UUID configurationId, AlertingResultQuery body, Integer skip, Integer top, Context context) {
        return new PagedIterable<>(
                getAlertsByAnomalyAlertingConfigurationAsync(configurationId, body, skip, top, context));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
            UUID configurationId, String alertId, Integer skip, Integer top) {
        return FluxUtil.withContext(
                        context ->
                                service.getAnomaliesFromAlertByAnomalyAlertingConfiguration(
                                        this.getEndpoint(), configurationId, alertId, skip, top, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
            UUID configurationId, String alertId, Integer skip, Integer top, Context context) {
        return service.getAnomaliesFromAlertByAnomalyAlertingConfiguration(
                        this.getEndpoint(), configurationId, alertId, skip, top, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnomalyResult> getAnomaliesFromAlertByAnomalyAlertingConfigurationAsync(
            UUID configurationId, String alertId, Integer skip, Integer top) {
        return new PagedFlux<>(
                () ->
                        getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
                                configurationId, alertId, skip, top),
                nextLink -> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnomalyResult> getAnomaliesFromAlertByAnomalyAlertingConfigurationAsync(
            UUID configurationId, String alertId, Integer skip, Integer top, Context context) {
        return new PagedFlux<>(
                () ->
                        getAnomaliesFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
                                configurationId, alertId, skip, top, context),
                nextLink -> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnomalyResult> getAnomaliesFromAlertByAnomalyAlertingConfiguration(
            UUID configurationId, String alertId, Integer skip, Integer top) {
        return new PagedIterable<>(
                getAnomaliesFromAlertByAnomalyAlertingConfigurationAsync(configurationId, alertId, skip, top));
    }

    /**
     * Query anomalies under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnomalyResult> getAnomaliesFromAlertByAnomalyAlertingConfiguration(
            UUID configurationId, String alertId, Integer skip, Integer top, Context context) {
        return new PagedIterable<>(
                getAnomaliesFromAlertByAnomalyAlertingConfigurationAsync(configurationId, alertId, skip, top, context));
    }

    /**
     * Query incidents under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
            UUID configurationId, String alertId, Integer skip, Integer top) {
        return FluxUtil.withContext(
                        context ->
                                service.getIncidentsFromAlertByAnomalyAlertingConfiguration(
                                        this.getEndpoint(), configurationId, alertId, skip, top, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query incidents under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
            UUID configurationId, String alertId, Integer skip, Integer top, Context context) {
        return service.getIncidentsFromAlertByAnomalyAlertingConfiguration(
                        this.getEndpoint(), configurationId, alertId, skip, top, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query incidents under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<IncidentResult> getIncidentsFromAlertByAnomalyAlertingConfigurationAsync(
            UUID configurationId, String alertId, Integer skip, Integer top) {
        return new PagedFlux<>(
                () ->
                        getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
                                configurationId, alertId, skip, top),
                nextLink -> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink));
    }

    /**
     * Query incidents under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<IncidentResult> getIncidentsFromAlertByAnomalyAlertingConfigurationAsync(
            UUID configurationId, String alertId, Integer skip, Integer top, Context context) {
        return new PagedFlux<>(
                () ->
                        getIncidentsFromAlertByAnomalyAlertingConfigurationSinglePageAsync(
                                configurationId, alertId, skip, top, context),
                nextLink -> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(nextLink));
    }

    /**
     * Query incidents under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<IncidentResult> getIncidentsFromAlertByAnomalyAlertingConfiguration(
            UUID configurationId, String alertId, Integer skip, Integer top) {
        return new PagedIterable<>(
                getIncidentsFromAlertByAnomalyAlertingConfigurationAsync(configurationId, alertId, skip, top));
    }

    /**
     * Query incidents under a specific alert.
     *
     * @param configurationId anomaly alerting configuration unique id.
     * @param alertId alert id.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<IncidentResult> getIncidentsFromAlertByAnomalyAlertingConfiguration(
            UUID configurationId, String alertId, Integer skip, Integer top, Context context) {
        return new PagedIterable<>(
                getIncidentsFromAlertByAnomalyAlertingConfigurationAsync(configurationId, alertId, skip, top, context));
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyDetectionConfiguration>> getAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId) {
        return FluxUtil.withContext(
                context -> service.getAnomalyDetectionConfiguration(this.getEndpoint(), configurationId, context));
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyDetectionConfiguration>> getAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, Context context) {
        return service.getAnomalyDetectionConfiguration(this.getEndpoint(), configurationId, context);
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyDetectionConfiguration> getAnomalyDetectionConfigurationAsync(UUID configurationId) {
        return getAnomalyDetectionConfigurationWithResponseAsync(configurationId)
                .flatMap(
                        (Response<AnomalyDetectionConfiguration> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyDetectionConfiguration> getAnomalyDetectionConfigurationAsync(
            UUID configurationId, Context context) {
        return getAnomalyDetectionConfigurationWithResponseAsync(configurationId, context)
                .flatMap(
                        (Response<AnomalyDetectionConfiguration> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnomalyDetectionConfiguration getAnomalyDetectionConfiguration(UUID configurationId) {
        return getAnomalyDetectionConfigurationAsync(configurationId).block();
    }

    /**
     * Query a single anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnomalyDetectionConfiguration getAnomalyDetectionConfiguration(UUID configurationId, Context context) {
        return getAnomalyDetectionConfigurationAsync(configurationId, context).block();
    }

    /**
     * Update anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, AnomalyDetectionConfigurationPatch body) {
        return FluxUtil.withContext(
                context ->
                        service.updateAnomalyDetectionConfiguration(
                                this.getEndpoint(), configurationId, body, context));
    }

    /**
     * Update anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, AnomalyDetectionConfigurationPatch body, Context context) {
        return service.updateAnomalyDetectionConfiguration(this.getEndpoint(), configurationId, body, context);
    }

    /**
     * Update anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateAnomalyDetectionConfigurationAsync(
            UUID configurationId, AnomalyDetectionConfigurationPatch body) {
        return updateAnomalyDetectionConfigurationWithResponseAsync(configurationId, body)
                .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Update anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateAnomalyDetectionConfigurationAsync(
            UUID configurationId, AnomalyDetectionConfigurationPatch body, Context context) {
        return updateAnomalyDetectionConfigurationWithResponseAsync(configurationId, body, context)
                .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Update anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updateAnomalyDetectionConfiguration(UUID configurationId, AnomalyDetectionConfigurationPatch body) {
        updateAnomalyDetectionConfigurationAsync(configurationId, body).block();
    }

    /**
     * Update anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body anomaly detection configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updateAnomalyDetectionConfiguration(
            UUID configurationId, AnomalyDetectionConfigurationPatch body, Context context) {
        updateAnomalyDetectionConfigurationAsync(configurationId, body, context).block();
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAnomalyDetectionConfigurationWithResponseAsync(UUID configurationId) {
        return FluxUtil.withContext(
                context -> service.deleteAnomalyDetectionConfiguration(this.getEndpoint(), configurationId, context));
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, Context context) {
        return service.deleteAnomalyDetectionConfiguration(this.getEndpoint(), configurationId, context);
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAnomalyDetectionConfigurationAsync(UUID configurationId) {
        return deleteAnomalyDetectionConfigurationWithResponseAsync(configurationId)
                .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAnomalyDetectionConfigurationAsync(UUID configurationId, Context context) {
        return deleteAnomalyDetectionConfigurationWithResponseAsync(configurationId, context)
                .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteAnomalyDetectionConfiguration(UUID configurationId) {
        deleteAnomalyDetectionConfigurationAsync(configurationId).block();
    }

    /**
     * Delete anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteAnomalyDetectionConfiguration(UUID configurationId, Context context) {
        deleteAnomalyDetectionConfigurationAsync(configurationId, context).block();
    }

    /**
     * Create anomaly detection configuration.
     *
     * @param body anomaly detection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateAnomalyDetectionConfigurationResponse> createAnomalyDetectionConfigurationWithResponseAsync(
            AnomalyDetectionConfiguration body) {
        return FluxUtil.withContext(
                context -> service.createAnomalyDetectionConfiguration(this.getEndpoint(), body, context));
    }

    /**
     * Create anomaly detection configuration.
     *
     * @param body anomaly detection configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateAnomalyDetectionConfigurationResponse> createAnomalyDetectionConfigurationWithResponseAsync(
            AnomalyDetectionConfiguration body, Context context) {
        return service.createAnomalyDetectionConfiguration(this.getEndpoint(), body, context);
    }

    /**
     * Create anomaly detection configuration.
     *
     * @param body anomaly detection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createAnomalyDetectionConfigurationAsync(AnomalyDetectionConfiguration body) {
        return createAnomalyDetectionConfigurationWithResponseAsync(body)
                .flatMap((CreateAnomalyDetectionConfigurationResponse res) -> Mono.empty());
    }

    /**
     * Create anomaly detection configuration.
     *
     * @param body anomaly detection configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createAnomalyDetectionConfigurationAsync(AnomalyDetectionConfiguration body, Context context) {
        return createAnomalyDetectionConfigurationWithResponseAsync(body, context)
                .flatMap((CreateAnomalyDetectionConfigurationResponse res) -> Mono.empty());
    }

    /**
     * Create anomaly detection configuration.
     *
     * @param body anomaly detection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createAnomalyDetectionConfiguration(AnomalyDetectionConfiguration body) {
        createAnomalyDetectionConfigurationAsync(body).block();
    }

    /**
     * Create anomaly detection configuration.
     *
     * @param body anomaly detection configuration.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createAnomalyDetectionConfiguration(AnomalyDetectionConfiguration body, Context context) {
        createAnomalyDetectionConfigurationAsync(body, context).block();
    }

    /**
     * Query all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyAlertingConfigurationList>>
            getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationWithResponseAsync(UUID configurationId) {
        return FluxUtil.withContext(
                context ->
                        service.getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
                                this.getEndpoint(), configurationId, context));
    }

    /**
     * Query all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyAlertingConfigurationList>>
            getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationWithResponseAsync(
                    UUID configurationId, Context context) {
        return service.getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
                this.getEndpoint(), configurationId, context);
    }

    /**
     * Query all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyAlertingConfigurationList> getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationAsync(
            UUID configurationId) {
        return getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationWithResponseAsync(configurationId)
                .flatMap(
                        (Response<AnomalyAlertingConfigurationList> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Query all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyAlertingConfigurationList> getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationAsync(
            UUID configurationId, Context context) {
        return getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationWithResponseAsync(
                        configurationId, context)
                .flatMap(
                        (Response<AnomalyAlertingConfigurationList> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Query all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnomalyAlertingConfigurationList getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
            UUID configurationId) {
        return getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationAsync(configurationId).block();
    }

    /**
     * Query all anomaly alerting configurations for specific anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnomalyAlertingConfigurationList getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration(
            UUID configurationId, Context context) {
        return getAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationAsync(configurationId, context).block();
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query series detection result request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SeriesResultList>> getSeriesByAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, DetectionSeriesQuery body) {
        return FluxUtil.withContext(
                context ->
                        service.getSeriesByAnomalyDetectionConfiguration(
                                this.getEndpoint(), configurationId, body, context));
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query series detection result request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SeriesResultList>> getSeriesByAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, DetectionSeriesQuery body, Context context) {
        return service.getSeriesByAnomalyDetectionConfiguration(this.getEndpoint(), configurationId, body, context);
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query series detection result request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SeriesResultList> getSeriesByAnomalyDetectionConfigurationAsync(
            UUID configurationId, DetectionSeriesQuery body) {
        return getSeriesByAnomalyDetectionConfigurationWithResponseAsync(configurationId, body)
                .flatMap(
                        (Response<SeriesResultList> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query series detection result request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SeriesResultList> getSeriesByAnomalyDetectionConfigurationAsync(
            UUID configurationId, DetectionSeriesQuery body, Context context) {
        return getSeriesByAnomalyDetectionConfigurationWithResponseAsync(configurationId, body, context)
                .flatMap(
                        (Response<SeriesResultList> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query series detection result request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SeriesResultList getSeriesByAnomalyDetectionConfiguration(UUID configurationId, DetectionSeriesQuery body) {
        return getSeriesByAnomalyDetectionConfigurationAsync(configurationId, body).block();
    }

    /**
     * Query series enriched by anomaly detection.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query series detection result request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SeriesResultList getSeriesByAnomalyDetectionConfiguration(
            UUID configurationId, DetectionSeriesQuery body, Context context) {
        return getSeriesByAnomalyDetectionConfigurationAsync(configurationId, body, context).block();
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
            UUID configurationId, DetectionAnomalyResultQuery body, Integer skip, Integer top) {
        return FluxUtil.withContext(
                        context ->
                                service.getAnomaliesByAnomalyDetectionConfiguration(
                                        this.getEndpoint(), configurationId, skip, top, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
            UUID configurationId, DetectionAnomalyResultQuery body, Integer skip, Integer top, Context context) {
        return service.getAnomaliesByAnomalyDetectionConfiguration(
                        this.getEndpoint(), configurationId, skip, top, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnomalyResult> getAnomaliesByAnomalyDetectionConfigurationAsync(
            UUID configurationId, DetectionAnomalyResultQuery body, Integer skip, Integer top) {
        return new PagedFlux<>(
                () -> getAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(configurationId, body, skip, top),
                nextLink -> getAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink, body));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<AnomalyResult> getAnomaliesByAnomalyDetectionConfigurationAsync(
            UUID configurationId, DetectionAnomalyResultQuery body, Integer skip, Integer top, Context context) {
        return new PagedFlux<>(
                () ->
                        getAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, body, skip, top, context),
                nextLink -> getAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink, body));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnomalyResult> getAnomaliesByAnomalyDetectionConfiguration(
            UUID configurationId, DetectionAnomalyResultQuery body, Integer skip, Integer top) {
        return new PagedIterable<>(getAnomaliesByAnomalyDetectionConfigurationAsync(configurationId, body, skip, top));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection anomaly result request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<AnomalyResult> getAnomaliesByAnomalyDetectionConfiguration(
            UUID configurationId, DetectionAnomalyResultQuery body, Integer skip, Integer top, Context context) {
        return new PagedIterable<>(
                getAnomaliesByAnomalyDetectionConfigurationAsync(configurationId, body, skip, top, context));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
            UUID configurationId, AnomalyDimensionQuery body, Integer skip, Integer top) {
        return FluxUtil.withContext(
                        context ->
                                service.getDimensionOfAnomaliesByAnomalyDetectionConfiguration(
                                        this.getEndpoint(), configurationId, skip, top, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
            UUID configurationId, AnomalyDimensionQuery body, Integer skip, Integer top, Context context) {
        return service.getDimensionOfAnomaliesByAnomalyDetectionConfiguration(
                        this.getEndpoint(), configurationId, skip, top, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<String> getDimensionOfAnomaliesByAnomalyDetectionConfigurationAsync(
            UUID configurationId, AnomalyDimensionQuery body, Integer skip, Integer top) {
        return new PagedFlux<>(
                () ->
                        getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, body, skip, top),
                nextLink -> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink, body));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<String> getDimensionOfAnomaliesByAnomalyDetectionConfigurationAsync(
            UUID configurationId, AnomalyDimensionQuery body, Integer skip, Integer top, Context context) {
        return new PagedFlux<>(
                () ->
                        getDimensionOfAnomaliesByAnomalyDetectionConfigurationSinglePageAsync(
                                configurationId, body, skip, top, context),
                nextLink -> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink, body));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<String> getDimensionOfAnomaliesByAnomalyDetectionConfiguration(
            UUID configurationId, AnomalyDimensionQuery body, Integer skip, Integer top) {
        return new PagedIterable<>(
                getDimensionOfAnomaliesByAnomalyDetectionConfigurationAsync(configurationId, body, skip, top));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query dimension values request.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<String> getDimensionOfAnomaliesByAnomalyDetectionConfiguration(
            UUID configurationId, AnomalyDimensionQuery body, Integer skip, Integer top, Context context) {
        return new PagedIterable<>(
                getDimensionOfAnomaliesByAnomalyDetectionConfigurationAsync(configurationId, body, skip, top, context));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsByAnomalyDetectionConfigurationSinglePageAsync(
            UUID configurationId, DetectionIncidentResultQuery body, Integer top) {
        return FluxUtil.withContext(
                        context ->
                                service.getIncidentsByAnomalyDetectionConfiguration(
                                        this.getEndpoint(), configurationId, top, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsByAnomalyDetectionConfigurationSinglePageAsync(
            UUID configurationId, DetectionIncidentResultQuery body, Integer top, Context context) {
        return service.getIncidentsByAnomalyDetectionConfiguration(
                        this.getEndpoint(), configurationId, top, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<IncidentResult> getIncidentsByAnomalyDetectionConfigurationAsync(
            UUID configurationId, DetectionIncidentResultQuery body, Integer top) {
        return new PagedFlux<>(
                () -> getIncidentsByAnomalyDetectionConfigurationSinglePageAsync(configurationId, body, top),
                nextLink -> getIncidentsByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<IncidentResult> getIncidentsByAnomalyDetectionConfigurationAsync(
            UUID configurationId, DetectionIncidentResultQuery body, Integer top, Context context) {
        return new PagedFlux<>(
                () -> getIncidentsByAnomalyDetectionConfigurationSinglePageAsync(configurationId, body, top, context),
                nextLink -> getIncidentsByAnomalyDetectionConfigurationNextSinglePageAsync(nextLink));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<IncidentResult> getIncidentsByAnomalyDetectionConfiguration(
            UUID configurationId, DetectionIncidentResultQuery body, Integer top) {
        return new PagedIterable<>(getIncidentsByAnomalyDetectionConfigurationAsync(configurationId, body, top));
    }

    /**
     * Query incidents under anomaly detection configuration.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param body query detection incident result request.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<IncidentResult> getIncidentsByAnomalyDetectionConfiguration(
            UUID configurationId, DetectionIncidentResultQuery body, Integer top, Context context) {
        return new PagedIterable<>(
                getIncidentsByAnomalyDetectionConfigurationAsync(configurationId, body, top, context));
    }

    /**
     * Query root cause for incident.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId incident id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RootCauseList>> getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, String incidentId) {
        return FluxUtil.withContext(
                context ->
                        service.getRootCauseOfIncidentByAnomalyDetectionConfiguration(
                                this.getEndpoint(), configurationId, incidentId, context));
    }

    /**
     * Query root cause for incident.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId incident id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RootCauseList>> getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponseAsync(
            UUID configurationId, String incidentId, Context context) {
        return service.getRootCauseOfIncidentByAnomalyDetectionConfiguration(
                this.getEndpoint(), configurationId, incidentId, context);
    }

    /**
     * Query root cause for incident.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId incident id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RootCauseList> getRootCauseOfIncidentByAnomalyDetectionConfigurationAsync(
            UUID configurationId, String incidentId) {
        return getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponseAsync(configurationId, incidentId)
                .flatMap(
                        (Response<RootCauseList> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Query root cause for incident.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId incident id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RootCauseList> getRootCauseOfIncidentByAnomalyDetectionConfigurationAsync(
            UUID configurationId, String incidentId, Context context) {
        return getRootCauseOfIncidentByAnomalyDetectionConfigurationWithResponseAsync(
                        configurationId, incidentId, context)
                .flatMap(
                        (Response<RootCauseList> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Query root cause for incident.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId incident id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RootCauseList getRootCauseOfIncidentByAnomalyDetectionConfiguration(
            UUID configurationId, String incidentId) {
        return getRootCauseOfIncidentByAnomalyDetectionConfigurationAsync(configurationId, incidentId).block();
    }

    /**
     * Query root cause for incident.
     *
     * @param configurationId anomaly detection configuration unique id.
     * @param incidentId incident id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RootCauseList getRootCauseOfIncidentByAnomalyDetectionConfiguration(
            UUID configurationId, String incidentId, Context context) {
        return getRootCauseOfIncidentByAnomalyDetectionConfigurationAsync(configurationId, incidentId, context).block();
    }

    /**
     * List all data feeds.
     *
     * @param dataFeedName filter data feed by its name.
     * @param dataSourceType filter data feed by its source type.
     * @param granularityName filter data feed by its granularity.
     * @param status filter data feed by its status.
     * @param creator filter data feed by its creator.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedDetail>> listDataFeedsSinglePageAsync(
            String dataFeedName,
            DataSourceType dataSourceType,
            Granularity granularityName,
            EntityStatus status,
            String creator,
            Integer skip,
            Integer top) {
        return FluxUtil.withContext(
                        context ->
                                service.listDataFeeds(
                                        this.getEndpoint(),
                                        dataFeedName,
                                        dataSourceType,
                                        granularityName,
                                        status,
                                        creator,
                                        skip,
                                        top,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List all data feeds.
     *
     * @param dataFeedName filter data feed by its name.
     * @param dataSourceType filter data feed by its source type.
     * @param granularityName filter data feed by its granularity.
     * @param status filter data feed by its status.
     * @param creator filter data feed by its creator.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedDetail>> listDataFeedsSinglePageAsync(
            String dataFeedName,
            DataSourceType dataSourceType,
            Granularity granularityName,
            EntityStatus status,
            String creator,
            Integer skip,
            Integer top,
            Context context) {
        return service.listDataFeeds(
                        this.getEndpoint(),
                        dataFeedName,
                        dataSourceType,
                        granularityName,
                        status,
                        creator,
                        skip,
                        top,
                        context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List all data feeds.
     *
     * @param dataFeedName filter data feed by its name.
     * @param dataSourceType filter data feed by its source type.
     * @param granularityName filter data feed by its granularity.
     * @param status filter data feed by its status.
     * @param creator filter data feed by its creator.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DataFeedDetail> listDataFeedsAsync(
            String dataFeedName,
            DataSourceType dataSourceType,
            Granularity granularityName,
            EntityStatus status,
            String creator,
            Integer skip,
            Integer top) {
        return new PagedFlux<>(
                () ->
                        listDataFeedsSinglePageAsync(
                                dataFeedName, dataSourceType, granularityName, status, creator, skip, top),
                nextLink -> listDataFeedsNextSinglePageAsync(nextLink));
    }

    /**
     * List all data feeds.
     *
     * @param dataFeedName filter data feed by its name.
     * @param dataSourceType filter data feed by its source type.
     * @param granularityName filter data feed by its granularity.
     * @param status filter data feed by its status.
     * @param creator filter data feed by its creator.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DataFeedDetail> listDataFeedsAsync(
            String dataFeedName,
            DataSourceType dataSourceType,
            Granularity granularityName,
            EntityStatus status,
            String creator,
            Integer skip,
            Integer top,
            Context context) {
        return new PagedFlux<>(
                () ->
                        listDataFeedsSinglePageAsync(
                                dataFeedName, dataSourceType, granularityName, status, creator, skip, top, context),
                nextLink -> listDataFeedsNextSinglePageAsync(nextLink));
    }

    /**
     * List all data feeds.
     *
     * @param dataFeedName filter data feed by its name.
     * @param dataSourceType filter data feed by its source type.
     * @param granularityName filter data feed by its granularity.
     * @param status filter data feed by its status.
     * @param creator filter data feed by its creator.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DataFeedDetail> listDataFeeds(
            String dataFeedName,
            DataSourceType dataSourceType,
            Granularity granularityName,
            EntityStatus status,
            String creator,
            Integer skip,
            Integer top) {
        return new PagedIterable<>(
                listDataFeedsAsync(dataFeedName, dataSourceType, granularityName, status, creator, skip, top));
    }

    /**
     * List all data feeds.
     *
     * @param dataFeedName filter data feed by its name.
     * @param dataSourceType filter data feed by its source type.
     * @param granularityName filter data feed by its granularity.
     * @param status filter data feed by its status.
     * @param creator filter data feed by its creator.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DataFeedDetail> listDataFeeds(
            String dataFeedName,
            DataSourceType dataSourceType,
            Granularity granularityName,
            EntityStatus status,
            String creator,
            Integer skip,
            Integer top,
            Context context) {
        return new PagedIterable<>(
                listDataFeedsAsync(dataFeedName, dataSourceType, granularityName, status, creator, skip, top, context));
    }

    /**
     * Create a new data feed.
     *
     * @param body parameters to create a data feed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateDataFeedResponse> createDataFeedWithResponseAsync(DataFeedDetail body) {
        return FluxUtil.withContext(context -> service.createDataFeed(this.getEndpoint(), body, context));
    }

    /**
     * Create a new data feed.
     *
     * @param body parameters to create a data feed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateDataFeedResponse> createDataFeedWithResponseAsync(DataFeedDetail body, Context context) {
        return service.createDataFeed(this.getEndpoint(), body, context);
    }

    /**
     * Create a new data feed.
     *
     * @param body parameters to create a data feed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createDataFeedAsync(DataFeedDetail body) {
        return createDataFeedWithResponseAsync(body).flatMap((CreateDataFeedResponse res) -> Mono.empty());
    }

    /**
     * Create a new data feed.
     *
     * @param body parameters to create a data feed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createDataFeedAsync(DataFeedDetail body, Context context) {
        return createDataFeedWithResponseAsync(body, context).flatMap((CreateDataFeedResponse res) -> Mono.empty());
    }

    /**
     * Create a new data feed.
     *
     * @param body parameters to create a data feed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createDataFeed(DataFeedDetail body) {
        createDataFeedAsync(body).block();
    }

    /**
     * Create a new data feed.
     *
     * @param body parameters to create a data feed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createDataFeed(DataFeedDetail body, Context context) {
        createDataFeedAsync(body, context).block();
    }

    /**
     * Get a data feed by its id.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data feed by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataFeedDetail>> getDataFeedByIdWithResponseAsync(UUID dataFeedId) {
        return FluxUtil.withContext(context -> service.getDataFeedById(this.getEndpoint(), dataFeedId, context));
    }

    /**
     * Get a data feed by its id.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data feed by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataFeedDetail>> getDataFeedByIdWithResponseAsync(UUID dataFeedId, Context context) {
        return service.getDataFeedById(this.getEndpoint(), dataFeedId, context);
    }

    /**
     * Get a data feed by its id.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data feed by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataFeedDetail> getDataFeedByIdAsync(UUID dataFeedId) {
        return getDataFeedByIdWithResponseAsync(dataFeedId)
                .flatMap(
                        (Response<DataFeedDetail> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get a data feed by its id.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data feed by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataFeedDetail> getDataFeedByIdAsync(UUID dataFeedId, Context context) {
        return getDataFeedByIdWithResponseAsync(dataFeedId, context)
                .flatMap(
                        (Response<DataFeedDetail> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get a data feed by its id.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data feed by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DataFeedDetail getDataFeedById(UUID dataFeedId) {
        return getDataFeedByIdAsync(dataFeedId).block();
    }

    /**
     * Get a data feed by its id.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a data feed by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DataFeedDetail getDataFeedById(UUID dataFeedId, Context context) {
        return getDataFeedByIdAsync(dataFeedId, context).block();
    }

    /**
     * Update a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateDataFeedWithResponseAsync(UUID dataFeedId, DataFeedDetailPatch body) {
        return FluxUtil.withContext(context -> service.updateDataFeed(this.getEndpoint(), dataFeedId, body, context));
    }

    /**
     * Update a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateDataFeedWithResponseAsync(
            UUID dataFeedId, DataFeedDetailPatch body, Context context) {
        return service.updateDataFeed(this.getEndpoint(), dataFeedId, body, context);
    }

    /**
     * Update a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateDataFeedAsync(UUID dataFeedId, DataFeedDetailPatch body) {
        return updateDataFeedWithResponseAsync(dataFeedId, body).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Update a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateDataFeedAsync(UUID dataFeedId, DataFeedDetailPatch body, Context context) {
        return updateDataFeedWithResponseAsync(dataFeedId, body, context).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Update a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updateDataFeed(UUID dataFeedId, DataFeedDetailPatch body) {
        updateDataFeedAsync(dataFeedId, body).block();
    }

    /**
     * Update a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body parameters to update a data feed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updateDataFeed(UUID dataFeedId, DataFeedDetailPatch body, Context context) {
        updateDataFeedAsync(dataFeedId, body, context).block();
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteDataFeedWithResponseAsync(UUID dataFeedId) {
        return FluxUtil.withContext(context -> service.deleteDataFeed(this.getEndpoint(), dataFeedId, context));
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteDataFeedWithResponseAsync(UUID dataFeedId, Context context) {
        return service.deleteDataFeed(this.getEndpoint(), dataFeedId, context);
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteDataFeedAsync(UUID dataFeedId) {
        return deleteDataFeedWithResponseAsync(dataFeedId).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteDataFeedAsync(UUID dataFeedId, Context context) {
        return deleteDataFeedWithResponseAsync(dataFeedId, context).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteDataFeed(UUID dataFeedId) {
        deleteDataFeedAsync(dataFeedId).block();
    }

    /**
     * Delete a data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteDataFeed(UUID dataFeedId, Context context) {
        deleteDataFeedAsync(dataFeedId, context).block();
    }

    /**
     * Get a metric feedback by its id.
     *
     * @param feedbackId The feedbackId parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a metric feedback by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<MetricFeedback>> getMetricFeedbackWithResponseAsync(UUID feedbackId) {
        return FluxUtil.withContext(context -> service.getMetricFeedback(this.getEndpoint(), feedbackId, context));
    }

    /**
     * Get a metric feedback by its id.
     *
     * @param feedbackId The feedbackId parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a metric feedback by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<MetricFeedback>> getMetricFeedbackWithResponseAsync(UUID feedbackId, Context context) {
        return service.getMetricFeedback(this.getEndpoint(), feedbackId, context);
    }

    /**
     * Get a metric feedback by its id.
     *
     * @param feedbackId The feedbackId parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a metric feedback by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<MetricFeedback> getMetricFeedbackAsync(UUID feedbackId) {
        return getMetricFeedbackWithResponseAsync(feedbackId)
                .flatMap(
                        (Response<MetricFeedback> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get a metric feedback by its id.
     *
     * @param feedbackId The feedbackId parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a metric feedback by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<MetricFeedback> getMetricFeedbackAsync(UUID feedbackId, Context context) {
        return getMetricFeedbackWithResponseAsync(feedbackId, context)
                .flatMap(
                        (Response<MetricFeedback> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get a metric feedback by its id.
     *
     * @param feedbackId The feedbackId parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a metric feedback by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public MetricFeedback getMetricFeedback(UUID feedbackId) {
        return getMetricFeedbackAsync(feedbackId).block();
    }

    /**
     * Get a metric feedback by its id.
     *
     * @param feedbackId The feedbackId parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a metric feedback by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public MetricFeedback getMetricFeedback(UUID feedbackId, Context context) {
        return getMetricFeedbackAsync(feedbackId, context).block();
    }

    /**
     * List feedback on the given metric.
     *
     * @param body metric feedback filter.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricFeedback>> listMetricFeedbacksSinglePageAsync(
            MetricFeedbackFilter body, Integer skip, Integer top) {
        return FluxUtil.withContext(
                        context -> service.listMetricFeedbacks(this.getEndpoint(), skip, top, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List feedback on the given metric.
     *
     * @param body metric feedback filter.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricFeedback>> listMetricFeedbacksSinglePageAsync(
            MetricFeedbackFilter body, Integer skip, Integer top, Context context) {
        return service.listMetricFeedbacks(this.getEndpoint(), skip, top, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List feedback on the given metric.
     *
     * @param body metric feedback filter.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<MetricFeedback> listMetricFeedbacksAsync(MetricFeedbackFilter body, Integer skip, Integer top) {
        return new PagedFlux<>(
                () -> listMetricFeedbacksSinglePageAsync(body, skip, top),
                nextLink -> listMetricFeedbacksNextSinglePageAsync(nextLink, body));
    }

    /**
     * List feedback on the given metric.
     *
     * @param body metric feedback filter.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<MetricFeedback> listMetricFeedbacksAsync(
            MetricFeedbackFilter body, Integer skip, Integer top, Context context) {
        return new PagedFlux<>(
                () -> listMetricFeedbacksSinglePageAsync(body, skip, top, context),
                nextLink -> listMetricFeedbacksNextSinglePageAsync(nextLink, body));
    }

    /**
     * List feedback on the given metric.
     *
     * @param body metric feedback filter.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<MetricFeedback> listMetricFeedbacks(MetricFeedbackFilter body, Integer skip, Integer top) {
        return new PagedIterable<>(listMetricFeedbacksAsync(body, skip, top));
    }

    /**
     * List feedback on the given metric.
     *
     * @param body metric feedback filter.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<MetricFeedback> listMetricFeedbacks(
            MetricFeedbackFilter body, Integer skip, Integer top, Context context) {
        return new PagedIterable<>(listMetricFeedbacksAsync(body, skip, top, context));
    }

    /**
     * Create a new metric feedback.
     *
     * @param body metric feedback.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateMetricFeedbackResponse> createMetricFeedbackWithResponseAsync(MetricFeedback body) {
        return FluxUtil.withContext(context -> service.createMetricFeedback(this.getEndpoint(), body, context));
    }

    /**
     * Create a new metric feedback.
     *
     * @param body metric feedback.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateMetricFeedbackResponse> createMetricFeedbackWithResponseAsync(
            MetricFeedback body, Context context) {
        return service.createMetricFeedback(this.getEndpoint(), body, context);
    }

    /**
     * Create a new metric feedback.
     *
     * @param body metric feedback.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createMetricFeedbackAsync(MetricFeedback body) {
        return createMetricFeedbackWithResponseAsync(body).flatMap((CreateMetricFeedbackResponse res) -> Mono.empty());
    }

    /**
     * Create a new metric feedback.
     *
     * @param body metric feedback.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createMetricFeedbackAsync(MetricFeedback body, Context context) {
        return createMetricFeedbackWithResponseAsync(body, context)
                .flatMap((CreateMetricFeedbackResponse res) -> Mono.empty());
    }

    /**
     * Create a new metric feedback.
     *
     * @param body metric feedback.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createMetricFeedback(MetricFeedback body) {
        createMetricFeedbackAsync(body).block();
    }

    /**
     * Create a new metric feedback.
     *
     * @param body metric feedback.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createMetricFeedback(MetricFeedback body, Context context) {
        createMetricFeedbackAsync(body, context).block();
    }

    /**
     * List all hooks.
     *
     * @param hookName filter hook by its name.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<HookInfo>> listHooksSinglePageAsync(String hookName, Integer skip, Integer top) {
        return FluxUtil.withContext(context -> service.listHooks(this.getEndpoint(), hookName, skip, top, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List all hooks.
     *
     * @param hookName filter hook by its name.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<HookInfo>> listHooksSinglePageAsync(
            String hookName, Integer skip, Integer top, Context context) {
        return service.listHooks(this.getEndpoint(), hookName, skip, top, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List all hooks.
     *
     * @param hookName filter hook by its name.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<HookInfo> listHooksAsync(String hookName, Integer skip, Integer top) {
        return new PagedFlux<>(
                () -> listHooksSinglePageAsync(hookName, skip, top),
                nextLink -> listHooksNextSinglePageAsync(nextLink));
    }

    /**
     * List all hooks.
     *
     * @param hookName filter hook by its name.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<HookInfo> listHooksAsync(String hookName, Integer skip, Integer top, Context context) {
        return new PagedFlux<>(
                () -> listHooksSinglePageAsync(hookName, skip, top, context),
                nextLink -> listHooksNextSinglePageAsync(nextLink));
    }

    /**
     * List all hooks.
     *
     * @param hookName filter hook by its name.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<HookInfo> listHooks(String hookName, Integer skip, Integer top) {
        return new PagedIterable<>(listHooksAsync(hookName, skip, top));
    }

    /**
     * List all hooks.
     *
     * @param hookName filter hook by its name.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<HookInfo> listHooks(String hookName, Integer skip, Integer top, Context context) {
        return new PagedIterable<>(listHooksAsync(hookName, skip, top, context));
    }

    /**
     * Create a new hook.
     *
     * @param body Create hook request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateHookResponse> createHookWithResponseAsync(HookInfo body) {
        return FluxUtil.withContext(context -> service.createHook(this.getEndpoint(), body, context));
    }

    /**
     * Create a new hook.
     *
     * @param body Create hook request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CreateHookResponse> createHookWithResponseAsync(HookInfo body, Context context) {
        return service.createHook(this.getEndpoint(), body, context);
    }

    /**
     * Create a new hook.
     *
     * @param body Create hook request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createHookAsync(HookInfo body) {
        return createHookWithResponseAsync(body).flatMap((CreateHookResponse res) -> Mono.empty());
    }

    /**
     * Create a new hook.
     *
     * @param body Create hook request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> createHookAsync(HookInfo body, Context context) {
        return createHookWithResponseAsync(body, context).flatMap((CreateHookResponse res) -> Mono.empty());
    }

    /**
     * Create a new hook.
     *
     * @param body Create hook request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createHook(HookInfo body) {
        createHookAsync(body).block();
    }

    /**
     * Create a new hook.
     *
     * @param body Create hook request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void createHook(HookInfo body, Context context) {
        createHookAsync(body, context).block();
    }

    /**
     * Get a hook by its id.
     *
     * @param hookId Hook unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a hook by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<HookInfo>> getHookWithResponseAsync(UUID hookId) {
        return FluxUtil.withContext(context -> service.getHook(this.getEndpoint(), hookId, context));
    }

    /**
     * Get a hook by its id.
     *
     * @param hookId Hook unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a hook by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<HookInfo>> getHookWithResponseAsync(UUID hookId, Context context) {
        return service.getHook(this.getEndpoint(), hookId, context);
    }

    /**
     * Get a hook by its id.
     *
     * @param hookId Hook unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a hook by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<HookInfo> getHookAsync(UUID hookId) {
        return getHookWithResponseAsync(hookId)
                .flatMap(
                        (Response<HookInfo> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get a hook by its id.
     *
     * @param hookId Hook unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a hook by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<HookInfo> getHookAsync(UUID hookId, Context context) {
        return getHookWithResponseAsync(hookId, context)
                .flatMap(
                        (Response<HookInfo> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get a hook by its id.
     *
     * @param hookId Hook unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a hook by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public HookInfo getHook(UUID hookId) {
        return getHookAsync(hookId).block();
    }

    /**
     * Get a hook by its id.
     *
     * @param hookId Hook unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a hook by its id.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public HookInfo getHook(UUID hookId, Context context) {
        return getHookAsync(hookId, context).block();
    }

    /**
     * Update a hook.
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateHookWithResponseAsync(UUID hookId, HookInfoPatch body) {
        return FluxUtil.withContext(context -> service.updateHook(this.getEndpoint(), hookId, body, context));
    }

    /**
     * Update a hook.
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateHookWithResponseAsync(UUID hookId, HookInfoPatch body, Context context) {
        return service.updateHook(this.getEndpoint(), hookId, body, context);
    }

    /**
     * Update a hook.
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateHookAsync(UUID hookId, HookInfoPatch body) {
        return updateHookWithResponseAsync(hookId, body).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Update a hook.
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateHookAsync(UUID hookId, HookInfoPatch body, Context context) {
        return updateHookWithResponseAsync(hookId, body, context).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Update a hook.
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updateHook(UUID hookId, HookInfoPatch body) {
        updateHookAsync(hookId, body).block();
    }

    /**
     * Update a hook.
     *
     * @param hookId Hook unique ID.
     * @param body Update hook request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updateHook(UUID hookId, HookInfoPatch body, Context context) {
        updateHookAsync(hookId, body, context).block();
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteHookWithResponseAsync(UUID hookId) {
        return FluxUtil.withContext(context -> service.deleteHook(this.getEndpoint(), hookId, context));
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteHookWithResponseAsync(UUID hookId, Context context) {
        return service.deleteHook(this.getEndpoint(), hookId, context);
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteHookAsync(UUID hookId) {
        return deleteHookWithResponseAsync(hookId).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteHookAsync(UUID hookId, Context context) {
        return deleteHookWithResponseAsync(hookId, context).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteHook(UUID hookId) {
        deleteHookAsync(hookId).block();
    }

    /**
     * Delete a hook.
     *
     * @param hookId Hook unique ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteHook(UUID hookId, Context context) {
        deleteHookAsync(hookId, context).block();
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedIngestionStatus>> getDataFeedIngestionStatusSinglePageAsync(
            UUID dataFeedId, IngestionStatusQueryOptions body, Integer skip, Integer top) {
        return FluxUtil.withContext(
                        context ->
                                service.getDataFeedIngestionStatus(
                                        this.getEndpoint(), dataFeedId, skip, top, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedIngestionStatus>> getDataFeedIngestionStatusSinglePageAsync(
            UUID dataFeedId, IngestionStatusQueryOptions body, Integer skip, Integer top, Context context) {
        return service.getDataFeedIngestionStatus(this.getEndpoint(), dataFeedId, skip, top, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DataFeedIngestionStatus> getDataFeedIngestionStatusAsync(
            UUID dataFeedId, IngestionStatusQueryOptions body, Integer skip, Integer top) {
        return new PagedFlux<>(
                () -> getDataFeedIngestionStatusSinglePageAsync(dataFeedId, body, skip, top),
                nextLink -> getDataFeedIngestionStatusNextSinglePageAsync(nextLink, body));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DataFeedIngestionStatus> getDataFeedIngestionStatusAsync(
            UUID dataFeedId, IngestionStatusQueryOptions body, Integer skip, Integer top, Context context) {
        return new PagedFlux<>(
                () -> getDataFeedIngestionStatusSinglePageAsync(dataFeedId, body, skip, top, context),
                nextLink -> getDataFeedIngestionStatusNextSinglePageAsync(nextLink, body));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DataFeedIngestionStatus> getDataFeedIngestionStatus(
            UUID dataFeedId, IngestionStatusQueryOptions body, Integer skip, Integer top) {
        return new PagedIterable<>(getDataFeedIngestionStatusAsync(dataFeedId, body, skip, top));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The query time range.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DataFeedIngestionStatus> getDataFeedIngestionStatus(
            UUID dataFeedId, IngestionStatusQueryOptions body, Integer skip, Integer top, Context context) {
        return new PagedIterable<>(getDataFeedIngestionStatusAsync(dataFeedId, body, skip, top, context));
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> resetDataFeedIngestionStatusWithResponseAsync(
            UUID dataFeedId, IngestionProgressResetOptions body) {
        return FluxUtil.withContext(
                context -> service.resetDataFeedIngestionStatus(this.getEndpoint(), dataFeedId, body, context));
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> resetDataFeedIngestionStatusWithResponseAsync(
            UUID dataFeedId, IngestionProgressResetOptions body, Context context) {
        return service.resetDataFeedIngestionStatus(this.getEndpoint(), dataFeedId, body, context);
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> resetDataFeedIngestionStatusAsync(UUID dataFeedId, IngestionProgressResetOptions body) {
        return resetDataFeedIngestionStatusWithResponseAsync(dataFeedId, body)
                .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> resetDataFeedIngestionStatusAsync(
            UUID dataFeedId, IngestionProgressResetOptions body, Context context) {
        return resetDataFeedIngestionStatusWithResponseAsync(dataFeedId, body, context)
                .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void resetDataFeedIngestionStatus(UUID dataFeedId, IngestionProgressResetOptions body) {
        resetDataFeedIngestionStatusAsync(dataFeedId, body).block();
    }

    /**
     * Reset data ingestion status by data feed to backfill data.
     *
     * @param dataFeedId The data feed unique id.
     * @param body The backfill time range.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void resetDataFeedIngestionStatus(UUID dataFeedId, IngestionProgressResetOptions body, Context context) {
        resetDataFeedIngestionStatusAsync(dataFeedId, body, context).block();
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data last success ingestion job timestamp by data feed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataFeedIngestionProgress>> getIngestionProgressWithResponseAsync(UUID dataFeedId) {
        return FluxUtil.withContext(context -> service.getIngestionProgress(this.getEndpoint(), dataFeedId, context));
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data last success ingestion job timestamp by data feed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DataFeedIngestionProgress>> getIngestionProgressWithResponseAsync(
            UUID dataFeedId, Context context) {
        return service.getIngestionProgress(this.getEndpoint(), dataFeedId, context);
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data last success ingestion job timestamp by data feed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataFeedIngestionProgress> getIngestionProgressAsync(UUID dataFeedId) {
        return getIngestionProgressWithResponseAsync(dataFeedId)
                .flatMap(
                        (Response<DataFeedIngestionProgress> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data last success ingestion job timestamp by data feed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DataFeedIngestionProgress> getIngestionProgressAsync(UUID dataFeedId, Context context) {
        return getIngestionProgressWithResponseAsync(dataFeedId, context)
                .flatMap(
                        (Response<DataFeedIngestionProgress> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data last success ingestion job timestamp by data feed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DataFeedIngestionProgress getIngestionProgress(UUID dataFeedId) {
        return getIngestionProgressAsync(dataFeedId).block();
    }

    /**
     * Get data last success ingestion job timestamp by data feed.
     *
     * @param dataFeedId The data feed unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data last success ingestion job timestamp by data feed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DataFeedIngestionProgress getIngestionProgress(UUID dataFeedId, Context context) {
        return getIngestionProgressAsync(dataFeedId, context).block();
    }

    /**
     * Get time series data from metric.
     *
     * @param metricId metric unique id.
     * @param body query time series data condition.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return time series data from metric.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<MetricDataList>> getMetricDataWithResponseAsync(UUID metricId, MetricDataQueryOptions body) {
        return FluxUtil.withContext(context -> service.getMetricData(this.getEndpoint(), metricId, body, context));
    }

    /**
     * Get time series data from metric.
     *
     * @param metricId metric unique id.
     * @param body query time series data condition.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return time series data from metric.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<MetricDataList>> getMetricDataWithResponseAsync(
            UUID metricId, MetricDataQueryOptions body, Context context) {
        return service.getMetricData(this.getEndpoint(), metricId, body, context);
    }

    /**
     * Get time series data from metric.
     *
     * @param metricId metric unique id.
     * @param body query time series data condition.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return time series data from metric.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<MetricDataList> getMetricDataAsync(UUID metricId, MetricDataQueryOptions body) {
        return getMetricDataWithResponseAsync(metricId, body)
                .flatMap(
                        (Response<MetricDataList> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get time series data from metric.
     *
     * @param metricId metric unique id.
     * @param body query time series data condition.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return time series data from metric.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<MetricDataList> getMetricDataAsync(UUID metricId, MetricDataQueryOptions body, Context context) {
        return getMetricDataWithResponseAsync(metricId, body, context)
                .flatMap(
                        (Response<MetricDataList> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Get time series data from metric.
     *
     * @param metricId metric unique id.
     * @param body query time series data condition.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return time series data from metric.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public MetricDataList getMetricData(UUID metricId, MetricDataQueryOptions body) {
        return getMetricDataAsync(metricId, body).block();
    }

    /**
     * Get time series data from metric.
     *
     * @param metricId metric unique id.
     * @param body query time series data condition.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return time series data from metric.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public MetricDataList getMetricData(UUID metricId, MetricDataQueryOptions body, Context context) {
        return getMetricDataAsync(metricId, body, context).block();
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricSeriesItem>> getMetricSeriesSinglePageAsync(
            UUID metricId, MetricSeriesQueryOptions body, Integer skip, Integer top) {
        return FluxUtil.withContext(
                        context -> service.getMetricSeries(this.getEndpoint(), metricId, skip, top, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricSeriesItem>> getMetricSeriesSinglePageAsync(
            UUID metricId, MetricSeriesQueryOptions body, Integer skip, Integer top, Context context) {
        return service.getMetricSeries(this.getEndpoint(), metricId, skip, top, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<MetricSeriesItem> getMetricSeriesAsync(
            UUID metricId, MetricSeriesQueryOptions body, Integer skip, Integer top) {
        return new PagedFlux<>(
                () -> getMetricSeriesSinglePageAsync(metricId, body, skip, top),
                nextLink -> getMetricSeriesNextSinglePageAsync(nextLink, body));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<MetricSeriesItem> getMetricSeriesAsync(
            UUID metricId, MetricSeriesQueryOptions body, Integer skip, Integer top, Context context) {
        return new PagedFlux<>(
                () -> getMetricSeriesSinglePageAsync(metricId, body, skip, top, context),
                nextLink -> getMetricSeriesNextSinglePageAsync(nextLink, body));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<MetricSeriesItem> getMetricSeries(
            UUID metricId, MetricSeriesQueryOptions body, Integer skip, Integer top) {
        return new PagedIterable<>(getMetricSeriesAsync(metricId, body, skip, top));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param metricId metric unique id.
     * @param body filter to query series.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<MetricSeriesItem> getMetricSeries(
            UUID metricId, MetricSeriesQueryOptions body, Integer skip, Integer top, Context context) {
        return new PagedIterable<>(getMetricSeriesAsync(metricId, body, skip, top, context));
    }

    /**
     * List dimension from certain metric.
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getMetricDimensionSinglePageAsync(
            UUID metricId, MetricDimensionQueryOptions body, Integer skip, Integer top) {
        return FluxUtil.withContext(
                        context -> service.getMetricDimension(this.getEndpoint(), metricId, skip, top, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List dimension from certain metric.
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getMetricDimensionSinglePageAsync(
            UUID metricId, MetricDimensionQueryOptions body, Integer skip, Integer top, Context context) {
        return service.getMetricDimension(this.getEndpoint(), metricId, skip, top, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List dimension from certain metric.
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<String> getMetricDimensionAsync(
            UUID metricId, MetricDimensionQueryOptions body, Integer skip, Integer top) {
        return new PagedFlux<>(
                () -> getMetricDimensionSinglePageAsync(metricId, body, skip, top),
                nextLink -> getMetricDimensionNextSinglePageAsync(nextLink, body));
    }

    /**
     * List dimension from certain metric.
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<String> getMetricDimensionAsync(
            UUID metricId, MetricDimensionQueryOptions body, Integer skip, Integer top, Context context) {
        return new PagedFlux<>(
                () -> getMetricDimensionSinglePageAsync(metricId, body, skip, top, context),
                nextLink -> getMetricDimensionNextSinglePageAsync(nextLink, body));
    }

    /**
     * List dimension from certain metric.
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<String> getMetricDimension(
            UUID metricId, MetricDimensionQueryOptions body, Integer skip, Integer top) {
        return new PagedIterable<>(getMetricDimensionAsync(metricId, body, skip, top));
    }

    /**
     * List dimension from certain metric.
     *
     * @param metricId metric unique id.
     * @param body query dimension option.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<String> getMetricDimension(
            UUID metricId, MetricDimensionQueryOptions body, Integer skip, Integer top, Context context) {
        return new PagedIterable<>(getMetricDimensionAsync(metricId, body, skip, top, context));
    }

    /**
     * Query all anomaly detection configurations for specific metric.
     *
     * @param metricId metric unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyDetectionConfigurationList>> getAnomalyDetectionConfigurationsByMetricWithResponseAsync(
            UUID metricId) {
        return FluxUtil.withContext(
                context -> service.getAnomalyDetectionConfigurationsByMetric(this.getEndpoint(), metricId, context));
    }

    /**
     * Query all anomaly detection configurations for specific metric.
     *
     * @param metricId metric unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnomalyDetectionConfigurationList>> getAnomalyDetectionConfigurationsByMetricWithResponseAsync(
            UUID metricId, Context context) {
        return service.getAnomalyDetectionConfigurationsByMetric(this.getEndpoint(), metricId, context);
    }

    /**
     * Query all anomaly detection configurations for specific metric.
     *
     * @param metricId metric unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyDetectionConfigurationList> getAnomalyDetectionConfigurationsByMetricAsync(UUID metricId) {
        return getAnomalyDetectionConfigurationsByMetricWithResponseAsync(metricId)
                .flatMap(
                        (Response<AnomalyDetectionConfigurationList> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Query all anomaly detection configurations for specific metric.
     *
     * @param metricId metric unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnomalyDetectionConfigurationList> getAnomalyDetectionConfigurationsByMetricAsync(
            UUID metricId, Context context) {
        return getAnomalyDetectionConfigurationsByMetricWithResponseAsync(metricId, context)
                .flatMap(
                        (Response<AnomalyDetectionConfigurationList> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Query all anomaly detection configurations for specific metric.
     *
     * @param metricId metric unique id.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnomalyDetectionConfigurationList getAnomalyDetectionConfigurationsByMetric(UUID metricId) {
        return getAnomalyDetectionConfigurationsByMetricAsync(metricId).block();
    }

    /**
     * Query all anomaly detection configurations for specific metric.
     *
     * @param metricId metric unique id.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnomalyDetectionConfigurationList getAnomalyDetectionConfigurationsByMetric(UUID metricId, Context context) {
        return getAnomalyDetectionConfigurationsByMetricAsync(metricId, context).block();
    }

    /**
     * Query anomaly detection status.
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<EnrichmentStatus>> getEnrichmentStatusByMetricSinglePageAsync(
            UUID metricId, EnrichmentStatusQueryOption body, Integer skip, Integer top) {
        return FluxUtil.withContext(
                        context ->
                                service.getEnrichmentStatusByMetric(
                                        this.getEndpoint(), metricId, skip, top, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query anomaly detection status.
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<EnrichmentStatus>> getEnrichmentStatusByMetricSinglePageAsync(
            UUID metricId, EnrichmentStatusQueryOption body, Integer skip, Integer top, Context context) {
        return service.getEnrichmentStatusByMetric(this.getEndpoint(), metricId, skip, top, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query anomaly detection status.
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<EnrichmentStatus> getEnrichmentStatusByMetricAsync(
            UUID metricId, EnrichmentStatusQueryOption body, Integer skip, Integer top) {
        return new PagedFlux<>(
                () -> getEnrichmentStatusByMetricSinglePageAsync(metricId, body, skip, top),
                nextLink -> getEnrichmentStatusByMetricNextSinglePageAsync(nextLink, body));
    }

    /**
     * Query anomaly detection status.
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<EnrichmentStatus> getEnrichmentStatusByMetricAsync(
            UUID metricId, EnrichmentStatusQueryOption body, Integer skip, Integer top, Context context) {
        return new PagedFlux<>(
                () -> getEnrichmentStatusByMetricSinglePageAsync(metricId, body, skip, top, context),
                nextLink -> getEnrichmentStatusByMetricNextSinglePageAsync(nextLink, body));
    }

    /**
     * Query anomaly detection status.
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<EnrichmentStatus> getEnrichmentStatusByMetric(
            UUID metricId, EnrichmentStatusQueryOption body, Integer skip, Integer top) {
        return new PagedIterable<>(getEnrichmentStatusByMetricAsync(metricId, body, skip, top));
    }

    /**
     * Query anomaly detection status.
     *
     * @param metricId metric unique id.
     * @param body query options.
     * @param skip The skip parameter.
     * @param top The top parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<EnrichmentStatus> getEnrichmentStatusByMetric(
            UUID metricId, EnrichmentStatusQueryOption body, Integer skip, Integer top, Context context) {
        return new PagedIterable<>(getEnrichmentStatusByMetricAsync(metricId, body, skip, top, context));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param nextLink the next link.
     * @param body query alerting result request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<Alert>> getAlertsByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink, AlertingResultQuery body) {
        return FluxUtil.withContext(
                        context ->
                                service.getAlertsByAnomalyAlertingConfigurationNext(
                                        this.getEndpoint(), nextLink, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query alerts under anomaly alerting configuration.
     *
     * @param nextLink the next link.
     * @param body query alerting result request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<Alert>> getAlertsByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink, AlertingResultQuery body, Context context) {
        return service.getAlertsByAnomalyAlertingConfigurationNext(this.getEndpoint(), nextLink, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param nextLink the next link.
     * @param body query detection anomaly result request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, DetectionAnomalyResultQuery body) {
        return FluxUtil.withContext(
                        context ->
                                service.getAnomaliesByAnomalyDetectionConfigurationNext(
                                        this.getEndpoint(), nextLink, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Query anomalies under anomaly detection configuration.
     *
     * @param nextLink the next link.
     * @param body query detection anomaly result request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, DetectionAnomalyResultQuery body, Context context) {
        return service.getAnomaliesByAnomalyDetectionConfigurationNext(this.getEndpoint(), nextLink, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param nextLink the next link.
     * @param body query dimension values request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, AnomalyDimensionQuery body) {
        return FluxUtil.withContext(
                        context ->
                                service.getDimensionOfAnomaliesByAnomalyDetectionConfigurationNext(
                                        this.getEndpoint(), nextLink, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Query dimension values of anomalies.
     *
     * @param nextLink the next link.
     * @param body query dimension values request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getDimensionOfAnomaliesByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, AnomalyDimensionQuery body, Context context) {
        return service.getDimensionOfAnomaliesByAnomalyDetectionConfigurationNext(
                        this.getEndpoint(), nextLink, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List feedback on the given metric.
     *
     * @param nextLink the next link.
     * @param body metric feedback filter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricFeedback>> listMetricFeedbacksNextSinglePageAsync(
            String nextLink, MetricFeedbackFilter body) {
        return FluxUtil.withContext(
                        context -> service.listMetricFeedbacksNext(this.getEndpoint(), nextLink, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * List feedback on the given metric.
     *
     * @param nextLink the next link.
     * @param body metric feedback filter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricFeedback>> listMetricFeedbacksNextSinglePageAsync(
            String nextLink, MetricFeedbackFilter body, Context context) {
        return service.listMetricFeedbacksNext(this.getEndpoint(), nextLink, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param nextLink the next link.
     * @param body The query time range.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedIngestionStatus>> getDataFeedIngestionStatusNextSinglePageAsync(
            String nextLink, IngestionStatusQueryOptions body) {
        return FluxUtil.withContext(
                        context -> service.getDataFeedIngestionStatusNext(this.getEndpoint(), nextLink, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Get data ingestion status by data feed.
     *
     * @param nextLink the next link.
     * @param body The query time range.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return data ingestion status by data feed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedIngestionStatus>> getDataFeedIngestionStatusNextSinglePageAsync(
            String nextLink, IngestionStatusQueryOptions body, Context context) {
        return service.getDataFeedIngestionStatusNext(this.getEndpoint(), nextLink, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param nextLink the next link.
     * @param body filter to query series.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricSeriesItem>> getMetricSeriesNextSinglePageAsync(
            String nextLink, MetricSeriesQueryOptions body) {
        return FluxUtil.withContext(context -> service.getMetricSeriesNext(this.getEndpoint(), nextLink, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * List series (dimension combinations) from metric.
     *
     * @param nextLink the next link.
     * @param body filter to query series.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<MetricSeriesItem>> getMetricSeriesNextSinglePageAsync(
            String nextLink, MetricSeriesQueryOptions body, Context context) {
        return service.getMetricSeriesNext(this.getEndpoint(), nextLink, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * List dimension from certain metric.
     *
     * @param nextLink the next link.
     * @param body query dimension option.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getMetricDimensionNextSinglePageAsync(
            String nextLink, MetricDimensionQueryOptions body) {
        return FluxUtil.withContext(
                        context -> service.getMetricDimensionNext(this.getEndpoint(), nextLink, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * List dimension from certain metric.
     *
     * @param nextLink the next link.
     * @param body query dimension option.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<String>> getMetricDimensionNextSinglePageAsync(
            String nextLink, MetricDimensionQueryOptions body, Context context) {
        return service.getMetricDimensionNext(this.getEndpoint(), nextLink, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Query anomaly detection status.
     *
     * @param nextLink the next link.
     * @param body query options.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<EnrichmentStatus>> getEnrichmentStatusByMetricNextSinglePageAsync(
            String nextLink, EnrichmentStatusQueryOption body) {
        return FluxUtil.withContext(
                        context -> service.getEnrichmentStatusByMetricNext(this.getEndpoint(), nextLink, body, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Query anomaly detection status.
     *
     * @param nextLink the next link.
     * @param body query options.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<EnrichmentStatus>> getEnrichmentStatusByMetricNextSinglePageAsync(
            String nextLink, EnrichmentStatusQueryOption body, Context context) {
        return service.getEnrichmentStatusByMetricNext(this.getEndpoint(), nextLink, body, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        null,
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink) {
        return FluxUtil.withContext(
                        context -> service.getAnomaliesFromAlertByAnomalyAlertingConfigurationNext(nextLink, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<AnomalyResult>> getAnomaliesFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink, Context context) {
        return service.getAnomaliesFromAlertByAnomalyAlertingConfigurationNext(nextLink, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink) {
        return FluxUtil.withContext(
                        context -> service.getIncidentsFromAlertByAnomalyAlertingConfigurationNext(nextLink, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsFromAlertByAnomalyAlertingConfigurationNextSinglePageAsync(
            String nextLink, Context context) {
        return service.getIncidentsFromAlertByAnomalyAlertingConfigurationNext(nextLink, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink) {
        return FluxUtil.withContext(
                        context -> service.getIncidentsByAnomalyDetectionConfigurationNext(nextLink, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<IncidentResult>> getIncidentsByAnomalyDetectionConfigurationNextSinglePageAsync(
            String nextLink, Context context) {
        return service.getIncidentsByAnomalyDetectionConfigurationNext(nextLink, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedDetail>> listDataFeedsNextSinglePageAsync(String nextLink) {
        return FluxUtil.withContext(context -> service.listDataFeedsNext(nextLink, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DataFeedDetail>> listDataFeedsNextSinglePageAsync(String nextLink, Context context) {
        return service.listDataFeedsNext(nextLink, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<HookInfo>> listHooksNextSinglePageAsync(String nextLink) {
        return FluxUtil.withContext(context -> service.listHooksNext(nextLink, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorCodeException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<HookInfo>> listHooksNextSinglePageAsync(String nextLink, Context context) {
        return service.listHooksNext(nextLink, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }
}
