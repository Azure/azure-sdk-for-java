// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.communication.jobrouter;

import com.azure.communication.jobrouter.implementation.JobRouterAdministrationClientImpl;
import com.azure.communication.jobrouter.implementation.JsonMergePatchHelper;
import com.azure.communication.jobrouter.models.ClassificationPolicy;
import com.azure.communication.jobrouter.models.DistributionPolicy;
import com.azure.communication.jobrouter.models.ExceptionPolicy;
import com.azure.communication.jobrouter.models.RouterQueue;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpHeaderName;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.BinaryData;
import com.azure.core.util.DateTimeRfc1123;
import com.azure.core.util.FluxUtil;
import java.time.OffsetDateTime;
import java.util.stream.Collectors;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import com.azure.communication.jobrouter.implementation.converters.OptionBagAdapters;
import com.azure.communication.jobrouter.models.CreateClassificationPolicyOptions;
import com.azure.communication.jobrouter.models.CreateDistributionPolicyOptions;
import com.azure.communication.jobrouter.models.CreateExceptionPolicyOptions;
import com.azure.communication.jobrouter.models.CreateQueueOptions;

/**
 * Initializes a new instance of the asynchronous JobRouterAdministrationClient type.
 */
@ServiceClient(builder = JobRouterAdministrationClientBuilder.class, isAsync = true)
public final class JobRouterAdministrationAsyncClient {

    @Generated
    private final JobRouterAdministrationClientImpl serviceClient;

    /**
     * Initializes an instance of JobRouterAdministrationAsyncClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    JobRouterAdministrationAsyncClient(JobRouterAdministrationClientImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Creates or updates a distribution policy.
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>The request should only proceed if an entity matches this
     * string.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>The request should only proceed if the
     * entity was not modified after this time.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         kind: String(bestWorker/longestIdle/roundRobin) (Required)
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         kind: String(bestWorker/longestIdle/roundRobin) (Required)
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param distributionPolicyId Id of a distribution policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return policy governing how jobs are distributed to workers along with {@link Response} on successful completion
     * of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<Response<BinaryData>> upsertDistributionPolicyWithResponse(String distributionPolicyId, BinaryData resource,
        RequestOptions requestOptions) {
        return this.serviceClient.upsertDistributionPolicyWithResponseAsync(distributionPolicyId, resource,
            requestOptions);
    }

    /**
     * Updates a distribution policy.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     distributionPolicyId: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     distributionPolicyId: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param distributionPolicyId The unique identifier of the policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return policy governing how jobs are distributed to workers along with {@link Response} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> updateDistributionPolicyWithResponse(String distributionPolicyId,
        BinaryData resource, RequestOptions requestOptions) {
        return this.serviceClient.upsertDistributionPolicyWithResponseAsync(distributionPolicyId, resource,
            requestOptions);
    }

    /**
     * Updates a distribution policy.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     distributionPolicyId: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     distributionPolicyId: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param distributionPolicyId The unique identifier of the policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return policy governing how jobs are distributed to workers on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> updateDistributionPolicy(String distributionPolicyId, BinaryData resource,
        RequestOptions requestOptions) {
        return this.serviceClient
            .upsertDistributionPolicyWithResponseAsync(distributionPolicyId, resource, requestOptions)
            .map(policy -> policy.getValue());
    }

    /**
     * Updates a distribution policy.
     *
     * @param distributionPolicyId The unique identifier of the policy.
     * @param distributionPolicy The distribution policy to update.
     * @return policy governing how jobs are distributed to workers on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DistributionPolicy> updateDistributionPolicy(String distributionPolicyId,
        DistributionPolicy distributionPolicy) {
        return this
            .updateDistributionPolicyWithResponse(distributionPolicyId, BinaryData.fromObject(distributionPolicy), null)
            .map(response -> response.getValue().toObject(DistributionPolicy.class));
    }

    /**
     * Creates a distribution policy.
     *
     * @param createDistributionPolicyOptions Container for inputs to create a distribution policy.
     * @return response The response instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DistributionPolicy>>
        createDistributionPolicyWithResponse(CreateDistributionPolicyOptions createDistributionPolicyOptions) {
        RequestOptions requestOptions = new RequestOptions();
        DistributionPolicy distributionPolicy = OptionBagAdapters.toDistributionPolicy(createDistributionPolicyOptions);
        return upsertDistributionPolicyWithResponse(createDistributionPolicyOptions.getDistributionPolicyId(),
            BinaryData.fromObject(distributionPolicy), requestOptions)
            .map(response -> new SimpleResponse<>(response.getRequest(), response.getStatusCode(),
                response.getHeaders(), response.getValue().toObject(DistributionPolicy.class)));
    }

    /**
     * Creates a distribution policy.
     *
     * @param createDistributionPolicyOptions Container for inputs to create a distribution policy.
     * @return response The response instance.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DistributionPolicy>
        createDistributionPolicy(CreateDistributionPolicyOptions createDistributionPolicyOptions) {
        return createDistributionPolicyWithResponse(createDistributionPolicyOptions)
            .map(response -> response.getValue());
    }

    /**
     * Retrieves an existing distribution policy by Id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         kind: String(bestWorker/longestIdle/roundRobin) (Required)
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param distributionPolicyId Id of a distribution policy.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return policy governing how jobs are distributed to workers along with {@link Response} on successful completion
     * of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getDistributionPolicyWithResponse(String distributionPolicyId,
        RequestOptions requestOptions) {
        return this.serviceClient.getDistributionPolicyWithResponseAsync(distributionPolicyId, requestOptions);
    }

    /**
     * Retrieves existing distribution policies.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of objects to return per page.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         kind: String(bestWorker/longestIdle/roundRobin) (Required)
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DistributionPolicy items as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listDistributionPolicies(RequestOptions requestOptions) {
        return this.serviceClient.listDistributionPoliciesAsync(requestOptions);
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param distributionPolicyId Id of a distribution policy.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteDistributionPolicyWithResponse(String distributionPolicyId,
        RequestOptions requestOptions) {
        return this.serviceClient.deleteDistributionPolicyWithResponseAsync(distributionPolicyId, requestOptions);
    }

    /**
     * Creates or updates a classification policy.
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>The request should only proceed if an entity matches this
     * string.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>The request should only proceed if the
     * entity was not modified after this time.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectorAttachments (Optional): [
     *          (Optional){
     *             kind: String(conditional/passThrough/ruleEngine/static/weightedAllocation) (Required)
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *         kind: String(directMap/expression/function/static/webhook) (Required)
     *     }
     *     workerSelectorAttachments (Optional): [
     *          (Optional){
     *             kind: String(conditional/passThrough/ruleEngine/static/weightedAllocation) (Required)
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectorAttachments (Optional): [
     *          (Optional){
     *             kind: String(conditional/passThrough/ruleEngine/static/weightedAllocation) (Required)
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *         kind: String(directMap/expression/function/static/webhook) (Required)
     *     }
     *     workerSelectorAttachments (Optional): [
     *          (Optional){
     *             kind: String(conditional/passThrough/ruleEngine/static/weightedAllocation) (Required)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param classificationPolicyId Id of a classification policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a container for the rules that govern how jobs are classified along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<Response<BinaryData>> upsertClassificationPolicyWithResponse(String classificationPolicyId,
        BinaryData resource, RequestOptions requestOptions) {
        return this.serviceClient.upsertClassificationPolicyWithResponseAsync(classificationPolicyId, resource,
            requestOptions);
    }

    /**
     * Updates a classification policy.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     classificationPolicyId: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *     }
     *     workerSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     classificationPolicyId: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *     }
     *     workerSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param classificationPolicyId Unique identifier of this policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a container for the rules that govern how jobs are classified along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> updateClassificationPolicyWithResponse(String classificationPolicyId,
        BinaryData resource, RequestOptions requestOptions) {
        return this.serviceClient.upsertClassificationPolicyWithResponseAsync(classificationPolicyId, resource,
            requestOptions);
    }

    /**
     * Updates a classification policy.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     classificationPolicyId: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *     }
     *     workerSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     classificationPolicyId: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *     }
     *     workerSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param classificationPolicyId Unique identifier of this policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a container for the rules that govern how jobs are classified on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> updateClassificationPolicy(String classificationPolicyId, BinaryData resource,
        RequestOptions requestOptions) {
        return this.serviceClient
            .upsertClassificationPolicyWithResponseAsync(classificationPolicyId, resource, requestOptions)
            .map(policy -> policy.getValue());
    }

    /**
     * Updates a classification policy.
     *
     * @param classificationPolicyId Unique identifier of this policy.
     * @param classificationPolicy The classification policy to update.
     * @return the updated classification policy.
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ClassificationPolicy> updateClassificationPolicy(String classificationPolicyId,
        ClassificationPolicy classificationPolicy) {
        return this
            .updateClassificationPolicyWithResponse(classificationPolicyId, BinaryData.fromObject(classificationPolicy),
                null)
            .map(response -> response.getValue().toObject(ClassificationPolicy.class));
    }

    /**
     * Creates a classification policy.
     *
     * @param createClassificationPolicyOptions Container for inputs to create a classification policy.
     * @return response The response instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ClassificationPolicy>>
        createClassificationPolicyWithResponse(CreateClassificationPolicyOptions createClassificationPolicyOptions) {
        RequestOptions requestOptions = new RequestOptions();
        ClassificationPolicy classificationPolicy
            = OptionBagAdapters.toClassificationPolicy(createClassificationPolicyOptions);
        return upsertClassificationPolicyWithResponse(createClassificationPolicyOptions.getClassificationPolicyId(),
            BinaryData.fromObject(classificationPolicy), requestOptions)
            .map(response -> new SimpleResponse<>(response.getRequest(), response.getStatusCode(),
                response.getHeaders(), response.getValue().toObject(ClassificationPolicy.class)));
    }

    /**
     * Convenience method to create a classification policy.
     *
     * @param createClassificationPolicyOptions Container for inputs to create a classification policy.
     * @return a container for the rules that govern how jobs are classified.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ClassificationPolicy>
        createClassificationPolicy(CreateClassificationPolicyOptions createClassificationPolicyOptions) {
        return createClassificationPolicyWithResponse(createClassificationPolicyOptions)
            .map(response -> response.getValue());
    }

    /**
     * Retrieves an existing classification policy by Id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectorAttachments (Optional): [
     *          (Optional){
     *             kind: String(conditional/passThrough/ruleEngine/static/weightedAllocation) (Required)
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *         kind: String(directMap/expression/function/static/webhook) (Required)
     *     }
     *     workerSelectorAttachments (Optional): [
     *          (Optional){
     *             kind: String(conditional/passThrough/ruleEngine/static/weightedAllocation) (Required)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param classificationPolicyId Id of a classification policy.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a container for the rules that govern how jobs are classified along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getClassificationPolicyWithResponse(String classificationPolicyId,
        RequestOptions requestOptions) {
        return this.serviceClient.getClassificationPolicyWithResponseAsync(classificationPolicyId, requestOptions);
    }

    /**
     * Retrieves existing classification policies.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of objects to return per page.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectorAttachments (Optional): [
     *          (Optional){
     *             kind: String(conditional/passThrough/ruleEngine/static/weightedAllocation) (Required)
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *         kind: String(directMap/expression/function/static/webhook) (Required)
     *     }
     *     workerSelectorAttachments (Optional): [
     *          (Optional){
     *             kind: String(conditional/passThrough/ruleEngine/static/weightedAllocation) (Required)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of ClassificationPolicy items as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listClassificationPolicies(RequestOptions requestOptions) {
        return this.serviceClient.listClassificationPoliciesAsync(requestOptions);
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param classificationPolicyId Id of a classification policy.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteClassificationPolicyWithResponse(String classificationPolicyId,
        RequestOptions requestOptions) {
        return this.serviceClient.deleteClassificationPolicyWithResponseAsync(classificationPolicyId, requestOptions);
    }

    /**
     * Creates or updates a exception policy.
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>The request should only proceed if an entity matches this
     * string.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>The request should only proceed if the
     * entity was not modified after this time.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): [
     *          (Optional){
     *             id: String (Optional, Required on create)
     *             trigger (Optional, Required on create): {
     *                 kind: String(queueLength/waitTime) (Required)
     *             }
     *             actions (Optional, Required on create): [
     *                  (Optional, Required on create){
     *                     kind: String(cancel/manualReclassify/reclassify) (Required)
     *                     id: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): [
     *          (Optional){
     *             id: String (Optional, Required on create)
     *             trigger (Optional, Required on create): {
     *                 kind: String(queueLength/waitTime) (Required)
     *             }
     *             actions (Optional, Required on create): [
     *                  (Optional, Required on create){
     *                     kind: String(cancel/manualReclassify/reclassify) (Required)
     *                     id: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param exceptionPolicyId Id of an exception policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response} on
     * successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<Response<BinaryData>> upsertExceptionPolicyWithResponse(String exceptionPolicyId, BinaryData resource,
        RequestOptions requestOptions) {
        return this.serviceClient.upsertExceptionPolicyWithResponseAsync(exceptionPolicyId, resource, requestOptions);
    }

    /**
     * Updates a exception policy.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     exceptionPolicyId: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): {
     *         String (Optional): {
     *             trigger (Required): {
     *             }
     *             actions (Required): {
     *                 String (Required): {
     *                 }
     *             }
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     exceptionPolicyId: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): {
     *         String (Optional): {
     *             trigger (Required): {
     *             }
     *             actions (Required): {
     *                 String (Required): {
     *                 }
     *             }
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param exceptionPolicyId The Id of the exception policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response} on
     * successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> updateExceptionPolicyWithResponse(String exceptionPolicyId, BinaryData resource,
        RequestOptions requestOptions) {
        return this.serviceClient.upsertExceptionPolicyWithResponseAsync(exceptionPolicyId, resource, requestOptions);
    }

    /**
     * Updates a exception policy.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     exceptionPolicyId: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): {
     *         String (Optional): {
     *             trigger (Required): {
     *             }
     *             actions (Required): {
     *                 String (Required): {
     *                 }
     *             }
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     exceptionPolicyId: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): {
     *         String (Optional): {
     *             trigger (Required): {
     *             }
     *             actions (Required): {
     *                 String (Required): {
     *                 }
     *             }
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param exceptionPolicyId The Id of the exception policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a policy that defines actions to execute when exception are triggered on
     * successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> updateExceptionPolicy(String exceptionPolicyId, BinaryData resource,
        RequestOptions requestOptions) {
        return this.serviceClient.upsertExceptionPolicyWithResponseAsync(exceptionPolicyId, resource, requestOptions)
            .map(policy -> policy.getValue());
    }

    /**
     * Updates a exception policy.
     *
     * @param exceptionPolicyId The Id of the exception policy.
     * @param exceptionPolicy The exception policy to update.
     * @return a policy that defines actions to execute when exception are triggered on
     * successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ExceptionPolicy> updateExceptionPolicy(String exceptionPolicyId, ExceptionPolicy exceptionPolicy) {
        return this.updateExceptionPolicyWithResponse(exceptionPolicyId, BinaryData.fromObject(exceptionPolicy), null)
            .map(response -> response.getValue().toObject(ExceptionPolicy.class));
    }

    /**
     * Creates an exception policy.
     *
     * @param createExceptionPolicyOptions Create options for Exception Policy.
     * @return response The response instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ExceptionPolicy>>
        createExceptionPolicyWithResponse(CreateExceptionPolicyOptions createExceptionPolicyOptions) {
        RequestOptions requestOptions = new RequestOptions();
        ExceptionPolicy exceptionPolicy = OptionBagAdapters.toExceptionPolicy(createExceptionPolicyOptions);
        return upsertExceptionPolicyWithResponse(createExceptionPolicyOptions.getExceptionPolicyId(),
            BinaryData.fromObject(exceptionPolicy), requestOptions)
            .map(response -> new SimpleResponse<>(response.getRequest(), response.getStatusCode(),
                response.getHeaders(), response.getValue().toObject(ExceptionPolicy.class)));
    }

    /**
     * Creates an exception policy.
     *
     * @param createExceptionPolicyOptions Create options for Exception Policy.
     * @return response The response instance.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ExceptionPolicy> createExceptionPolicy(CreateExceptionPolicyOptions createExceptionPolicyOptions) {
        return createExceptionPolicyWithResponse(createExceptionPolicyOptions).map(response -> response.getValue());
    }

    /**
     * Retrieves an existing exception policy by Id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): [
     *          (Optional){
     *             id: String (Optional, Required on create)
     *             trigger (Optional, Required on create): {
     *                 kind: String(queueLength/waitTime) (Required)
     *             }
     *             actions (Optional, Required on create): [
     *                  (Optional, Required on create){
     *                     kind: String(cancel/manualReclassify/reclassify) (Required)
     *                     id: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param exceptionPolicyId Id of an exception policy.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response} on
     * successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getExceptionPolicyWithResponse(String exceptionPolicyId,
        RequestOptions requestOptions) {
        return this.serviceClient.getExceptionPolicyWithResponseAsync(exceptionPolicyId, requestOptions);
    }

    /**
     * Retrieves existing exception policies.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>maxpagesize</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Number of objects to return per page.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     *
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): [
     *          (Optional){
     *             id: String (Required)
     *             trigger (Required): {
     *             }
     *             actions (Required): [
     *                  (Required){
     *                     id: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of ExceptionPolicy items as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listExceptionPolicies(RequestOptions requestOptions) {
        return this.serviceClient.listExceptionPoliciesAsync(requestOptions);
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param exceptionPolicyId Id of an exception policy.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteExceptionPolicyWithResponse(String exceptionPolicyId,
        RequestOptions requestOptions) {
        return this.serviceClient.deleteExceptionPolicyWithResponseAsync(exceptionPolicyId, requestOptions);
    }

    /**
     * Creates or updates a queue.
     * <p><strong>Header Parameters</strong></p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>If-Match</td><td>String</td><td>No</td><td>The request should only proceed if an entity matches this
     * string.</td></tr>
     * <tr><td>If-Unmodified-Since</td><td>OffsetDateTime</td><td>No</td><td>The request should only proceed if the
     * entity was not modified after this time.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Required)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Required)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     *
     * @param queueId Id of a queue.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a queue that can contain jobs to be routed along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<Response<BinaryData>> upsertQueueWithResponse(String queueId, BinaryData resource,
        RequestOptions requestOptions) {
        return this.serviceClient.upsertQueueWithResponseAsync(queueId, resource, requestOptions);
    }

    /**
     * Updates a queue.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     queueId: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Optional)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     queueId: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Optional)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     *
     * @param queueId The Id of this queue.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a queue that can contain jobs to be routed along with {@link Response} on successful completion of {@link
     * Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> updateQueueWithResponse(String queueId, BinaryData resource,
        RequestOptions requestOptions) {
        return this.serviceClient.upsertQueueWithResponseAsync(queueId, resource, requestOptions);
    }

    /**
     * Updates a queue.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     queueId: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Optional)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     queueId: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Optional)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     *
     * @param queueId The Id of this queue.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a queue that can contain jobs to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BinaryData> updateQueue(String queueId, BinaryData resource, RequestOptions requestOptions) {
        return this.serviceClient.upsertQueueWithResponseAsync(queueId, resource, requestOptions)
            .map(queue -> queue.getValue());
    }

    /**
     * Updates a queue.
     *
     * @param queueId The Id of this queue.
     * @param queue The queue to update.
     * @return The updated queue.
     * Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterQueue> updateQueue(String queueId, RouterQueue queue) {
        return this.upsertQueueWithResponse(queueId, BinaryData.fromObject(queue), null)
            .map(response -> response.getValue().toObject(RouterQueue.class));
    }

    /**
     * Create a queue.
     *
     * @param createQueueOptions Container for inputs to create a queue.
     * @return response The response instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterQueue>> createQueueWithResponse(CreateQueueOptions createQueueOptions) {
        RequestOptions requestOptions = new RequestOptions();
        RouterQueue queue = OptionBagAdapters.toRouterQueue(createQueueOptions);
        return upsertQueueWithResponse(createQueueOptions.getQueueId(), BinaryData.fromObject(queue), requestOptions)
            .map(response -> new SimpleResponse<RouterQueue>(response.getRequest(), response.getStatusCode(),
                response.getHeaders(), response.getValue().toObject(RouterQueue.class)));
    }

    /**
     * Create a queue.
     *
     * @param createQueueOptions Container for inputs to create a queue.
     * @return response The response instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterQueue> createQueue(CreateQueueOptions createQueueOptions) {
        RequestOptions requestOptions = new RequestOptions();
        RouterQueue queue = OptionBagAdapters.toRouterQueue(createQueueOptions);
        return upsertQueueWithResponse(createQueueOptions.getQueueId(), BinaryData.fromObject(queue), requestOptions)
            .map(response -> response.getValue().toObject(RouterQueue.class));
    }

    /**
     * Retrieves an existing queue by Id.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Required)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     *
     * @param queueId Id of a queue.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a queue that can contain jobs to be routed along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getQueueWithResponse(String queueId, RequestOptions requestOptions) {
        return this.serviceClient.getQueueWithResponseAsync(queueId, requestOptions);
    }

    /**
     * Retrieves existing queues.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>Number of objects to return per page.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Required)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of RouterQueue items as paginated response with {@link PagedFlux}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listQueues(RequestOptions requestOptions) {
        return this.serviceClient.listQueuesAsync(requestOptions);
    }

    /**
     * Deletes a queue by Id.
     *
     * @param queueId Id of a queue.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteQueueWithResponse(String queueId, RequestOptions requestOptions) {
        return this.serviceClient.deleteQueueWithResponseAsync(queueId, requestOptions);
    }

    /**
     * Retrieves an existing distribution policy by Id.
     *
     * @param distributionPolicyId The unique identifier of the policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DistributionPolicy> getDistributionPolicy(String distributionPolicyId) {
        // Generated convenience method for getDistributionPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDistributionPolicyWithResponse(distributionPolicyId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(DistributionPolicy.class));
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DistributionPolicy> listDistributionPolicies() {
        // Generated convenience method for listDistributionPolicies
        RequestOptions requestOptions = new RequestOptions();
        PagedFlux<BinaryData> pagedFluxResponse = listDistributionPolicies(requestOptions);
        return PagedFlux.create(() -> (continuationToken, pageSize) -> {
            Flux<PagedResponse<BinaryData>> flux = (continuationToken == null)
                ? pagedFluxResponse.byPage().take(1)
                : pagedFluxResponse.byPage(continuationToken).take(1);
            return flux.map(pagedResponse -> new PagedResponseBase<Void, DistributionPolicy>(pagedResponse.getRequest(),
                pagedResponse.getStatusCode(), pagedResponse.getHeaders(),
                pagedResponse.getValue()
                    .stream()
                    .map(protocolMethodData -> protocolMethodData.toObject(DistributionPolicy.class))
                    .collect(Collectors.toList()),
                pagedResponse.getContinuationToken(), null));
        });
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param distributionPolicyId Id of a distribution policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteDistributionPolicy(String distributionPolicyId) {
        // Generated convenience method for deleteDistributionPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deleteDistributionPolicyWithResponse(distributionPolicyId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Retrieves an existing classification policy by Id.
     *
     * @param classificationPolicyId Unique identifier of this policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ClassificationPolicy> getClassificationPolicy(String classificationPolicyId) {
        // Generated convenience method for getClassificationPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getClassificationPolicyWithResponse(classificationPolicyId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(ClassificationPolicy.class));
    }

    /**
     * Retrieves existing classification policies.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<ClassificationPolicy> listClassificationPolicies() {
        // Generated convenience method for listClassificationPolicies
        RequestOptions requestOptions = new RequestOptions();
        PagedFlux<BinaryData> pagedFluxResponse = listClassificationPolicies(requestOptions);
        return PagedFlux.create(() -> (continuationToken, pageSize) -> {
            Flux<PagedResponse<BinaryData>> flux = (continuationToken == null)
                ? pagedFluxResponse.byPage().take(1)
                : pagedFluxResponse.byPage(continuationToken).take(1);
            return flux
                .map(pagedResponse -> new PagedResponseBase<Void, ClassificationPolicy>(pagedResponse.getRequest(),
                    pagedResponse.getStatusCode(), pagedResponse.getHeaders(),
                    pagedResponse.getValue()
                        .stream()
                        .map(protocolMethodData -> protocolMethodData.toObject(ClassificationPolicy.class))
                        .collect(Collectors.toList()),
                    pagedResponse.getContinuationToken(), null));
        });
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param classificationPolicyId Id of a classification policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteClassificationPolicy(String classificationPolicyId) {
        // Generated convenience method for deleteClassificationPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deleteClassificationPolicyWithResponse(classificationPolicyId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Retrieves an existing exception policy by Id.
     *
     * @param exceptionPolicyId Id of an exception policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ExceptionPolicy> getExceptionPolicy(String exceptionPolicyId) {
        RequestOptions requestOptions = new RequestOptions();
        return getExceptionPolicyWithResponse(exceptionPolicyId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(ExceptionPolicy.class));
    }

    /**
     * Retrieves existing exception policies.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of ExceptionPolicy items as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<ExceptionPolicy> listExceptionPolicies() {
        // Generated convenience method for listExceptionPolicies
        RequestOptions requestOptions = new RequestOptions();
        PagedFlux<BinaryData> pagedFluxResponse = listExceptionPolicies(requestOptions);
        return PagedFlux.create(() -> (continuationToken, pageSize) -> {
            Flux<PagedResponse<BinaryData>> flux = (continuationToken == null)
                ? pagedFluxResponse.byPage().take(1)
                : pagedFluxResponse.byPage(continuationToken).take(1);
            return flux.map(pagedResponse -> new PagedResponseBase<Void, ExceptionPolicy>(pagedResponse.getRequest(),
                pagedResponse.getStatusCode(), pagedResponse.getHeaders(),
                pagedResponse.getValue()
                    .stream()
                    .map(protocolMethodData -> protocolMethodData.toObject(ExceptionPolicy.class))
                    .collect(Collectors.toList()),
                pagedResponse.getContinuationToken(), null));
        });
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param exceptionPolicyId Id of an exception policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteExceptionPolicy(String exceptionPolicyId) {
        // Generated convenience method for deleteExceptionPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deleteExceptionPolicyWithResponse(exceptionPolicyId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Retrieves an existing queue by Id.
     *
     * @param queueId The Id of this queue.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterQueue> getQueue(String queueId) {
        // Generated convenience method for getQueueWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getQueueWithResponse(queueId, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(RouterQueue.class));
    }

    /**
     * Retrieves existing queues.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<RouterQueue> listQueues() {
        // Generated convenience method for listQueues
        RequestOptions requestOptions = new RequestOptions();
        PagedFlux<BinaryData> pagedFluxResponse = listQueues(requestOptions);
        return PagedFlux.create(() -> (continuationToken, pageSize) -> {
            Flux<PagedResponse<BinaryData>> flux = (continuationToken == null)
                ? pagedFluxResponse.byPage().take(1)
                : pagedFluxResponse.byPage(continuationToken).take(1);
            return flux.map(pagedResponse -> new PagedResponseBase<Void, RouterQueue>(pagedResponse.getRequest(),
                pagedResponse.getStatusCode(), pagedResponse.getHeaders(),
                pagedResponse.getValue()
                    .stream()
                    .map(protocolMethodData -> protocolMethodData.toObject(RouterQueue.class))
                    .collect(Collectors.toList()),
                pagedResponse.getContinuationToken(), null));
        });
    }

    /**
     * Deletes a queue by Id.
     *
     * @param queueId Id of a queue.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteQueue(String queueId) {
        // Generated convenience method for deleteQueueWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return deleteQueueWithResponse(queueId, requestOptions).flatMap(FluxUtil::toMono);
    }

    /**
     * Creates or updates a exception policy.
     *
     * @param exceptionPolicyId Id of an exception policy.
     * @param resource The resource instance.
     * @param ifMatch The request should only proceed if an entity matches this string.
     * @param ifUnmodifiedSince The request should only proceed if the entity was not modified after this time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<ExceptionPolicy> upsertExceptionPolicy(String exceptionPolicyId, ExceptionPolicy resource, String ifMatch,
        OffsetDateTime ifUnmodifiedSince) {
        // Generated convenience method for upsertExceptionPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        JsonMergePatchHelper.getExceptionPolicyAccessor().prepareModelForJsonMergePatch(resource, true);
        BinaryData resourceInBinaryData = BinaryData.fromObject(resource);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        resourceInBinaryData.getLength();
        JsonMergePatchHelper.getExceptionPolicyAccessor().prepareModelForJsonMergePatch(resource, false);
        return upsertExceptionPolicyWithResponse(exceptionPolicyId, resourceInBinaryData, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(ExceptionPolicy.class));
    }

    /**
     * Creates or updates a exception policy.
     *
     * @param exceptionPolicyId Id of an exception policy.
     * @param resource The resource instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<ExceptionPolicy> upsertExceptionPolicy(String exceptionPolicyId, ExceptionPolicy resource) {
        // Generated convenience method for upsertExceptionPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getExceptionPolicyAccessor().prepareModelForJsonMergePatch(resource, true);
        BinaryData resourceInBinaryData = BinaryData.fromObject(resource);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        resourceInBinaryData.getLength();
        JsonMergePatchHelper.getExceptionPolicyAccessor().prepareModelForJsonMergePatch(resource, false);
        return upsertExceptionPolicyWithResponse(exceptionPolicyId, resourceInBinaryData, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(ExceptionPolicy.class));
    }

    /**
     * Creates or updates a distribution policy.
     *
     * @param distributionPolicyId Id of a distribution policy.
     * @param resource The resource instance.
     * @param ifMatch The request should only proceed if an entity matches this string.
     * @param ifUnmodifiedSince The request should only proceed if the entity was not modified after this time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<DistributionPolicy> upsertDistributionPolicy(String distributionPolicyId, DistributionPolicy resource,
        String ifMatch, OffsetDateTime ifUnmodifiedSince) {
        // Generated convenience method for upsertDistributionPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        JsonMergePatchHelper.getDistributionPolicyAccessor().prepareModelForJsonMergePatch(resource, true);
        BinaryData resourceInBinaryData = BinaryData.fromObject(resource);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        resourceInBinaryData.getLength();
        JsonMergePatchHelper.getDistributionPolicyAccessor().prepareModelForJsonMergePatch(resource, false);
        return upsertDistributionPolicyWithResponse(distributionPolicyId, resourceInBinaryData, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(DistributionPolicy.class));
    }

    /**
     * Creates or updates a distribution policy.
     *
     * @param distributionPolicyId Id of a distribution policy.
     * @param resource The resource instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<DistributionPolicy> upsertDistributionPolicy(String distributionPolicyId, DistributionPolicy resource) {
        // Generated convenience method for upsertDistributionPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getDistributionPolicyAccessor().prepareModelForJsonMergePatch(resource, true);
        BinaryData resourceInBinaryData = BinaryData.fromObject(resource);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        resourceInBinaryData.getLength();
        JsonMergePatchHelper.getDistributionPolicyAccessor().prepareModelForJsonMergePatch(resource, false);
        return upsertDistributionPolicyWithResponse(distributionPolicyId, resourceInBinaryData, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(DistributionPolicy.class));
    }

    /**
     * Creates or updates a classification policy.
     *
     * @param classificationPolicyId Id of a classification policy.
     * @param resource The resource instance.
     * @param ifMatch The request should only proceed if an entity matches this string.
     * @param ifUnmodifiedSince The request should only proceed if the entity was not modified after this time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<ClassificationPolicy> upsertClassificationPolicy(String classificationPolicyId, ClassificationPolicy resource,
        String ifMatch, OffsetDateTime ifUnmodifiedSince) {
        // Generated convenience method for upsertClassificationPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        JsonMergePatchHelper.getClassificationPolicyAccessor().prepareModelForJsonMergePatch(resource, true);
        BinaryData resourceInBinaryData = BinaryData.fromObject(resource);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        resourceInBinaryData.getLength();
        JsonMergePatchHelper.getClassificationPolicyAccessor().prepareModelForJsonMergePatch(resource, false);
        return upsertClassificationPolicyWithResponse(classificationPolicyId, resourceInBinaryData, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(ClassificationPolicy.class));
    }

    /**
     * Creates or updates a classification policy.
     *
     * @param classificationPolicyId Id of a classification policy.
     * @param resource The resource instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<ClassificationPolicy> upsertClassificationPolicy(String classificationPolicyId,
        ClassificationPolicy resource) {
        // Generated convenience method for upsertClassificationPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getClassificationPolicyAccessor().prepareModelForJsonMergePatch(resource, true);
        BinaryData resourceInBinaryData = BinaryData.fromObject(resource);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        resourceInBinaryData.getLength();
        JsonMergePatchHelper.getClassificationPolicyAccessor().prepareModelForJsonMergePatch(resource, false);
        return upsertClassificationPolicyWithResponse(classificationPolicyId, resourceInBinaryData, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(ClassificationPolicy.class));
    }

    /**
     * Creates or updates a queue.
     *
     * @param queueId Id of a queue.
     * @param resource The resource instance.
     * @param ifMatch The request should only proceed if an entity matches this string.
     * @param ifUnmodifiedSince The request should only proceed if the entity was not modified after this time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<RouterQueue> upsertQueue(String queueId, RouterQueue resource, String ifMatch,
        OffsetDateTime ifUnmodifiedSince) {
        // Generated convenience method for upsertQueueWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(HttpHeaderName.IF_UNMODIFIED_SINCE,
                String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        JsonMergePatchHelper.getRouterQueueAccessor().prepareModelForJsonMergePatch(resource, true);
        BinaryData resourceInBinaryData = BinaryData.fromObject(resource);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        resourceInBinaryData.getLength();
        JsonMergePatchHelper.getRouterQueueAccessor().prepareModelForJsonMergePatch(resource, false);
        return upsertQueueWithResponse(queueId, resourceInBinaryData, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(RouterQueue.class));
    }

    /**
     * Creates or updates a queue.
     *
     * @param queueId Id of a queue.
     * @param resource The resource instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Mono<RouterQueue> upsertQueue(String queueId, RouterQueue resource) {
        // Generated convenience method for upsertQueueWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getRouterQueueAccessor().prepareModelForJsonMergePatch(resource, true);
        BinaryData resourceInBinaryData = BinaryData.fromObject(resource);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        resourceInBinaryData.getLength();
        JsonMergePatchHelper.getRouterQueueAccessor().prepareModelForJsonMergePatch(resource, false);
        return upsertQueueWithResponse(queueId, resourceInBinaryData, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(RouterQueue.class));
    }
}
