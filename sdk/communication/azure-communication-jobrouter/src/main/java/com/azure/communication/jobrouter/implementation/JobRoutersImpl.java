// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.communication.jobrouter.implementation;

import com.azure.communication.jobrouter.implementation.models.AcceptJobOfferResultInternal;
import com.azure.communication.jobrouter.implementation.models.CancelJobRequest;
import com.azure.communication.jobrouter.implementation.models.CloseJobRequest;
import com.azure.communication.jobrouter.implementation.models.CommunicationErrorResponseException;
import com.azure.communication.jobrouter.implementation.models.CompleteJobRequest;
import com.azure.communication.jobrouter.implementation.models.DeclineJobOfferRequest;
import com.azure.communication.jobrouter.implementation.models.RouterJobCollectionInternal;
import com.azure.communication.jobrouter.implementation.models.RouterJobInternal;
import com.azure.communication.jobrouter.implementation.models.RouterJobItemInternal;
import com.azure.communication.jobrouter.implementation.models.RouterJobPositionDetailsInternal;
import com.azure.communication.jobrouter.implementation.models.RouterJobStatusSelectorInternal;
import com.azure.communication.jobrouter.implementation.models.RouterQueueStatisticsInternal;
import com.azure.communication.jobrouter.implementation.models.RouterWorkerCollectionInternal;
import com.azure.communication.jobrouter.implementation.models.RouterWorkerInternal;
import com.azure.communication.jobrouter.implementation.models.RouterWorkerItemInternal;
import com.azure.communication.jobrouter.implementation.models.RouterWorkerStateSelectorInternal;
import com.azure.communication.jobrouter.implementation.models.UnassignJobRequest;
import com.azure.communication.jobrouter.implementation.models.UnassignJobResultInternal;
import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import reactor.core.publisher.Mono;

import java.time.OffsetDateTime;

/** An instance of this class provides access to all the operations defined in JobRouters. */
public final class JobRoutersImpl {
    /** The proxy service used to perform REST calls. */
    private final JobRoutersService service;

    /** The service client containing this operation class. */
    private final AzureCommunicationServicesImpl client;

    /**
     * Initializes an instance of JobRoutersImpl.
     *
     * @param client the instance of the service client containing this operation class.
     */
    JobRoutersImpl(AzureCommunicationServicesImpl client) {
        this.service =
                RestProxy.create(JobRoutersService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for AzureCommunicationServicesJobRouters to be used by the proxy service
     * to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "AzureCommunicationSe")
    public interface JobRoutersService {
        @Patch("/routing/jobs/{id}")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterJobInternal>> upsertJob(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/merge-patch+json") RouterJobInternal patch,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/jobs/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterJobInternal>> getJob(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/routing/jobs/{id}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Void>> deleteJob(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/jobs/{id}:reclassify")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Object>> reclassifyJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") Object reclassifyJobRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/jobs/{id}:cancel")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Object>> cancelJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") CancelJobRequest cancelJobRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/jobs/{id}:complete")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Object>> completeJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") CompleteJobRequest completeJobRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/jobs/{id}:close")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Object>> closeJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") CloseJobRequest closeJobRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/jobs")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterJobCollectionInternal>> listJobs(
                @HostParam("endpoint") String endpoint,
                @QueryParam("status") RouterJobStatusSelectorInternal status,
                @QueryParam("queueId") String queueId,
                @QueryParam("channelId") String channelId,
                @QueryParam("classificationPolicyId") String classificationPolicyId,
                @QueryParam("scheduledBefore") OffsetDateTime scheduledBefore,
                @QueryParam("scheduledAfter") OffsetDateTime scheduledAfter,
                @QueryParam("maxpagesize") Integer maxPageSize,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/jobs/{id}/position")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterJobPositionDetailsInternal>> getInQueuePosition(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/jobs/{id}/assignments/{assignmentId}:unassign")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<UnassignJobResultInternal>> unassignJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @PathParam("assignmentId") String assignmentId,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") UnassignJobRequest unassignJobRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/workers/{workerId}/offers/{offerId}:accept")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<AcceptJobOfferResultInternal>> acceptJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("workerId") String workerId,
                @PathParam("offerId") String offerId,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/workers/{workerId}/offers/{offerId}:decline")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Object>> declineJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("workerId") String workerId,
                @PathParam("offerId") String offerId,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") DeclineJobOfferRequest declineJobOfferRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/queues/{id}/statistics")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterQueueStatisticsInternal>> getQueueStatistics(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/routing/workers/{workerId}")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterWorkerInternal>> upsertWorker(
                @HostParam("endpoint") String endpoint,
                @PathParam("workerId") String workerId,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/merge-patch+json") RouterWorkerInternal patch,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/workers/{workerId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterWorkerInternal>> getWorker(
                @HostParam("endpoint") String endpoint,
                @PathParam("workerId") String workerId,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/routing/workers/{workerId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Void>> deleteWorker(
                @HostParam("endpoint") String endpoint,
                @PathParam("workerId") String workerId,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/workers")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterWorkerCollectionInternal>> listWorkers(
                @HostParam("endpoint") String endpoint,
                @QueryParam("state") RouterWorkerStateSelectorInternal state,
                @QueryParam("channelId") String channelId,
                @QueryParam("queueId") String queueId,
                @QueryParam("hasCapacity") Boolean hasCapacity,
                @QueryParam("maxpagesize") Integer maxPageSize,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterJobCollectionInternal>> listJobsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterWorkerCollectionInternal>> listWorkersNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);
    }

    /**
     * Creates or updates a router job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterJobInternal>> upsertJobWithResponseAsync(String id, RouterJobInternal patch) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upsertJob(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context));
    }

    /**
     * Creates or updates a router job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterJobInternal>> upsertJobWithResponseAsync(
            String id, RouterJobInternal patch, Context context) {
        final String accept = "application/json";
        return service.upsertJob(this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context);
    }

    /**
     * Creates or updates a router job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterJobInternal> upsertJobAsync(String id, RouterJobInternal patch) {
        return upsertJobWithResponseAsync(id, patch).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a router job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterJobInternal> upsertJobAsync(String id, RouterJobInternal patch, Context context) {
        return upsertJobWithResponseAsync(id, patch, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a router job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RouterJobInternal> upsertJobWithResponse(String id, RouterJobInternal patch, Context context) {
        return upsertJobWithResponseAsync(id, patch, context).block();
    }

    /**
     * Creates or updates a router job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterJobInternal upsertJob(String id, RouterJobInternal patch) {
        return upsertJobWithResponse(id, patch, Context.NONE).getValue();
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterJobInternal>> getJobWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getJob(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterJobInternal>> getJobWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.getJob(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterJobInternal> getJobAsync(String id) {
        return getJobWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterJobInternal> getJobAsync(String id, Context context) {
        return getJobWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RouterJobInternal> getJobWithResponse(String id, Context context) {
        return getJobWithResponseAsync(id, context).block();
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterJobInternal getJob(String id) {
        return getJobWithResponse(id, Context.NONE).getValue();
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteJobWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteJob(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteJobWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.deleteJob(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteJobAsync(String id) {
        return deleteJobWithResponseAsync(id).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteJobAsync(String id, Context context) {
        return deleteJobWithResponseAsync(id, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteJobWithResponse(String id, Context context) {
        return deleteJobWithResponseAsync(id, context).block();
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteJob(String id) {
        deleteJobWithResponse(id, Context.NONE);
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> reclassifyJobActionWithResponseAsync(String id, Object reclassifyJobRequest) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.reclassifyJobAction(
                                this.client.getEndpoint(),
                                id,
                                this.client.getApiVersion(),
                                reclassifyJobRequest,
                                accept,
                                context));
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> reclassifyJobActionWithResponseAsync(
            String id, Object reclassifyJobRequest, Context context) {
        final String accept = "application/json";
        return service.reclassifyJobAction(
                this.client.getEndpoint(), id, this.client.getApiVersion(), reclassifyJobRequest, accept, context);
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> reclassifyJobActionAsync(String id, Object reclassifyJobRequest) {
        return reclassifyJobActionWithResponseAsync(id, reclassifyJobRequest)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> reclassifyJobActionAsync(String id, Object reclassifyJobRequest, Context context) {
        return reclassifyJobActionWithResponseAsync(id, reclassifyJobRequest, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Object> reclassifyJobActionWithResponse(String id, Object reclassifyJobRequest, Context context) {
        return reclassifyJobActionWithResponseAsync(id, reclassifyJobRequest, context).block();
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object reclassifyJobAction(String id, Object reclassifyJobRequest) {
        return reclassifyJobActionWithResponse(id, reclassifyJobRequest, Context.NONE).getValue();
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> cancelJobActionWithResponseAsync(String id, String note, String dispositionCode) {
        final String accept = "application/json";
        CancelJobRequest cancelJobRequest = new CancelJobRequest();
        cancelJobRequest.setNote(note);
        cancelJobRequest.setDispositionCode(dispositionCode);
        return FluxUtil.withContext(
                context ->
                        service.cancelJobAction(
                                this.client.getEndpoint(),
                                id,
                                this.client.getApiVersion(),
                                cancelJobRequest,
                                accept,
                                context));
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> cancelJobActionWithResponseAsync(
            String id, String note, String dispositionCode, Context context) {
        final String accept = "application/json";
        CancelJobRequest cancelJobRequest = new CancelJobRequest();
        cancelJobRequest.setNote(note);
        cancelJobRequest.setDispositionCode(dispositionCode);
        return service.cancelJobAction(
                this.client.getEndpoint(), id, this.client.getApiVersion(), cancelJobRequest, accept, context);
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> cancelJobActionAsync(String id, String note, String dispositionCode) {
        return cancelJobActionWithResponseAsync(id, note, dispositionCode)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> cancelJobActionAsync(String id, String note, String dispositionCode, Context context) {
        return cancelJobActionWithResponseAsync(id, note, dispositionCode, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Object> cancelJobActionWithResponse(
            String id, String note, String dispositionCode, Context context) {
        return cancelJobActionWithResponseAsync(id, note, dispositionCode, context).block();
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object cancelJobAction(String id, String note, String dispositionCode) {
        return cancelJobActionWithResponse(id, note, dispositionCode, Context.NONE).getValue();
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> completeJobActionWithResponseAsync(String id, String assignmentId, String note) {
        final String accept = "application/json";
        CompleteJobRequest completeJobRequest = new CompleteJobRequest();
        completeJobRequest.setAssignmentId(assignmentId);
        completeJobRequest.setNote(note);
        return FluxUtil.withContext(
                context ->
                        service.completeJobAction(
                                this.client.getEndpoint(),
                                id,
                                this.client.getApiVersion(),
                                completeJobRequest,
                                accept,
                                context));
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> completeJobActionWithResponseAsync(
            String id, String assignmentId, String note, Context context) {
        final String accept = "application/json";
        CompleteJobRequest completeJobRequest = new CompleteJobRequest();
        completeJobRequest.setAssignmentId(assignmentId);
        completeJobRequest.setNote(note);
        return service.completeJobAction(
                this.client.getEndpoint(), id, this.client.getApiVersion(), completeJobRequest, accept, context);
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> completeJobActionAsync(String id, String assignmentId, String note) {
        return completeJobActionWithResponseAsync(id, assignmentId, note)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> completeJobActionAsync(String id, String assignmentId, String note, Context context) {
        return completeJobActionWithResponseAsync(id, assignmentId, note, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Object> completeJobActionWithResponse(
            String id, String assignmentId, String note, Context context) {
        return completeJobActionWithResponseAsync(id, assignmentId, note, context).block();
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object completeJobAction(String id, String assignmentId, String note) {
        return completeJobActionWithResponse(id, assignmentId, note, Context.NONE).getValue();
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeAt If not provided, worker capacity is released immediately along with a JobClosedEvent notification.
     *     If provided, worker capacity is released along with a JobClosedEvent notification at a future time in UTC.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> closeJobActionWithResponseAsync(
            String id, String assignmentId, String dispositionCode, OffsetDateTime closeAt, String note) {
        final String accept = "application/json";
        CloseJobRequest closeJobRequest = new CloseJobRequest();
        closeJobRequest.setAssignmentId(assignmentId);
        closeJobRequest.setDispositionCode(dispositionCode);
        closeJobRequest.setCloseAt(closeAt);
        closeJobRequest.setNote(note);
        return FluxUtil.withContext(
                context ->
                        service.closeJobAction(
                                this.client.getEndpoint(),
                                id,
                                this.client.getApiVersion(),
                                closeJobRequest,
                                accept,
                                context));
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeAt If not provided, worker capacity is released immediately along with a JobClosedEvent notification.
     *     If provided, worker capacity is released along with a JobClosedEvent notification at a future time in UTC.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> closeJobActionWithResponseAsync(
            String id,
            String assignmentId,
            String dispositionCode,
            OffsetDateTime closeAt,
            String note,
            Context context) {
        final String accept = "application/json";
        CloseJobRequest closeJobRequest = new CloseJobRequest();
        closeJobRequest.setAssignmentId(assignmentId);
        closeJobRequest.setDispositionCode(dispositionCode);
        closeJobRequest.setCloseAt(closeAt);
        closeJobRequest.setNote(note);
        return service.closeJobAction(
                this.client.getEndpoint(), id, this.client.getApiVersion(), closeJobRequest, accept, context);
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeAt If not provided, worker capacity is released immediately along with a JobClosedEvent notification.
     *     If provided, worker capacity is released along with a JobClosedEvent notification at a future time in UTC.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> closeJobActionAsync(
            String id, String assignmentId, String dispositionCode, OffsetDateTime closeAt, String note) {
        return closeJobActionWithResponseAsync(id, assignmentId, dispositionCode, closeAt, note)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeAt If not provided, worker capacity is released immediately along with a JobClosedEvent notification.
     *     If provided, worker capacity is released along with a JobClosedEvent notification at a future time in UTC.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> closeJobActionAsync(
            String id,
            String assignmentId,
            String dispositionCode,
            OffsetDateTime closeAt,
            String note,
            Context context) {
        return closeJobActionWithResponseAsync(id, assignmentId, dispositionCode, closeAt, note, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeAt If not provided, worker capacity is released immediately along with a JobClosedEvent notification.
     *     If provided, worker capacity is released along with a JobClosedEvent notification at a future time in UTC.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Object> closeJobActionWithResponse(
            String id,
            String assignmentId,
            String dispositionCode,
            OffsetDateTime closeAt,
            String note,
            Context context) {
        return closeJobActionWithResponseAsync(id, assignmentId, dispositionCode, closeAt, note, context).block();
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeAt If not provided, worker capacity is released immediately along with a JobClosedEvent notification.
     *     If provided, worker capacity is released along with a JobClosedEvent notification at a future time in UTC.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object closeJobAction(
            String id, String assignmentId, String dispositionCode, OffsetDateTime closeAt, String note) {
        return closeJobActionWithResponse(id, assignmentId, dispositionCode, closeAt, note, Context.NONE).getValue();
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status If specified, filter jobs by status.
     * @param queueId If specified, filter jobs by queue.
     * @param channelId If specified, filter jobs by channel.
     * @param classificationPolicyId If specified, filter jobs by classificationPolicy.
     * @param scheduledBefore If specified, filter on jobs that was scheduled before or at given timestamp. Range:
     *     (-Inf, scheduledBefore].
     * @param scheduledAfter If specified, filter on jobs that was scheduled at or after given value. Range:
     *     [scheduledAfter, +Inf).
     * @param maxPageSize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterJobItemInternal>> listJobsSinglePageAsync(
            RouterJobStatusSelectorInternal status,
            String queueId,
            String channelId,
            String classificationPolicyId,
            OffsetDateTime scheduledBefore,
            OffsetDateTime scheduledAfter,
            Integer maxPageSize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listJobs(
                                        this.client.getEndpoint(),
                                        status,
                                        queueId,
                                        channelId,
                                        classificationPolicyId,
                                        scheduledBefore,
                                        scheduledAfter,
                                        maxPageSize,
                                        this.client.getApiVersion(),
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status If specified, filter jobs by status.
     * @param queueId If specified, filter jobs by queue.
     * @param channelId If specified, filter jobs by channel.
     * @param classificationPolicyId If specified, filter jobs by classificationPolicy.
     * @param scheduledBefore If specified, filter on jobs that was scheduled before or at given timestamp. Range:
     *     (-Inf, scheduledBefore].
     * @param scheduledAfter If specified, filter on jobs that was scheduled at or after given value. Range:
     *     [scheduledAfter, +Inf).
     * @param maxPageSize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterJobItemInternal>> listJobsSinglePageAsync(
            RouterJobStatusSelectorInternal status,
            String queueId,
            String channelId,
            String classificationPolicyId,
            OffsetDateTime scheduledBefore,
            OffsetDateTime scheduledAfter,
            Integer maxPageSize,
            Context context) {
        final String accept = "application/json";
        return service.listJobs(
                        this.client.getEndpoint(),
                        status,
                        queueId,
                        channelId,
                        classificationPolicyId,
                        scheduledBefore,
                        scheduledAfter,
                        maxPageSize,
                        this.client.getApiVersion(),
                        accept,
                        context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status If specified, filter jobs by status.
     * @param queueId If specified, filter jobs by queue.
     * @param channelId If specified, filter jobs by channel.
     * @param classificationPolicyId If specified, filter jobs by classificationPolicy.
     * @param scheduledBefore If specified, filter on jobs that was scheduled before or at given timestamp. Range:
     *     (-Inf, scheduledBefore].
     * @param scheduledAfter If specified, filter on jobs that was scheduled at or after given value. Range:
     *     [scheduledAfter, +Inf).
     * @param maxPageSize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<RouterJobItemInternal> listJobsAsync(
            RouterJobStatusSelectorInternal status,
            String queueId,
            String channelId,
            String classificationPolicyId,
            OffsetDateTime scheduledBefore,
            OffsetDateTime scheduledAfter,
            Integer maxPageSize) {
        return new PagedFlux<>(
                () ->
                        listJobsSinglePageAsync(
                                status,
                                queueId,
                                channelId,
                                classificationPolicyId,
                                scheduledBefore,
                                scheduledAfter,
                                maxPageSize),
                nextLink -> listJobsNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status If specified, filter jobs by status.
     * @param queueId If specified, filter jobs by queue.
     * @param channelId If specified, filter jobs by channel.
     * @param classificationPolicyId If specified, filter jobs by classificationPolicy.
     * @param scheduledBefore If specified, filter on jobs that was scheduled before or at given timestamp. Range:
     *     (-Inf, scheduledBefore].
     * @param scheduledAfter If specified, filter on jobs that was scheduled at or after given value. Range:
     *     [scheduledAfter, +Inf).
     * @param maxPageSize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<RouterJobItemInternal> listJobsAsync(
            RouterJobStatusSelectorInternal status,
            String queueId,
            String channelId,
            String classificationPolicyId,
            OffsetDateTime scheduledBefore,
            OffsetDateTime scheduledAfter,
            Integer maxPageSize,
            Context context) {
        return new PagedFlux<>(
                () ->
                        listJobsSinglePageAsync(
                                status,
                                queueId,
                                channelId,
                                classificationPolicyId,
                                scheduledBefore,
                                scheduledAfter,
                                maxPageSize,
                                context),
                nextLink -> listJobsNextSinglePageAsync(nextLink, context));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status If specified, filter jobs by status.
     * @param queueId If specified, filter jobs by queue.
     * @param channelId If specified, filter jobs by channel.
     * @param classificationPolicyId If specified, filter jobs by classificationPolicy.
     * @param scheduledBefore If specified, filter on jobs that was scheduled before or at given timestamp. Range:
     *     (-Inf, scheduledBefore].
     * @param scheduledAfter If specified, filter on jobs that was scheduled at or after given value. Range:
     *     [scheduledAfter, +Inf).
     * @param maxPageSize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<RouterJobItemInternal> listJobsSinglePage(
            RouterJobStatusSelectorInternal status,
            String queueId,
            String channelId,
            String classificationPolicyId,
            OffsetDateTime scheduledBefore,
            OffsetDateTime scheduledAfter,
            Integer maxPageSize) {
        return listJobsSinglePageAsync(
                        status,
                        queueId,
                        channelId,
                        classificationPolicyId,
                        scheduledBefore,
                        scheduledAfter,
                        maxPageSize)
                .block();
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status If specified, filter jobs by status.
     * @param queueId If specified, filter jobs by queue.
     * @param channelId If specified, filter jobs by channel.
     * @param classificationPolicyId If specified, filter jobs by classificationPolicy.
     * @param scheduledBefore If specified, filter on jobs that was scheduled before or at given timestamp. Range:
     *     (-Inf, scheduledBefore].
     * @param scheduledAfter If specified, filter on jobs that was scheduled at or after given value. Range:
     *     [scheduledAfter, +Inf).
     * @param maxPageSize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<RouterJobItemInternal> listJobsSinglePage(
            RouterJobStatusSelectorInternal status,
            String queueId,
            String channelId,
            String classificationPolicyId,
            OffsetDateTime scheduledBefore,
            OffsetDateTime scheduledAfter,
            Integer maxPageSize,
            Context context) {
        return listJobsSinglePageAsync(
                        status,
                        queueId,
                        channelId,
                        classificationPolicyId,
                        scheduledBefore,
                        scheduledAfter,
                        maxPageSize,
                        context)
                .block();
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status If specified, filter jobs by status.
     * @param queueId If specified, filter jobs by queue.
     * @param channelId If specified, filter jobs by channel.
     * @param classificationPolicyId If specified, filter jobs by classificationPolicy.
     * @param scheduledBefore If specified, filter on jobs that was scheduled before or at given timestamp. Range:
     *     (-Inf, scheduledBefore].
     * @param scheduledAfter If specified, filter on jobs that was scheduled at or after given value. Range:
     *     [scheduledAfter, +Inf).
     * @param maxPageSize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<RouterJobItemInternal> listJobs(
            RouterJobStatusSelectorInternal status,
            String queueId,
            String channelId,
            String classificationPolicyId,
            OffsetDateTime scheduledBefore,
            OffsetDateTime scheduledAfter,
            Integer maxPageSize) {
        return new PagedIterable<>(
                listJobsAsync(
                        status,
                        queueId,
                        channelId,
                        classificationPolicyId,
                        scheduledBefore,
                        scheduledAfter,
                        maxPageSize));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status If specified, filter jobs by status.
     * @param queueId If specified, filter jobs by queue.
     * @param channelId If specified, filter jobs by channel.
     * @param classificationPolicyId If specified, filter jobs by classificationPolicy.
     * @param scheduledBefore If specified, filter on jobs that was scheduled before or at given timestamp. Range:
     *     (-Inf, scheduledBefore].
     * @param scheduledAfter If specified, filter on jobs that was scheduled at or after given value. Range:
     *     [scheduledAfter, +Inf).
     * @param maxPageSize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<RouterJobItemInternal> listJobs(
            RouterJobStatusSelectorInternal status,
            String queueId,
            String channelId,
            String classificationPolicyId,
            OffsetDateTime scheduledBefore,
            OffsetDateTime scheduledAfter,
            Integer maxPageSize,
            Context context) {
        return new PagedIterable<>(
                listJobsAsync(
                        status,
                        queueId,
                        channelId,
                        classificationPolicyId,
                        scheduledBefore,
                        scheduledAfter,
                        maxPageSize,
                        context));
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterJobPositionDetailsInternal>> getInQueuePositionWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getInQueuePosition(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterJobPositionDetailsInternal>> getInQueuePositionWithResponseAsync(
            String id, Context context) {
        final String accept = "application/json";
        return service.getInQueuePosition(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterJobPositionDetailsInternal> getInQueuePositionAsync(String id) {
        return getInQueuePositionWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterJobPositionDetailsInternal> getInQueuePositionAsync(String id, Context context) {
        return getInQueuePositionWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RouterJobPositionDetailsInternal> getInQueuePositionWithResponse(String id, Context context) {
        return getInQueuePositionWithResponseAsync(id, context).block();
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterJobPositionDetailsInternal getInQueuePosition(String id) {
        return getInQueuePositionWithResponse(id, Context.NONE).getValue();
    }

    /**
     * Un-assign a job.
     *
     * @param id Id of the job to un-assign.
     * @param assignmentId Id of the assignment to un-assign.
     * @param unassignJobRequest Request body for unassign route.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response payload after a job has been successfully unassigned along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<UnassignJobResultInternal>> unassignJobActionWithResponseAsync(
            String id, String assignmentId, UnassignJobRequest unassignJobRequest) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.unassignJobAction(
                                this.client.getEndpoint(),
                                id,
                                assignmentId,
                                this.client.getApiVersion(),
                                unassignJobRequest,
                                accept,
                                context));
    }

    /**
     * Un-assign a job.
     *
     * @param id Id of the job to un-assign.
     * @param assignmentId Id of the assignment to un-assign.
     * @param unassignJobRequest Request body for unassign route.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response payload after a job has been successfully unassigned along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<UnassignJobResultInternal>> unassignJobActionWithResponseAsync(
            String id, String assignmentId, UnassignJobRequest unassignJobRequest, Context context) {
        final String accept = "application/json";
        return service.unassignJobAction(
                this.client.getEndpoint(),
                id,
                assignmentId,
                this.client.getApiVersion(),
                unassignJobRequest,
                accept,
                context);
    }

    /**
     * Un-assign a job.
     *
     * @param id Id of the job to un-assign.
     * @param assignmentId Id of the assignment to un-assign.
     * @param unassignJobRequest Request body for unassign route.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response payload after a job has been successfully unassigned on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<UnassignJobResultInternal> unassignJobActionAsync(
            String id, String assignmentId, UnassignJobRequest unassignJobRequest) {
        return unassignJobActionWithResponseAsync(id, assignmentId, unassignJobRequest)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Un-assign a job.
     *
     * @param id Id of the job to un-assign.
     * @param assignmentId Id of the assignment to un-assign.
     * @param unassignJobRequest Request body for unassign route.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response payload after a job has been successfully unassigned on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<UnassignJobResultInternal> unassignJobActionAsync(
            String id, String assignmentId, UnassignJobRequest unassignJobRequest, Context context) {
        return unassignJobActionWithResponseAsync(id, assignmentId, unassignJobRequest, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Un-assign a job.
     *
     * @param id Id of the job to un-assign.
     * @param assignmentId Id of the assignment to un-assign.
     * @param unassignJobRequest Request body for unassign route.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response payload after a job has been successfully unassigned along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<UnassignJobResultInternal> unassignJobActionWithResponse(
            String id, String assignmentId, UnassignJobRequest unassignJobRequest, Context context) {
        return unassignJobActionWithResponseAsync(id, assignmentId, unassignJobRequest, context).block();
    }

    /**
     * Un-assign a job.
     *
     * @param id Id of the job to un-assign.
     * @param assignmentId Id of the assignment to un-assign.
     * @param unassignJobRequest Request body for unassign route.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response payload after a job has been successfully unassigned.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public UnassignJobResultInternal unassignJobAction(
            String id, String assignmentId, UnassignJobRequest unassignJobRequest) {
        return unassignJobActionWithResponse(id, assignmentId, unassignJobRequest, Context.NONE).getValue();
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer along with {@link
     *     Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AcceptJobOfferResultInternal>> acceptJobActionWithResponseAsync(
            String workerId, String offerId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.acceptJobAction(
                                this.client.getEndpoint(),
                                workerId,
                                offerId,
                                this.client.getApiVersion(),
                                accept,
                                context));
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer along with {@link
     *     Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AcceptJobOfferResultInternal>> acceptJobActionWithResponseAsync(
            String workerId, String offerId, Context context) {
        final String accept = "application/json";
        return service.acceptJobAction(
                this.client.getEndpoint(), workerId, offerId, this.client.getApiVersion(), accept, context);
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AcceptJobOfferResultInternal> acceptJobActionAsync(String workerId, String offerId) {
        return acceptJobActionWithResponseAsync(workerId, offerId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AcceptJobOfferResultInternal> acceptJobActionAsync(String workerId, String offerId, Context context) {
        return acceptJobActionWithResponseAsync(workerId, offerId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer along with {@link
     *     Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AcceptJobOfferResultInternal> acceptJobActionWithResponse(
            String workerId, String offerId, Context context) {
        return acceptJobActionWithResponseAsync(workerId, offerId, context).block();
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AcceptJobOfferResultInternal acceptJobAction(String workerId, String offerId) {
        return acceptJobActionWithResponse(workerId, offerId, Context.NONE).getValue();
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param declineJobOfferRequest Request model for declining offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> declineJobActionWithResponseAsync(
            String workerId, String offerId, DeclineJobOfferRequest declineJobOfferRequest) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.declineJobAction(
                                this.client.getEndpoint(),
                                workerId,
                                offerId,
                                this.client.getApiVersion(),
                                declineJobOfferRequest,
                                accept,
                                context));
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param declineJobOfferRequest Request model for declining offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> declineJobActionWithResponseAsync(
            String workerId, String offerId, DeclineJobOfferRequest declineJobOfferRequest, Context context) {
        final String accept = "application/json";
        return service.declineJobAction(
                this.client.getEndpoint(),
                workerId,
                offerId,
                this.client.getApiVersion(),
                declineJobOfferRequest,
                accept,
                context);
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param declineJobOfferRequest Request model for declining offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> declineJobActionAsync(
            String workerId, String offerId, DeclineJobOfferRequest declineJobOfferRequest) {
        return declineJobActionWithResponseAsync(workerId, offerId, declineJobOfferRequest)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param declineJobOfferRequest Request model for declining offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> declineJobActionAsync(
            String workerId, String offerId, DeclineJobOfferRequest declineJobOfferRequest, Context context) {
        return declineJobActionWithResponseAsync(workerId, offerId, declineJobOfferRequest, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param declineJobOfferRequest Request model for declining offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Object> declineJobActionWithResponse(
            String workerId, String offerId, DeclineJobOfferRequest declineJobOfferRequest, Context context) {
        return declineJobActionWithResponseAsync(workerId, offerId, declineJobOfferRequest, context).block();
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param declineJobOfferRequest Request model for declining offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object declineJobAction(String workerId, String offerId, DeclineJobOfferRequest declineJobOfferRequest) {
        return declineJobActionWithResponse(workerId, offerId, declineJobOfferRequest, Context.NONE).getValue();
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterQueueStatisticsInternal>> getQueueStatisticsWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getQueueStatistics(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterQueueStatisticsInternal>> getQueueStatisticsWithResponseAsync(
            String id, Context context) {
        final String accept = "application/json";
        return service.getQueueStatistics(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterQueueStatisticsInternal> getQueueStatisticsAsync(String id) {
        return getQueueStatisticsWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterQueueStatisticsInternal> getQueueStatisticsAsync(String id, Context context) {
        return getQueueStatisticsWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RouterQueueStatisticsInternal> getQueueStatisticsWithResponse(String id, Context context) {
        return getQueueStatisticsWithResponseAsync(id, context).block();
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterQueueStatisticsInternal getQueueStatistics(String id) {
        return getQueueStatisticsWithResponse(id, Context.NONE).getValue();
    }

    /**
     * Creates or updates a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterWorkerInternal>> upsertWorkerWithResponseAsync(
            String workerId, RouterWorkerInternal patch) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upsertWorker(
                                this.client.getEndpoint(),
                                workerId,
                                this.client.getApiVersion(),
                                patch,
                                accept,
                                context));
    }

    /**
     * Creates or updates a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterWorkerInternal>> upsertWorkerWithResponseAsync(
            String workerId, RouterWorkerInternal patch, Context context) {
        final String accept = "application/json";
        return service.upsertWorker(
                this.client.getEndpoint(), workerId, this.client.getApiVersion(), patch, accept, context);
    }

    /**
     * Creates or updates a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterWorkerInternal> upsertWorkerAsync(String workerId, RouterWorkerInternal patch) {
        return upsertWorkerWithResponseAsync(workerId, patch).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterWorkerInternal> upsertWorkerAsync(String workerId, RouterWorkerInternal patch, Context context) {
        return upsertWorkerWithResponseAsync(workerId, patch, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RouterWorkerInternal> upsertWorkerWithResponse(
            String workerId, RouterWorkerInternal patch, Context context) {
        return upsertWorkerWithResponseAsync(workerId, patch, context).block();
    }

    /**
     * Creates or updates a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterWorkerInternal upsertWorker(String workerId, RouterWorkerInternal patch) {
        return upsertWorkerWithResponse(workerId, patch, Context.NONE).getValue();
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterWorkerInternal>> getWorkerWithResponseAsync(String workerId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getWorker(
                                this.client.getEndpoint(), workerId, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterWorkerInternal>> getWorkerWithResponseAsync(String workerId, Context context) {
        final String accept = "application/json";
        return service.getWorker(this.client.getEndpoint(), workerId, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterWorkerInternal> getWorkerAsync(String workerId) {
        return getWorkerWithResponseAsync(workerId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterWorkerInternal> getWorkerAsync(String workerId, Context context) {
        return getWorkerWithResponseAsync(workerId, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RouterWorkerInternal> getWorkerWithResponse(String workerId, Context context) {
        return getWorkerWithResponseAsync(workerId, context).block();
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterWorkerInternal getWorker(String workerId) {
        return getWorkerWithResponse(workerId, Context.NONE).getValue();
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteWorkerWithResponseAsync(String workerId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteWorker(
                                this.client.getEndpoint(), workerId, this.client.getApiVersion(), accept, context));
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteWorkerWithResponseAsync(String workerId, Context context) {
        final String accept = "application/json";
        return service.deleteWorker(this.client.getEndpoint(), workerId, this.client.getApiVersion(), accept, context);
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteWorkerAsync(String workerId) {
        return deleteWorkerWithResponseAsync(workerId).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteWorkerAsync(String workerId, Context context) {
        return deleteWorkerWithResponseAsync(workerId, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteWorkerWithResponse(String workerId, Context context) {
        return deleteWorkerWithResponseAsync(workerId, context).block();
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteWorker(String workerId) {
        deleteWorkerWithResponse(workerId, Context.NONE);
    }

    /**
     * Retrieves existing workers.
     *
     * @param state If specified, select workers by worker state.
     * @param channelId If specified, select workers who have a channel configuration with this channel.
     * @param queueId If specified, select workers who are assigned to this queue.
     * @param hasCapacity If set to true, select only workers who have capacity for the channel specified by `channelId`
     *     or for any channel if `channelId` not specified. If set to false, then will return all workers including
     *     workers without any capacity for jobs. Defaults to false.
     * @param maxPageSize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterWorkerItemInternal>> listWorkersSinglePageAsync(
            RouterWorkerStateSelectorInternal state,
            String channelId,
            String queueId,
            Boolean hasCapacity,
            Integer maxPageSize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listWorkers(
                                        this.client.getEndpoint(),
                                        state,
                                        channelId,
                                        queueId,
                                        hasCapacity,
                                        maxPageSize,
                                        this.client.getApiVersion(),
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing workers.
     *
     * @param state If specified, select workers by worker state.
     * @param channelId If specified, select workers who have a channel configuration with this channel.
     * @param queueId If specified, select workers who are assigned to this queue.
     * @param hasCapacity If set to true, select only workers who have capacity for the channel specified by `channelId`
     *     or for any channel if `channelId` not specified. If set to false, then will return all workers including
     *     workers without any capacity for jobs. Defaults to false.
     * @param maxPageSize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterWorkerItemInternal>> listWorkersSinglePageAsync(
            RouterWorkerStateSelectorInternal state,
            String channelId,
            String queueId,
            Boolean hasCapacity,
            Integer maxPageSize,
            Context context) {
        final String accept = "application/json";
        return service.listWorkers(
                        this.client.getEndpoint(),
                        state,
                        channelId,
                        queueId,
                        hasCapacity,
                        maxPageSize,
                        this.client.getApiVersion(),
                        accept,
                        context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing workers.
     *
     * @param state If specified, select workers by worker state.
     * @param channelId If specified, select workers who have a channel configuration with this channel.
     * @param queueId If specified, select workers who are assigned to this queue.
     * @param hasCapacity If set to true, select only workers who have capacity for the channel specified by `channelId`
     *     or for any channel if `channelId` not specified. If set to false, then will return all workers including
     *     workers without any capacity for jobs. Defaults to false.
     * @param maxPageSize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<RouterWorkerItemInternal> listWorkersAsync(
            RouterWorkerStateSelectorInternal state,
            String channelId,
            String queueId,
            Boolean hasCapacity,
            Integer maxPageSize) {
        return new PagedFlux<>(
                () -> listWorkersSinglePageAsync(state, channelId, queueId, hasCapacity, maxPageSize),
                nextLink -> listWorkersNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing workers.
     *
     * @param state If specified, select workers by worker state.
     * @param channelId If specified, select workers who have a channel configuration with this channel.
     * @param queueId If specified, select workers who are assigned to this queue.
     * @param hasCapacity If set to true, select only workers who have capacity for the channel specified by `channelId`
     *     or for any channel if `channelId` not specified. If set to false, then will return all workers including
     *     workers without any capacity for jobs. Defaults to false.
     * @param maxPageSize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<RouterWorkerItemInternal> listWorkersAsync(
            RouterWorkerStateSelectorInternal state,
            String channelId,
            String queueId,
            Boolean hasCapacity,
            Integer maxPageSize,
            Context context) {
        return new PagedFlux<>(
                () -> listWorkersSinglePageAsync(state, channelId, queueId, hasCapacity, maxPageSize, context),
                nextLink -> listWorkersNextSinglePageAsync(nextLink, context));
    }

    /**
     * Retrieves existing workers.
     *
     * @param state If specified, select workers by worker state.
     * @param channelId If specified, select workers who have a channel configuration with this channel.
     * @param queueId If specified, select workers who are assigned to this queue.
     * @param hasCapacity If set to true, select only workers who have capacity for the channel specified by `channelId`
     *     or for any channel if `channelId` not specified. If set to false, then will return all workers including
     *     workers without any capacity for jobs. Defaults to false.
     * @param maxPageSize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<RouterWorkerItemInternal> listWorkersSinglePage(
            RouterWorkerStateSelectorInternal state,
            String channelId,
            String queueId,
            Boolean hasCapacity,
            Integer maxPageSize) {
        return listWorkersSinglePageAsync(state, channelId, queueId, hasCapacity, maxPageSize).block();
    }

    /**
     * Retrieves existing workers.
     *
     * @param state If specified, select workers by worker state.
     * @param channelId If specified, select workers who have a channel configuration with this channel.
     * @param queueId If specified, select workers who are assigned to this queue.
     * @param hasCapacity If set to true, select only workers who have capacity for the channel specified by `channelId`
     *     or for any channel if `channelId` not specified. If set to false, then will return all workers including
     *     workers without any capacity for jobs. Defaults to false.
     * @param maxPageSize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<RouterWorkerItemInternal> listWorkersSinglePage(
            RouterWorkerStateSelectorInternal state,
            String channelId,
            String queueId,
            Boolean hasCapacity,
            Integer maxPageSize,
            Context context) {
        return listWorkersSinglePageAsync(state, channelId, queueId, hasCapacity, maxPageSize, context).block();
    }

    /**
     * Retrieves existing workers.
     *
     * @param state If specified, select workers by worker state.
     * @param channelId If specified, select workers who have a channel configuration with this channel.
     * @param queueId If specified, select workers who are assigned to this queue.
     * @param hasCapacity If set to true, select only workers who have capacity for the channel specified by `channelId`
     *     or for any channel if `channelId` not specified. If set to false, then will return all workers including
     *     workers without any capacity for jobs. Defaults to false.
     * @param maxPageSize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<RouterWorkerItemInternal> listWorkers(
            RouterWorkerStateSelectorInternal state,
            String channelId,
            String queueId,
            Boolean hasCapacity,
            Integer maxPageSize) {
        return new PagedIterable<>(listWorkersAsync(state, channelId, queueId, hasCapacity, maxPageSize));
    }

    /**
     * Retrieves existing workers.
     *
     * @param state If specified, select workers by worker state.
     * @param channelId If specified, select workers who have a channel configuration with this channel.
     * @param queueId If specified, select workers who are assigned to this queue.
     * @param hasCapacity If set to true, select only workers who have capacity for the channel specified by `channelId`
     *     or for any channel if `channelId` not specified. If set to false, then will return all workers including
     *     workers without any capacity for jobs. Defaults to false.
     * @param maxPageSize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<RouterWorkerItemInternal> listWorkers(
            RouterWorkerStateSelectorInternal state,
            String channelId,
            String queueId,
            Boolean hasCapacity,
            Integer maxPageSize,
            Context context) {
        return new PagedIterable<>(listWorkersAsync(state, channelId, queueId, hasCapacity, maxPageSize, context));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterJobItemInternal>> listJobsNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context -> service.listJobsNext(nextLink, this.client.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterJobItemInternal>> listJobsNextSinglePageAsync(String nextLink, Context context) {
        final String accept = "application/json";
        return service.listJobsNext(nextLink, this.client.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<RouterJobItemInternal> listJobsNextSinglePage(String nextLink) {
        return listJobsNextSinglePageAsync(nextLink).block();
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<RouterJobItemInternal> listJobsNextSinglePage(String nextLink, Context context) {
        return listJobsNextSinglePageAsync(nextLink, context).block();
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterWorkerItemInternal>> listWorkersNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context -> service.listWorkersNext(nextLink, this.client.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterWorkerItemInternal>> listWorkersNextSinglePageAsync(
            String nextLink, Context context) {
        final String accept = "application/json";
        return service.listWorkersNext(nextLink, this.client.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<RouterWorkerItemInternal> listWorkersNextSinglePage(String nextLink) {
        return listWorkersNextSinglePageAsync(nextLink).block();
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<RouterWorkerItemInternal> listWorkersNextSinglePage(String nextLink, Context context) {
        return listWorkersNextSinglePageAsync(nextLink, context).block();
    }
}
