// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.communication.jobrouter.implementation;

import com.azure.communication.jobrouter.models.AcceptJobOfferResponse;
import com.azure.communication.jobrouter.implementation.models.CancelJobRequest;
import com.azure.communication.jobrouter.models.ClassificationPolicy;
import com.azure.communication.jobrouter.models.ClassificationPolicyCollection;
import com.azure.communication.jobrouter.implementation.models.CloseJobRequest;
import com.azure.communication.jobrouter.implementation.models.CommunicationErrorResponseException;
import com.azure.communication.jobrouter.implementation.models.CompleteJobRequest;
import com.azure.communication.jobrouter.models.DistributionPolicy;
import com.azure.communication.jobrouter.models.DistributionPolicyCollection;
import com.azure.communication.jobrouter.models.ExceptionPolicy;
import com.azure.communication.jobrouter.implementation.models.ExceptionPolicyCollection;
import com.azure.communication.jobrouter.models.JobCollection;
import com.azure.communication.jobrouter.models.JobPositionDetails;
import com.azure.communication.jobrouter.models.JobQueue;
import com.azure.communication.jobrouter.models.JobStateSelector;
import com.azure.communication.jobrouter.models.PagedClassificationPolicy;
import com.azure.communication.jobrouter.models.PagedDistributionPolicy;
import com.azure.communication.jobrouter.models.PagedExceptionPolicy;
import com.azure.communication.jobrouter.models.PagedJob;
import com.azure.communication.jobrouter.models.PagedQueue;
import com.azure.communication.jobrouter.models.PagedWorker;
import com.azure.communication.jobrouter.implementation.models.QueueCollection;
import com.azure.communication.jobrouter.models.QueueStatistics;
import com.azure.communication.jobrouter.models.RouterJob;
import com.azure.communication.jobrouter.models.RouterWorker;
import com.azure.communication.jobrouter.models.WorkerCollection;
import com.azure.communication.jobrouter.models.WorkerStateSelector;
import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import java.time.OffsetDateTime;
import reactor.core.publisher.Mono;

/** An instance of this class provides access to all the operations defined in JobRouters. */
public final class JobRoutersImpl {
    /** The proxy service used to perform REST calls. */
    private final JobRoutersService service;

    /** The service client containing this operation class. */
    private final AzureCommunicationRoutingServiceImpl client;

    /**
     * Initializes an instance of JobRoutersImpl.
     *
     * @param client the instance of the service client containing this operation class.
     */
    JobRoutersImpl(AzureCommunicationRoutingServiceImpl client) {
        this.service =
                RestProxy.create(JobRoutersService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for AzureCommunicationRoutingServiceJobRouters to be used by the proxy
     * service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "AzureCommunicationRo")
    private interface JobRoutersService {
        @Patch("/routing/classificationPolicies/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ClassificationPolicy>> upsertClassificationPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/merge-patch+json") ClassificationPolicy patch,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/classificationPolicies/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ClassificationPolicy>> getClassificationPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/routing/classificationPolicies/{id}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Void>> deleteClassificationPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/classificationPolicies")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ClassificationPolicyCollection>> listClassificationPolicies(
                @HostParam("endpoint") String endpoint,
                @QueryParam("maxpagesize") Integer maxpagesize,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/routing/distributionPolicies/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<DistributionPolicy>> upsertDistributionPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/merge-patch+json") DistributionPolicy patch,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/distributionPolicies/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<DistributionPolicy>> getDistributionPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/routing/distributionPolicies/{id}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Void>> deleteDistributionPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/distributionPolicies")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<DistributionPolicyCollection>> listDistributionPolicies(
                @HostParam("endpoint") String endpoint,
                @QueryParam("maxpagesize") Integer maxpagesize,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/routing/exceptionPolicies/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ExceptionPolicy>> upsertExceptionPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/merge-patch+json") ExceptionPolicy patch,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/exceptionPolicies/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ExceptionPolicy>> getExceptionPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/routing/exceptionPolicies/{id}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Void>> deleteExceptionPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/exceptionPolicies")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ExceptionPolicyCollection>> listExceptionPolicies(
                @HostParam("endpoint") String endpoint,
                @QueryParam("maxpagesize") Integer maxpagesize,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/routing/jobs/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterJob>> upsertJob(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/merge-patch+json") RouterJob patch,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/jobs/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterJob>> getJob(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/routing/jobs/{id}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Void>> deleteJob(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/jobs/{id}:reclassify")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Object>> reclassifyJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") Object reclassifyJobRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/jobs/{id}:cancel")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Object>> cancelJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") CancelJobRequest cancelJobRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/jobs/{id}:complete")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Object>> completeJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") CompleteJobRequest completeJobRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/jobs/{id}:close")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Object>> closeJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") CloseJobRequest closeJobRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/jobs")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<JobCollection>> listJobs(
                @HostParam("endpoint") String endpoint,
                @QueryParam("status") JobStateSelector status,
                @QueryParam("queueId") String queueId,
                @QueryParam("channelId") String channelId,
                @QueryParam("maxpagesize") Integer maxpagesize,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/jobs/{id}/position")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<JobPositionDetails>> getInQueuePosition(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/workers/{workerId}/offers/{offerId}:accept")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<AcceptJobOfferResponse>> acceptJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("workerId") String workerId,
                @PathParam("offerId") String offerId,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/workers/{workerId}/offers/{offerId}:decline")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Object>> declineJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("workerId") String workerId,
                @PathParam("offerId") String offerId,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/routing/queues/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<JobQueue>> upsertQueue(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/merge-patch+json") JobQueue patch,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/queues/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<JobQueue>> getQueue(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/routing/queues/{id}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Void>> deleteQueue(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/queues")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<QueueCollection>> listQueues(
                @HostParam("endpoint") String endpoint,
                @QueryParam("maxpagesize") Integer maxpagesize,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/queues/{id}/statistics")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<QueueStatistics>> getQueueStatistics(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/routing/workers/{workerId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterWorker>> upsertWorker(
                @HostParam("endpoint") String endpoint,
                @PathParam("workerId") String workerId,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/merge-patch+json") RouterWorker patch,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/workers/{workerId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterWorker>> getWorker(
                @HostParam("endpoint") String endpoint,
                @PathParam("workerId") String workerId,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/routing/workers/{workerId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Void>> deleteWorker(
                @HostParam("endpoint") String endpoint,
                @PathParam("workerId") String workerId,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/workers")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<WorkerCollection>> listWorkers(
                @HostParam("endpoint") String endpoint,
                @QueryParam("status") WorkerStateSelector status,
                @QueryParam("channelId") String channelId,
                @QueryParam("queueId") String queueId,
                @QueryParam("hasCapacity") Boolean hasCapacity,
                @QueryParam("maxpagesize") Integer maxpagesize,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ClassificationPolicyCollection>> listClassificationPoliciesNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<DistributionPolicyCollection>> listDistributionPoliciesNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ExceptionPolicyCollection>> listExceptionPoliciesNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<JobCollection>> listJobsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<QueueCollection>> listQueuesNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<WorkerCollection>> listWorkersNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);
    }

    /**
     * Upsert a classification policy.
     *
     * @param id Id of the classification policy.
     * @param patch Model of classification policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ClassificationPolicy>> upsertClassificationPolicyWithResponseAsync(
            String id, ClassificationPolicy patch) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upsertClassificationPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context));
    }

    /**
     * Upsert a classification policy.
     *
     * @param id Id of the classification policy.
     * @param patch Model of classification policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ClassificationPolicy>> upsertClassificationPolicyWithResponseAsync(
            String id, ClassificationPolicy patch, Context context) {
        final String accept = "application/json";
        return service.upsertClassificationPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context);
    }

    /**
     * Upsert a classification policy.
     *
     * @param id Id of the classification policy.
     * @param patch Model of classification policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ClassificationPolicy> upsertClassificationPolicyAsync(String id, ClassificationPolicy patch) {
        return upsertClassificationPolicyWithResponseAsync(id, patch).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Upsert a classification policy.
     *
     * @param id Id of the classification policy.
     * @param patch Model of classification policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ClassificationPolicy> upsertClassificationPolicyAsync(
            String id, ClassificationPolicy patch, Context context) {
        return upsertClassificationPolicyWithResponseAsync(id, patch, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Upsert a classification policy.
     *
     * @param id Id of the classification policy.
     * @param patch Model of classification policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ClassificationPolicy upsertClassificationPolicy(String id, ClassificationPolicy patch) {
        return upsertClassificationPolicyAsync(id, patch).block();
    }

    /**
     * Upsert a classification policy.
     *
     * @param id Id of the classification policy.
     * @param patch Model of classification policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<ClassificationPolicy> upsertClassificationPolicyWithResponse(
            String id, ClassificationPolicy patch, Context context) {
        return upsertClassificationPolicyWithResponseAsync(id, patch, context).block();
    }

    /**
     * Retrieves an existing classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ClassificationPolicy>> getClassificationPolicyWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getClassificationPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves an existing classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ClassificationPolicy>> getClassificationPolicyWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.getClassificationPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves an existing classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ClassificationPolicy> getClassificationPolicyAsync(String id) {
        return getClassificationPolicyWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ClassificationPolicy> getClassificationPolicyAsync(String id, Context context) {
        return getClassificationPolicyWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ClassificationPolicy getClassificationPolicy(String id) {
        return getClassificationPolicyAsync(id).block();
    }

    /**
     * Retrieves an existing classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<ClassificationPolicy> getClassificationPolicyWithResponse(String id, Context context) {
        return getClassificationPolicyWithResponseAsync(id, context).block();
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteClassificationPolicyWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteClassificationPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteClassificationPolicyWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.deleteClassificationPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteClassificationPolicyAsync(String id) {
        return deleteClassificationPolicyWithResponseAsync(id).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteClassificationPolicyAsync(String id, Context context) {
        return deleteClassificationPolicyWithResponseAsync(id, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteClassificationPolicy(String id) {
        deleteClassificationPolicyAsync(id).block();
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteClassificationPolicyWithResponse(String id, Context context) {
        return deleteClassificationPolicyWithResponseAsync(id, context).block();
    }

    /**
     * Retrieves existing classification policies.
     *
     * @param maxpagesize Maximum page size.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies along with {@link PagedResponse} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedClassificationPolicy>> listClassificationPoliciesSinglePageAsync(
            Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listClassificationPolicies(
                                        this.client.getEndpoint(),
                                        maxpagesize,
                                        this.client.getApiVersion(),
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing classification policies.
     *
     * @param maxpagesize Maximum page size.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies along with {@link PagedResponse} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedClassificationPolicy>> listClassificationPoliciesSinglePageAsync(
            Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.listClassificationPolicies(
                        this.client.getEndpoint(), maxpagesize, this.client.getApiVersion(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing classification policies.
     *
     * @param maxpagesize Maximum page size.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedClassificationPolicy> listClassificationPoliciesAsync(Integer maxpagesize) {
        return new PagedFlux<>(
                () -> listClassificationPoliciesSinglePageAsync(maxpagesize),
                nextLink -> listClassificationPoliciesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing classification policies.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedClassificationPolicy> listClassificationPoliciesAsync() {
        final Integer maxpagesize = null;
        return new PagedFlux<>(
                () -> listClassificationPoliciesSinglePageAsync(maxpagesize),
                nextLink -> listClassificationPoliciesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing classification policies.
     *
     * @param maxpagesize Maximum page size.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedClassificationPolicy> listClassificationPoliciesAsync(Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> listClassificationPoliciesSinglePageAsync(maxpagesize, context),
                nextLink -> listClassificationPoliciesNextSinglePageAsync(nextLink, context));
    }

    /**
     * Retrieves existing classification policies.
     *
     * @param maxpagesize Maximum page size.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedClassificationPolicy> listClassificationPolicies(Integer maxpagesize) {
        return new PagedIterable<>(listClassificationPoliciesAsync(maxpagesize));
    }

    /**
     * Retrieves existing classification policies.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedClassificationPolicy> listClassificationPolicies() {
        final Integer maxpagesize = null;
        return new PagedIterable<>(listClassificationPoliciesAsync(maxpagesize));
    }

    /**
     * Retrieves existing classification policies.
     *
     * @param maxpagesize Maximum page size.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedClassificationPolicy> listClassificationPolicies(Integer maxpagesize, Context context) {
        return new PagedIterable<>(listClassificationPoliciesAsync(maxpagesize, context));
    }

    /**
     * Upsert a distribution policy.
     *
     * @param id Id of the distribution policy.
     * @param patch Model of distribution policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers along with {@link Response} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DistributionPolicy>> upsertDistributionPolicyWithResponseAsync(
            String id, DistributionPolicy patch) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upsertDistributionPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context));
    }

    /**
     * Upsert a distribution policy.
     *
     * @param id Id of the distribution policy.
     * @param patch Model of distribution policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers along with {@link Response} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DistributionPolicy>> upsertDistributionPolicyWithResponseAsync(
            String id, DistributionPolicy patch, Context context) {
        final String accept = "application/json";
        return service.upsertDistributionPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context);
    }

    /**
     * Upsert a distribution policy.
     *
     * @param id Id of the distribution policy.
     * @param patch Model of distribution policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DistributionPolicy> upsertDistributionPolicyAsync(String id, DistributionPolicy patch) {
        return upsertDistributionPolicyWithResponseAsync(id, patch).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Upsert a distribution policy.
     *
     * @param id Id of the distribution policy.
     * @param patch Model of distribution policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DistributionPolicy> upsertDistributionPolicyAsync(
            String id, DistributionPolicy patch, Context context) {
        return upsertDistributionPolicyWithResponseAsync(id, patch, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Upsert a distribution policy.
     *
     * @param id Id of the distribution policy.
     * @param patch Model of distribution policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DistributionPolicy upsertDistributionPolicy(String id, DistributionPolicy patch) {
        return upsertDistributionPolicyAsync(id, patch).block();
    }

    /**
     * Upsert a distribution policy.
     *
     * @param id Id of the distribution policy.
     * @param patch Model of distribution policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DistributionPolicy> upsertDistributionPolicyWithResponse(
            String id, DistributionPolicy patch, Context context) {
        return upsertDistributionPolicyWithResponseAsync(id, patch, context).block();
    }

    /**
     * Retrieves an existing distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers along with {@link Response} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DistributionPolicy>> getDistributionPolicyWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getDistributionPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves an existing distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers along with {@link Response} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DistributionPolicy>> getDistributionPolicyWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.getDistributionPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves an existing distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DistributionPolicy> getDistributionPolicyAsync(String id) {
        return getDistributionPolicyWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DistributionPolicy> getDistributionPolicyAsync(String id, Context context) {
        return getDistributionPolicyWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DistributionPolicy getDistributionPolicy(String id) {
        return getDistributionPolicyAsync(id).block();
    }

    /**
     * Retrieves an existing distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DistributionPolicy> getDistributionPolicyWithResponse(String id, Context context) {
        return getDistributionPolicyWithResponseAsync(id, context).block();
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteDistributionPolicyWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteDistributionPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteDistributionPolicyWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.deleteDistributionPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteDistributionPolicyAsync(String id) {
        return deleteDistributionPolicyWithResponseAsync(id).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteDistributionPolicyAsync(String id, Context context) {
        return deleteDistributionPolicyWithResponseAsync(id, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteDistributionPolicy(String id) {
        deleteDistributionPolicyAsync(id).block();
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDistributionPolicyWithResponse(String id, Context context) {
        return deleteDistributionPolicyWithResponseAsync(id, context).block();
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @param maxpagesize Maximum page size.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedDistributionPolicy>> listDistributionPoliciesSinglePageAsync(Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listDistributionPolicies(
                                        this.client.getEndpoint(),
                                        maxpagesize,
                                        this.client.getApiVersion(),
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @param maxpagesize Maximum page size.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedDistributionPolicy>> listDistributionPoliciesSinglePageAsync(
            Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.listDistributionPolicies(
                        this.client.getEndpoint(), maxpagesize, this.client.getApiVersion(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @param maxpagesize Maximum page size.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedDistributionPolicy> listDistributionPoliciesAsync(Integer maxpagesize) {
        return new PagedFlux<>(
                () -> listDistributionPoliciesSinglePageAsync(maxpagesize),
                nextLink -> listDistributionPoliciesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedDistributionPolicy> listDistributionPoliciesAsync() {
        final Integer maxpagesize = null;
        return new PagedFlux<>(
                () -> listDistributionPoliciesSinglePageAsync(maxpagesize),
                nextLink -> listDistributionPoliciesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @param maxpagesize Maximum page size.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedDistributionPolicy> listDistributionPoliciesAsync(Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> listDistributionPoliciesSinglePageAsync(maxpagesize, context),
                nextLink -> listDistributionPoliciesNextSinglePageAsync(nextLink, context));
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @param maxpagesize Maximum page size.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedDistributionPolicy> listDistributionPolicies(Integer maxpagesize) {
        return new PagedIterable<>(listDistributionPoliciesAsync(maxpagesize));
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedDistributionPolicy> listDistributionPolicies() {
        final Integer maxpagesize = null;
        return new PagedIterable<>(listDistributionPoliciesAsync(maxpagesize));
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @param maxpagesize Maximum page size.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedDistributionPolicy> listDistributionPolicies(Integer maxpagesize, Context context) {
        return new PagedIterable<>(listDistributionPoliciesAsync(maxpagesize, context));
    }

    /**
     * Upsert a exception policy.
     *
     * @param id Id of the exception policy.
     * @param patch Model of exception policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response} on
     *     successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ExceptionPolicy>> upsertExceptionPolicyWithResponseAsync(String id, ExceptionPolicy patch) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upsertExceptionPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context));
    }

    /**
     * Upsert a exception policy.
     *
     * @param id Id of the exception policy.
     * @param patch Model of exception policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response} on
     *     successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ExceptionPolicy>> upsertExceptionPolicyWithResponseAsync(
            String id, ExceptionPolicy patch, Context context) {
        final String accept = "application/json";
        return service.upsertExceptionPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context);
    }

    /**
     * Upsert a exception policy.
     *
     * @param id Id of the exception policy.
     * @param patch Model of exception policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ExceptionPolicy> upsertExceptionPolicyAsync(String id, ExceptionPolicy patch) {
        return upsertExceptionPolicyWithResponseAsync(id, patch).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Upsert a exception policy.
     *
     * @param id Id of the exception policy.
     * @param patch Model of exception policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ExceptionPolicy> upsertExceptionPolicyAsync(String id, ExceptionPolicy patch, Context context) {
        return upsertExceptionPolicyWithResponseAsync(id, patch, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Upsert a exception policy.
     *
     * @param id Id of the exception policy.
     * @param patch Model of exception policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ExceptionPolicy upsertExceptionPolicy(String id, ExceptionPolicy patch) {
        return upsertExceptionPolicyAsync(id, patch).block();
    }

    /**
     * Upsert a exception policy.
     *
     * @param id Id of the exception policy.
     * @param patch Model of exception policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<ExceptionPolicy> upsertExceptionPolicyWithResponse(
            String id, ExceptionPolicy patch, Context context) {
        return upsertExceptionPolicyWithResponseAsync(id, patch, context).block();
    }

    /**
     * Retrieves an existing exception policy by Id.
     *
     * @param id Id of the exception policy to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response} on
     *     successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ExceptionPolicy>> getExceptionPolicyWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getExceptionPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves an existing exception policy by Id.
     *
     * @param id Id of the exception policy to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response} on
     *     successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ExceptionPolicy>> getExceptionPolicyWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.getExceptionPolicy(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves an existing exception policy by Id.
     *
     * @param id Id of the exception policy to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ExceptionPolicy> getExceptionPolicyAsync(String id) {
        return getExceptionPolicyWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing exception policy by Id.
     *
     * @param id Id of the exception policy to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ExceptionPolicy> getExceptionPolicyAsync(String id, Context context) {
        return getExceptionPolicyWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing exception policy by Id.
     *
     * @param id Id of the exception policy to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ExceptionPolicy getExceptionPolicy(String id) {
        return getExceptionPolicyAsync(id).block();
    }

    /**
     * Retrieves an existing exception policy by Id.
     *
     * @param id Id of the exception policy to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<ExceptionPolicy> getExceptionPolicyWithResponse(String id, Context context) {
        return getExceptionPolicyWithResponseAsync(id, context).block();
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param id Id of the exception policy to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteExceptionPolicyWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteExceptionPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param id Id of the exception policy to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteExceptionPolicyWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.deleteExceptionPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param id Id of the exception policy to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteExceptionPolicyAsync(String id) {
        return deleteExceptionPolicyWithResponseAsync(id).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param id Id of the exception policy to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteExceptionPolicyAsync(String id, Context context) {
        return deleteExceptionPolicyWithResponseAsync(id, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param id Id of the exception policy to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteExceptionPolicy(String id) {
        deleteExceptionPolicyAsync(id).block();
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param id Id of the exception policy to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteExceptionPolicyWithResponse(String id, Context context) {
        return deleteExceptionPolicyWithResponseAsync(id, context).block();
    }

    /**
     * Retrieves existing exception policies.
     *
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedExceptionPolicy>> listExceptionPoliciesSinglePageAsync(Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listExceptionPolicies(
                                        this.client.getEndpoint(),
                                        maxpagesize,
                                        this.client.getApiVersion(),
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing exception policies.
     *
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedExceptionPolicy>> listExceptionPoliciesSinglePageAsync(
            Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.listExceptionPolicies(
                        this.client.getEndpoint(), maxpagesize, this.client.getApiVersion(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing exception policies.
     *
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedExceptionPolicy> listExceptionPoliciesAsync(Integer maxpagesize) {
        return new PagedFlux<>(
                () -> listExceptionPoliciesSinglePageAsync(maxpagesize),
                nextLink -> listExceptionPoliciesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing exception policies.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedExceptionPolicy> listExceptionPoliciesAsync() {
        final Integer maxpagesize = null;
        return new PagedFlux<>(
                () -> listExceptionPoliciesSinglePageAsync(maxpagesize),
                nextLink -> listExceptionPoliciesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing exception policies.
     *
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedExceptionPolicy> listExceptionPoliciesAsync(Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> listExceptionPoliciesSinglePageAsync(maxpagesize, context),
                nextLink -> listExceptionPoliciesNextSinglePageAsync(nextLink, context));
    }

    /**
     * Retrieves existing exception policies.
     *
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedExceptionPolicy> listExceptionPolicies(Integer maxpagesize) {
        return new PagedIterable<>(listExceptionPoliciesAsync(maxpagesize));
    }

    /**
     * Retrieves existing exception policies.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedExceptionPolicy> listExceptionPolicies() {
        final Integer maxpagesize = null;
        return new PagedIterable<>(listExceptionPoliciesAsync(maxpagesize));
    }

    /**
     * Retrieves existing exception policies.
     *
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedExceptionPolicy> listExceptionPolicies(Integer maxpagesize, Context context) {
        return new PagedIterable<>(listExceptionPoliciesAsync(maxpagesize, context));
    }

    /**
     * Upsert a job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterJob>> upsertJobWithResponseAsync(String id, RouterJob patch) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upsertJob(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context));
    }

    /**
     * Upsert a job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterJob>> upsertJobWithResponseAsync(String id, RouterJob patch, Context context) {
        final String accept = "application/json";
        return service.upsertJob(this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context);
    }

    /**
     * Upsert a job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterJob> upsertJobAsync(String id, RouterJob patch) {
        return upsertJobWithResponseAsync(id, patch).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Upsert a job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterJob> upsertJobAsync(String id, RouterJob patch, Context context) {
        return upsertJobWithResponseAsync(id, patch, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Upsert a job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterJob upsertJob(String id, RouterJob patch) {
        return upsertJobAsync(id, patch).block();
    }

    /**
     * Upsert a job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RouterJob> upsertJobWithResponse(String id, RouterJob patch, Context context) {
        return upsertJobWithResponseAsync(id, patch, context).block();
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterJob>> getJobWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getJob(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterJob>> getJobWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.getJob(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterJob> getJobAsync(String id) {
        return getJobWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterJob> getJobAsync(String id, Context context) {
        return getJobWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterJob getJob(String id) {
        return getJobAsync(id).block();
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RouterJob> getJobWithResponse(String id, Context context) {
        return getJobWithResponseAsync(id, context).block();
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteJobWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteJob(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteJobWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.deleteJob(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteJobAsync(String id) {
        return deleteJobWithResponseAsync(id).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteJobAsync(String id, Context context) {
        return deleteJobWithResponseAsync(id, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteJob(String id) {
        deleteJobAsync(id).block();
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteJobWithResponse(String id, Context context) {
        return deleteJobWithResponseAsync(id, context).block();
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> reclassifyJobActionWithResponseAsync(String id, Object reclassifyJobRequest) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.reclassifyJobAction(
                                this.client.getEndpoint(),
                                id,
                                this.client.getApiVersion(),
                                reclassifyJobRequest,
                                accept,
                                context));
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> reclassifyJobActionWithResponseAsync(
            String id, Object reclassifyJobRequest, Context context) {
        final String accept = "application/json";
        return service.reclassifyJobAction(
                this.client.getEndpoint(), id, this.client.getApiVersion(), reclassifyJobRequest, accept, context);
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> reclassifyJobActionAsync(String id, Object reclassifyJobRequest) {
        return reclassifyJobActionWithResponseAsync(id, reclassifyJobRequest)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> reclassifyJobActionAsync(String id) {
        final Object reclassifyJobRequest = null;
        return reclassifyJobActionWithResponseAsync(id, reclassifyJobRequest)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> reclassifyJobActionAsync(String id, Object reclassifyJobRequest, Context context) {
        return reclassifyJobActionWithResponseAsync(id, reclassifyJobRequest, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object reclassifyJobAction(String id, Object reclassifyJobRequest) {
        return reclassifyJobActionAsync(id, reclassifyJobRequest).block();
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object reclassifyJobAction(String id) {
        final Object reclassifyJobRequest = null;
        return reclassifyJobActionAsync(id, reclassifyJobRequest).block();
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Object> reclassifyJobActionWithResponse(String id, Object reclassifyJobRequest, Context context) {
        return reclassifyJobActionWithResponseAsync(id, reclassifyJobRequest, context).block();
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> cancelJobActionWithResponseAsync(String id, String note, String dispositionCode) {
        final String accept = "application/json";
        CancelJobRequest cancelJobRequestInternal = null;
        if (note != null || dispositionCode != null) {
            cancelJobRequestInternal = new CancelJobRequest();
            cancelJobRequestInternal.setNote(note);
            cancelJobRequestInternal.setDispositionCode(dispositionCode);
        }
        CancelJobRequest cancelJobRequest = cancelJobRequestInternal;
        return FluxUtil.withContext(
                context ->
                        service.cancelJobAction(
                                this.client.getEndpoint(),
                                id,
                                this.client.getApiVersion(),
                                cancelJobRequest,
                                accept,
                                context));
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> cancelJobActionWithResponseAsync(
            String id, String note, String dispositionCode, Context context) {
        final String accept = "application/json";
        CancelJobRequest cancelJobRequestInternal = null;
        if (note != null || dispositionCode != null) {
            cancelJobRequestInternal = new CancelJobRequest();
            cancelJobRequestInternal.setNote(note);
            cancelJobRequestInternal.setDispositionCode(dispositionCode);
        }
        CancelJobRequest cancelJobRequest = cancelJobRequestInternal;
        return service.cancelJobAction(
                this.client.getEndpoint(), id, this.client.getApiVersion(), cancelJobRequest, accept, context);
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> cancelJobActionAsync(String id, String note, String dispositionCode) {
        return cancelJobActionWithResponseAsync(id, note, dispositionCode)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> cancelJobActionAsync(String id) {
        final String note = null;
        final String dispositionCode = null;
        return cancelJobActionWithResponseAsync(id, note, dispositionCode)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> cancelJobActionAsync(String id, String note, String dispositionCode, Context context) {
        return cancelJobActionWithResponseAsync(id, note, dispositionCode, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object cancelJobAction(String id, String note, String dispositionCode) {
        return cancelJobActionAsync(id, note, dispositionCode).block();
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object cancelJobAction(String id) {
        final String note = null;
        final String dispositionCode = null;
        return cancelJobActionAsync(id, note, dispositionCode).block();
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Object> cancelJobActionWithResponse(
            String id, String note, String dispositionCode, Context context) {
        return cancelJobActionWithResponseAsync(id, note, dispositionCode, context).block();
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> completeJobActionWithResponseAsync(String id, String assignmentId, String note) {
        final String accept = "application/json";
        CompleteJobRequest completeJobRequest = new CompleteJobRequest();
        completeJobRequest.setAssignmentId(assignmentId);
        completeJobRequest.setNote(note);
        return FluxUtil.withContext(
                context ->
                        service.completeJobAction(
                                this.client.getEndpoint(),
                                id,
                                this.client.getApiVersion(),
                                completeJobRequest,
                                accept,
                                context));
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> completeJobActionWithResponseAsync(
            String id, String assignmentId, String note, Context context) {
        final String accept = "application/json";
        CompleteJobRequest completeJobRequest = new CompleteJobRequest();
        completeJobRequest.setAssignmentId(assignmentId);
        completeJobRequest.setNote(note);
        return service.completeJobAction(
                this.client.getEndpoint(), id, this.client.getApiVersion(), completeJobRequest, accept, context);
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> completeJobActionAsync(String id, String assignmentId, String note) {
        return completeJobActionWithResponseAsync(id, assignmentId, note)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> completeJobActionAsync(String id, String assignmentId) {
        final String note = null;
        return completeJobActionWithResponseAsync(id, assignmentId, note)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> completeJobActionAsync(String id, String assignmentId, String note, Context context) {
        return completeJobActionWithResponseAsync(id, assignmentId, note, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object completeJobAction(String id, String assignmentId, String note) {
        return completeJobActionAsync(id, assignmentId, note).block();
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object completeJobAction(String id, String assignmentId) {
        final String note = null;
        return completeJobActionAsync(id, assignmentId, note).block();
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Object> completeJobActionWithResponse(
            String id, String assignmentId, String note, Context context) {
        return completeJobActionWithResponseAsync(id, assignmentId, note, context).block();
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeTime If not provided, worker capacity is released immediately along with a JobClosedEvent
     *     notification. If provided, worker capacity is released along with a JobClosedEvent notification at a future
     *     time.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> closeJobActionWithResponseAsync(
            String id, String assignmentId, String dispositionCode, OffsetDateTime closeTime, String note) {
        final String accept = "application/json";
        CloseJobRequest closeJobRequest = new CloseJobRequest();
        closeJobRequest.setAssignmentId(assignmentId);
        closeJobRequest.setDispositionCode(dispositionCode);
        closeJobRequest.setCloseTime(closeTime);
        closeJobRequest.setNote(note);
        return FluxUtil.withContext(
                context ->
                        service.closeJobAction(
                                this.client.getEndpoint(),
                                id,
                                this.client.getApiVersion(),
                                closeJobRequest,
                                accept,
                                context));
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeTime If not provided, worker capacity is released immediately along with a JobClosedEvent
     *     notification. If provided, worker capacity is released along with a JobClosedEvent notification at a future
     *     time.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> closeJobActionWithResponseAsync(
            String id,
            String assignmentId,
            String dispositionCode,
            OffsetDateTime closeTime,
            String note,
            Context context) {
        final String accept = "application/json";
        CloseJobRequest closeJobRequest = new CloseJobRequest();
        closeJobRequest.setAssignmentId(assignmentId);
        closeJobRequest.setDispositionCode(dispositionCode);
        closeJobRequest.setCloseTime(closeTime);
        closeJobRequest.setNote(note);
        return service.closeJobAction(
                this.client.getEndpoint(), id, this.client.getApiVersion(), closeJobRequest, accept, context);
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeTime If not provided, worker capacity is released immediately along with a JobClosedEvent
     *     notification. If provided, worker capacity is released along with a JobClosedEvent notification at a future
     *     time.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> closeJobActionAsync(
            String id, String assignmentId, String dispositionCode, OffsetDateTime closeTime, String note) {
        return closeJobActionWithResponseAsync(id, assignmentId, dispositionCode, closeTime, note)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> closeJobActionAsync(String id, String assignmentId) {
        final String dispositionCode = null;
        final OffsetDateTime closeTime = null;
        final String note = null;
        return closeJobActionWithResponseAsync(id, assignmentId, dispositionCode, closeTime, note)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeTime If not provided, worker capacity is released immediately along with a JobClosedEvent
     *     notification. If provided, worker capacity is released along with a JobClosedEvent notification at a future
     *     time.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> closeJobActionAsync(
            String id,
            String assignmentId,
            String dispositionCode,
            OffsetDateTime closeTime,
            String note,
            Context context) {
        return closeJobActionWithResponseAsync(id, assignmentId, dispositionCode, closeTime, note, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeTime If not provided, worker capacity is released immediately along with a JobClosedEvent
     *     notification. If provided, worker capacity is released along with a JobClosedEvent notification at a future
     *     time.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object closeJobAction(
            String id, String assignmentId, String dispositionCode, OffsetDateTime closeTime, String note) {
        return closeJobActionAsync(id, assignmentId, dispositionCode, closeTime, note).block();
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object closeJobAction(String id, String assignmentId) {
        final String dispositionCode = null;
        final OffsetDateTime closeTime = null;
        final String note = null;
        return closeJobActionAsync(id, assignmentId, dispositionCode, closeTime, note).block();
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeTime If not provided, worker capacity is released immediately along with a JobClosedEvent
     *     notification. If provided, worker capacity is released along with a JobClosedEvent notification at a future
     *     time.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Object> closeJobActionWithResponse(
            String id,
            String assignmentId,
            String dispositionCode,
            OffsetDateTime closeTime,
            String note,
            Context context) {
        return closeJobActionWithResponseAsync(id, assignmentId, dispositionCode, closeTime, note, context).block();
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status (Optional) If specified, filter jobs by status.
     * @param queueId (Optional) If specified, filter jobs by queue.
     * @param channelId (Optional) If specified, filter jobs by channel.
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedJob>> listJobsSinglePageAsync(
            JobStateSelector status, String queueId, String channelId, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listJobs(
                                        this.client.getEndpoint(),
                                        status,
                                        queueId,
                                        channelId,
                                        maxpagesize,
                                        this.client.getApiVersion(),
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status (Optional) If specified, filter jobs by status.
     * @param queueId (Optional) If specified, filter jobs by queue.
     * @param channelId (Optional) If specified, filter jobs by channel.
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedJob>> listJobsSinglePageAsync(
            JobStateSelector status, String queueId, String channelId, Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.listJobs(
                        this.client.getEndpoint(),
                        status,
                        queueId,
                        channelId,
                        maxpagesize,
                        this.client.getApiVersion(),
                        accept,
                        context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status (Optional) If specified, filter jobs by status.
     * @param queueId (Optional) If specified, filter jobs by queue.
     * @param channelId (Optional) If specified, filter jobs by channel.
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedJob> listJobsAsync(
            JobStateSelector status, String queueId, String channelId, Integer maxpagesize) {
        return new PagedFlux<>(
                () -> listJobsSinglePageAsync(status, queueId, channelId, maxpagesize),
                nextLink -> listJobsNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedJob> listJobsAsync() {
        final JobStateSelector status = null;
        final String queueId = null;
        final String channelId = null;
        final Integer maxpagesize = null;
        return new PagedFlux<>(
                () -> listJobsSinglePageAsync(status, queueId, channelId, maxpagesize),
                nextLink -> listJobsNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status (Optional) If specified, filter jobs by status.
     * @param queueId (Optional) If specified, filter jobs by queue.
     * @param channelId (Optional) If specified, filter jobs by channel.
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedJob> listJobsAsync(
            JobStateSelector status, String queueId, String channelId, Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> listJobsSinglePageAsync(status, queueId, channelId, maxpagesize, context),
                nextLink -> listJobsNextSinglePageAsync(nextLink, context));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status (Optional) If specified, filter jobs by status.
     * @param queueId (Optional) If specified, filter jobs by queue.
     * @param channelId (Optional) If specified, filter jobs by channel.
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedJob> listJobs(
            JobStateSelector status, String queueId, String channelId, Integer maxpagesize) {
        return new PagedIterable<>(listJobsAsync(status, queueId, channelId, maxpagesize));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedJob> listJobs() {
        final JobStateSelector status = null;
        final String queueId = null;
        final String channelId = null;
        final Integer maxpagesize = null;
        return new PagedIterable<>(listJobsAsync(status, queueId, channelId, maxpagesize));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status (Optional) If specified, filter jobs by status.
     * @param queueId (Optional) If specified, filter jobs by queue.
     * @param channelId (Optional) If specified, filter jobs by channel.
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedJob> listJobs(
            JobStateSelector status, String queueId, String channelId, Integer maxpagesize, Context context) {
        return new PagedIterable<>(listJobsAsync(status, queueId, channelId, maxpagesize, context));
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<JobPositionDetails>> getInQueuePositionWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getInQueuePosition(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<JobPositionDetails>> getInQueuePositionWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.getInQueuePosition(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<JobPositionDetails> getInQueuePositionAsync(String id) {
        return getInQueuePositionWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<JobPositionDetails> getInQueuePositionAsync(String id, Context context) {
        return getInQueuePositionWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public JobPositionDetails getInQueuePosition(String id) {
        return getInQueuePositionAsync(id).block();
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<JobPositionDetails> getInQueuePositionWithResponse(String id, Context context) {
        return getInQueuePositionWithResponseAsync(id, context).block();
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer along with {@link
     *     Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AcceptJobOfferResponse>> acceptJobActionWithResponseAsync(String workerId, String offerId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.acceptJobAction(
                                this.client.getEndpoint(),
                                workerId,
                                offerId,
                                this.client.getApiVersion(),
                                accept,
                                context));
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer along with {@link
     *     Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AcceptJobOfferResponse>> acceptJobActionWithResponseAsync(
            String workerId, String offerId, Context context) {
        final String accept = "application/json";
        return service.acceptJobAction(
                this.client.getEndpoint(), workerId, offerId, this.client.getApiVersion(), accept, context);
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AcceptJobOfferResponse> acceptJobActionAsync(String workerId, String offerId) {
        return acceptJobActionWithResponseAsync(workerId, offerId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AcceptJobOfferResponse> acceptJobActionAsync(String workerId, String offerId, Context context) {
        return acceptJobActionWithResponseAsync(workerId, offerId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AcceptJobOfferResponse acceptJobAction(String workerId, String offerId) {
        return acceptJobActionAsync(workerId, offerId).block();
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer along with {@link
     *     Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AcceptJobOfferResponse> acceptJobActionWithResponse(
            String workerId, String offerId, Context context) {
        return acceptJobActionWithResponseAsync(workerId, offerId, context).block();
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> declineJobActionWithResponseAsync(String workerId, String offerId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.declineJobAction(
                                this.client.getEndpoint(),
                                workerId,
                                offerId,
                                this.client.getApiVersion(),
                                accept,
                                context));
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> declineJobActionWithResponseAsync(String workerId, String offerId, Context context) {
        final String accept = "application/json";
        return service.declineJobAction(
                this.client.getEndpoint(), workerId, offerId, this.client.getApiVersion(), accept, context);
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> declineJobActionAsync(String workerId, String offerId) {
        return declineJobActionWithResponseAsync(workerId, offerId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> declineJobActionAsync(String workerId, String offerId, Context context) {
        return declineJobActionWithResponseAsync(workerId, offerId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object declineJobAction(String workerId, String offerId) {
        return declineJobActionAsync(workerId, offerId).block();
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Object> declineJobActionWithResponse(String workerId, String offerId, Context context) {
        return declineJobActionWithResponseAsync(workerId, offerId, context).block();
    }

    /**
     * Upsert a queue.
     *
     * @param id Id of the queue.
     * @param patch Model of queue properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed along with {@link Response} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<JobQueue>> upsertQueueWithResponseAsync(String id, JobQueue patch) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upsertQueue(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context));
    }

    /**
     * Upsert a queue.
     *
     * @param id Id of the queue.
     * @param patch Model of queue properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed along with {@link Response} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<JobQueue>> upsertQueueWithResponseAsync(String id, JobQueue patch, Context context) {
        final String accept = "application/json";
        return service.upsertQueue(this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context);
    }

    /**
     * Upsert a queue.
     *
     * @param id Id of the queue.
     * @param patch Model of queue properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<JobQueue> upsertQueueAsync(String id, JobQueue patch) {
        return upsertQueueWithResponseAsync(id, patch).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Upsert a queue.
     *
     * @param id Id of the queue.
     * @param patch Model of queue properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<JobQueue> upsertQueueAsync(String id, JobQueue patch, Context context) {
        return upsertQueueWithResponseAsync(id, patch, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Upsert a queue.
     *
     * @param id Id of the queue.
     * @param patch Model of queue properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public JobQueue upsertQueue(String id, JobQueue patch) {
        return upsertQueueAsync(id, patch).block();
    }

    /**
     * Upsert a queue.
     *
     * @param id Id of the queue.
     * @param patch Model of queue properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<JobQueue> upsertQueueWithResponse(String id, JobQueue patch, Context context) {
        return upsertQueueWithResponseAsync(id, patch, context).block();
    }

    /**
     * Retrieves an existing queue by Id.
     *
     * @param id Id of the queue to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed along with {@link Response} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<JobQueue>> getQueueWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getQueue(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves an existing queue by Id.
     *
     * @param id Id of the queue to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed along with {@link Response} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<JobQueue>> getQueueWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.getQueue(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves an existing queue by Id.
     *
     * @param id Id of the queue to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<JobQueue> getQueueAsync(String id) {
        return getQueueWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing queue by Id.
     *
     * @param id Id of the queue to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<JobQueue> getQueueAsync(String id, Context context) {
        return getQueueWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing queue by Id.
     *
     * @param id Id of the queue to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public JobQueue getQueue(String id) {
        return getQueueAsync(id).block();
    }

    /**
     * Retrieves an existing queue by Id.
     *
     * @param id Id of the queue to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<JobQueue> getQueueWithResponse(String id, Context context) {
        return getQueueWithResponseAsync(id, context).block();
    }

    /**
     * Deletes a queue by Id.
     *
     * @param id Id of the queue to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteQueueWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteQueue(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Deletes a queue by Id.
     *
     * @param id Id of the queue to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteQueueWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.deleteQueue(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Deletes a queue by Id.
     *
     * @param id Id of the queue to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteQueueAsync(String id) {
        return deleteQueueWithResponseAsync(id).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a queue by Id.
     *
     * @param id Id of the queue to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteQueueAsync(String id, Context context) {
        return deleteQueueWithResponseAsync(id, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a queue by Id.
     *
     * @param id Id of the queue to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteQueue(String id) {
        deleteQueueAsync(id).block();
    }

    /**
     * Deletes a queue by Id.
     *
     * @param id Id of the queue to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteQueueWithResponse(String id, Context context) {
        return deleteQueueWithResponseAsync(id, context).block();
    }

    /**
     * Retrieves existing queues.
     *
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedQueue>> listQueuesSinglePageAsync(Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listQueues(
                                        this.client.getEndpoint(),
                                        maxpagesize,
                                        this.client.getApiVersion(),
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing queues.
     *
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedQueue>> listQueuesSinglePageAsync(Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.listQueues(this.client.getEndpoint(), maxpagesize, this.client.getApiVersion(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing queues.
     *
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedQueue> listQueuesAsync(Integer maxpagesize) {
        return new PagedFlux<>(
                () -> listQueuesSinglePageAsync(maxpagesize), nextLink -> listQueuesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing queues.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedQueue> listQueuesAsync() {
        final Integer maxpagesize = null;
        return new PagedFlux<>(
                () -> listQueuesSinglePageAsync(maxpagesize), nextLink -> listQueuesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing queues.
     *
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedQueue> listQueuesAsync(Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> listQueuesSinglePageAsync(maxpagesize, context),
                nextLink -> listQueuesNextSinglePageAsync(nextLink, context));
    }

    /**
     * Retrieves existing queues.
     *
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedQueue> listQueues(Integer maxpagesize) {
        return new PagedIterable<>(listQueuesAsync(maxpagesize));
    }

    /**
     * Retrieves existing queues.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedQueue> listQueues() {
        final Integer maxpagesize = null;
        return new PagedIterable<>(listQueuesAsync(maxpagesize));
    }

    /**
     * Retrieves existing queues.
     *
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedQueue> listQueues(Integer maxpagesize, Context context) {
        return new PagedIterable<>(listQueuesAsync(maxpagesize, context));
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<QueueStatistics>> getQueueStatisticsWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getQueueStatistics(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<QueueStatistics>> getQueueStatisticsWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.getQueueStatistics(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<QueueStatistics> getQueueStatisticsAsync(String id) {
        return getQueueStatisticsWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<QueueStatistics> getQueueStatisticsAsync(String id, Context context) {
        return getQueueStatisticsWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public QueueStatistics getQueueStatistics(String id) {
        return getQueueStatisticsAsync(id).block();
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<QueueStatistics> getQueueStatisticsWithResponse(String id, Context context) {
        return getQueueStatisticsWithResponseAsync(id, context).block();
    }

    /**
     * Upsert a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterWorker>> upsertWorkerWithResponseAsync(String workerId, RouterWorker patch) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upsertWorker(
                                this.client.getEndpoint(),
                                workerId,
                                this.client.getApiVersion(),
                                patch,
                                accept,
                                context));
    }

    /**
     * Upsert a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterWorker>> upsertWorkerWithResponseAsync(
            String workerId, RouterWorker patch, Context context) {
        final String accept = "application/json";
        return service.upsertWorker(
                this.client.getEndpoint(), workerId, this.client.getApiVersion(), patch, accept, context);
    }

    /**
     * Upsert a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterWorker> upsertWorkerAsync(String workerId, RouterWorker patch) {
        return upsertWorkerWithResponseAsync(workerId, patch).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Upsert a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterWorker> upsertWorkerAsync(String workerId, RouterWorker patch, Context context) {
        return upsertWorkerWithResponseAsync(workerId, patch, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Upsert a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterWorker upsertWorker(String workerId, RouterWorker patch) {
        return upsertWorkerAsync(workerId, patch).block();
    }

    /**
     * Upsert a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RouterWorker> upsertWorkerWithResponse(String workerId, RouterWorker patch, Context context) {
        return upsertWorkerWithResponseAsync(workerId, patch, context).block();
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterWorker>> getWorkerWithResponseAsync(String workerId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getWorker(
                                this.client.getEndpoint(), workerId, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterWorker>> getWorkerWithResponseAsync(String workerId, Context context) {
        final String accept = "application/json";
        return service.getWorker(this.client.getEndpoint(), workerId, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterWorker> getWorkerAsync(String workerId) {
        return getWorkerWithResponseAsync(workerId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterWorker> getWorkerAsync(String workerId, Context context) {
        return getWorkerWithResponseAsync(workerId, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterWorker getWorker(String workerId) {
        return getWorkerAsync(workerId).block();
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RouterWorker> getWorkerWithResponse(String workerId, Context context) {
        return getWorkerWithResponseAsync(workerId, context).block();
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteWorkerWithResponseAsync(String workerId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteWorker(
                                this.client.getEndpoint(), workerId, this.client.getApiVersion(), accept, context));
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteWorkerWithResponseAsync(String workerId, Context context) {
        final String accept = "application/json";
        return service.deleteWorker(this.client.getEndpoint(), workerId, this.client.getApiVersion(), accept, context);
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteWorkerAsync(String workerId) {
        return deleteWorkerWithResponseAsync(workerId).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteWorkerAsync(String workerId, Context context) {
        return deleteWorkerWithResponseAsync(workerId, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteWorker(String workerId) {
        deleteWorkerAsync(workerId).block();
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteWorkerWithResponse(String workerId, Context context) {
        return deleteWorkerWithResponseAsync(workerId, context).block();
    }

    /**
     * Retrieves existing workers.
     *
     * @param status (Optional) If specified, select workers by worker status.
     * @param channelId (Optional) If specified, select workers who have a channel configuration with this channel.
     * @param queueId (Optional) If specified, select workers who are assigned to this queue.
     * @param hasCapacity (Optional) If set to true, select only workers who have capacity for the channel specified by
     *     `channelId` or for any channel if `channelId` not specified. If set to false, then will return all workers
     *     including workers without any capacity for jobs. Defaults to false.
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedWorker>> listWorkersSinglePageAsync(
            WorkerStateSelector status, String channelId, String queueId, Boolean hasCapacity, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listWorkers(
                                        this.client.getEndpoint(),
                                        status,
                                        channelId,
                                        queueId,
                                        hasCapacity,
                                        maxpagesize,
                                        this.client.getApiVersion(),
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing workers.
     *
     * @param status (Optional) If specified, select workers by worker status.
     * @param channelId (Optional) If specified, select workers who have a channel configuration with this channel.
     * @param queueId (Optional) If specified, select workers who are assigned to this queue.
     * @param hasCapacity (Optional) If set to true, select only workers who have capacity for the channel specified by
     *     `channelId` or for any channel if `channelId` not specified. If set to false, then will return all workers
     *     including workers without any capacity for jobs. Defaults to false.
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedWorker>> listWorkersSinglePageAsync(
            WorkerStateSelector status,
            String channelId,
            String queueId,
            Boolean hasCapacity,
            Integer maxpagesize,
            Context context) {
        final String accept = "application/json";
        return service.listWorkers(
                        this.client.getEndpoint(),
                        status,
                        channelId,
                        queueId,
                        hasCapacity,
                        maxpagesize,
                        this.client.getApiVersion(),
                        accept,
                        context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing workers.
     *
     * @param status (Optional) If specified, select workers by worker status.
     * @param channelId (Optional) If specified, select workers who have a channel configuration with this channel.
     * @param queueId (Optional) If specified, select workers who are assigned to this queue.
     * @param hasCapacity (Optional) If set to true, select only workers who have capacity for the channel specified by
     *     `channelId` or for any channel if `channelId` not specified. If set to false, then will return all workers
     *     including workers without any capacity for jobs. Defaults to false.
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedWorker> listWorkersAsync(
            WorkerStateSelector status, String channelId, String queueId, Boolean hasCapacity, Integer maxpagesize) {
        return new PagedFlux<>(
                () -> listWorkersSinglePageAsync(status, channelId, queueId, hasCapacity, maxpagesize),
                nextLink -> listWorkersNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing workers.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedWorker> listWorkersAsync() {
        final WorkerStateSelector status = null;
        final String channelId = null;
        final String queueId = null;
        final Boolean hasCapacity = null;
        final Integer maxpagesize = null;
        return new PagedFlux<>(
                () -> listWorkersSinglePageAsync(status, channelId, queueId, hasCapacity, maxpagesize),
                nextLink -> listWorkersNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing workers.
     *
     * @param status (Optional) If specified, select workers by worker status.
     * @param channelId (Optional) If specified, select workers who have a channel configuration with this channel.
     * @param queueId (Optional) If specified, select workers who are assigned to this queue.
     * @param hasCapacity (Optional) If set to true, select only workers who have capacity for the channel specified by
     *     `channelId` or for any channel if `channelId` not specified. If set to false, then will return all workers
     *     including workers without any capacity for jobs. Defaults to false.
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<PagedWorker> listWorkersAsync(
            WorkerStateSelector status,
            String channelId,
            String queueId,
            Boolean hasCapacity,
            Integer maxpagesize,
            Context context) {
        return new PagedFlux<>(
                () -> listWorkersSinglePageAsync(status, channelId, queueId, hasCapacity, maxpagesize, context),
                nextLink -> listWorkersNextSinglePageAsync(nextLink, context));
    }

    /**
     * Retrieves existing workers.
     *
     * @param status (Optional) If specified, select workers by worker status.
     * @param channelId (Optional) If specified, select workers who have a channel configuration with this channel.
     * @param queueId (Optional) If specified, select workers who are assigned to this queue.
     * @param hasCapacity (Optional) If set to true, select only workers who have capacity for the channel specified by
     *     `channelId` or for any channel if `channelId` not specified. If set to false, then will return all workers
     *     including workers without any capacity for jobs. Defaults to false.
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedWorker> listWorkers(
            WorkerStateSelector status, String channelId, String queueId, Boolean hasCapacity, Integer maxpagesize) {
        return new PagedIterable<>(listWorkersAsync(status, channelId, queueId, hasCapacity, maxpagesize));
    }

    /**
     * Retrieves existing workers.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedWorker> listWorkers() {
        final WorkerStateSelector status = null;
        final String channelId = null;
        final String queueId = null;
        final Boolean hasCapacity = null;
        final Integer maxpagesize = null;
        return new PagedIterable<>(listWorkersAsync(status, channelId, queueId, hasCapacity, maxpagesize));
    }

    /**
     * Retrieves existing workers.
     *
     * @param status (Optional) If specified, select workers by worker status.
     * @param channelId (Optional) If specified, select workers who have a channel configuration with this channel.
     * @param queueId (Optional) If specified, select workers who are assigned to this queue.
     * @param hasCapacity (Optional) If set to true, select only workers who have capacity for the channel specified by
     *     `channelId` or for any channel if `channelId` not specified. If set to false, then will return all workers
     *     including workers without any capacity for jobs. Defaults to false.
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PagedWorker> listWorkers(
            WorkerStateSelector status,
            String channelId,
            String queueId,
            Boolean hasCapacity,
            Integer maxpagesize,
            Context context) {
        return new PagedIterable<>(listWorkersAsync(status, channelId, queueId, hasCapacity, maxpagesize, context));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies along with {@link PagedResponse} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedClassificationPolicy>> listClassificationPoliciesNextSinglePageAsync(
            String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listClassificationPoliciesNext(
                                        nextLink, this.client.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies along with {@link PagedResponse} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedClassificationPolicy>> listClassificationPoliciesNextSinglePageAsync(
            String nextLink, Context context) {
        final String accept = "application/json";
        return service.listClassificationPoliciesNext(nextLink, this.client.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedDistributionPolicy>> listDistributionPoliciesNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listDistributionPoliciesNext(
                                        nextLink, this.client.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedDistributionPolicy>> listDistributionPoliciesNextSinglePageAsync(
            String nextLink, Context context) {
        final String accept = "application/json";
        return service.listDistributionPoliciesNext(nextLink, this.client.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedExceptionPolicy>> listExceptionPoliciesNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listExceptionPoliciesNext(nextLink, this.client.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedExceptionPolicy>> listExceptionPoliciesNextSinglePageAsync(
            String nextLink, Context context) {
        final String accept = "application/json";
        return service.listExceptionPoliciesNext(nextLink, this.client.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedJob>> listJobsNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context -> service.listJobsNext(nextLink, this.client.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedJob>> listJobsNextSinglePageAsync(String nextLink, Context context) {
        final String accept = "application/json";
        return service.listJobsNext(nextLink, this.client.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedQueue>> listQueuesNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context -> service.listQueuesNext(nextLink, this.client.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedQueue>> listQueuesNextSinglePageAsync(String nextLink, Context context) {
        final String accept = "application/json";
        return service.listQueuesNext(nextLink, this.client.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedWorker>> listWorkersNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context -> service.listWorkersNext(nextLink, this.client.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<PagedWorker>> listWorkersNextSinglePageAsync(String nextLink, Context context) {
        final String accept = "application/json";
        return service.listWorkersNext(nextLink, this.client.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }
}
