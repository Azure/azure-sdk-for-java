// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.communication.jobrouter.implementation;

import com.azure.communication.jobrouter.implementation.models.CancelJobRequest;
import com.azure.communication.jobrouter.implementation.models.CloseJobRequest;
import com.azure.communication.jobrouter.implementation.models.CommunicationErrorResponseException;
import com.azure.communication.jobrouter.implementation.models.CompleteJobRequest;
import com.azure.communication.jobrouter.models.AcceptJobOfferResult;
import com.azure.communication.jobrouter.models.JobCollection;
import com.azure.communication.jobrouter.models.JobPositionDetails;
import com.azure.communication.jobrouter.models.JobStateSelector;
import com.azure.communication.jobrouter.models.QueueStatistics;
import com.azure.communication.jobrouter.models.RouterJob;
import com.azure.communication.jobrouter.models.RouterJobItem;
import com.azure.communication.jobrouter.models.RouterWorker;
import com.azure.communication.jobrouter.models.RouterWorkerItem;
import com.azure.communication.jobrouter.models.UnassignJobResult;
import com.azure.communication.jobrouter.models.WorkerCollection;
import com.azure.communication.jobrouter.models.WorkerStateSelector;
import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import reactor.core.publisher.Mono;

import java.time.OffsetDateTime;

/** An instance of this class provides access to all the operations defined in JobRouters. */
public final class JobRoutersImpl {
    /** The proxy service used to perform REST calls. */
    private final JobRoutersService service;

    /** The service client containing this operation class. */
    private final AzureCommunicationRoutingServiceImpl client;

    /**
     * Initializes an instance of JobRoutersImpl.
     *
     * @param client the instance of the service client containing this operation class.
     */
    JobRoutersImpl(AzureCommunicationRoutingServiceImpl client) {
        this.service =
                RestProxy.create(JobRoutersService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for AzureCommunicationRoutingServiceJobRouters to be used by the proxy
     * service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "AzureCommunicationRo")
    private interface JobRoutersService {
        @Patch("/routing/jobs/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterJob>> upsertJob(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/merge-patch+json") RouterJob patch,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/jobs/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterJob>> getJob(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/routing/jobs/{id}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Void>> deleteJob(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/jobs/{id}:reclassify")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Object>> reclassifyJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") Object reclassifyJobRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/jobs/{id}:cancel")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Object>> cancelJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") CancelJobRequest cancelJobRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/jobs/{id}:complete")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Object>> completeJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") CompleteJobRequest completeJobRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/jobs/{id}:close")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Object>> closeJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") CloseJobRequest closeJobRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/jobs")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<JobCollection>> listJobs(
                @HostParam("endpoint") String endpoint,
                @QueryParam("status") JobStateSelector status,
                @QueryParam("queueId") String queueId,
                @QueryParam("channelId") String channelId,
                @QueryParam("classificationPolicyId") String classificationPolicyId,
                @QueryParam("maxpagesize") Integer maxpagesize,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/jobs/{id}/position")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<JobPositionDetails>> getInQueuePosition(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/jobs/{id}/assignments/{assignmentId}:unassign")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<UnassignJobResult>> unassignJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @PathParam("assignmentId") String assignmentId,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/workers/{workerId}/offers/{offerId}:accept")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<AcceptJobOfferResult>> acceptJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("workerId") String workerId,
                @PathParam("offerId") String offerId,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/routing/workers/{workerId}/offers/{offerId}:decline")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Object>> declineJobAction(
                @HostParam("endpoint") String endpoint,
                @PathParam("workerId") String workerId,
                @PathParam("offerId") String offerId,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/queues/{id}/statistics")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<QueueStatistics>> getQueueStatistics(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/routing/workers/{workerId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterWorker>> upsertWorker(
                @HostParam("endpoint") String endpoint,
                @PathParam("workerId") String workerId,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/merge-patch+json") RouterWorker patch,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/workers/{workerId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<RouterWorker>> getWorker(
                @HostParam("endpoint") String endpoint,
                @PathParam("workerId") String workerId,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/routing/workers/{workerId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Void>> deleteWorker(
                @HostParam("endpoint") String endpoint,
                @PathParam("workerId") String workerId,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/workers")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<WorkerCollection>> listWorkers(
                @HostParam("endpoint") String endpoint,
                @QueryParam("status") WorkerStateSelector status,
                @QueryParam("channelId") String channelId,
                @QueryParam("queueId") String queueId,
                @QueryParam("hasCapacity") Boolean hasCapacity,
                @QueryParam("maxpagesize") Integer maxpagesize,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<JobCollection>> listJobsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<WorkerCollection>> listWorkersNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);
    }

    /**
     * Creates or updates a router job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterJob>> upsertJobWithResponseAsync(String id, RouterJob patch) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upsertJob(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context));
    }

    /**
     * Creates or updates a router job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterJob>> upsertJobWithResponseAsync(String id, RouterJob patch, Context context) {
        final String accept = "application/json";
        return service.upsertJob(this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context);
    }

    /**
     * Creates or updates a router job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterJob> upsertJobAsync(String id, RouterJob patch) {
        return upsertJobWithResponseAsync(id, patch).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a router job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterJob> upsertJobAsync(String id, RouterJob patch, Context context) {
        return upsertJobWithResponseAsync(id, patch, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a router job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterJob upsertJob(String id, RouterJob patch) {
        return upsertJobAsync(id, patch).block();
    }

    /**
     * Creates or updates a router job.
     *
     * @param id Id of the job.
     * @param patch Model of job properties to be created or patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RouterJob> upsertJobWithResponse(String id, RouterJob patch, Context context) {
        return upsertJobWithResponseAsync(id, patch, context).block();
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterJob>> getJobWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getJob(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterJob>> getJobWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.getJob(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterJob> getJobAsync(String id) {
        return getJobWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterJob> getJobAsync(String id, Context context) {
        return getJobWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterJob getJob(String id) {
        return getJobAsync(id).block();
    }

    /**
     * Retrieves an existing job by Id.
     *
     * @param id Id of the job to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a unit of work to be routed along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RouterJob> getJobWithResponse(String id, Context context) {
        return getJobWithResponseAsync(id, context).block();
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteJobWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteJob(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteJobWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.deleteJob(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteJobAsync(String id) {
        return deleteJobWithResponseAsync(id).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteJobAsync(String id, Context context) {
        return deleteJobWithResponseAsync(id, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteJob(String id) {
        deleteJobAsync(id).block();
    }

    /**
     * Deletes a job and all of its traces.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteJobWithResponse(String id, Context context) {
        return deleteJobWithResponseAsync(id, context).block();
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> reclassifyJobActionWithResponseAsync(String id, Object reclassifyJobRequest) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.reclassifyJobAction(
                                this.client.getEndpoint(),
                                id,
                                this.client.getApiVersion(),
                                reclassifyJobRequest,
                                accept,
                                context));
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> reclassifyJobActionWithResponseAsync(
            String id, Object reclassifyJobRequest, Context context) {
        final String accept = "application/json";
        return service.reclassifyJobAction(
                this.client.getEndpoint(), id, this.client.getApiVersion(), reclassifyJobRequest, accept, context);
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> reclassifyJobActionAsync(String id, Object reclassifyJobRequest) {
        return reclassifyJobActionWithResponseAsync(id, reclassifyJobRequest)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> reclassifyJobActionAsync(String id) {
        final Object reclassifyJobRequest = null;
        return reclassifyJobActionWithResponseAsync(id, reclassifyJobRequest)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> reclassifyJobActionAsync(String id, Object reclassifyJobRequest, Context context) {
        return reclassifyJobActionWithResponseAsync(id, reclassifyJobRequest, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object reclassifyJobAction(String id, Object reclassifyJobRequest) {
        return reclassifyJobActionAsync(id, reclassifyJobRequest).block();
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object reclassifyJobAction(String id) {
        final Object reclassifyJobRequest = null;
        return reclassifyJobActionAsync(id, reclassifyJobRequest).block();
    }

    /**
     * Reclassify a job.
     *
     * @param id Id of the job.
     * @param reclassifyJobRequest Request object for reclassifying a job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Object> reclassifyJobActionWithResponse(String id, Object reclassifyJobRequest, Context context) {
        return reclassifyJobActionWithResponseAsync(id, reclassifyJobRequest, context).block();
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> cancelJobActionWithResponseAsync(String id, String note, String dispositionCode) {
        final String accept = "application/json";
        CancelJobRequest cancelJobRequestInternal = null;
        if (note != null || dispositionCode != null) {
            cancelJobRequestInternal = new CancelJobRequest();
            cancelJobRequestInternal.setNote(note);
            cancelJobRequestInternal.setDispositionCode(dispositionCode);
        }
        CancelJobRequest cancelJobRequest = cancelJobRequestInternal;
        return FluxUtil.withContext(
                context ->
                        service.cancelJobAction(
                                this.client.getEndpoint(),
                                id,
                                this.client.getApiVersion(),
                                cancelJobRequest,
                                accept,
                                context));
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> cancelJobActionWithResponseAsync(
            String id, String note, String dispositionCode, Context context) {
        final String accept = "application/json";
        CancelJobRequest cancelJobRequestInternal = null;
        if (note != null || dispositionCode != null) {
            cancelJobRequestInternal = new CancelJobRequest();
            cancelJobRequestInternal.setNote(note);
            cancelJobRequestInternal.setDispositionCode(dispositionCode);
        }
        CancelJobRequest cancelJobRequest = cancelJobRequestInternal;
        return service.cancelJobAction(
                this.client.getEndpoint(), id, this.client.getApiVersion(), cancelJobRequest, accept, context);
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> cancelJobActionAsync(String id, String note, String dispositionCode) {
        return cancelJobActionWithResponseAsync(id, note, dispositionCode)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> cancelJobActionAsync(String id) {
        final String note = null;
        final String dispositionCode = null;
        return cancelJobActionWithResponseAsync(id, note, dispositionCode)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> cancelJobActionAsync(String id, String note, String dispositionCode, Context context) {
        return cancelJobActionWithResponseAsync(id, note, dispositionCode, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object cancelJobAction(String id, String note, String dispositionCode) {
        return cancelJobActionAsync(id, note, dispositionCode).block();
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object cancelJobAction(String id) {
        final String note = null;
        final String dispositionCode = null;
        return cancelJobActionAsync(id, note, dispositionCode).block();
    }

    /**
     * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
     *
     * @param id Id of the job.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values. If not
     *     provided, default value of "Cancelled" is set.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Object> cancelJobActionWithResponse(
            String id, String note, String dispositionCode, Context context) {
        return cancelJobActionWithResponseAsync(id, note, dispositionCode, context).block();
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> completeJobActionWithResponseAsync(String id, String assignmentId, String note) {
        final String accept = "application/json";
        CompleteJobRequest completeJobRequest = new CompleteJobRequest();
        completeJobRequest.setAssignmentId(assignmentId);
        completeJobRequest.setNote(note);
        return FluxUtil.withContext(
                context ->
                        service.completeJobAction(
                                this.client.getEndpoint(),
                                id,
                                this.client.getApiVersion(),
                                completeJobRequest,
                                accept,
                                context));
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> completeJobActionWithResponseAsync(
            String id, String assignmentId, String note, Context context) {
        final String accept = "application/json";
        CompleteJobRequest completeJobRequest = new CompleteJobRequest();
        completeJobRequest.setAssignmentId(assignmentId);
        completeJobRequest.setNote(note);
        return service.completeJobAction(
                this.client.getEndpoint(), id, this.client.getApiVersion(), completeJobRequest, accept, context);
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> completeJobActionAsync(String id, String assignmentId, String note) {
        return completeJobActionWithResponseAsync(id, assignmentId, note)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> completeJobActionAsync(String id, String assignmentId) {
        final String note = null;
        return completeJobActionWithResponseAsync(id, assignmentId, note)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> completeJobActionAsync(String id, String assignmentId, String note, Context context) {
        return completeJobActionWithResponseAsync(id, assignmentId, note, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object completeJobAction(String id, String assignmentId, String note) {
        return completeJobActionAsync(id, assignmentId, note).block();
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object completeJobAction(String id, String assignmentId) {
        final String note = null;
        return completeJobActionAsync(id, assignmentId, note).block();
    }

    /**
     * Completes an assigned job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within the job to complete.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Object> completeJobActionWithResponse(
            String id, String assignmentId, String note, Context context) {
        return completeJobActionWithResponseAsync(id, assignmentId, note, context).block();
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeTime If not provided, worker capacity is released immediately along with a JobClosedEvent
     *     notification. If provided, worker capacity is released along with a JobClosedEvent notification at a future
     *     time.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> closeJobActionWithResponseAsync(
            String id, String assignmentId, String dispositionCode, OffsetDateTime closeTime, String note) {
        final String accept = "application/json";
        CloseJobRequest closeJobRequest = new CloseJobRequest();
        closeJobRequest.setAssignmentId(assignmentId);
        closeJobRequest.setDispositionCode(dispositionCode);
        closeJobRequest.setCloseTime(closeTime);
        closeJobRequest.setNote(note);
        return FluxUtil.withContext(
                context ->
                        service.closeJobAction(
                                this.client.getEndpoint(),
                                id,
                                this.client.getApiVersion(),
                                closeJobRequest,
                                accept,
                                context));
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeTime If not provided, worker capacity is released immediately along with a JobClosedEvent
     *     notification. If provided, worker capacity is released along with a JobClosedEvent notification at a future
     *     time.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> closeJobActionWithResponseAsync(
            String id,
            String assignmentId,
            String dispositionCode,
            OffsetDateTime closeTime,
            String note,
            Context context) {
        final String accept = "application/json";
        CloseJobRequest closeJobRequest = new CloseJobRequest();
        closeJobRequest.setAssignmentId(assignmentId);
        closeJobRequest.setDispositionCode(dispositionCode);
        closeJobRequest.setCloseTime(closeTime);
        closeJobRequest.setNote(note);
        return service.closeJobAction(
                this.client.getEndpoint(), id, this.client.getApiVersion(), closeJobRequest, accept, context);
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeTime If not provided, worker capacity is released immediately along with a JobClosedEvent
     *     notification. If provided, worker capacity is released along with a JobClosedEvent notification at a future
     *     time.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> closeJobActionAsync(
            String id, String assignmentId, String dispositionCode, OffsetDateTime closeTime, String note) {
        return closeJobActionWithResponseAsync(id, assignmentId, dispositionCode, closeTime, note)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> closeJobActionAsync(String id, String assignmentId) {
        final String dispositionCode = null;
        final OffsetDateTime closeTime = null;
        final String note = null;
        return closeJobActionWithResponseAsync(id, assignmentId, dispositionCode, closeTime, note)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeTime If not provided, worker capacity is released immediately along with a JobClosedEvent
     *     notification. If provided, worker capacity is released along with a JobClosedEvent notification at a future
     *     time.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> closeJobActionAsync(
            String id,
            String assignmentId,
            String dispositionCode,
            OffsetDateTime closeTime,
            String note,
            Context context) {
        return closeJobActionWithResponseAsync(id, assignmentId, dispositionCode, closeTime, note, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeTime If not provided, worker capacity is released immediately along with a JobClosedEvent
     *     notification. If provided, worker capacity is released along with a JobClosedEvent notification at a future
     *     time.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object closeJobAction(
            String id, String assignmentId, String dispositionCode, OffsetDateTime closeTime, String note) {
        return closeJobActionAsync(id, assignmentId, dispositionCode, closeTime, note).block();
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object closeJobAction(String id, String assignmentId) {
        final String dispositionCode = null;
        final OffsetDateTime closeTime = null;
        final String note = null;
        return closeJobActionAsync(id, assignmentId, dispositionCode, closeTime, note).block();
    }

    /**
     * Closes a completed job.
     *
     * @param id Id of the job.
     * @param assignmentId The assignment within which the job is to be closed.
     * @param dispositionCode Indicates the outcome of the job, populate this field with your own custom values.
     * @param closeTime If not provided, worker capacity is released immediately along with a JobClosedEvent
     *     notification. If provided, worker capacity is released along with a JobClosedEvent notification at a future
     *     time.
     * @param note (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Object> closeJobActionWithResponse(
            String id,
            String assignmentId,
            String dispositionCode,
            OffsetDateTime closeTime,
            String note,
            Context context) {
        return closeJobActionWithResponseAsync(id, assignmentId, dispositionCode, closeTime, note, context).block();
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status (Optional) If specified, filter jobs by status.
     * @param queueId (Optional) If specified, filter jobs by queue.
     * @param channelId (Optional) If specified, filter jobs by channel.
     * @param classificationPolicyId (Optional) If specified, filter jobs by classificationPolicy.
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterJobItem>> listJobsSinglePageAsync(
            JobStateSelector status,
            String queueId,
            String channelId,
            String classificationPolicyId,
            Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listJobs(
                                        this.client.getEndpoint(),
                                        status,
                                        queueId,
                                        channelId,
                                        classificationPolicyId,
                                        maxpagesize,
                                        this.client.getApiVersion(),
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status (Optional) If specified, filter jobs by status.
     * @param queueId (Optional) If specified, filter jobs by queue.
     * @param channelId (Optional) If specified, filter jobs by channel.
     * @param classificationPolicyId (Optional) If specified, filter jobs by classificationPolicy.
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterJobItem>> listJobsSinglePageAsync(
            JobStateSelector status,
            String queueId,
            String channelId,
            String classificationPolicyId,
            Integer maxpagesize,
            Context context) {
        final String accept = "application/json";
        return service.listJobs(
                        this.client.getEndpoint(),
                        status,
                        queueId,
                        channelId,
                        classificationPolicyId,
                        maxpagesize,
                        this.client.getApiVersion(),
                        accept,
                        context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status (Optional) If specified, filter jobs by status.
     * @param queueId (Optional) If specified, filter jobs by queue.
     * @param channelId (Optional) If specified, filter jobs by channel.
     * @param classificationPolicyId (Optional) If specified, filter jobs by classificationPolicy.
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<RouterJobItem> listJobsAsync(
            JobStateSelector status,
            String queueId,
            String channelId,
            String classificationPolicyId,
            Integer maxpagesize) {
        return new PagedFlux<>(
                () -> listJobsSinglePageAsync(status, queueId, channelId, classificationPolicyId, maxpagesize),
                nextLink -> listJobsNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<RouterJobItem> listJobsAsync() {
        final JobStateSelector status = null;
        final String queueId = null;
        final String channelId = null;
        final String classificationPolicyId = null;
        final Integer maxpagesize = null;
        return new PagedFlux<>(
                () -> listJobsSinglePageAsync(status, queueId, channelId, classificationPolicyId, maxpagesize),
                nextLink -> listJobsNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status (Optional) If specified, filter jobs by status.
     * @param queueId (Optional) If specified, filter jobs by queue.
     * @param channelId (Optional) If specified, filter jobs by channel.
     * @param classificationPolicyId (Optional) If specified, filter jobs by classificationPolicy.
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<RouterJobItem> listJobsAsync(
            JobStateSelector status,
            String queueId,
            String channelId,
            String classificationPolicyId,
            Integer maxpagesize,
            Context context) {
        return new PagedFlux<>(
                () -> listJobsSinglePageAsync(status, queueId, channelId, classificationPolicyId, maxpagesize, context),
                nextLink -> listJobsNextSinglePageAsync(nextLink, context));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status (Optional) If specified, filter jobs by status.
     * @param queueId (Optional) If specified, filter jobs by queue.
     * @param channelId (Optional) If specified, filter jobs by channel.
     * @param classificationPolicyId (Optional) If specified, filter jobs by classificationPolicy.
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<RouterJobItem> listJobs(
            JobStateSelector status,
            String queueId,
            String channelId,
            String classificationPolicyId,
            Integer maxpagesize) {
        return new PagedIterable<>(listJobsAsync(status, queueId, channelId, classificationPolicyId, maxpagesize));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<RouterJobItem> listJobs() {
        final JobStateSelector status = null;
        final String queueId = null;
        final String channelId = null;
        final String classificationPolicyId = null;
        final Integer maxpagesize = null;
        return new PagedIterable<>(listJobsAsync(status, queueId, channelId, classificationPolicyId, maxpagesize));
    }

    /**
     * Retrieves list of jobs based on filter parameters.
     *
     * @param status (Optional) If specified, filter jobs by status.
     * @param queueId (Optional) If specified, filter jobs by queue.
     * @param channelId (Optional) If specified, filter jobs by channel.
     * @param classificationPolicyId (Optional) If specified, filter jobs by classificationPolicy.
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<RouterJobItem> listJobs(
            JobStateSelector status,
            String queueId,
            String channelId,
            String classificationPolicyId,
            Integer maxpagesize,
            Context context) {
        return new PagedIterable<>(
                listJobsAsync(status, queueId, channelId, classificationPolicyId, maxpagesize, context));
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<JobPositionDetails>> getInQueuePositionWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getInQueuePosition(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<JobPositionDetails>> getInQueuePositionWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.getInQueuePosition(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<JobPositionDetails> getInQueuePositionAsync(String id) {
        return getInQueuePositionWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<JobPositionDetails> getInQueuePositionAsync(String id, Context context) {
        return getInQueuePositionWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public JobPositionDetails getInQueuePosition(String id) {
        return getInQueuePositionAsync(id).block();
    }

    /**
     * Gets a job's position details.
     *
     * @param id Id of the job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a job's position details along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<JobPositionDetails> getInQueuePositionWithResponse(String id, Context context) {
        return getInQueuePositionWithResponseAsync(id, context).block();
    }

    /**
     * Un-assign a job.
     *
     * @param id Id of the job to un-assign.
     * @param assignmentId Id of the assignment to un-assign.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response payload after a job has been successfully unassigned along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<UnassignJobResult>> unassignJobActionWithResponseAsync(String id, String assignmentId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.unassignJobAction(
                                this.client.getEndpoint(),
                                id,
                                assignmentId,
                                this.client.getApiVersion(),
                                accept,
                                context));
    }

    /**
     * Un-assign a job.
     *
     * @param id Id of the job to un-assign.
     * @param assignmentId Id of the assignment to un-assign.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response payload after a job has been successfully unassigned along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<UnassignJobResult>> unassignJobActionWithResponseAsync(
            String id, String assignmentId, Context context) {
        final String accept = "application/json";
        return service.unassignJobAction(
                this.client.getEndpoint(), id, assignmentId, this.client.getApiVersion(), accept, context);
    }

    /**
     * Un-assign a job.
     *
     * @param id Id of the job to un-assign.
     * @param assignmentId Id of the assignment to un-assign.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response payload after a job has been successfully unassigned on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<UnassignJobResult> unassignJobActionAsync(String id, String assignmentId) {
        return unassignJobActionWithResponseAsync(id, assignmentId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Un-assign a job.
     *
     * @param id Id of the job to un-assign.
     * @param assignmentId Id of the assignment to un-assign.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response payload after a job has been successfully unassigned on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<UnassignJobResult> unassignJobActionAsync(String id, String assignmentId, Context context) {
        return unassignJobActionWithResponseAsync(id, assignmentId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Un-assign a job.
     *
     * @param id Id of the job to un-assign.
     * @param assignmentId Id of the assignment to un-assign.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response payload after a job has been successfully unassigned.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public UnassignJobResult unassignJobAction(String id, String assignmentId) {
        return unassignJobActionAsync(id, assignmentId).block();
    }

    /**
     * Un-assign a job.
     *
     * @param id Id of the job to un-assign.
     * @param assignmentId Id of the assignment to un-assign.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response payload after a job has been successfully unassigned along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<UnassignJobResult> unassignJobActionWithResponse(String id, String assignmentId, Context context) {
        return unassignJobActionWithResponseAsync(id, assignmentId, context).block();
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer along with {@link
     *     Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AcceptJobOfferResult>> acceptJobActionWithResponseAsync(String workerId, String offerId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.acceptJobAction(
                                this.client.getEndpoint(),
                                workerId,
                                offerId,
                                this.client.getApiVersion(),
                                accept,
                                context));
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer along with {@link
     *     Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AcceptJobOfferResult>> acceptJobActionWithResponseAsync(
            String workerId, String offerId, Context context) {
        final String accept = "application/json";
        return service.acceptJobAction(
                this.client.getEndpoint(), workerId, offerId, this.client.getApiVersion(), accept, context);
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AcceptJobOfferResult> acceptJobActionAsync(String workerId, String offerId) {
        return acceptJobActionWithResponseAsync(workerId, offerId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AcceptJobOfferResult> acceptJobActionAsync(String workerId, String offerId, Context context) {
        return acceptJobActionWithResponseAsync(workerId, offerId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AcceptJobOfferResult acceptJobAction(String workerId, String offerId) {
        return acceptJobActionAsync(workerId, offerId).block();
    }

    /**
     * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing Id's for the worker, job, and assignment from an accepted offer along with {@link
     *     Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AcceptJobOfferResult> acceptJobActionWithResponse(
            String workerId, String offerId, Context context) {
        return acceptJobActionWithResponseAsync(workerId, offerId, context).block();
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> declineJobActionWithResponseAsync(String workerId, String offerId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.declineJobAction(
                                this.client.getEndpoint(),
                                workerId,
                                offerId,
                                this.client.getApiVersion(),
                                accept,
                                context));
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Object>> declineJobActionWithResponseAsync(String workerId, String offerId, Context context) {
        final String accept = "application/json";
        return service.declineJobAction(
                this.client.getEndpoint(), workerId, offerId, this.client.getApiVersion(), accept, context);
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> declineJobActionAsync(String workerId, String offerId) {
        return declineJobActionWithResponseAsync(workerId, offerId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Object> declineJobActionAsync(String workerId, String offerId, Context context) {
        return declineJobActionWithResponseAsync(workerId, offerId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Object declineJobAction(String workerId, String offerId) {
        return declineJobActionAsync(workerId, offerId).block();
    }

    /**
     * Declines an offer to work on a job.
     *
     * @param workerId Id of the worker.
     * @param offerId Id of the offer.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return any object along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Object> declineJobActionWithResponse(String workerId, String offerId, Context context) {
        return declineJobActionWithResponseAsync(workerId, offerId, context).block();
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<QueueStatistics>> getQueueStatisticsWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getQueueStatistics(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<QueueStatistics>> getQueueStatisticsWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.getQueueStatistics(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<QueueStatistics> getQueueStatisticsAsync(String id) {
        return getQueueStatisticsWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<QueueStatistics> getQueueStatisticsAsync(String id, Context context) {
        return getQueueStatisticsWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public QueueStatistics getQueueStatistics(String id) {
        return getQueueStatisticsAsync(id).block();
    }

    /**
     * Retrieves a queue's statistics.
     *
     * @param id Id of the queue to retrieve statistics.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return statistics for the queue along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<QueueStatistics> getQueueStatisticsWithResponse(String id, Context context) {
        return getQueueStatisticsWithResponseAsync(id, context).block();
    }

    /**
     * Creates or updates a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterWorker>> upsertWorkerWithResponseAsync(String workerId, RouterWorker patch) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upsertWorker(
                                this.client.getEndpoint(),
                                workerId,
                                this.client.getApiVersion(),
                                patch,
                                accept,
                                context));
    }

    /**
     * Creates or updates a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterWorker>> upsertWorkerWithResponseAsync(
            String workerId, RouterWorker patch, Context context) {
        final String accept = "application/json";
        return service.upsertWorker(
                this.client.getEndpoint(), workerId, this.client.getApiVersion(), patch, accept, context);
    }

    /**
     * Creates or updates a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterWorker> upsertWorkerAsync(String workerId, RouterWorker patch) {
        return upsertWorkerWithResponseAsync(workerId, patch).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterWorker> upsertWorkerAsync(String workerId, RouterWorker patch, Context context) {
        return upsertWorkerWithResponseAsync(workerId, patch, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterWorker upsertWorker(String workerId, RouterWorker patch) {
        return upsertWorkerAsync(workerId, patch).block();
    }

    /**
     * Creates or updates a worker.
     *
     * @param workerId Id of the worker.
     * @param patch Model of worker properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RouterWorker> upsertWorkerWithResponse(String workerId, RouterWorker patch, Context context) {
        return upsertWorkerWithResponseAsync(workerId, patch, context).block();
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterWorker>> getWorkerWithResponseAsync(String workerId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getWorker(
                                this.client.getEndpoint(), workerId, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<RouterWorker>> getWorkerWithResponseAsync(String workerId, Context context) {
        final String accept = "application/json";
        return service.getWorker(this.client.getEndpoint(), workerId, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterWorker> getWorkerAsync(String workerId) {
        return getWorkerWithResponseAsync(workerId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<RouterWorker> getWorkerAsync(String workerId, Context context) {
        return getWorkerWithResponseAsync(workerId, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterWorker getWorker(String workerId) {
        return getWorkerAsync(workerId).block();
    }

    /**
     * Retrieves an existing worker by Id.
     *
     * @param workerId Id of the worker to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an entity for jobs to be routed to along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RouterWorker> getWorkerWithResponse(String workerId, Context context) {
        return getWorkerWithResponseAsync(workerId, context).block();
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteWorkerWithResponseAsync(String workerId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteWorker(
                                this.client.getEndpoint(), workerId, this.client.getApiVersion(), accept, context));
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteWorkerWithResponseAsync(String workerId, Context context) {
        final String accept = "application/json";
        return service.deleteWorker(this.client.getEndpoint(), workerId, this.client.getApiVersion(), accept, context);
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteWorkerAsync(String workerId) {
        return deleteWorkerWithResponseAsync(workerId).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteWorkerAsync(String workerId, Context context) {
        return deleteWorkerWithResponseAsync(workerId, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteWorker(String workerId) {
        deleteWorkerAsync(workerId).block();
    }

    /**
     * Deletes a worker and all of its traces.
     *
     * @param workerId Id of the worker to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteWorkerWithResponse(String workerId, Context context) {
        return deleteWorkerWithResponseAsync(workerId, context).block();
    }

    /**
     * Retrieves existing workers.
     *
     * @param status (Optional) If specified, select workers by worker status.
     * @param channelId (Optional) If specified, select workers who have a channel configuration with this channel.
     * @param queueId (Optional) If specified, select workers who are assigned to this queue.
     * @param hasCapacity (Optional) If set to true, select only workers who have capacity for the channel specified by
     *     `channelId` or for any channel if `channelId` not specified. If set to false, then will return all workers
     *     including workers without any capacity for jobs. Defaults to false.
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterWorkerItem>> listWorkersSinglePageAsync(
            WorkerStateSelector status, String channelId, String queueId, Boolean hasCapacity, Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listWorkers(
                                        this.client.getEndpoint(),
                                        status,
                                        channelId,
                                        queueId,
                                        hasCapacity,
                                        maxpagesize,
                                        this.client.getApiVersion(),
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing workers.
     *
     * @param status (Optional) If specified, select workers by worker status.
     * @param channelId (Optional) If specified, select workers who have a channel configuration with this channel.
     * @param queueId (Optional) If specified, select workers who are assigned to this queue.
     * @param hasCapacity (Optional) If set to true, select only workers who have capacity for the channel specified by
     *     `channelId` or for any channel if `channelId` not specified. If set to false, then will return all workers
     *     including workers without any capacity for jobs. Defaults to false.
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterWorkerItem>> listWorkersSinglePageAsync(
            WorkerStateSelector status,
            String channelId,
            String queueId,
            Boolean hasCapacity,
            Integer maxpagesize,
            Context context) {
        final String accept = "application/json";
        return service.listWorkers(
                        this.client.getEndpoint(),
                        status,
                        channelId,
                        queueId,
                        hasCapacity,
                        maxpagesize,
                        this.client.getApiVersion(),
                        accept,
                        context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing workers.
     *
     * @param status (Optional) If specified, select workers by worker status.
     * @param channelId (Optional) If specified, select workers who have a channel configuration with this channel.
     * @param queueId (Optional) If specified, select workers who are assigned to this queue.
     * @param hasCapacity (Optional) If set to true, select only workers who have capacity for the channel specified by
     *     `channelId` or for any channel if `channelId` not specified. If set to false, then will return all workers
     *     including workers without any capacity for jobs. Defaults to false.
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<RouterWorkerItem> listWorkersAsync(
            WorkerStateSelector status, String channelId, String queueId, Boolean hasCapacity, Integer maxpagesize) {
        return new PagedFlux<>(
                () -> listWorkersSinglePageAsync(status, channelId, queueId, hasCapacity, maxpagesize),
                nextLink -> listWorkersNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing workers.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<RouterWorkerItem> listWorkersAsync() {
        final WorkerStateSelector status = null;
        final String channelId = null;
        final String queueId = null;
        final Boolean hasCapacity = null;
        final Integer maxpagesize = null;
        return new PagedFlux<>(
                () -> listWorkersSinglePageAsync(status, channelId, queueId, hasCapacity, maxpagesize),
                nextLink -> listWorkersNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing workers.
     *
     * @param status (Optional) If specified, select workers by worker status.
     * @param channelId (Optional) If specified, select workers who have a channel configuration with this channel.
     * @param queueId (Optional) If specified, select workers who are assigned to this queue.
     * @param hasCapacity (Optional) If set to true, select only workers who have capacity for the channel specified by
     *     `channelId` or for any channel if `channelId` not specified. If set to false, then will return all workers
     *     including workers without any capacity for jobs. Defaults to false.
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<RouterWorkerItem> listWorkersAsync(
            WorkerStateSelector status,
            String channelId,
            String queueId,
            Boolean hasCapacity,
            Integer maxpagesize,
            Context context) {
        return new PagedFlux<>(
                () -> listWorkersSinglePageAsync(status, channelId, queueId, hasCapacity, maxpagesize, context),
                nextLink -> listWorkersNextSinglePageAsync(nextLink, context));
    }

    /**
     * Retrieves existing workers.
     *
     * @param status (Optional) If specified, select workers by worker status.
     * @param channelId (Optional) If specified, select workers who have a channel configuration with this channel.
     * @param queueId (Optional) If specified, select workers who are assigned to this queue.
     * @param hasCapacity (Optional) If set to true, select only workers who have capacity for the channel specified by
     *     `channelId` or for any channel if `channelId` not specified. If set to false, then will return all workers
     *     including workers without any capacity for jobs. Defaults to false.
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<RouterWorkerItem> listWorkers(
            WorkerStateSelector status, String channelId, String queueId, Boolean hasCapacity, Integer maxpagesize) {
        return new PagedIterable<>(listWorkersAsync(status, channelId, queueId, hasCapacity, maxpagesize));
    }

    /**
     * Retrieves existing workers.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<RouterWorkerItem> listWorkers() {
        final WorkerStateSelector status = null;
        final String channelId = null;
        final String queueId = null;
        final Boolean hasCapacity = null;
        final Integer maxpagesize = null;
        return new PagedIterable<>(listWorkersAsync(status, channelId, queueId, hasCapacity, maxpagesize));
    }

    /**
     * Retrieves existing workers.
     *
     * @param status (Optional) If specified, select workers by worker status.
     * @param channelId (Optional) If specified, select workers who have a channel configuration with this channel.
     * @param queueId (Optional) If specified, select workers who are assigned to this queue.
     * @param hasCapacity (Optional) If set to true, select only workers who have capacity for the channel specified by
     *     `channelId` or for any channel if `channelId` not specified. If set to false, then will return all workers
     *     including workers without any capacity for jobs. Defaults to false.
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<RouterWorkerItem> listWorkers(
            WorkerStateSelector status,
            String channelId,
            String queueId,
            Boolean hasCapacity,
            Integer maxpagesize,
            Context context) {
        return new PagedIterable<>(listWorkersAsync(status, channelId, queueId, hasCapacity, maxpagesize, context));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterJobItem>> listJobsNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context -> service.listJobsNext(nextLink, this.client.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of jobs along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterJobItem>> listJobsNextSinglePageAsync(String nextLink, Context context) {
        final String accept = "application/json";
        return service.listJobsNext(nextLink, this.client.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterWorkerItem>> listWorkersNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context -> service.listWorkersNext(nextLink, this.client.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of workers along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<RouterWorkerItem>> listWorkersNextSinglePageAsync(String nextLink, Context context) {
        final String accept = "application/json";
        return service.listWorkersNext(nextLink, this.client.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }
}
