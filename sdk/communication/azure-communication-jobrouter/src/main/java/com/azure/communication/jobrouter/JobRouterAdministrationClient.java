// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.communication.jobrouter;

import com.azure.communication.jobrouter.implementation.JobRouterAdministrationClientImpl;
import com.azure.communication.jobrouter.implementation.accesshelpers.ClassificationPolicyConstructorProxy;
import com.azure.communication.jobrouter.implementation.accesshelpers.DistributionPolicyConstructorProxy;
import com.azure.communication.jobrouter.implementation.accesshelpers.ExceptionPolicyConstructorProxy;
import com.azure.communication.jobrouter.implementation.accesshelpers.RouterQueueConstructorProxy;
import com.azure.communication.jobrouter.implementation.converters.ClassificationPolicyAdapter;
import com.azure.communication.jobrouter.implementation.converters.DistributionPolicyAdapter;
import com.azure.communication.jobrouter.implementation.converters.ExceptionPolicyAdapter;
import com.azure.communication.jobrouter.implementation.converters.QueueAdapter;
import com.azure.communication.jobrouter.implementation.models.ClassificationPolicyInternal;
import com.azure.communication.jobrouter.implementation.models.DistributionPolicyInternal;
import com.azure.communication.jobrouter.implementation.models.ExceptionPolicyInternal;
import com.azure.communication.jobrouter.implementation.models.RouterQueueInternal;
import com.azure.communication.jobrouter.models.ClassificationPolicy;
import com.azure.communication.jobrouter.models.CreateClassificationPolicyOptions;
import com.azure.communication.jobrouter.models.CreateDistributionPolicyOptions;
import com.azure.communication.jobrouter.models.CreateExceptionPolicyOptions;
import com.azure.communication.jobrouter.models.CreateQueueOptions;
import com.azure.communication.jobrouter.models.DistributionPolicy;
import com.azure.communication.jobrouter.models.ExceptionPolicy;
import com.azure.communication.jobrouter.models.RouterQueue;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.BinaryData;

/**
 * Initializes a new instance of the synchronous JobRouterAdministrationClient type.
 */
@ServiceClient(builder = JobRouterAdministrationClientBuilder.class)
public final class JobRouterAdministrationClient {

    @Generated
    private final JobRouterAdministrationClientImpl serviceClient;

    /**
     * Initializes an instance of JobRouterAdministrationClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    JobRouterAdministrationClient(JobRouterAdministrationClientImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Creates or updates a distribution policy.
     * <p>
     * <strong>Header Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param distributionPolicyId Id of a distribution policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return policy governing how jobs are distributed to workers along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> upsertDistributionPolicyWithResponse(String distributionPolicyId, BinaryData resource,
        RequestOptions requestOptions) {
        // Convenience API is not generated, as operation 'upsertDistributionPolicy' is 'application/merge-patch+json'
        return this.serviceClient.upsertDistributionPolicyWithResponse(distributionPolicyId, resource, requestOptions);
    }

    /**
     * Updates a distribution policy.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     distributionPolicyId: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     distributionPolicyId: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param distributionPolicyId The unique identifier of the policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return policy governing how jobs are distributed to workers along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> updateDistributionPolicyWithResponse(String distributionPolicyId, BinaryData resource,
        RequestOptions requestOptions) {
        return this.serviceClient.upsertDistributionPolicyWithResponse(distributionPolicyId, resource, requestOptions);
    }

    /**
     * Updates a distribution policy.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     distributionPolicyId: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     distributionPolicyId: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param distributionPolicyId The unique identifier of the policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return result object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BinaryData updateDistributionPolicy(String distributionPolicyId, BinaryData resource,
        RequestOptions requestOptions) {
        return updateDistributionPolicyWithResponse(distributionPolicyId, resource, requestOptions).getValue();
    }

    /**
     * Create a distribution policy.
     *
     * @param createDistributionPolicyOptions Container for inputs to create a distribution policy.
     * @param requestOptions RequestOptions.
     * @return resource The resource instance
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DistributionPolicy> createDistributionPolicyWithResponse(
        CreateDistributionPolicyOptions createDistributionPolicyOptions, RequestOptions requestOptions) {
        DistributionPolicyInternal distributionPolicy
            = DistributionPolicyAdapter.convertCreateOptionsToDistributionPolicy(createDistributionPolicyOptions);
        Response<BinaryData> response = this.serviceClient.upsertDistributionPolicyWithResponse(
            createDistributionPolicyOptions.getDistributionPolicyId(), BinaryData.fromObject(distributionPolicy),
            requestOptions);
        return new SimpleResponse<DistributionPolicy>(response.getRequest(), response.getStatusCode(),
            response.getHeaders(),
            DistributionPolicyConstructorProxy.create(response.getValue().toObject(DistributionPolicyInternal.class)));
    }

    /**
     * Convenience method to create a distribution policy.
     *
     * @param createDistributionPolicyOptions Container for inputs to create a distribution policy.
     * @return resource The resource instance
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DistributionPolicy
        createDistributionPolicy(CreateDistributionPolicyOptions createDistributionPolicyOptions) {
        RequestOptions requestOptions = new RequestOptions();
        return this.createDistributionPolicyWithResponse(createDistributionPolicyOptions, requestOptions).getValue();
    }

    /**
     * Retrieves an existing distribution policy by Id.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param distributionPolicyId Id of a distribution policy.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return policy governing how jobs are distributed to workers along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDistributionPolicyWithResponse(String distributionPolicyId,
        RequestOptions requestOptions) {
        return this.serviceClient.getDistributionPolicyWithResponse(distributionPolicyId, requestOptions);
    }

    /**
     * Retrieves existing distribution policies.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>maxpagesize</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Number of objects to return per page.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     offerExpiresAfterSeconds: Double (Optional)
     *     mode (Optional): {
     *         minConcurrentOffers: Integer (Optional)
     *         maxConcurrentOffers: Integer (Optional)
     *         bypassSelectors: Boolean (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DistributionPolicy items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listDistributionPolicies(RequestOptions requestOptions) {
        return this.serviceClient.listDistributionPolicies(requestOptions);
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param distributionPolicyId Id of a distribution policy.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDistributionPolicyWithResponse(String distributionPolicyId,
        RequestOptions requestOptions) {
        return this.serviceClient.deleteDistributionPolicyWithResponse(distributionPolicyId, requestOptions);
    }

    /**
     * Creates or updates a classification policy.
     * <p>
     * <strong>Header Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectorAttachments (Optional): [
     *          (Optional){
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *     }
     *     workerSelectorAttachments (Optional): [
     *          (Optional){
     *         }
     *     ]
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectorAttachments (Optional): [
     *          (Optional){
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *     }
     *     workerSelectorAttachments (Optional): [
     *          (Optional){
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param classificationPolicyId Id of a classification policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a container for the rules that govern how jobs are classified along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> upsertClassificationPolicyWithResponse(String classificationPolicyId, BinaryData resource,
        RequestOptions requestOptions) {
        // Convenience API is not generated, as operation 'upsertClassificationPolicy' is 'application/merge-patch+json'
        return this.serviceClient.upsertClassificationPolicyWithResponse(classificationPolicyId, resource,
            requestOptions);
    }

    /**
     * Updates a classification policy.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     classificationPolicyId: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *     }
     *     workerSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     classificationPolicyId: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *     }
     *     workerSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param classificationPolicyId Unique identifier of this policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a container for the rules that govern how jobs are classified along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> updateClassificationPolicyWithResponse(String classificationPolicyId,
        BinaryData resource, RequestOptions requestOptions) {
        return this.serviceClient.upsertClassificationPolicyWithResponse(classificationPolicyId, resource,
            requestOptions);
    }

    /**
     * Updates a classification policy.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     classificationPolicyId: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *     }
     *     workerSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     classificationPolicyId: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *     }
     *     workerSelectors (Optional): [
     *          (Optional){
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param classificationPolicyId Unique identifier of this policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return result object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BinaryData updateClassificationPolicy(String classificationPolicyId, BinaryData resource,
        RequestOptions requestOptions) {
        return updateClassificationPolicyWithResponse(classificationPolicyId, resource, requestOptions).getValue();
    }

    /**
     * Create a classification policy.
     *
     * @param createClassificationPolicyOptions Container for inputs to create a classification policy.
     * @param requestOptions RequestOptions.
     * @return response The response instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<ClassificationPolicy> createClassificationPolicyWithResponse(
        CreateClassificationPolicyOptions createClassificationPolicyOptions, RequestOptions requestOptions) {
        ClassificationPolicyInternal classificationPolicy = ClassificationPolicyAdapter
            .convertCreateOptionsToClassificationPolicyInternal(createClassificationPolicyOptions);
        Response<BinaryData> response = this.serviceClient.upsertClassificationPolicyWithResponse(
            createClassificationPolicyOptions.getClassificationPolicyId(), BinaryData.fromObject(classificationPolicy),
            requestOptions);
        return new SimpleResponse<ClassificationPolicy>(response.getRequest(), response.getStatusCode(),
            response.getHeaders(), ClassificationPolicyConstructorProxy
                .create(response.getValue().toObject(ClassificationPolicyInternal.class)));
    }

    /**
     * Convenience method to create a classification policy.
     *
     * @param createClassificationPolicyOptions Container for inputs to create a classification policy.
     * @return a container for the rules that govern how jobs are classified.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ClassificationPolicy
        createClassificationPolicy(CreateClassificationPolicyOptions createClassificationPolicyOptions) {
        RequestOptions requestOptions = new RequestOptions();
        return this.createClassificationPolicyWithResponse(createClassificationPolicyOptions, requestOptions)
            .getValue();
    }

    /**
     * Retrieves an existing classification policy by Id.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectorAttachments (Optional): [
     *          (Optional){
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *     }
     *     workerSelectorAttachments (Optional): [
     *          (Optional){
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param classificationPolicyId Id of a classification policy.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a container for the rules that govern how jobs are classified along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getClassificationPolicyWithResponse(String classificationPolicyId,
        RequestOptions requestOptions) {
        return this.serviceClient.getClassificationPolicyWithResponse(classificationPolicyId, requestOptions);
    }

    /**
     * Retrieves existing classification policies.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>maxpagesize</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Number of objects to return per page.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     fallbackQueueId: String (Optional)
     *     queueSelectorAttachments (Optional): [
     *          (Optional){
     *         }
     *     ]
     *     prioritizationRule (Optional): {
     *     }
     *     workerSelectorAttachments (Optional): [
     *          (Optional){
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of ClassificationPolicy items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listClassificationPolicies(RequestOptions requestOptions) {
        return this.serviceClient.listClassificationPolicies(requestOptions);
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param classificationPolicyId Id of a classification policy.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteClassificationPolicyWithResponse(String classificationPolicyId,
        RequestOptions requestOptions) {
        return this.serviceClient.deleteClassificationPolicyWithResponse(classificationPolicyId, requestOptions);
    }

    /**
     * Creates or updates a exception policy.
     * <p>
     * <strong>Header Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): [
     *          (Optional){
     *             id: String (Required)
     *             trigger (Required): {
     *             }
     *             actions (Required): [
     *                  (Required){
     *                     id: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): [
     *          (Optional){
     *             id: String (Required)
     *             trigger (Required): {
     *             }
     *             actions (Required): [
     *                  (Required){
     *                     id: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param exceptionPolicyId Id of an exception policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> upsertExceptionPolicyWithResponse(String exceptionPolicyId, BinaryData resource,
        RequestOptions requestOptions) {
        // Convenience API is not generated, as operation 'upsertExceptionPolicy' is 'application/merge-patch+json'
        return this.serviceClient.upsertExceptionPolicyWithResponse(exceptionPolicyId, resource, requestOptions);
    }

    /**
     * Updates a exception policy.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     exceptionPolicyId: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): {
     *         String (Optional): {
     *             trigger (Required): {
     *             }
     *             actions (Required): {
     *                 String (Required): {
     *                 }
     *             }
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     exceptionPolicyId: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): {
     *         String (Optional): {
     *             trigger (Required): {
     *             }
     *             actions (Required): {
     *                 String (Required): {
     *                 }
     *             }
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param exceptionPolicyId The Id of the exception policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> updateExceptionPolicyWithResponse(String exceptionPolicyId, BinaryData resource,
        RequestOptions requestOptions) {
        return this.serviceClient.upsertExceptionPolicyWithResponse(exceptionPolicyId, resource, requestOptions);
    }

    /**
     * Updates a exception policy.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     exceptionPolicyId: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): {
     *         String (Optional): {
     *             trigger (Required): {
     *             }
     *             actions (Required): {
     *                 String (Required): {
     *                 }
     *             }
     *         }
     *     }
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     exceptionPolicyId: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): {
     *         String (Optional): {
     *             trigger (Required): {
     *             }
     *             actions (Required): {
     *                 String (Required): {
     *                 }
     *             }
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param exceptionPolicyId The Id of the exception policy.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return result object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BinaryData updateExceptionPolicy(String exceptionPolicyId, BinaryData resource,
        RequestOptions requestOptions) {
        return updateExceptionPolicyWithResponse(exceptionPolicyId, resource, requestOptions).getValue();
    }

    /**
     * Create an exception policy.
     *
     * @param createExceptionPolicyOptions Create options for Exception Policy.
     * @param requestOptions RequestOptions.
     * @return resource The resource instance
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<ExceptionPolicy> createExceptionPolicyWithResponse(
        CreateExceptionPolicyOptions createExceptionPolicyOptions, RequestOptions requestOptions) {
        ExceptionPolicyInternal exceptionPolicy
            = ExceptionPolicyAdapter.convertCreateOptionsToExceptionPolicy(createExceptionPolicyOptions);
        Response<BinaryData> response
            = this.serviceClient.upsertExceptionPolicyWithResponse(createExceptionPolicyOptions.getExceptionPolicyId(),
                BinaryData.fromObject(exceptionPolicy), requestOptions);
        return new SimpleResponse<ExceptionPolicy>(response.getRequest(), response.getStatusCode(),
            response.getHeaders(),
            ExceptionPolicyConstructorProxy.create(response.getValue().toObject(ExceptionPolicyInternal.class)));
    }

    /**
     * Convenience method to create an exception policy.
     *
     * @param createExceptionPolicyOptions Create options for Exception Policy.
     * @return resource The resource instance
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ExceptionPolicy createExceptionPolicy(CreateExceptionPolicyOptions createExceptionPolicyOptions) {
        RequestOptions requestOptions = new RequestOptions();
        return this.createExceptionPolicyWithResponse(createExceptionPolicyOptions, requestOptions).getValue();
    }

    /**
     * Retrieves an existing exception policy by Id.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): [
     *          (Optional){
     *             id: String (Required)
     *             trigger (Required): {
     *             }
     *             actions (Required): [
     *                  (Required){
     *                     id: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param exceptionPolicyId Id of an exception policy.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getExceptionPolicyWithResponse(String exceptionPolicyId,
        RequestOptions requestOptions) {
        return this.serviceClient.getExceptionPolicyWithResponse(exceptionPolicyId, requestOptions);
    }

    /**
     * Retrieves existing exception policies.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>maxpagesize</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Number of objects to return per page.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     exceptionRules (Optional): [
     *          (Optional){
     *             id: String (Required)
     *             trigger (Required): {
     *             }
     *             actions (Required): [
     *                  (Required){
     *                     id: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of ExceptionPolicy items as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listExceptionPolicies(RequestOptions requestOptions) {
        return this.serviceClient.listExceptionPolicies(requestOptions);
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param exceptionPolicyId Id of an exception policy.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteExceptionPolicyWithResponse(String exceptionPolicyId, RequestOptions requestOptions) {
        return this.serviceClient.deleteExceptionPolicyWithResponse(exceptionPolicyId, requestOptions);
    }

    /**
     * Creates or updates a queue.
     * <p>
     * <strong>Header Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addHeader}
     * <p>
     * <strong>Request Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Required)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Required)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     *
     * @param queueId Id of a queue.
     * @param resource The resource instance.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a queue that can contain jobs to be routed along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<BinaryData> upsertQueueWithResponse(String queueId, BinaryData resource, RequestOptions requestOptions) {
        // Convenience API is not generated, as operation 'upsertQueue' is 'application/merge-patch+json'
        return this.serviceClient.upsertQueueWithResponse(queueId, resource, requestOptions);
    }

    /**
     * Updates a queue.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     queueId: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Optional)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     queueId: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Optional)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     *
     * @param queueId The Id of this queue.
     * @param resource RouterQueue resource.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a queue that can contain jobs to be routed along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> updateQueueWithResponse(String queueId, BinaryData resource,
        RequestOptions requestOptions) {
        return this.serviceClient.upsertQueueWithResponse(queueId, resource, requestOptions);
    }

    /**
     * Updates a queue.
     *
     * <p>
     * <strong>Header Parameters</strong>
     *
     * <table border="1">
     * <caption>Header Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>If-Match</td>
     * <td>String</td>
     * <td>No</td>
     * <td>The request should only proceed if an entity matches this string.</td>
     * </tr>
     * <tr>
     * <td>If-Unmodified-Since</td>
     * <td>OffsetDateTime</td>
     * <td>No</td>
     * <td>The request should only proceed if the entity was not modified after this time.</td>
     * </tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p>
     * <strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     queueId: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Optional)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     *
     * <p>
     * <strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     queueId: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Optional)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     *
     * @param queueId The Id of this queue.
     * @param resource RouterQueue resource.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @return a queue that can contain jobs to be routed along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BinaryData updateQueue(String queueId, BinaryData resource, RequestOptions requestOptions) {
        return updateQueueWithResponse(queueId, resource, requestOptions).getValue();
    }

    /**
     * Create a queue.
     *
     * @param createQueueOptions Container for inputs to create a queue.
     * @param requestOptions RequestOptions.
     * @return a queue that can contain jobs to be routed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RouterQueue> createQueueWithResponse(CreateQueueOptions createQueueOptions,
        RequestOptions requestOptions) {
        RouterQueueInternal queue = QueueAdapter.convertCreateQueueOptionsToRouterQueueInternal(createQueueOptions);
        Response<BinaryData> response = this.serviceClient.upsertQueueWithResponse(createQueueOptions.getQueueId(),
            BinaryData.fromObject(queue), requestOptions);
        return new SimpleResponse<RouterQueue>(response.getRequest(), response.getStatusCode(), response.getHeaders(),
            RouterQueueConstructorProxy.create(response.getValue().toObject(RouterQueueInternal.class)));
    }

    /**
     * Convenience method to create a queue.
     *
     * @param createQueueOptions Container for inputs to create a queue.
     * @return a queue that can contain jobs to be routed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterQueue createQueue(CreateQueueOptions createQueueOptions) {
        RequestOptions requestOptions = new RequestOptions();
        return this.createQueueWithResponse(createQueueOptions, requestOptions).getValue();
    }

    /**
     * Retrieves an existing queue by Id.
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Required)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     *
     * @param queueId Id of a queue.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a queue that can contain jobs to be routed along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getQueueWithResponse(String queueId, RequestOptions requestOptions) {
        return this.serviceClient.getQueueWithResponse(queueId, requestOptions);
    }

    /**
     * Retrieves existing queues.
     * <p>
     * <strong>Query Parameters</strong>
     * </p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr>
     * <th>Name</th>
     * <th>Type</th>
     * <th>Required</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>maxpagesize</td>
     * <td>Integer</td>
     * <td>No</td>
     * <td>Number of objects to return per page.</td>
     * </tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p>
     * <strong>Response Body Schema</strong>
     * </p>
     * <pre>{@code
     * {
     *     etag: String (Required)
     *     id: String (Required)
     *     name: String (Optional)
     *     distributionPolicyId: String (Optional)
     *     labels (Optional): {
     *         String: Object (Required)
     *     }
     *     exceptionPolicyId: String (Optional)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of RouterQueue items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listQueues(RequestOptions requestOptions) {
        return this.serviceClient.listQueues(requestOptions);
    }

    /**
     * Deletes a queue by Id.
     *
     * @param queueId Id of a queue.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteQueueWithResponse(String queueId, RequestOptions requestOptions) {
        return this.serviceClient.deleteQueueWithResponse(queueId, requestOptions);
    }

    /**
     * Retrieves an existing distribution policy by Id.
     *
     * @param distributionPolicyId The unique identifier of the policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DistributionPolicy getDistributionPolicy(String distributionPolicyId) {
        // Generated convenience method for getDistributionPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDistributionPolicyWithResponse(distributionPolicyId, requestOptions).getValue()
            .toObject(DistributionPolicy.class);
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DistributionPolicy> listDistributionPolicies() {
        // Generated convenience method for listDistributionPolicies
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listDistributionPolicies(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DistributionPolicy.class));
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param distributionPolicyId Id of a distribution policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteDistributionPolicy(String distributionPolicyId) {
        // Generated convenience method for deleteDistributionPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteDistributionPolicyWithResponse(distributionPolicyId, requestOptions).getValue();
    }

    /**
     * Retrieves an existing classification policy by Id.
     *
     * @param classificationPolicyId Unique identifier of this policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ClassificationPolicy getClassificationPolicy(String classificationPolicyId) {
        // Generated convenience method for getClassificationPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getClassificationPolicyWithResponse(classificationPolicyId, requestOptions).getValue()
            .toObject(ClassificationPolicy.class);
    }

    /**
     * Retrieves existing classification policies.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ClassificationPolicy> listClassificationPolicies() {
        // Generated convenience method for listClassificationPolicies
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listClassificationPolicies(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(ClassificationPolicy.class));
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param classificationPolicyId Id of a classification policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteClassificationPolicy(String classificationPolicyId) {
        // Generated convenience method for deleteClassificationPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteClassificationPolicyWithResponse(classificationPolicyId, requestOptions).getValue();
    }

    /**
     * Retrieves an existing exception policy by Id.
     *
     * @param exceptionPolicyId The Id of the exception policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ExceptionPolicy getExceptionPolicy(String exceptionPolicyId) {
        // Generated convenience method for getExceptionPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getExceptionPolicyWithResponse(exceptionPolicyId, requestOptions).getValue()
            .toObject(ExceptionPolicy.class);
    }

    /**
     * Retrieves existing exception policies.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of ExceptionPolicy items as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ExceptionPolicy> listExceptionPolicies() {
        // Generated convenience method for listExceptionPolicies
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listExceptionPolicies(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(ExceptionPolicy.class));
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param exceptionPolicyId Id of an exception policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteExceptionPolicy(String exceptionPolicyId) {
        // Generated convenience method for deleteExceptionPolicyWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteExceptionPolicyWithResponse(exceptionPolicyId, requestOptions).getValue();
    }

    /**
     * Retrieves an existing queue by Id.
     *
     * @param queueId The Id of this queue.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RouterQueue getQueue(String queueId) {
        // Generated convenience method for getQueueWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getQueueWithResponse(queueId, requestOptions).getValue().toObject(RouterQueue.class);
    }

    /**
     * Retrieves existing queues.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<RouterQueue> listQueues() {
        // Generated convenience method for listQueues
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listQueues(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(RouterQueue.class));
    }

    /**
     * Deletes a queue by Id.
     *
     * @param queueId Id of a queue.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteQueue(String queueId) {
        // Generated convenience method for deleteQueueWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteQueueWithResponse(queueId, requestOptions).getValue();
    }
}
