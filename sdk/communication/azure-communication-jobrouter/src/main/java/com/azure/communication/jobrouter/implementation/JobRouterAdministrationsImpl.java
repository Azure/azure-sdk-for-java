// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.communication.jobrouter.implementation;

import com.azure.communication.jobrouter.implementation.models.CommunicationErrorResponseException;
import com.azure.communication.jobrouter.models.ClassificationPolicy;
import com.azure.communication.jobrouter.models.ClassificationPolicyCollection;
import com.azure.communication.jobrouter.models.ClassificationPolicyItem;
import com.azure.communication.jobrouter.models.DistributionPolicy;
import com.azure.communication.jobrouter.models.DistributionPolicyCollection;
import com.azure.communication.jobrouter.models.DistributionPolicyItem;
import com.azure.communication.jobrouter.models.ExceptionPolicy;
import com.azure.communication.jobrouter.models.ExceptionPolicyCollection;
import com.azure.communication.jobrouter.models.ExceptionPolicyItem;
import com.azure.communication.jobrouter.models.JobQueue;
import com.azure.communication.jobrouter.models.JobQueueItem;
import com.azure.communication.jobrouter.models.QueueCollection;
import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import reactor.core.publisher.Mono;

/** An instance of this class provides access to all the operations defined in JobRouterAdministrations. */
public final class JobRouterAdministrationsImpl {
    /** The proxy service used to perform REST calls. */
    private final JobRouterAdministrationsService service;

    /** The service client containing this operation class. */
    private final AzureCommunicationRoutingServiceImpl client;

    /**
     * Initializes an instance of JobRouterAdministrationsImpl.
     *
     * @param client the instance of the service client containing this operation class.
     */
    JobRouterAdministrationsImpl(AzureCommunicationRoutingServiceImpl client) {
        this.service =
                RestProxy.create(
                        JobRouterAdministrationsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for AzureCommunicationRoutingServiceJobRouterAdministrations to be used
     * by the proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "AzureCommunicationRo")
    private interface JobRouterAdministrationsService {
        @Patch("/routing/classificationPolicies/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ClassificationPolicy>> upsertClassificationPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/merge-patch+json") ClassificationPolicy patch,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/classificationPolicies/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ClassificationPolicy>> getClassificationPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/routing/classificationPolicies/{id}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Void>> deleteClassificationPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/classificationPolicies")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ClassificationPolicyCollection>> listClassificationPolicies(
                @HostParam("endpoint") String endpoint,
                @QueryParam("maxpagesize") Integer maxpagesize,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/routing/distributionPolicies/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<DistributionPolicy>> upsertDistributionPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/merge-patch+json") DistributionPolicy patch,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/distributionPolicies/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<DistributionPolicy>> getDistributionPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/routing/distributionPolicies/{id}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Void>> deleteDistributionPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/distributionPolicies")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<DistributionPolicyCollection>> listDistributionPolicies(
                @HostParam("endpoint") String endpoint,
                @QueryParam("maxpagesize") Integer maxpagesize,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/routing/exceptionPolicies/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ExceptionPolicy>> upsertExceptionPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/merge-patch+json") ExceptionPolicy patch,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/exceptionPolicies/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ExceptionPolicy>> getExceptionPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/routing/exceptionPolicies/{id}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Void>> deleteExceptionPolicy(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/exceptionPolicies")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ExceptionPolicyCollection>> listExceptionPolicies(
                @HostParam("endpoint") String endpoint,
                @QueryParam("maxpagesize") Integer maxpagesize,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Patch("/routing/queues/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<JobQueue>> upsertQueue(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/merge-patch+json") JobQueue patch,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/queues/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<JobQueue>> getQueue(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/routing/queues/{id}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<Void>> deleteQueue(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/routing/queues")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<QueueCollection>> listQueues(
                @HostParam("endpoint") String endpoint,
                @QueryParam("maxpagesize") Integer maxpagesize,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ClassificationPolicyCollection>> listClassificationPoliciesNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<DistributionPolicyCollection>> listDistributionPoliciesNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<ExceptionPolicyCollection>> listExceptionPoliciesNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CommunicationErrorResponseException.class)
        Mono<Response<QueueCollection>> listQueuesNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);
    }

    /**
     * Creates or updates a classification policy.
     *
     * @param id Id of the classification policy.
     * @param patch Model of classification policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ClassificationPolicy>> upsertClassificationPolicyWithResponseAsync(
            String id, ClassificationPolicy patch) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upsertClassificationPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context));
    }

    /**
     * Creates or updates a classification policy.
     *
     * @param id Id of the classification policy.
     * @param patch Model of classification policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ClassificationPolicy>> upsertClassificationPolicyWithResponseAsync(
            String id, ClassificationPolicy patch, Context context) {
        final String accept = "application/json";
        return service.upsertClassificationPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context);
    }

    /**
     * Creates or updates a classification policy.
     *
     * @param id Id of the classification policy.
     * @param patch Model of classification policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ClassificationPolicy> upsertClassificationPolicyAsync(String id, ClassificationPolicy patch) {
        return upsertClassificationPolicyWithResponseAsync(id, patch).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a classification policy.
     *
     * @param id Id of the classification policy.
     * @param patch Model of classification policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ClassificationPolicy> upsertClassificationPolicyAsync(
            String id, ClassificationPolicy patch, Context context) {
        return upsertClassificationPolicyWithResponseAsync(id, patch, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a classification policy.
     *
     * @param id Id of the classification policy.
     * @param patch Model of classification policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ClassificationPolicy upsertClassificationPolicy(String id, ClassificationPolicy patch) {
        return upsertClassificationPolicyAsync(id, patch).block();
    }

    /**
     * Creates or updates a classification policy.
     *
     * @param id Id of the classification policy.
     * @param patch Model of classification policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<ClassificationPolicy> upsertClassificationPolicyWithResponse(
            String id, ClassificationPolicy patch, Context context) {
        return upsertClassificationPolicyWithResponseAsync(id, patch, context).block();
    }

    /**
     * Retrieves an existing classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ClassificationPolicy>> getClassificationPolicyWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getClassificationPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves an existing classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified along with {@link Response} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ClassificationPolicy>> getClassificationPolicyWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.getClassificationPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves an existing classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ClassificationPolicy> getClassificationPolicyAsync(String id) {
        return getClassificationPolicyWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ClassificationPolicy> getClassificationPolicyAsync(String id, Context context) {
        return getClassificationPolicyWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ClassificationPolicy getClassificationPolicy(String id) {
        return getClassificationPolicyAsync(id).block();
    }

    /**
     * Retrieves an existing classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a container for the rules that govern how jobs are classified along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<ClassificationPolicy> getClassificationPolicyWithResponse(String id, Context context) {
        return getClassificationPolicyWithResponseAsync(id, context).block();
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteClassificationPolicyWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteClassificationPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteClassificationPolicyWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.deleteClassificationPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteClassificationPolicyAsync(String id) {
        return deleteClassificationPolicyWithResponseAsync(id).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteClassificationPolicyAsync(String id, Context context) {
        return deleteClassificationPolicyWithResponseAsync(id, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteClassificationPolicy(String id) {
        deleteClassificationPolicyAsync(id).block();
    }

    /**
     * Delete a classification policy by Id.
     *
     * @param id Id of the classification policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteClassificationPolicyWithResponse(String id, Context context) {
        return deleteClassificationPolicyWithResponseAsync(id, context).block();
    }

    /**
     * Retrieves existing classification policies.
     *
     * @param maxpagesize Maximum page size.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies along with {@link PagedResponse} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ClassificationPolicyItem>> listClassificationPoliciesSinglePageAsync(
            Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listClassificationPolicies(
                                        this.client.getEndpoint(),
                                        maxpagesize,
                                        this.client.getApiVersion(),
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing classification policies.
     *
     * @param maxpagesize Maximum page size.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies along with {@link PagedResponse} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ClassificationPolicyItem>> listClassificationPoliciesSinglePageAsync(
            Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.listClassificationPolicies(
                        this.client.getEndpoint(), maxpagesize, this.client.getApiVersion(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing classification policies.
     *
     * @param maxpagesize Maximum page size.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<ClassificationPolicyItem> listClassificationPoliciesAsync(Integer maxpagesize) {
        return new PagedFlux<>(
                () -> listClassificationPoliciesSinglePageAsync(maxpagesize),
                nextLink -> listClassificationPoliciesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing classification policies.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<ClassificationPolicyItem> listClassificationPoliciesAsync() {
        final Integer maxpagesize = null;
        return new PagedFlux<>(
                () -> listClassificationPoliciesSinglePageAsync(maxpagesize),
                nextLink -> listClassificationPoliciesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing classification policies.
     *
     * @param maxpagesize Maximum page size.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<ClassificationPolicyItem> listClassificationPoliciesAsync(Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> listClassificationPoliciesSinglePageAsync(maxpagesize, context),
                nextLink -> listClassificationPoliciesNextSinglePageAsync(nextLink, context));
    }

    /**
     * Retrieves existing classification policies.
     *
     * @param maxpagesize Maximum page size.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ClassificationPolicyItem> listClassificationPolicies(Integer maxpagesize) {
        return new PagedIterable<>(listClassificationPoliciesAsync(maxpagesize));
    }

    /**
     * Retrieves existing classification policies.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ClassificationPolicyItem> listClassificationPolicies() {
        final Integer maxpagesize = null;
        return new PagedIterable<>(listClassificationPoliciesAsync(maxpagesize));
    }

    /**
     * Retrieves existing classification policies.
     *
     * @param maxpagesize Maximum page size.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ClassificationPolicyItem> listClassificationPolicies(Integer maxpagesize, Context context) {
        return new PagedIterable<>(listClassificationPoliciesAsync(maxpagesize, context));
    }

    /**
     * Creates or updates a distribution policy.
     *
     * @param id Id of the distribution policy.
     * @param patch Model of distribution policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers along with {@link Response} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DistributionPolicy>> upsertDistributionPolicyWithResponseAsync(
            String id, DistributionPolicy patch) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upsertDistributionPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context));
    }

    /**
     * Creates or updates a distribution policy.
     *
     * @param id Id of the distribution policy.
     * @param patch Model of distribution policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers along with {@link Response} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DistributionPolicy>> upsertDistributionPolicyWithResponseAsync(
            String id, DistributionPolicy patch, Context context) {
        final String accept = "application/json";
        return service.upsertDistributionPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context);
    }

    /**
     * Creates or updates a distribution policy.
     *
     * @param id Id of the distribution policy.
     * @param patch Model of distribution policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DistributionPolicy> upsertDistributionPolicyAsync(String id, DistributionPolicy patch) {
        return upsertDistributionPolicyWithResponseAsync(id, patch).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a distribution policy.
     *
     * @param id Id of the distribution policy.
     * @param patch Model of distribution policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DistributionPolicy> upsertDistributionPolicyAsync(
            String id, DistributionPolicy patch, Context context) {
        return upsertDistributionPolicyWithResponseAsync(id, patch, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a distribution policy.
     *
     * @param id Id of the distribution policy.
     * @param patch Model of distribution policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DistributionPolicy upsertDistributionPolicy(String id, DistributionPolicy patch) {
        return upsertDistributionPolicyAsync(id, patch).block();
    }

    /**
     * Creates or updates a distribution policy.
     *
     * @param id Id of the distribution policy.
     * @param patch Model of distribution policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DistributionPolicy> upsertDistributionPolicyWithResponse(
            String id, DistributionPolicy patch, Context context) {
        return upsertDistributionPolicyWithResponseAsync(id, patch, context).block();
    }

    /**
     * Retrieves an existing distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers along with {@link Response} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DistributionPolicy>> getDistributionPolicyWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getDistributionPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves an existing distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers along with {@link Response} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DistributionPolicy>> getDistributionPolicyWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.getDistributionPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves an existing distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DistributionPolicy> getDistributionPolicyAsync(String id) {
        return getDistributionPolicyWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DistributionPolicy> getDistributionPolicyAsync(String id, Context context) {
        return getDistributionPolicyWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DistributionPolicy getDistributionPolicy(String id) {
        return getDistributionPolicyAsync(id).block();
    }

    /**
     * Retrieves an existing distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return policy governing how jobs are distributed to workers along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DistributionPolicy> getDistributionPolicyWithResponse(String id, Context context) {
        return getDistributionPolicyWithResponseAsync(id, context).block();
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteDistributionPolicyWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteDistributionPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteDistributionPolicyWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.deleteDistributionPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteDistributionPolicyAsync(String id) {
        return deleteDistributionPolicyWithResponseAsync(id).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteDistributionPolicyAsync(String id, Context context) {
        return deleteDistributionPolicyWithResponseAsync(id, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteDistributionPolicy(String id) {
        deleteDistributionPolicyAsync(id).block();
    }

    /**
     * Delete a distribution policy by Id.
     *
     * @param id Id of the distribution policy.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDistributionPolicyWithResponse(String id, Context context) {
        return deleteDistributionPolicyWithResponseAsync(id, context).block();
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @param maxpagesize Maximum page size.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DistributionPolicyItem>> listDistributionPoliciesSinglePageAsync(Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listDistributionPolicies(
                                        this.client.getEndpoint(),
                                        maxpagesize,
                                        this.client.getApiVersion(),
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @param maxpagesize Maximum page size.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DistributionPolicyItem>> listDistributionPoliciesSinglePageAsync(
            Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.listDistributionPolicies(
                        this.client.getEndpoint(), maxpagesize, this.client.getApiVersion(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @param maxpagesize Maximum page size.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DistributionPolicyItem> listDistributionPoliciesAsync(Integer maxpagesize) {
        return new PagedFlux<>(
                () -> listDistributionPoliciesSinglePageAsync(maxpagesize),
                nextLink -> listDistributionPoliciesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DistributionPolicyItem> listDistributionPoliciesAsync() {
        final Integer maxpagesize = null;
        return new PagedFlux<>(
                () -> listDistributionPoliciesSinglePageAsync(maxpagesize),
                nextLink -> listDistributionPoliciesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @param maxpagesize Maximum page size.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DistributionPolicyItem> listDistributionPoliciesAsync(Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> listDistributionPoliciesSinglePageAsync(maxpagesize, context),
                nextLink -> listDistributionPoliciesNextSinglePageAsync(nextLink, context));
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @param maxpagesize Maximum page size.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DistributionPolicyItem> listDistributionPolicies(Integer maxpagesize) {
        return new PagedIterable<>(listDistributionPoliciesAsync(maxpagesize));
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DistributionPolicyItem> listDistributionPolicies() {
        final Integer maxpagesize = null;
        return new PagedIterable<>(listDistributionPoliciesAsync(maxpagesize));
    }

    /**
     * Retrieves existing distribution policies.
     *
     * @param maxpagesize Maximum page size.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DistributionPolicyItem> listDistributionPolicies(Integer maxpagesize, Context context) {
        return new PagedIterable<>(listDistributionPoliciesAsync(maxpagesize, context));
    }

    /**
     * Creates or updates a exception policy.
     *
     * @param id Id of the exception policy.
     * @param patch Model of exception policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response} on
     *     successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ExceptionPolicy>> upsertExceptionPolicyWithResponseAsync(String id, ExceptionPolicy patch) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upsertExceptionPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context));
    }

    /**
     * Creates or updates a exception policy.
     *
     * @param id Id of the exception policy.
     * @param patch Model of exception policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response} on
     *     successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ExceptionPolicy>> upsertExceptionPolicyWithResponseAsync(
            String id, ExceptionPolicy patch, Context context) {
        final String accept = "application/json";
        return service.upsertExceptionPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context);
    }

    /**
     * Creates or updates a exception policy.
     *
     * @param id Id of the exception policy.
     * @param patch Model of exception policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ExceptionPolicy> upsertExceptionPolicyAsync(String id, ExceptionPolicy patch) {
        return upsertExceptionPolicyWithResponseAsync(id, patch).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a exception policy.
     *
     * @param id Id of the exception policy.
     * @param patch Model of exception policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ExceptionPolicy> upsertExceptionPolicyAsync(String id, ExceptionPolicy patch, Context context) {
        return upsertExceptionPolicyWithResponseAsync(id, patch, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a exception policy.
     *
     * @param id Id of the exception policy.
     * @param patch Model of exception policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ExceptionPolicy upsertExceptionPolicy(String id, ExceptionPolicy patch) {
        return upsertExceptionPolicyAsync(id, patch).block();
    }

    /**
     * Creates or updates a exception policy.
     *
     * @param id Id of the exception policy.
     * @param patch Model of exception policy properties to be patched. See also:
     *     https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<ExceptionPolicy> upsertExceptionPolicyWithResponse(
            String id, ExceptionPolicy patch, Context context) {
        return upsertExceptionPolicyWithResponseAsync(id, patch, context).block();
    }

    /**
     * Retrieves an existing exception policy by Id.
     *
     * @param id Id of the exception policy to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response} on
     *     successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ExceptionPolicy>> getExceptionPolicyWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getExceptionPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves an existing exception policy by Id.
     *
     * @param id Id of the exception policy to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response} on
     *     successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<ExceptionPolicy>> getExceptionPolicyWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.getExceptionPolicy(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves an existing exception policy by Id.
     *
     * @param id Id of the exception policy to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ExceptionPolicy> getExceptionPolicyAsync(String id) {
        return getExceptionPolicyWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing exception policy by Id.
     *
     * @param id Id of the exception policy to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ExceptionPolicy> getExceptionPolicyAsync(String id, Context context) {
        return getExceptionPolicyWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing exception policy by Id.
     *
     * @param id Id of the exception policy to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ExceptionPolicy getExceptionPolicy(String id) {
        return getExceptionPolicyAsync(id).block();
    }

    /**
     * Retrieves an existing exception policy by Id.
     *
     * @param id Id of the exception policy to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a policy that defines actions to execute when exception are triggered along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<ExceptionPolicy> getExceptionPolicyWithResponse(String id, Context context) {
        return getExceptionPolicyWithResponseAsync(id, context).block();
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param id Id of the exception policy to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteExceptionPolicyWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteExceptionPolicy(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param id Id of the exception policy to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteExceptionPolicyWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.deleteExceptionPolicy(
                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param id Id of the exception policy to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteExceptionPolicyAsync(String id) {
        return deleteExceptionPolicyWithResponseAsync(id).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param id Id of the exception policy to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteExceptionPolicyAsync(String id, Context context) {
        return deleteExceptionPolicyWithResponseAsync(id, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param id Id of the exception policy to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteExceptionPolicy(String id) {
        deleteExceptionPolicyAsync(id).block();
    }

    /**
     * Deletes a exception policy by Id.
     *
     * @param id Id of the exception policy to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteExceptionPolicyWithResponse(String id, Context context) {
        return deleteExceptionPolicyWithResponseAsync(id, context).block();
    }

    /**
     * Retrieves existing exception policies.
     *
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ExceptionPolicyItem>> listExceptionPoliciesSinglePageAsync(Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listExceptionPolicies(
                                        this.client.getEndpoint(),
                                        maxpagesize,
                                        this.client.getApiVersion(),
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing exception policies.
     *
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ExceptionPolicyItem>> listExceptionPoliciesSinglePageAsync(
            Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.listExceptionPolicies(
                        this.client.getEndpoint(), maxpagesize, this.client.getApiVersion(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing exception policies.
     *
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<ExceptionPolicyItem> listExceptionPoliciesAsync(Integer maxpagesize) {
        return new PagedFlux<>(
                () -> listExceptionPoliciesSinglePageAsync(maxpagesize),
                nextLink -> listExceptionPoliciesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing exception policies.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<ExceptionPolicyItem> listExceptionPoliciesAsync() {
        final Integer maxpagesize = null;
        return new PagedFlux<>(
                () -> listExceptionPoliciesSinglePageAsync(maxpagesize),
                nextLink -> listExceptionPoliciesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing exception policies.
     *
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<ExceptionPolicyItem> listExceptionPoliciesAsync(Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> listExceptionPoliciesSinglePageAsync(maxpagesize, context),
                nextLink -> listExceptionPoliciesNextSinglePageAsync(nextLink, context));
    }

    /**
     * Retrieves existing exception policies.
     *
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ExceptionPolicyItem> listExceptionPolicies(Integer maxpagesize) {
        return new PagedIterable<>(listExceptionPoliciesAsync(maxpagesize));
    }

    /**
     * Retrieves existing exception policies.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ExceptionPolicyItem> listExceptionPolicies() {
        final Integer maxpagesize = null;
        return new PagedIterable<>(listExceptionPoliciesAsync(maxpagesize));
    }

    /**
     * Retrieves existing exception policies.
     *
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ExceptionPolicyItem> listExceptionPolicies(Integer maxpagesize, Context context) {
        return new PagedIterable<>(listExceptionPoliciesAsync(maxpagesize, context));
    }

    /**
     * Creates or updates a queue.
     *
     * @param id Id of the queue.
     * @param patch Model of queue properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed along with {@link Response} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<JobQueue>> upsertQueueWithResponseAsync(String id, JobQueue patch) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upsertQueue(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context));
    }

    /**
     * Creates or updates a queue.
     *
     * @param id Id of the queue.
     * @param patch Model of queue properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed along with {@link Response} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<JobQueue>> upsertQueueWithResponseAsync(String id, JobQueue patch, Context context) {
        final String accept = "application/json";
        return service.upsertQueue(this.client.getEndpoint(), id, this.client.getApiVersion(), patch, accept, context);
    }

    /**
     * Creates or updates a queue.
     *
     * @param id Id of the queue.
     * @param patch Model of queue properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<JobQueue> upsertQueueAsync(String id, JobQueue patch) {
        return upsertQueueWithResponseAsync(id, patch).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a queue.
     *
     * @param id Id of the queue.
     * @param patch Model of queue properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<JobQueue> upsertQueueAsync(String id, JobQueue patch, Context context) {
        return upsertQueueWithResponseAsync(id, patch, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Creates or updates a queue.
     *
     * @param id Id of the queue.
     * @param patch Model of queue properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public JobQueue upsertQueue(String id, JobQueue patch) {
        return upsertQueueAsync(id, patch).block();
    }

    /**
     * Creates or updates a queue.
     *
     * @param id Id of the queue.
     * @param patch Model of queue properties to be patched. See also: https://datatracker.ietf.org/doc/html/rfc7386.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<JobQueue> upsertQueueWithResponse(String id, JobQueue patch, Context context) {
        return upsertQueueWithResponseAsync(id, patch, context).block();
    }

    /**
     * Retrieves an existing queue by Id.
     *
     * @param id Id of the queue to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed along with {@link Response} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<JobQueue>> getQueueWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.getQueue(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Retrieves an existing queue by Id.
     *
     * @param id Id of the queue to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed along with {@link Response} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<JobQueue>> getQueueWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.getQueue(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Retrieves an existing queue by Id.
     *
     * @param id Id of the queue to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<JobQueue> getQueueAsync(String id) {
        return getQueueWithResponseAsync(id).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing queue by Id.
     *
     * @param id Id of the queue to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<JobQueue> getQueueAsync(String id, Context context) {
        return getQueueWithResponseAsync(id, context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Retrieves an existing queue by Id.
     *
     * @param id Id of the queue to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public JobQueue getQueue(String id) {
        return getQueueAsync(id).block();
    }

    /**
     * Retrieves an existing queue by Id.
     *
     * @param id Id of the queue to retrieve.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a queue that can contain jobs to be routed along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<JobQueue> getQueueWithResponse(String id, Context context) {
        return getQueueWithResponseAsync(id, context).block();
    }

    /**
     * Deletes a queue by Id.
     *
     * @param id Id of the queue to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteQueueWithResponseAsync(String id) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.deleteQueue(
                                this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context));
    }

    /**
     * Deletes a queue by Id.
     *
     * @param id Id of the queue to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteQueueWithResponseAsync(String id, Context context) {
        final String accept = "application/json";
        return service.deleteQueue(this.client.getEndpoint(), id, this.client.getApiVersion(), accept, context);
    }

    /**
     * Deletes a queue by Id.
     *
     * @param id Id of the queue to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteQueueAsync(String id) {
        return deleteQueueWithResponseAsync(id).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a queue by Id.
     *
     * @param id Id of the queue to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteQueueAsync(String id, Context context) {
        return deleteQueueWithResponseAsync(id, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Deletes a queue by Id.
     *
     * @param id Id of the queue to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteQueue(String id) {
        deleteQueueAsync(id).block();
    }

    /**
     * Deletes a queue by Id.
     *
     * @param id Id of the queue to delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteQueueWithResponse(String id, Context context) {
        return deleteQueueWithResponseAsync(id, context).block();
    }

    /**
     * Retrieves existing queues.
     *
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<JobQueueItem>> listQueuesSinglePageAsync(Integer maxpagesize) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listQueues(
                                        this.client.getEndpoint(),
                                        maxpagesize,
                                        this.client.getApiVersion(),
                                        accept,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing queues.
     *
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<JobQueueItem>> listQueuesSinglePageAsync(Integer maxpagesize, Context context) {
        final String accept = "application/json";
        return service.listQueues(this.client.getEndpoint(), maxpagesize, this.client.getApiVersion(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Retrieves existing queues.
     *
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<JobQueueItem> listQueuesAsync(Integer maxpagesize) {
        return new PagedFlux<>(
                () -> listQueuesSinglePageAsync(maxpagesize), nextLink -> listQueuesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing queues.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<JobQueueItem> listQueuesAsync() {
        final Integer maxpagesize = null;
        return new PagedFlux<>(
                () -> listQueuesSinglePageAsync(maxpagesize), nextLink -> listQueuesNextSinglePageAsync(nextLink));
    }

    /**
     * Retrieves existing queues.
     *
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<JobQueueItem> listQueuesAsync(Integer maxpagesize, Context context) {
        return new PagedFlux<>(
                () -> listQueuesSinglePageAsync(maxpagesize, context),
                nextLink -> listQueuesNextSinglePageAsync(nextLink, context));
    }

    /**
     * Retrieves existing queues.
     *
     * @param maxpagesize Number of objects to return per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<JobQueueItem> listQueues(Integer maxpagesize) {
        return new PagedIterable<>(listQueuesAsync(maxpagesize));
    }

    /**
     * Retrieves existing queues.
     *
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<JobQueueItem> listQueues() {
        final Integer maxpagesize = null;
        return new PagedIterable<>(listQueuesAsync(maxpagesize));
    }

    /**
     * Retrieves existing queues.
     *
     * @param maxpagesize Number of objects to return per page.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<JobQueueItem> listQueues(Integer maxpagesize, Context context) {
        return new PagedIterable<>(listQueuesAsync(maxpagesize, context));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies along with {@link PagedResponse} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ClassificationPolicyItem>> listClassificationPoliciesNextSinglePageAsync(
            String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listClassificationPoliciesNext(
                                        nextLink, this.client.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of classification policies along with {@link PagedResponse} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ClassificationPolicyItem>> listClassificationPoliciesNextSinglePageAsync(
            String nextLink, Context context) {
        final String accept = "application/json";
        return service.listClassificationPoliciesNext(nextLink, this.client.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DistributionPolicyItem>> listDistributionPoliciesNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listDistributionPoliciesNext(
                                        nextLink, this.client.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of distribution policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DistributionPolicyItem>> listDistributionPoliciesNextSinglePageAsync(
            String nextLink, Context context) {
        final String accept = "application/json";
        return service.listDistributionPoliciesNext(nextLink, this.client.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ExceptionPolicyItem>> listExceptionPoliciesNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listExceptionPoliciesNext(nextLink, this.client.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of exception policies along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ExceptionPolicyItem>> listExceptionPoliciesNextSinglePageAsync(
            String nextLink, Context context) {
        final String accept = "application/json";
        return service.listExceptionPoliciesNext(nextLink, this.client.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<JobQueueItem>> listQueuesNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context -> service.listQueuesNext(nextLink, this.client.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CommunicationErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a paged collection of queues along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<JobQueueItem>> listQueuesNextSinglePageAsync(String nextLink, Context context) {
        final String accept = "application/json";
        return service.listQueuesNext(nextLink, this.client.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getValue(),
                                        res.getValue().getNextLink(),
                                        null));
    }
}
