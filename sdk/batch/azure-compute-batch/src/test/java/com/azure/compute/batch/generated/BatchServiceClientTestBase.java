// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.compute.batch.generated;

import com.azure.compute.batch.*;
import com.azure.compute.batch.auth.BatchSharedKeyCredentials;
import com.azure.compute.batch.models.*;
import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.policy.HttpLogDetailLevel;
import com.azure.core.http.policy.HttpLogOptions;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.test.TestBase;
import com.azure.core.test.TestMode;
import com.azure.core.util.Configuration;
import com.azure.identity.DefaultAzureCredentialBuilder;

import java.io.File;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.time.OffsetDateTime;

import com.azure.storage.blob.BlobContainerClient;
import com.azure.storage.blob.BlobContainerClientBuilder;
import com.azure.storage.blob.models.BlobStorageException;
import com.azure.storage.blob.sas.BlobServiceSasSignatureValues;
import com.azure.storage.common.StorageSharedKeyCredential;
import com.azure.storage.blob.BlobClient;
import com.azure.storage.blob.sas.BlobSasPermission;
import reactor.core.publisher.Mono;

import java.util.*;

import com.azure.core.management.AzureEnvironment;
import com.azure.core.management.profile.AzureProfile;
import com.azure.resourcemanager.network.NetworkManager;
import com.azure.resourcemanager.network.models.Network;
import com.azure.core.credential.TokenCredential;

import org.junit.Assert;


class BatchServiceClientTestBase extends TestBase {
    protected BatchServiceClientBuilder batchClientBuilder;

    protected ApplicationsClient applicationsClient;

    protected PoolClient poolClient;

    protected AccountClient accountClient;

    protected JobClient jobClient;

    protected CertificatesClient certificatesClient;

    protected FileClient fileClient;

    protected JobScheduleClient jobScheduleClient;

    protected TaskClient taskClient;

    protected ComputeNodesClient computeNodesClient;

    protected ComputeNodeExtensionsClient computeNodeExtensionsClient;

	static final int MAX_LEN_ID = 64;

	public enum AuthMode {
	        AAD, SharedKey
	    }
	
    @Override
    protected void beforeTest() {
    	batchClientBuilder =
                new BatchServiceClientBuilder()
                        .endpoint(Configuration.getGlobalConfiguration().get("AZURE_BATCH_ENDPOINT", "endpoint"))
                        .httpClient(HttpClient.createDefault())
                        .httpLogOptions(new HttpLogOptions().setLogLevel(HttpLogDetailLevel.BASIC));
        if (getTestMode() == TestMode.PLAYBACK) {
        	batchClientBuilder
                    .httpClient(interceptorManager.getPlaybackClient())
                    .credential(request -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)));
        } else if (getTestMode() == TestMode.RECORD) {
        	batchClientBuilder.addPolicy(interceptorManager.getRecordPolicy());
        }

        authenticateClient(AuthMode.AAD);

        applicationsClient = batchClientBuilder.buildApplicationsClient();
        poolClient = batchClientBuilder.buildPoolClient();
        accountClient = batchClientBuilder.buildAccountClient();
        jobClient = batchClientBuilder.buildJobClient();
        certificatesClient = batchClientBuilder.buildCertificatesClient();
        fileClient = batchClientBuilder.buildFileClient();
        jobScheduleClient = batchClientBuilder.buildJobScheduleClient();
        taskClient = batchClientBuilder.buildTaskClient();
        computeNodesClient = batchClientBuilder.buildComputeNodesClient();
        computeNodeExtensionsClient = batchClientBuilder.buildComputeNodeExtensionsClient();
    }
    
    void authenticateClient(AuthMode auth) {
	    if (getTestMode() == TestMode.RECORD) {
            if (auth == AuthMode.AAD) {
                batchClientBuilder.credential(new DefaultAzureCredentialBuilder().build());
            }
            else {
                BatchSharedKeyCredentials keyCredentials = getSharedKeyCredentials();
                batchClientBuilder.credential(keyCredentials);
            }
        }
    }

    static BatchSharedKeyCredentials getSharedKeyCredentials() {
        Configuration localConfig = Configuration.getGlobalConfiguration();
        String baseUrl = localConfig.get("AZURE_BATCH_ENDPOINT");
        String accountName = localConfig.get("AZURE_BATCH_ACCOUNT");
        String accountKey = localConfig.get("AZURE_BATCH_ACCESS_KEY");
        return new BatchSharedKeyCredentials(baseUrl, accountName, accountKey);
    }

    static String getStringIdWithUserNamePrefix(String name) {
        //'BatchUser' is the name used for Recording / Playing Back tests.
        // For Local testing, use your username here, to create your unique Batch resources and avoiding conflict in shared batch account.
        String userName = "BatchUser";
        StringBuilder out = new StringBuilder();
        int remainingSpace = MAX_LEN_ID - name.length();
        if (remainingSpace > 0) {
            if (userName.length() > remainingSpace) {
                out.append(userName.substring(0, remainingSpace));
            } else {
                out.append(userName);
            }
            out.append(name);
        } else {
            out.append(name.substring(0, MAX_LEN_ID));
        }
        return out.toString();
    }
    
    BatchPool createIfNotExistIaaSPool(String poolId) throws Exception {
        // Create a pool with 3 Small VMs
        String poolVmSize = "STANDARD_D1_V2";
        int poolVmCount = 1;

        // 10 minutes
        long poolSteadyTimeoutInSeconds = 10 * 60 * 1000;
        PoolClient poolClient = batchClientBuilder.buildPoolClient();
        

        // Check if pool exists
        if (!poolExists(poolClient, poolId)) {
            // Use IaaS VM with Ubuntu
            ImageReference imgRef = new ImageReference().setPublisher("Canonical").setOffer("UbuntuServer")
                    .setSku("18.04-LTS").setVersion("latest");

            VirtualMachineConfiguration configuration = new VirtualMachineConfiguration(imgRef, "batch.node.ubuntu 18.04");

            List<UserAccount> userList = new ArrayList<>();
            userList.add(new UserAccount("test-user", "kt#_gahr!@aGERDXA")
                    .setLinuxUserConfiguration(new LinuxUserConfiguration().setUid(5).setGid(5))
                    .setElevationLevel(ElevationLevel.ADMIN));

         // Need VNet to allow security to inject NSGs
            NetworkConfiguration networkConfiguration = createNetworkConfiguration();
            
            BatchPool poolToAdd = new BatchPool();
            poolToAdd.setId(poolId).setTargetDedicatedNodes(poolVmCount).setVmSize(poolVmSize)
            		 .setVirtualMachineConfiguration(configuration)
            		 .setUserAccounts(userList)
            		 .setNetworkConfiguration(networkConfiguration);

            poolClient.add(poolToAdd);
        } 
        else {
        	System.out.println(String.format("The %s already exists.", poolId));
            //logger.log(createLogRecord(Level.INFO, String.format("The %s already exists.", poolId)));
        }
        
        
        long startTime = System.currentTimeMillis();
        long elapsedTime = 0L;
        boolean steady = false;
        BatchPool pool = null;

        // Wait for the VM to be allocated
        while (elapsedTime < poolSteadyTimeoutInSeconds) {
        	pool = poolClient.get(poolId);
            if (pool.getAllocationState() == AllocationState.STEADY) {
                steady = true;
                break;
            }
            System.out.println("wait 30 seconds for pool steady...");
            Thread.sleep(30 * 1000);
            elapsedTime = (new Date()).getTime() - startTime;
        }

        Assert.assertTrue("The pool did not reach a steady state in the allotted time", steady);

        return pool;
    }
    
   NetworkConfiguration createNetworkConfiguration(){
    	Configuration localConfig = Configuration.getGlobalConfiguration();
        String vnetName = localConfig.get("AZURE_VNET", "");
        String subnetName = localConfig.get("AZURE_VNET_SUBNET");
        String subId = localConfig.get("AZURE_SUBSCRIPTION_ID");
        String vnetResourceGroup = localConfig.get("AZURE_VNET_RESOURCE_GROUP");

        if(getTestMode() == TestMode.RECORD) {
        	AzureProfile profile = new AzureProfile(AzureEnvironment.AZURE);
        	TokenCredential credential = new DefaultAzureCredentialBuilder()
        			.authorityHost(profile.getEnvironment().getActiveDirectoryEndpoint())
        		    .build();

        	NetworkManager manager = NetworkManager
        		    .authenticate(credential, profile);

        	PagedIterable<Network> networks = manager.networks().listByResourceGroup(vnetResourceGroup);
        	boolean networksFound = false;
        	
        	for (Network network: networks) {
        		networksFound = true;
        		break;
        	}
        	
        	if (!networksFound) {
        		Network network = manager.networks().define(vnetName)
        				.withRegion(localConfig.get("AZURE_BATCH_REGION"))
        				.withExistingResourceGroup(vnetResourceGroup)
        				.withAddressSpace(localConfig.get("AZURE_VNET_ADDRESS_SPACE"))
        				.withSubnet(subnetName, localConfig.get("AZURE_VNET_SUBNET_ADDRESS_SPACE"))
        				.create();
        	}
        }

        String vNetResourceId = String.format(
            "/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/virtualNetworks/%s/subnets/%s",
            subId,
            vnetResourceGroup,
            vnetName,
            subnetName);

        return new NetworkConfiguration().setSubnetId(vNetResourceId);
    }
    
    void threadSleepInRecordMode(long millis) throws InterruptedException {
        // Called for long timeouts which should only happen in Record mode.
        // Speeds up the tests in Playback mode.
        if (getTestMode() == TestMode.RECORD) {
            Thread.sleep(millis);
        }
    }
    
    static boolean poolExists(PoolClient poolClient, String poolId) {
    	try {
            poolClient.exists(poolId);
        	return true;
        }
        catch (Exception e) {
        	if (!e.getMessage().contains("Status code 404")) {
    			throw e;
    		}
        	return false;
        }
    }

    static BlobContainerClient createBlobContainer(String storageAccountName, String storageAccountKey,
                                                  String containerName) throws BlobStorageException  {
        // Create storage credential from name and key
        String endPoint = String.format(Locale.ROOT, "https://%s.blob.core.windows.net", storageAccountName);
        StorageSharedKeyCredential credentials = new StorageSharedKeyCredential(storageAccountName, storageAccountKey);
        BlobContainerClient containerClient = new BlobContainerClientBuilder().credential(credentials).containerName(containerName).endpoint(endPoint).buildClient();

        return containerClient;
    }

    /**
     * Upload file to blob container and return sas key
     *
     * @param container
     *            blob container
     * @param fileName
     *            the file name of blob
     * @param filePath
     *            the local file path
     * @return SAS key for the uploaded file
     */
    static String uploadFileToCloud(BlobContainerClient container, String fileName, String filePath)
            throws BlobStorageException {
        // Create the container if it does not exist.
        container.createIfNotExists();
        BlobClient blobClient = container.getBlobClient(fileName);

        //Upload file
        File source = new File(filePath);
        blobClient.uploadFromFile(source.getPath());

        // Create policy with 1 day read permission
        BlobSasPermission permissions = new BlobSasPermission()
                .setReadPermission(true);

        OffsetDateTime expiryTime = OffsetDateTime.now().plusDays(1);

        // Create SAS key
        BlobServiceSasSignatureValues sasSignatureValues = new BlobServiceSasSignatureValues(expiryTime, permissions);
        String sas = blobClient.generateSas(sasSignatureValues);
        return blobClient.getBlobUrl() + "?" + sas;
    }

    static String generateContainerSasToken(BlobContainerClient container) throws InvalidKeyException {
        container.createIfNotExists();

        // Create policy with 1 day read permission
        BlobSasPermission permissions = new BlobSasPermission()
                .setReadPermission(true);

        OffsetDateTime expiryTime = OffsetDateTime.now().plusDays(1);

        // Create SAS key
        BlobServiceSasSignatureValues sasSignatureValues = new BlobServiceSasSignatureValues(expiryTime, permissions);
        String sas = container.generateSas(sasSignatureValues);
        return container.getBlobContainerUrl() + "?" + sas;
    }

    static boolean waitForTasksToComplete(TaskClient taskClient, String jobId, int expiryTimeInSeconds)
            throws IOException, InterruptedException {
        long startTime = System.currentTimeMillis();
        long elapsedTime = 0L;

        while (elapsedTime < expiryTimeInSeconds * 1000) {
            PagedIterable<BatchTask> taskIterator = taskClient.list(jobId, null, null, null, null, null, null, "id, state", null);

            boolean allComplete = true;
            for (BatchTask task : taskIterator) {
                if (task.getState() != TaskState.COMPLETED) {
                    allComplete = false;
                    break;
                }
            }

            if (allComplete) {
                // All tasks completed
                return true;
            }

            // Check again after 10 seconds
            Thread.sleep(10 * 1000);
            elapsedTime = (new Date()).getTime() - startTime;
        }

        // Timeout, return false
        return false;
    }

    BatchPool waitForPoolState(String poolId, AllocationState targetState, long poolAllocationTimeoutInMilliseconds) throws IOException, InterruptedException {
        long startTime = System.currentTimeMillis();
        long elapsedTime = 0L;
        boolean allocationStateReached = false;
        BatchPool pool = null;

        // Wait for the VM to be allocated
        while (elapsedTime < poolAllocationTimeoutInMilliseconds) {
            pool = poolClient.get(poolId);
            Assert.assertNotNull(pool);

            if (pool.getAllocationState() == targetState) {
                allocationStateReached = true;
                break;
            }

            System.out.println("wait 30 seconds for pool allocationStateReached...");
            threadSleepInRecordMode(30 * 1000);
            elapsedTime = (new Date()).getTime() - startTime;
        }

        Assert.assertTrue("The pool did not reach a allocationStateReached state in the allotted time", allocationStateReached);
        return pool;
    }
}
