// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
package com.azure.compute.batch;

import com.azure.compute.batch.implementation.PoolsImpl;
import com.azure.compute.batch.models.AutoScaleRun;
import com.azure.compute.batch.models.BatchPool;
import com.azure.compute.batch.models.BatchPoolCreateParameters;
import com.azure.compute.batch.models.BatchPoolEnableAutoScaleParameters;
import com.azure.compute.batch.models.BatchPoolEvaluateAutoScaleParameters;
import com.azure.compute.batch.models.BatchPoolPatchParameters;
import com.azure.compute.batch.models.BatchPoolResizeParameters;
import com.azure.compute.batch.models.BatchPoolUpdateParameters;
import com.azure.compute.batch.models.NodeRemoveParameters;
import com.azure.compute.batch.models.PoolUsageMetrics;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpHeaderName;
import com.azure.core.http.RequestConditions;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.DateTimeRfc1123;
import java.time.OffsetDateTime;

/** Initializes a new instance of the synchronous BatchServiceClient type. */
@ServiceClient(builder = BatchServiceClientBuilder.class)
public final class PoolClient {

    /**
     * Lists the usage metrics, aggregated by Pool across individual time intervals, for the specified Account.
     *
     * <p>If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the
     * Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including
     * a startTime or endTime these filters default to the start and end times of the last aggregation interval
     * currently available; that is, only the last aggregation interval is returned.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>starttime</td><td>OffsetDateTime</td><td>No</td><td>The earliest time from which to include metrics. This must be at least two and
     * a half hours before the current time. If not specified this defaults to the
     * start time of the last aggregation interval currently available.</td></tr>
     *     <tr><td>endtime</td><td>OffsetDateTime</td><td>No</td><td>The latest time from which to include metrics. This must be at least two hours
     * before the current time. If not specified this defaults to the end time of the
     * last aggregation interval currently available.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     poolId: String (Required)
     *     startTime: OffsetDateTime (Required)
     *     endTime: OffsetDateTime (Required)
     *     vmSize: String (Required)
     *     totalCoreHours: double (Required)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of a listing the usage metrics for an Account as paginated response with {@link
     *     PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listUsageMetrics(RequestOptions requestOptions) {
        return this.serviceClient.listUsageMetrics(requestOptions);
    }

    /**
     * Creates a Pool to the specified Account.
     *
     * <p>When naming Pools, avoid including sensitive information such as user names or secret project names. This
     * information may appear in telemetry logs accessible to Microsoft Support engineers.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Optional)
     *     vmSize: String (Required)
     *     cloudServiceConfiguration (Optional): {
     *         osFamily: String (Required)
     *         osVersion: String (Optional)
     *     }
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     applicationLicenses (Optional): [
     *         String (Optional)
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param parameters The Pool to be created.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createWithResponse(BinaryData parameters, RequestOptions requestOptions) {
        return this.serviceClient.createWithResponse(parameters, requestOptions);
    }

    /**
     * Lists all of the Pools in the specified Account.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     allocationState: String(steady/resizing/stopping) (Optional)
     *     allocationStateTransitionTime: OffsetDateTime (Optional)
     *     vmSize: String (Optional)
     *     cloudServiceConfiguration (Optional): {
     *         osFamily: String (Required)
     *         osVersion: String (Optional)
     *     }
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     resizeErrors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     *     currentDedicatedNodes: Integer (Optional)
     *     currentLowPriorityNodes: Integer (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     autoScaleRun (Optional): {
     *         timestamp: OffsetDateTime (Required)
     *         results: String (Optional)
     *         error (Optional): {
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     applicationLicenses (Optional): [
     *         String (Optional)
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         usageStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             dedicatedCoreTime: Duration (Required)
     *         }
     *         resourceStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             avgCPUPercentage: double (Required)
     *             avgMemoryGiB: double (Required)
     *             peakMemoryGiB: double (Required)
     *             avgDiskGiB: double (Required)
     *             peakDiskGiB: double (Required)
     *             diskReadIOps: int (Required)
     *             diskWriteIOps: int (Required)
     *             diskReadGiB: double (Required)
     *             diskWriteGiB: double (Required)
     *             networkReadGiB: double (Required)
     *             networkWriteGiB: double (Required)
     *         }
     *     }
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     identity (Optional): {
     *         type: String(UserAssigned/None) (Required)
     *         userAssignedIdentities (Optional): [
     *              (Optional){
     *                 resourceId: String (Required)
     *                 clientId: String (Optional)
     *                 principalId: String (Optional)
     *             }
     *         ]
     *     }
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     currentNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Pools in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> list(RequestOptions requestOptions) {
        return this.serviceClient.list(requestOptions);
    }

    /**
     * Deletes a Pool from the specified Account.
     *
     * <p>When you request that a Pool be deleted, the following actions occur: the Pool state is set to deleting; any
     * ongoing resize operation on the Pool are stopped; the Batch service starts resizing the Pool to zero Compute
     * Nodes; any Tasks running on existing Compute Nodes are terminated and requeued (as if a resize Pool operation had
     * been requested with the default requeue option); finally, the Pool is removed from the system. Because running
     * Tasks are requeued, the user can rerun these Tasks by updating their Job to target a different Pool. The Tasks
     * can then run on the new Pool. If you want to override the requeue behavior, then you should call resize Pool
     * explicitly to shrink the Pool to zero size before deleting the Pool. If you call an Update, Patch or Delete API
     * on a Pool in the deleting state, it will fail with HTTP status code 409 with error code PoolBeingDeleted.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteWithResponse(String poolId, RequestOptions requestOptions) {
        return this.serviceClient.deleteWithResponse(poolId, requestOptions);
    }

    /**
     * Gets basic properties of a Pool.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * boolean
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return basic properties of a Pool along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Boolean> existsWithResponse(String poolId, RequestOptions requestOptions) {
        return this.serviceClient.existsWithResponse(poolId, requestOptions);
    }

    /**
     * Gets information about the specified Pool.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     allocationState: String(steady/resizing/stopping) (Optional)
     *     allocationStateTransitionTime: OffsetDateTime (Optional)
     *     vmSize: String (Optional)
     *     cloudServiceConfiguration (Optional): {
     *         osFamily: String (Required)
     *         osVersion: String (Optional)
     *     }
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     resizeErrors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     *     currentDedicatedNodes: Integer (Optional)
     *     currentLowPriorityNodes: Integer (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     autoScaleRun (Optional): {
     *         timestamp: OffsetDateTime (Required)
     *         results: String (Optional)
     *         error (Optional): {
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     applicationLicenses (Optional): [
     *         String (Optional)
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         usageStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             dedicatedCoreTime: Duration (Required)
     *         }
     *         resourceStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             avgCPUPercentage: double (Required)
     *             avgMemoryGiB: double (Required)
     *             peakMemoryGiB: double (Required)
     *             avgDiskGiB: double (Required)
     *             peakDiskGiB: double (Required)
     *             diskReadIOps: int (Required)
     *             diskWriteIOps: int (Required)
     *             diskReadGiB: double (Required)
     *             diskWriteGiB: double (Required)
     *             networkReadGiB: double (Required)
     *             networkWriteGiB: double (Required)
     *         }
     *     }
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     identity (Optional): {
     *         type: String(UserAssigned/None) (Required)
     *         userAssignedIdentities (Optional): [
     *              (Optional){
     *                 resourceId: String (Required)
     *                 clientId: String (Optional)
     *                 principalId: String (Optional)
     *             }
     *         ]
     *     }
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     currentNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about the specified Pool along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getWithResponse(String poolId, RequestOptions requestOptions) {
        return this.serviceClient.getWithResponse(poolId, requestOptions);
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * <p>This only replaces the Pool properties specified in the request. For example, if the Pool has a StartTask
     * associated with it, and a request does not specify a StartTask element, then the Pool keeps the existing
     * StartTask.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> patchWithResponse(String poolId, BinaryData parameters, RequestOptions requestOptions) {
        return this.serviceClient.patchWithResponse(poolId, parameters, requestOptions);
    }

    /**
     * Disables automatic scaling for a Pool.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param poolId The ID of the Pool on which to disable automatic scaling.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> disableAutoScaleWithResponse(String poolId, RequestOptions requestOptions) {
        return this.serviceClient.disableAutoScaleWithResponse(poolId, requestOptions);
    }

    /**
     * Enables automatic scaling for a Pool.
     *
     * <p>You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If automatic
     * scaling of the Pool is currently disabled, you must specify a valid autoscale formula as part of the request. If
     * automatic scaling of the Pool is already enabled, you may specify a new autoscale formula and/or a new evaluation
     * interval. You cannot call this API for the same Pool more than once every 30 seconds.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> enableAutoScaleWithResponse(
            String poolId, BinaryData parameters, RequestOptions requestOptions) {
        return this.serviceClient.enableAutoScaleWithResponse(poolId, parameters, requestOptions);
    }

    /**
     * Gets the result of evaluating an automatic scaling formula on the Pool.
     *
     * <p>This API is primarily for validating an autoscale formula, as it simply returns the result without applying
     * the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a formula.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     autoScaleFormula: String (Required)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     timestamp: OffsetDateTime (Required)
     *     results: String (Optional)
     *     error (Optional): {
     *         code: String (Optional)
     *         message: String (Optional)
     *         values (Optional): [
     *              (Optional){
     *                 name: String (Optional)
     *                 value: String (Optional)
     *             }
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool on which to evaluate the automatic scaling formula.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the results and errors from an execution of a Pool autoscale formula along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> evaluateAutoScaleWithResponse(
            String poolId, BinaryData parameters, RequestOptions requestOptions) {
        return this.serviceClient.evaluateAutoScaleWithResponse(poolId, parameters, requestOptions);
    }

    /**
     * Changes the number of Compute Nodes that are assigned to a Pool.
     *
     * <p>You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the request
     * fails with status code 409. When you resize a Pool, the Pool's allocation state changes from steady to resizing.
     * You cannot resize Pools which are configured for automatic scaling. If you try to do this, the Batch service
     * returns an error 409. If you resize a Pool downwards, the Batch service chooses which Compute Nodes to remove. To
     * remove specific Compute Nodes, use the Pool remove Compute Nodes API instead.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     resizeTimeout: Duration (Optional)
     *     nodeDeallocationOption: String(requeue/terminate/taskcompletion/retaineddata) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> resizeWithResponse(String poolId, BinaryData parameters, RequestOptions requestOptions) {
        return this.serviceClient.resizeWithResponse(poolId, parameters, requestOptions);
    }

    /**
     * Stops an ongoing resize operation on the Pool.
     *
     * <p>This does not restore the Pool to its previous state before the resize operation: it only stops any further
     * changes being made, and the Pool maintains its current state. After stopping, the Pool stabilizes at the number
     * of Compute Nodes it was at when the stop operation was done. During the stop operation, the Pool allocation state
     * changes first to stopping and then to steady. A resize operation need not be an explicit resize Pool request;
     * this API can also be used to halt the initial sizing of the Pool when it is created.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> stopResizeWithResponse(String poolId, RequestOptions requestOptions) {
        return this.serviceClient.stopResizeWithResponse(poolId, requestOptions);
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * <p>This fully replaces all the updatable properties of the Pool. For example, if the Pool has a StartTask
     * associated with it and if StartTask is not specified with this request, then the Batch service will remove the
     * existing StartTask.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Required): [
     *          (Required){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Required): [
     *          (Required){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     metadata (Required): [
     *          (Required){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to update.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updatePropertiesWithResponse(
            String poolId, BinaryData parameters, RequestOptions requestOptions) {
        return this.serviceClient.updatePropertiesWithResponse(poolId, parameters, requestOptions);
    }

    /**
     * Removes Compute Nodes from the specified Pool.
     *
     * <p>This operation can only run when the allocation state of the Pool is steady. When this operation runs, the
     * allocation state changes from steady to resizing. Each request may remove up to 100 nodes.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nodeList (Required): [
     *         String (Required)
     *     ]
     *     resizeTimeout: Duration (Optional)
     *     nodeDeallocationOption: String(requeue/terminate/taskcompletion/retaineddata) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> removeNodesWithResponse(String poolId, BinaryData parameters, RequestOptions requestOptions) {
        return this.serviceClient.removeNodesWithResponse(poolId, parameters, requestOptions);
    }

    /**
     * Lists the usage metrics, aggregated by Pool across individual time intervals, for the specified Account.
     *
     * <p>If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the
     * Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including
     * a startTime or endTime these filters default to the start and end times of the last aggregation interval
     * currently available; that is, only the last aggregation interval is returned.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of a listing the usage metrics for an Account as paginated response with {@link
     *     PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PoolUsageMetrics> listUsageMetrics() {
        // Generated convenience method for listUsageMetrics
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient
                .listUsageMetrics(requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(PoolUsageMetrics.class));
    }

    /**
     * Creates a Pool to the specified Account.
     *
     * <p>When naming Pools, avoid including sensitive information such as user names or secret project names. This
     * information may appear in telemetry logs accessible to Microsoft Support engineers.
     *
     * @param parameters The Pool to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void create(BatchPoolCreateParameters parameters) {
        // Generated convenience method for createWithResponse
        RequestOptions requestOptions = new RequestOptions();
        createWithResponse(BinaryData.fromObject(parameters), requestOptions).getValue();
    }

    /**
     * Lists all of the Pools in the specified Account.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Pools in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchPool> list() {
        // Generated convenience method for list
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.list(requestOptions).mapPage(bodyItemValue -> bodyItemValue.toObject(BatchPool.class));
    }

    /**
     * Deletes a Pool from the specified Account.
     *
     * <p>When you request that a Pool be deleted, the following actions occur: the Pool state is set to deleting; any
     * ongoing resize operation on the Pool are stopped; the Batch service starts resizing the Pool to zero Compute
     * Nodes; any Tasks running on existing Compute Nodes are terminated and requeued (as if a resize Pool operation had
     * been requested with the default requeue option); finally, the Pool is removed from the system. Because running
     * Tasks are requeued, the user can rerun these Tasks by updating their Job to target a different Pool. The Tasks
     * can then run on the new Pool. If you want to override the requeue behavior, then you should call resize Pool
     * explicitly to shrink the Pool to zero size before deleting the Pool. If you call an Update, Patch or Delete API
     * on a Pool in the deleting state, it will fail with HTTP status code 409 with error code PoolBeingDeleted.
     *
     * @param poolId The ID of the Pool to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String poolId) {
        // Generated convenience method for deleteWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Gets basic properties of a Pool.
     *
     * @param poolId The ID of the Pool to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return basic properties of a Pool.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public boolean exists(String poolId) {
        // Generated convenience method for existsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return existsWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Gets information about the specified Pool.
     *
     * @param poolId The ID of the Pool to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Pool.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchPool get(String poolId) {
        // Generated convenience method for getWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getWithResponse(poolId, requestOptions).getValue().toObject(BatchPool.class);
    }

    /**
     * Disables automatic scaling for a Pool.
     *
     * @param poolId The ID of the Pool on which to disable automatic scaling.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void disableAutoScale(String poolId) {
        // Generated convenience method for disableAutoScaleWithResponse
        RequestOptions requestOptions = new RequestOptions();
        disableAutoScaleWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Enables automatic scaling for a Pool.
     *
     * <p>You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If automatic
     * scaling of the Pool is currently disabled, you must specify a valid autoscale formula as part of the request. If
     * automatic scaling of the Pool is already enabled, you may specify a new autoscale formula and/or a new evaluation
     * interval. You cannot call this API for the same Pool more than once every 30 seconds.
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void enableAutoScale(String poolId, BatchPoolEnableAutoScaleParameters parameters) {
        // Generated convenience method for enableAutoScaleWithResponse
        RequestOptions requestOptions = new RequestOptions();
        enableAutoScaleWithResponse(poolId, BinaryData.fromObject(parameters), requestOptions).getValue();
    }

    /**
     * Gets the result of evaluating an automatic scaling formula on the Pool.
     *
     * <p>This API is primarily for validating an autoscale formula, as it simply returns the result without applying
     * the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a formula.
     *
     * @param poolId The ID of the Pool on which to evaluate the automatic scaling formula.
     * @param parameters The parameters for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the results and errors from an execution of a Pool autoscale formula.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AutoScaleRun evaluateAutoScale(String poolId, BatchPoolEvaluateAutoScaleParameters parameters) {
        // Generated convenience method for evaluateAutoScaleWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return evaluateAutoScaleWithResponse(poolId, BinaryData.fromObject(parameters), requestOptions)
                .getValue()
                .toObject(AutoScaleRun.class);
    }

    /**
     * Changes the number of Compute Nodes that are assigned to a Pool.
     *
     * <p>You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the request
     * fails with status code 409. When you resize a Pool, the Pool's allocation state changes from steady to resizing.
     * You cannot resize Pools which are configured for automatic scaling. If you try to do this, the Batch service
     * returns an error 409. If you resize a Pool downwards, the Batch service chooses which Compute Nodes to remove. To
     * remove specific Compute Nodes, use the Pool remove Compute Nodes API instead.
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void resize(String poolId, BatchPoolResizeParameters parameters) {
        // Generated convenience method for resizeWithResponse
        RequestOptions requestOptions = new RequestOptions();
        resizeWithResponse(poolId, BinaryData.fromObject(parameters), requestOptions).getValue();
    }

    /**
     * Stops an ongoing resize operation on the Pool.
     *
     * <p>This does not restore the Pool to its previous state before the resize operation: it only stops any further
     * changes being made, and the Pool maintains its current state. After stopping, the Pool stabilizes at the number
     * of Compute Nodes it was at when the stop operation was done. During the stop operation, the Pool allocation state
     * changes first to stopping and then to steady. A resize operation need not be an explicit resize Pool request;
     * this API can also be used to halt the initial sizing of the Pool when it is created.
     *
     * @param poolId The ID of the Pool to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void stopResize(String poolId) {
        // Generated convenience method for stopResizeWithResponse
        RequestOptions requestOptions = new RequestOptions();
        stopResizeWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Removes Compute Nodes from the specified Pool.
     *
     * <p>This operation can only run when the allocation state of the Pool is steady. When this operation runs, the
     * allocation state changes from steady to resizing. Each request may remove up to 100 nodes.
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void removeNodes(String poolId, NodeRemoveParameters parameters) {
        // Generated convenience method for removeNodesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        removeNodesWithResponse(poolId, BinaryData.fromObject(parameters), requestOptions).getValue();
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * <p>This only replaces the Pool properties specified in the request. For example, if the Pool has a StartTask
     * associated with it, and a request does not specify a StartTask element, then the Pool keeps the existing
     * StartTask.
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void patch(String poolId, BatchPoolPatchParameters parameters) {
        // Generated convenience method for patchWithResponse
        RequestOptions requestOptions = new RequestOptions();
        patchWithResponse(poolId, BinaryData.fromObject(parameters), requestOptions).getValue();
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * <p>This fully replaces all the updatable properties of the Pool. For example, if the Pool has a StartTask
     * associated with it and if StartTask is not specified with this request, then the Batch service will remove the
     * existing StartTask.
     *
     * @param poolId The ID of the Pool to update.
     * @param parameters The parameters for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updateProperties(String poolId, BatchPoolUpdateParameters parameters) {
        // Generated convenience method for updatePropertiesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        updatePropertiesWithResponse(poolId, BinaryData.fromObject(parameters), requestOptions).getValue();
    }

    @Generated private final PoolsImpl serviceClient;

    /**
     * Initializes an instance of PoolClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    PoolClient(PoolsImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Lists the usage metrics, aggregated by Pool across individual time intervals, for the specified Account.
     *
     * <p>If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the
     * Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including
     * a startTime or endTime these filters default to the start and end times of the last aggregation interval
     * currently available; that is, only the last aggregation interval is returned.
     *
     * @param maxresults The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param starttime The earliest time from which to include metrics. This must be at least two and a half hours
     *     before the current time. If not specified this defaults to the start time of the last aggregation interval
     *     currently available.
     * @param endtime The latest time from which to include metrics. This must be at least two hours before the current
     *     time. If not specified this defaults to the end time of the last aggregation interval currently available.
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     *     https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of a listing the usage metrics for an Account as paginated response with {@link
     *     PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<PoolUsageMetrics> listUsageMetrics(
            Integer maxresults,
            OffsetDateTime ocpDate,
            Integer timeOut,
            OffsetDateTime starttime,
            OffsetDateTime endtime,
            String filter) {
        // Generated convenience method for listUsageMetrics
        RequestOptions requestOptions = new RequestOptions();
        if (maxresults != null) {
            requestOptions.addQueryParam("maxresults", String.valueOf(maxresults), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (starttime != null) {
            requestOptions.addQueryParam("starttime", String.valueOf(starttime), false);
        }
        if (endtime != null) {
            requestOptions.addQueryParam("endtime", String.valueOf(endtime), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        return serviceClient
                .listUsageMetrics(requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(PoolUsageMetrics.class));
    }

    /**
     * Creates a Pool to the specified Account.
     *
     * <p>When naming Pools, avoid including sensitive information such as user names or secret project names. This
     * information may appear in telemetry logs accessible to Microsoft Support engineers.
     *
     * @param parameters The Pool to be created.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void create(BatchPoolCreateParameters parameters, Integer timeOut, OffsetDateTime ocpDate) {
        // Generated convenience method for createWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        createWithResponse(BinaryData.fromObject(parameters), requestOptions).getValue();
    }

    /**
     * Lists all of the Pools in the specified Account.
     *
     * @param maxresults The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     *     https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Pools in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchPool> list(
            Integer maxresults, OffsetDateTime ocpDate, Integer timeOut, String filter, String select, String expand) {
        // Generated convenience method for list
        RequestOptions requestOptions = new RequestOptions();
        if (maxresults != null) {
            requestOptions.addQueryParam("maxresults", String.valueOf(maxresults), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select", select, false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand", expand, false);
        }
        return serviceClient.list(requestOptions).mapPage(bodyItemValue -> bodyItemValue.toObject(BatchPool.class));
    }

    /**
     * Deletes a Pool from the specified Account.
     *
     * <p>When you request that a Pool be deleted, the following actions occur: the Pool state is set to deleting; any
     * ongoing resize operation on the Pool are stopped; the Batch service starts resizing the Pool to zero Compute
     * Nodes; any Tasks running on existing Compute Nodes are terminated and requeued (as if a resize Pool operation had
     * been requested with the default requeue option); finally, the Pool is removed from the system. Because running
     * Tasks are requeued, the user can rerun these Tasks by updating their Job to target a different Pool. The Tasks
     * can then run on the new Pool. If you want to override the requeue behavior, then you should call resize Pool
     * explicitly to shrink the Pool to zero size before deleting the Pool. If you call an Update, Patch or Delete API
     * on a Pool in the deleting state, it will fail with HTTP status code 409 with error code PoolBeingDeleted.
     *
     * @param poolId The ID of the Pool to get.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String poolId, Integer timeOut, OffsetDateTime ocpDate, RequestConditions requestConditions) {
        // Generated convenience method for deleteWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        deleteWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Gets basic properties of a Pool.
     *
     * @param poolId The ID of the Pool to get.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return basic properties of a Pool.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public boolean exists(String poolId, Integer timeOut, OffsetDateTime ocpDate, RequestConditions requestConditions) {
        // Generated convenience method for existsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        return existsWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Gets information about the specified Pool.
     *
     * @param poolId The ID of the Pool to get.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Pool.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchPool get(
            String poolId,
            Integer timeOut,
            OffsetDateTime ocpDate,
            String select,
            String expand,
            RequestConditions requestConditions) {
        // Generated convenience method for getWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (select != null) {
            requestOptions.addQueryParam("$select", select, false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand", expand, false);
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        return getWithResponse(poolId, requestOptions).getValue().toObject(BatchPool.class);
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * <p>This only replaces the Pool properties specified in the request. For example, if the Pool has a StartTask
     * associated with it, and a request does not specify a StartTask element, then the Pool keeps the existing
     * StartTask.
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void patch(
            String poolId,
            BatchPoolPatchParameters parameters,
            Integer timeOut,
            OffsetDateTime ocpDate,
            RequestConditions requestConditions) {
        // Generated convenience method for patchWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        patchWithResponse(poolId, BinaryData.fromObject(parameters), requestOptions).getValue();
    }

    /**
     * Disables automatic scaling for a Pool.
     *
     * @param poolId The ID of the Pool on which to disable automatic scaling.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void disableAutoScale(String poolId, Integer timeOut, OffsetDateTime ocpDate) {
        // Generated convenience method for disableAutoScaleWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        disableAutoScaleWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Enables automatic scaling for a Pool.
     *
     * <p>You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If automatic
     * scaling of the Pool is currently disabled, you must specify a valid autoscale formula as part of the request. If
     * automatic scaling of the Pool is already enabled, you may specify a new autoscale formula and/or a new evaluation
     * interval. You cannot call this API for the same Pool more than once every 30 seconds.
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void enableAutoScale(
            String poolId,
            BatchPoolEnableAutoScaleParameters parameters,
            Integer timeOut,
            OffsetDateTime ocpDate,
            RequestConditions requestConditions) {
        // Generated convenience method for enableAutoScaleWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        enableAutoScaleWithResponse(poolId, BinaryData.fromObject(parameters), requestOptions).getValue();
    }

    /**
     * Gets the result of evaluating an automatic scaling formula on the Pool.
     *
     * <p>This API is primarily for validating an autoscale formula, as it simply returns the result without applying
     * the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a formula.
     *
     * @param poolId The ID of the Pool on which to evaluate the automatic scaling formula.
     * @param parameters The parameters for the request.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the results and errors from an execution of a Pool autoscale formula.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AutoScaleRun evaluateAutoScale(
            String poolId, BatchPoolEvaluateAutoScaleParameters parameters, Integer timeOut, OffsetDateTime ocpDate) {
        // Generated convenience method for evaluateAutoScaleWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        return evaluateAutoScaleWithResponse(poolId, BinaryData.fromObject(parameters), requestOptions)
                .getValue()
                .toObject(AutoScaleRun.class);
    }

    /**
     * Changes the number of Compute Nodes that are assigned to a Pool.
     *
     * <p>You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the request
     * fails with status code 409. When you resize a Pool, the Pool's allocation state changes from steady to resizing.
     * You cannot resize Pools which are configured for automatic scaling. If you try to do this, the Batch service
     * returns an error 409. If you resize a Pool downwards, the Batch service chooses which Compute Nodes to remove. To
     * remove specific Compute Nodes, use the Pool remove Compute Nodes API instead.
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void resize(
            String poolId,
            BatchPoolResizeParameters parameters,
            Integer timeOut,
            OffsetDateTime ocpDate,
            RequestConditions requestConditions) {
        // Generated convenience method for resizeWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        resizeWithResponse(poolId, BinaryData.fromObject(parameters), requestOptions).getValue();
    }

    /**
     * Stops an ongoing resize operation on the Pool.
     *
     * <p>This does not restore the Pool to its previous state before the resize operation: it only stops any further
     * changes being made, and the Pool maintains its current state. After stopping, the Pool stabilizes at the number
     * of Compute Nodes it was at when the stop operation was done. During the stop operation, the Pool allocation state
     * changes first to stopping and then to steady. A resize operation need not be an explicit resize Pool request;
     * this API can also be used to halt the initial sizing of the Pool when it is created.
     *
     * @param poolId The ID of the Pool to get.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void stopResize(
            String poolId, Integer timeOut, OffsetDateTime ocpDate, RequestConditions requestConditions) {
        // Generated convenience method for stopResizeWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        stopResizeWithResponse(poolId, requestOptions).getValue();
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * <p>This fully replaces all the updatable properties of the Pool. For example, if the Pool has a StartTask
     * associated with it and if StartTask is not specified with this request, then the Batch service will remove the
     * existing StartTask.
     *
     * @param poolId The ID of the Pool to update.
     * @param parameters The parameters for the request.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void updateProperties(
            String poolId, BatchPoolUpdateParameters parameters, Integer timeOut, OffsetDateTime ocpDate) {
        // Generated convenience method for updatePropertiesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        updatePropertiesWithResponse(poolId, BinaryData.fromObject(parameters), requestOptions).getValue();
    }

    /**
     * Removes Compute Nodes from the specified Pool.
     *
     * <p>This operation can only run when the allocation state of the Pool is steady. When this operation runs, the
     * allocation state changes from steady to resizing. Each request may remove up to 100 nodes.
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void removeNodes(
            String poolId,
            NodeRemoveParameters parameters,
            Integer timeOut,
            OffsetDateTime ocpDate,
            RequestConditions requestConditions) {
        // Generated convenience method for removeNodesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        removeNodesWithResponse(poolId, BinaryData.fromObject(parameters), requestOptions).getValue();
    }
}
