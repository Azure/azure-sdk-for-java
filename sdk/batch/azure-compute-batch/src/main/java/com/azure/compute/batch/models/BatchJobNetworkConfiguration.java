// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.compute.batch.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * The network configuration for the Job.
 */
@Fluent
public final class BatchJobNetworkConfiguration implements JsonSerializable<BatchJobNetworkConfiguration> {

    /*
     * The ARM resource identifier of the virtual network subnet which Compute Nodes running Tasks from the Job will
     * join for the duration of the Task. The virtual network must be in the same region and subscription as the Azure
     * Batch Account. The specified subnet should have enough free IP addresses to accommodate the number of Compute
     * Nodes which will run Tasks from the Job. This can be up to the number of Compute Nodes in the Pool. The
     * 'MicrosoftAzureBatch' service principal must have the 'Classic Virtual Machine Contributor' Role-Based Access
     * Control (RBAC) role for the specified VNet so that Azure Batch service can schedule Tasks on the Nodes. This can
     * be verified by checking if the specified VNet has any associated Network Security Groups (NSG). If communication
     * to the Nodes in the specified subnet is denied by an NSG, then the Batch service will set the state of the
     * Compute Nodes to unusable. This is of the form
     * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{
     * subnet}. If the specified VNet has any associated Network Security Groups (NSG), then a few reserved system ports
     * must be enabled for inbound communication from the Azure Batch service. For Pools created with a Virtual Machine
     * configuration, enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for Windows. Port 443 is
     * also required to be open for outbound connections for communications to Azure Storage. For more details see:
     * https://learn.microsoft.com/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
     */
    @Generated
    private final String subnetId;

    /**
     * Get the subnetId property: The ARM resource identifier of the virtual network subnet which Compute Nodes running
     * Tasks from the Job will join for the duration of the Task. The virtual network must be in the same region and
     * subscription as the Azure Batch Account. The specified subnet should have enough free IP addresses to accommodate
     * the number of Compute Nodes which will run Tasks from the Job. This can be up to the number of Compute Nodes in
     * the Pool. The 'MicrosoftAzureBatch' service principal must have the 'Classic Virtual Machine Contributor'
     * Role-Based Access Control (RBAC) role for the specified VNet so that Azure Batch service can schedule Tasks on
     * the Nodes. This can be verified by checking if the specified VNet has any associated Network Security Groups
     * (NSG). If communication to the Nodes in the specified subnet is denied by an NSG, then the Batch service will set
     * the state of the Compute Nodes to unusable. This is of the form
     * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
     * If the specified VNet has any associated Network Security Groups (NSG), then a few reserved system ports must be
     * enabled for inbound communication from the Azure Batch service. For Pools created with a Virtual Machine
     * configuration, enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for Windows. Port 443 is
     * also required to be open for outbound connections for communications to Azure Storage. For more details see:
     * https://learn.microsoft.com/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
     *
     * @return the subnetId value.
     */
    @Generated
    public String getSubnetId() {
        return this.subnetId;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("subnetId", this.subnetId);
        jsonWriter.writeBooleanField("skipWithdrawFromVNet", this.skipWithdrawFromVnet);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of BatchJobNetworkConfiguration from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of BatchJobNetworkConfiguration if the JsonReader was pointing to an instance of it, or null
     * if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the BatchJobNetworkConfiguration.
     */
    @Generated
    public static BatchJobNetworkConfiguration fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            String subnetId = null;
            Boolean skipWithdrawFromVnet = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("subnetId".equals(fieldName)) {
                    subnetId = reader.getString();
                } else if ("skipWithdrawFromVNet".equals(fieldName)) {
                    skipWithdrawFromVnet = reader.getNullable(JsonReader::getBoolean);
                } else {
                    reader.skipChildren();
                }
            }
            BatchJobNetworkConfiguration deserializedBatchJobNetworkConfiguration
                = new BatchJobNetworkConfiguration(subnetId);
            deserializedBatchJobNetworkConfiguration.skipWithdrawFromVnet = skipWithdrawFromVnet;
            return deserializedBatchJobNetworkConfiguration;
        });
    }

    /*
     * Whether to withdraw Compute Nodes from the virtual network to DNC when the job is terminated or deleted. If true,
     * nodes will remain joined to the virtual network to DNC. If false, nodes will automatically withdraw when the job
     * ends. Defaults to false.
     */
    @Generated
    private Boolean skipWithdrawFromVnet;

    /**
     * Get the skipWithdrawFromVnet property: Whether to withdraw Compute Nodes from the virtual network to DNC when the
     * job is terminated or deleted. If true, nodes will remain joined to the virtual network to DNC. If false, nodes
     * will automatically withdraw when the job ends. Defaults to false.
     *
     * @return the skipWithdrawFromVnet value.
     */
    @Generated
    public Boolean isSkipWithdrawFromVnet() {
        return this.skipWithdrawFromVnet;
    }

    /**
     * Creates an instance of BatchJobNetworkConfiguration class.
     *
     * @param subnetId the subnetId value to set.
     */
    @Generated
    public BatchJobNetworkConfiguration(String subnetId) {
        this.subnetId = subnetId;
    }

    /**
     * Set the skipWithdrawFromVnet property: Whether to withdraw Compute Nodes from the virtual network to DNC when the
     * job is terminated or deleted. If true, nodes will remain joined to the virtual network to DNC. If false, nodes
     * will automatically withdraw when the job ends. Defaults to false.
     *
     * @param skipWithdrawFromVnet the skipWithdrawFromVnet value to set.
     * @return the BatchJobNetworkConfiguration object itself.
     */
    @Generated
    public BatchJobNetworkConfiguration setSkipWithdrawFromVnet(Boolean skipWithdrawFromVnet) {
        this.skipWithdrawFromVnet = skipWithdrawFromVnet;
        return this;
    }
}
