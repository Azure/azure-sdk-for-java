// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
package com.azure.compute.batch.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.time.OffsetDateTime;
import java.util.List;

/** An Azure Batch Job. */
@Fluent
public final class BatchJob {

    /*
     * The ID is case-preserving and case-insensitive (that is, you may not have two
     * IDs within an Account that differ only by case).
     */
    @Generated
    @JsonProperty(value = "id", access = JsonProperty.Access.WRITE_ONLY)
    private String id;

    /*
     * The display name for the Job.
     */
    @Generated
    @JsonProperty(value = "displayName", access = JsonProperty.Access.WRITE_ONLY)
    private String displayName;

    /*
     * Whether Tasks in the Job can define dependencies on each other. The default is
     * false.
     */
    @Generated
    @JsonProperty(value = "usesTaskDependencies", access = JsonProperty.Access.WRITE_ONLY)
    private Boolean usesTaskDependencies;

    /*
     * The URL of the Job.
     */
    @Generated
    @JsonProperty(value = "url", access = JsonProperty.Access.WRITE_ONLY)
    private String url;

    /*
     * This is an opaque string. You can use it to detect whether the Job has changed
     * between requests. In particular, you can be pass the ETag when updating a Job
     * to specify that your changes should take effect only if nobody else has
     * modified the Job in the meantime.
     */
    @Generated
    @JsonProperty(value = "eTag", access = JsonProperty.Access.WRITE_ONLY)
    private String eTag;

    /*
     * This is the last time at which the Job level data, such as the Job state or
     * priority, changed. It does not factor in task-level changes such as adding new
     * Tasks or Tasks changing state.
     */
    @Generated
    @JsonProperty(value = "lastModified", access = JsonProperty.Access.WRITE_ONLY)
    private OffsetDateTime lastModified;

    /*
     * The creation time of the Job.
     */
    @Generated
    @JsonProperty(value = "creationTime", access = JsonProperty.Access.WRITE_ONLY)
    private OffsetDateTime creationTime;

    /*
     * The state of the Job.
     */
    @Generated
    @JsonProperty(value = "state", access = JsonProperty.Access.WRITE_ONLY)
    private JobState state;

    /*
     * The time at which the Job entered its current state.
     */
    @Generated
    @JsonProperty(value = "stateTransitionTime", access = JsonProperty.Access.WRITE_ONLY)
    private OffsetDateTime stateTransitionTime;

    /*
     * This property is not set if the Job is in its initial Active state.
     */
    @Generated
    @JsonProperty(value = "previousState", access = JsonProperty.Access.WRITE_ONLY)
    private JobState previousState;

    /*
     * This property is not set if the Job is in its initial Active state.
     */
    @Generated
    @JsonProperty(value = "previousStateTransitionTime", access = JsonProperty.Access.WRITE_ONLY)
    private OffsetDateTime previousStateTransitionTime;

    /*
     * Priority values can range from -1000 to 1000, with -1000 being the lowest
     * priority and 1000 being the highest priority. The default value is 0.
     */
    @Generated
    @JsonProperty(value = "priority")
    private Integer priority;

    /*
     * If the value is set to True, other high priority jobs submitted to the system
     * will take precedence and will be able requeue tasks from this job. You can
     * update a job's allowTaskPreemption after it has been created using the update
     * job API.
     */
    @Generated
    @JsonProperty(value = "allowTaskPreemption")
    private Boolean allowTaskPreemption;

    /*
     * The value of maxParallelTasks must be -1 or greater than 0 if specified. If not
     * specified, the default value is -1, which means there's no limit to the number
     * of tasks that can be run at once. You can update a job's maxParallelTasks after
     * it has been created using the update job API.
     */
    @Generated
    @JsonProperty(value = "maxParallelTasks")
    private Integer maxParallelTasks;

    /*
     * The execution constraints for a Job.
     */
    @Generated
    @JsonProperty(value = "constraints")
    private JobConstraints constraints;

    /*
     * The Job Manager Task is automatically started when the Job is created. The
     * Batch service tries to schedule the Job Manager Task before any other Tasks in
     * the Job. When shrinking a Pool, the Batch service tries to preserve Nodes where
     * Job Manager Tasks are running for as long as possible (that is, Compute Nodes
     * running 'normal' Tasks are removed before Compute Nodes running Job Manager
     * Tasks). When a Job Manager Task fails and needs to be restarted, the system
     * tries to schedule it at the highest priority. If there are no idle Compute
     * Nodes available, the system may terminate one of the running Tasks in the Pool
     * and return it to the queue in order to make room for the Job Manager Task to
     * restart. Note that a Job Manager Task in one Job does not have priority over
     * Tasks in other Jobs. Across Jobs, only Job level priorities are observed. For
     * example, if a Job Manager in a priority 0 Job needs to be restarted, it will
     * not displace Tasks of a priority 1 Job. Batch will retry Tasks when a recovery
     * operation is triggered on a Node. Examples of recovery operations include (but
     * are not limited to) when an unhealthy Node is rebooted or a Compute Node
     * disappeared due to host failure. Retries due to recovery operations are
     * independent of and are not counted against the maxTaskRetryCount. Even if the
     * maxTaskRetryCount is 0, an internal retry due to a recovery operation may
     * occur. Because of this, all Tasks should be idempotent. This means Tasks need
     * to tolerate being interrupted and restarted without causing any corruption or
     * duplicate data. The best practice for long running Tasks is to use some form of
     * checkpointing.
     */
    @Generated
    @JsonProperty(value = "jobManagerTask", access = JsonProperty.Access.WRITE_ONLY)
    private JobManagerTask jobManagerTask;

    /*
     * The Job Preparation Task is a special Task run on each Compute Node before any
     * other Task of the Job.
     */
    @Generated
    @JsonProperty(value = "jobPreparationTask", access = JsonProperty.Access.WRITE_ONLY)
    private JobPreparationTask jobPreparationTask;

    /*
     * The Job Release Task is a special Task run at the end of the Job on each
     * Compute Node that has run any other Task of the Job.
     */
    @Generated
    @JsonProperty(value = "jobReleaseTask", access = JsonProperty.Access.WRITE_ONLY)
    private JobReleaseTask jobReleaseTask;

    /*
     * Individual Tasks can override an environment setting specified here by
     * specifying the same setting name with a different value.
     */
    @Generated
    @JsonProperty(value = "commonEnvironmentSettings", access = JsonProperty.Access.WRITE_ONLY)
    private List<EnvironmentSetting> commonEnvironmentSettings;

    /*
     * Specifies how a Job should be assigned to a Pool.
     */
    @Generated
    @JsonProperty(value = "poolInfo")
    private PoolInformation poolInfo;

    /*
     * The default is noaction.
     */
    @Generated
    @JsonProperty(value = "onAllTasksComplete")
    private OnAllTasksComplete onAllTasksComplete;

    /*
     * A Task is considered to have failed if has a failureInfo. A failureInfo is set
     * if the Task completes with a non-zero exit code after exhausting its retry
     * count, or if there was an error starting the Task, for example due to a
     * resource file download error. The default is noaction.
     */
    @Generated
    @JsonProperty(value = "onTaskFailure", access = JsonProperty.Access.WRITE_ONLY)
    private OnTaskFailure onTaskFailure;

    /*
     * The network configuration for the Job.
     */
    @Generated
    @JsonProperty(value = "networkConfiguration", access = JsonProperty.Access.WRITE_ONLY)
    private JobNetworkConfiguration networkConfiguration;

    /*
     * The Batch service does not assign any meaning to metadata; it is solely for the
     * use of user code.
     */
    @Generated
    @JsonProperty(value = "metadata")
    private List<MetadataItem> metadata;

    /*
     * Contains information about the execution of a Job in the Azure Batch service.
     */
    @Generated
    @JsonProperty(value = "executionInfo", access = JsonProperty.Access.WRITE_ONLY)
    private JobExecutionInformation executionInfo;

    /*
     * This property is populated only if the CloudJob was retrieved with an expand
     * clause including the 'stats' attribute; otherwise it is null. The statistics
     * may not be immediately available. The Batch service performs periodic roll-up
     * of statistics. The typical delay is about 30 minutes.
     */
    @Generated
    @JsonProperty(value = "stats", access = JsonProperty.Access.WRITE_ONLY)
    private JobStatistics stats;

    /**
     * Creates an instance of BatchJob class.
     *
     * @param poolInfo the poolInfo value to set.
     */
    @Generated
    @JsonCreator
    public BatchJob(@JsonProperty(value = "poolInfo") PoolInformation poolInfo) {
        this.poolInfo = poolInfo;
    }

    /**
     * Get the id property: The ID is case-preserving and case-insensitive (that is, you may not have two IDs within an
     * Account that differ only by case).
     *
     * @return the id value.
     */
    @Generated
    public String getId() {
        return this.id;
    }

    /**
     * Get the displayName property: The display name for the Job.
     *
     * @return the displayName value.
     */
    @Generated
    public String getDisplayName() {
        return this.displayName;
    }

    /**
     * Get the usesTaskDependencies property: Whether Tasks in the Job can define dependencies on each other. The
     * default is false.
     *
     * @return the usesTaskDependencies value.
     */
    @Generated
    public Boolean isUsesTaskDependencies() {
        return this.usesTaskDependencies;
    }

    /**
     * Get the url property: The URL of the Job.
     *
     * @return the url value.
     */
    @Generated
    public String getUrl() {
        return this.url;
    }

    /**
     * Get the eTag property: This is an opaque string. You can use it to detect whether the Job has changed between
     * requests. In particular, you can be pass the ETag when updating a Job to specify that your changes should take
     * effect only if nobody else has modified the Job in the meantime.
     *
     * @return the eTag value.
     */
    @Generated
    public String getETag() {
        return this.eTag;
    }

    /**
     * Get the lastModified property: This is the last time at which the Job level data, such as the Job state or
     * priority, changed. It does not factor in task-level changes such as adding new Tasks or Tasks changing state.
     *
     * @return the lastModified value.
     */
    @Generated
    public OffsetDateTime getLastModified() {
        return this.lastModified;
    }

    /**
     * Get the creationTime property: The creation time of the Job.
     *
     * @return the creationTime value.
     */
    @Generated
    public OffsetDateTime getCreationTime() {
        return this.creationTime;
    }

    /**
     * Get the state property: The state of the Job.
     *
     * @return the state value.
     */
    @Generated
    public JobState getState() {
        return this.state;
    }

    /**
     * Get the stateTransitionTime property: The time at which the Job entered its current state.
     *
     * @return the stateTransitionTime value.
     */
    @Generated
    public OffsetDateTime getStateTransitionTime() {
        return this.stateTransitionTime;
    }

    /**
     * Get the previousState property: This property is not set if the Job is in its initial Active state.
     *
     * @return the previousState value.
     */
    @Generated
    public JobState getPreviousState() {
        return this.previousState;
    }

    /**
     * Get the previousStateTransitionTime property: This property is not set if the Job is in its initial Active state.
     *
     * @return the previousStateTransitionTime value.
     */
    @Generated
    public OffsetDateTime getPreviousStateTransitionTime() {
        return this.previousStateTransitionTime;
    }

    /**
     * Get the priority property: Priority values can range from -1000 to 1000, with -1000 being the lowest priority and
     * 1000 being the highest priority. The default value is 0.
     *
     * @return the priority value.
     */
    @Generated
    public Integer getPriority() {
        return this.priority;
    }

    /**
     * Set the priority property: Priority values can range from -1000 to 1000, with -1000 being the lowest priority and
     * 1000 being the highest priority. The default value is 0.
     *
     * @param priority the priority value to set.
     * @return the BatchJob object itself.
     */
    @Generated
    public BatchJob setPriority(Integer priority) {
        this.priority = priority;
        return this;
    }

    /**
     * Get the allowTaskPreemption property: If the value is set to True, other high priority jobs submitted to the
     * system will take precedence and will be able requeue tasks from this job. You can update a job's
     * allowTaskPreemption after it has been created using the update job API.
     *
     * @return the allowTaskPreemption value.
     */
    @Generated
    public Boolean isAllowTaskPreemption() {
        return this.allowTaskPreemption;
    }

    /**
     * Set the allowTaskPreemption property: If the value is set to True, other high priority jobs submitted to the
     * system will take precedence and will be able requeue tasks from this job. You can update a job's
     * allowTaskPreemption after it has been created using the update job API.
     *
     * @param allowTaskPreemption the allowTaskPreemption value to set.
     * @return the BatchJob object itself.
     */
    @Generated
    public BatchJob setAllowTaskPreemption(Boolean allowTaskPreemption) {
        this.allowTaskPreemption = allowTaskPreemption;
        return this;
    }

    /**
     * Get the maxParallelTasks property: The value of maxParallelTasks must be -1 or greater than 0 if specified. If
     * not specified, the default value is -1, which means there's no limit to the number of tasks that can be run at
     * once. You can update a job's maxParallelTasks after it has been created using the update job API.
     *
     * @return the maxParallelTasks value.
     */
    @Generated
    public Integer getMaxParallelTasks() {
        return this.maxParallelTasks;
    }

    /**
     * Set the maxParallelTasks property: The value of maxParallelTasks must be -1 or greater than 0 if specified. If
     * not specified, the default value is -1, which means there's no limit to the number of tasks that can be run at
     * once. You can update a job's maxParallelTasks after it has been created using the update job API.
     *
     * @param maxParallelTasks the maxParallelTasks value to set.
     * @return the BatchJob object itself.
     */
    @Generated
    public BatchJob setMaxParallelTasks(Integer maxParallelTasks) {
        this.maxParallelTasks = maxParallelTasks;
        return this;
    }

    /**
     * Get the constraints property: The execution constraints for a Job.
     *
     * @return the constraints value.
     */
    @Generated
    public JobConstraints getConstraints() {
        return this.constraints;
    }

    /**
     * Set the constraints property: The execution constraints for a Job.
     *
     * @param constraints the constraints value to set.
     * @return the BatchJob object itself.
     */
    @Generated
    public BatchJob setConstraints(JobConstraints constraints) {
        this.constraints = constraints;
        return this;
    }

    /**
     * Get the jobManagerTask property: The Job Manager Task is automatically started when the Job is created. The Batch
     * service tries to schedule the Job Manager Task before any other Tasks in the Job. When shrinking a Pool, the
     * Batch service tries to preserve Nodes where Job Manager Tasks are running for as long as possible (that is,
     * Compute Nodes running 'normal' Tasks are removed before Compute Nodes running Job Manager Tasks). When a Job
     * Manager Task fails and needs to be restarted, the system tries to schedule it at the highest priority. If there
     * are no idle Compute Nodes available, the system may terminate one of the running Tasks in the Pool and return it
     * to the queue in order to make room for the Job Manager Task to restart. Note that a Job Manager Task in one Job
     * does not have priority over Tasks in other Jobs. Across Jobs, only Job level priorities are observed. For
     * example, if a Job Manager in a priority 0 Job needs to be restarted, it will not displace Tasks of a priority 1
     * Job. Batch will retry Tasks when a recovery operation is triggered on a Node. Examples of recovery operations
     * include (but are not limited to) when an unhealthy Node is rebooted or a Compute Node disappeared due to host
     * failure. Retries due to recovery operations are independent of and are not counted against the maxTaskRetryCount.
     * Even if the maxTaskRetryCount is 0, an internal retry due to a recovery operation may occur. Because of this, all
     * Tasks should be idempotent. This means Tasks need to tolerate being interrupted and restarted without causing any
     * corruption or duplicate data. The best practice for long running Tasks is to use some form of checkpointing.
     *
     * @return the jobManagerTask value.
     */
    @Generated
    public JobManagerTask getJobManagerTask() {
        return this.jobManagerTask;
    }

    /**
     * Get the jobPreparationTask property: The Job Preparation Task is a special Task run on each Compute Node before
     * any other Task of the Job.
     *
     * @return the jobPreparationTask value.
     */
    @Generated
    public JobPreparationTask getJobPreparationTask() {
        return this.jobPreparationTask;
    }

    /**
     * Get the jobReleaseTask property: The Job Release Task is a special Task run at the end of the Job on each Compute
     * Node that has run any other Task of the Job.
     *
     * @return the jobReleaseTask value.
     */
    @Generated
    public JobReleaseTask getJobReleaseTask() {
        return this.jobReleaseTask;
    }

    /**
     * Get the commonEnvironmentSettings property: Individual Tasks can override an environment setting specified here
     * by specifying the same setting name with a different value.
     *
     * @return the commonEnvironmentSettings value.
     */
    @Generated
    public List<EnvironmentSetting> getCommonEnvironmentSettings() {
        return this.commonEnvironmentSettings;
    }

    /**
     * Get the poolInfo property: Specifies how a Job should be assigned to a Pool.
     *
     * @return the poolInfo value.
     */
    @Generated
    public PoolInformation getPoolInfo() {
        return this.poolInfo;
    }

    /**
     * Set the poolInfo property: Specifies how a Job should be assigned to a Pool.
     *
     * @param poolInfo the poolInfo value to set.
     * @return the BatchJob object itself.
     */
    public BatchJob setPoolInfo(PoolInformation poolInfo) {
        this.poolInfo = poolInfo;
        return this;
    }

    /**
     * Get the onAllTasksComplete property: The default is noaction.
     *
     * @return the onAllTasksComplete value.
     */
    @Generated
    public OnAllTasksComplete getOnAllTasksComplete() {
        return this.onAllTasksComplete;
    }

    /**
     * Set the onAllTasksComplete property: The default is noaction.
     *
     * @param onAllTasksComplete the onAllTasksComplete value to set.
     * @return the BatchJob object itself.
     */
    @Generated
    public BatchJob setOnAllTasksComplete(OnAllTasksComplete onAllTasksComplete) {
        this.onAllTasksComplete = onAllTasksComplete;
        return this;
    }

    /**
     * Get the onTaskFailure property: A Task is considered to have failed if has a failureInfo. A failureInfo is set if
     * the Task completes with a non-zero exit code after exhausting its retry count, or if there was an error starting
     * the Task, for example due to a resource file download error. The default is noaction.
     *
     * @return the onTaskFailure value.
     */
    @Generated
    public OnTaskFailure getOnTaskFailure() {
        return this.onTaskFailure;
    }

    /**
     * Get the networkConfiguration property: The network configuration for the Job.
     *
     * @return the networkConfiguration value.
     */
    @Generated
    public JobNetworkConfiguration getNetworkConfiguration() {
        return this.networkConfiguration;
    }

    /**
     * Get the metadata property: The Batch service does not assign any meaning to metadata; it is solely for the use of
     * user code.
     *
     * @return the metadata value.
     */
    @Generated
    public List<MetadataItem> getMetadata() {
        return this.metadata;
    }

    /**
     * Set the metadata property: The Batch service does not assign any meaning to metadata; it is solely for the use of
     * user code.
     *
     * @param metadata the metadata value to set.
     * @return the BatchJob object itself.
     */
    @Generated
    public BatchJob setMetadata(List<MetadataItem> metadata) {
        this.metadata = metadata;
        return this;
    }

    /**
     * Get the executionInfo property: Contains information about the execution of a Job in the Azure Batch service.
     *
     * @return the executionInfo value.
     */
    @Generated
    public JobExecutionInformation getExecutionInfo() {
        return this.executionInfo;
    }

    /**
     * Get the stats property: This property is populated only if the CloudJob was retrieved with an expand clause
     * including the 'stats' attribute; otherwise it is null. The statistics may not be immediately available. The Batch
     * service performs periodic roll-up of statistics. The typical delay is about 30 minutes.
     *
     * @return the stats value.
     */
    @Generated
    public JobStatistics getStats() {
        return this.stats;
    }
}
