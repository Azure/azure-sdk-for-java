// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
package com.azure.compute.batch;

import com.azure.compute.batch.implementation.TasksImpl;
import com.azure.compute.batch.models.*;
import com.azure.compute.batch.models.BatchTask;
import com.azure.compute.batch.models.BatchTaskCollection;
import com.azure.compute.batch.models.BatchTaskCreateParameters;
import com.azure.compute.batch.models.BatchTaskListSubtasksResult;
import com.azure.compute.batch.models.NodeFile;
import com.azure.compute.batch.models.TaskAddCollectionResult;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpHeaderName;
import com.azure.core.http.RequestConditions;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.DateTimeRfc1123;
import java.time.OffsetDateTime;
import java.util.*;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;

/** Initializes a new instance of the synchronous BatchServiceClient type. */
@ServiceClient(builder = BatchServiceClientBuilder.class)
public final class TaskClient {

    /**
     * Creates a Task to the specified Job.
     *
     * <p>The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180
     * days of being added it will be terminated by the Batch service and left in whatever state it was in at that time.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     commandLine: String (Required)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to which the Task is to be created.
     * @param task The Task to be created.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createWithResponse(String jobId, BinaryData task, RequestOptions requestOptions) {
        return this.serviceClient.createWithResponse(jobId, task, requestOptions);
    }

    /**
     * Lists all of the Tasks that are associated with the specified Job.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     state: String(active/preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     commandLine: String (Optional)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Optional)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         requeueCount: int (Required)
     *         lastRequeueTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         waitTime: Duration (Required)
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Tasks in a Job as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> list(String jobId, RequestOptions requestOptions) {
        return this.serviceClient.list(jobId, requestOptions);
    }

    /**
     * Adds a collection of Tasks to the specified Job.
     *
     * <p>Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the
     * same order the Tasks were submitted in this request. If the server times out or the connection is closed during
     * the request, the request may have been partially or fully processed, or not at all. In such cases, the user
     * should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a
     * request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded,
     * the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a
     * client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to
     * omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to
     * completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the
     * Batch service and left in whatever state it was in at that time.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             id: String (Required)
     *             displayName: String (Optional)
     *             exitConditions (Optional): {
     *                 exitCodes (Optional): [
     *                      (Optional){
     *                         code: int (Required)
     *                         exitOptions (Required): {
     *                             jobAction: String(none/disable/terminate) (Optional)
     *                             dependencyAction: String(satisfy/block) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 exitCodeRanges (Optional): [
     *                      (Optional){
     *                         start: int (Required)
     *                         end: int (Required)
     *                         exitOptions (Required): (recursive schema, see exitOptions above)
     *                     }
     *                 ]
     *                 preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *                 fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *                 default (Optional): (recursive schema, see default above)
     *             }
     *             commandLine: String (Required)
     *             containerSettings (Optional): {
     *                 containerRunOptions: String (Optional)
     *                 imageName: String (Required)
     *                 registry (Optional): {
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *                 workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *             }
     *             resourceFiles (Optional): [
     *                  (Optional){
     *                     autoStorageContainerName: String (Optional)
     *                     storageContainerUrl: String (Optional)
     *                     httpUrl: String (Optional)
     *                     blobPrefix: String (Optional)
     *                     filePath: String (Optional)
     *                     fileMode: String (Optional)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                 }
     *             ]
     *             outputFiles (Optional): [
     *                  (Optional){
     *                     filePattern: String (Required)
     *                     destination (Required): {
     *                         container (Optional): {
     *                             path: String (Optional)
     *                             containerUrl: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                             uploadHeaders (Optional): [
     *                                  (Optional){
     *                                     name: String (Required)
     *                                     value: String (Optional)
     *                                 }
     *                             ]
     *                         }
     *                     }
     *                     uploadOptions (Required): {
     *                         uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                     }
     *                 }
     *             ]
     *             environmentSettings (Optional): [
     *                  (Optional){
     *                     name: String (Required)
     *                     value: String (Optional)
     *                 }
     *             ]
     *             affinityInfo (Optional): {
     *                 affinityId: String (Required)
     *             }
     *             constraints (Optional): {
     *                 maxWallClockTime: Duration (Optional)
     *                 retentionTime: Duration (Optional)
     *                 maxTaskRetryCount: Integer (Optional)
     *             }
     *             requiredSlots: Integer (Optional)
     *             userIdentity (Optional): {
     *                 username: String (Optional)
     *                 autoUser (Optional): {
     *                     scope: String(task/pool) (Optional)
     *                     elevationLevel: String(nonadmin/admin) (Optional)
     *                 }
     *             }
     *             multiInstanceSettings (Optional): {
     *                 numberOfInstances: Integer (Optional)
     *                 coordinationCommandLine: String (Required)
     *                 commonResourceFiles (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *             }
     *             dependsOn (Optional): {
     *                 taskIds (Optional): [
     *                     String (Optional)
     *                 ]
     *                 taskIdRanges (Optional): [
     *                      (Optional){
     *                         start: int (Required)
     *                         end: int (Required)
     *                     }
     *                 ]
     *             }
     *             applicationPackageReferences (Optional): [
     *                  (Optional){
     *                     applicationId: String (Required)
     *                     version: String (Optional)
     *                 }
     *             ]
     *             authenticationTokenSettings (Optional): {
     *                 access (Optional): [
     *                     String(job) (Optional)
     *                 ]
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Optional): [
     *          (Optional){
     *             status: String(Success/clienterror/servererror) (Required)
     *             taskId: String (Required)
     *             eTag: String (Optional)
     *             lastModified: OffsetDateTime (Optional)
     *             location: String (Optional)
     *             error (Optional): {
     *                 code: String (Required)
     *                 message (Optional): {
     *                     lang: String (Optional)
     *                     value: String (Optional)
     *                 }
     *                 values (Optional): [
     *                      (Optional){
     *                         key: String (Optional)
     *                         value: String (Optional)
     *                     }
     *                 ]
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to which the Task collection is to be added.
     * @param collection The Tasks to be added.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of adding a collection of Tasks to a Job along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> addCollectionWithResponse(
            String jobId, BinaryData collection, RequestOptions requestOptions) {
        return this.serviceClient.addCollectionWithResponse(jobId, collection, requestOptions);
    }

    /**
     * Deletes a Task from the specified Job.
     *
     * <p>When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted
     * (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to
     * the primary task; subtasks and their files are then deleted asynchronously in the background.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job from which to delete the Task.
     * @param taskId The ID of the Task to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.deleteWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Gets information about the specified Task.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     state: String(active/preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     commandLine: String (Optional)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Optional)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         requeueCount: int (Required)
     *         lastRequeueTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         waitTime: Duration (Required)
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task to get information about.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return batch will retry Tasks when a recovery operation is triggered on a Node. Examples of recovery operations
     *     include (but are not limited to) when an unhealthy Node is rebooted or a Compute Node disappeared due to host
     *     failure. Retries due to recovery operations are independent of and are not counted against the
     *     maxTaskRetryCount along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.getWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Updates the properties of the specified Task.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     state: String(active/preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     commandLine: String (Optional)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Optional)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         requeueCount: int (Required)
     *         lastRequeueTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         waitTime: Duration (Required)
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to update.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updateWithResponse(
            String jobId, String taskId, BinaryData parameters, RequestOptions requestOptions) {
        return this.serviceClient.updateWithResponse(jobId, taskId, parameters, requestOptions);
    }

    /**
     * Terminates the specified Task.
     *
     * <p>When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate
     * Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the
     * background.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to terminate.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> terminateWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.terminateWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Reactivates a Task, allowing it to run again even if its retry count has been exhausted.
     *
     * <p>Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task's state is
     * changed to active. As the Task is no longer in the completed state, any previous exit code or failure information
     * is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0.
     * Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit
     * code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting).
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to reactivate.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> reactivateWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.reactivateWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Creates a Task to the specified Job.
     *
     * <p>The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180
     * days of being added it will be terminated by the Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task is to be created.
     * @param task The Task to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void create(String jobId, BatchTaskCreateParameters task) {
        // Generated convenience method for createWithResponse
        RequestOptions requestOptions = new RequestOptions();
        createWithResponse(jobId, BinaryData.fromObject(task), requestOptions).getValue();
    }

    /**
     * Lists all of the Tasks that are associated with the specified Job.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Tasks in a Job as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchTask> list(String jobId) {
        // Generated convenience method for list
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient
                .list(jobId, requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchTask.class));
    }

    /**
     * Adds a collection of Tasks to the specified Job.
     *
     * <p>Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the
     * same order the Tasks were submitted in this request. If the server times out or the connection is closed during
     * the request, the request may have been partially or fully processed, or not at all. In such cases, the user
     * should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a
     * request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded,
     * the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a
     * client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to
     * omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to
     * completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the
     * Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task collection is to be added.
     * @param collection The Tasks to be added.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of adding a collection of Tasks to a Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TaskAddCollectionResult addCollection(String jobId, BatchTaskCollection collection) {
        // Generated convenience method for addCollectionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return addCollectionWithResponse(jobId, BinaryData.fromObject(collection), requestOptions)
                .getValue()
                .toObject(TaskAddCollectionResult.class);
    }

    /**
     * Deletes a Task from the specified Job.
     *
     * <p>When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted
     * (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to
     * the primary task; subtasks and their files are then deleted asynchronously in the background.
     *
     * @param jobId The ID of the Job from which to delete the Task.
     * @param taskId The ID of the Task to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String jobId, String taskId) {
        // Generated convenience method for deleteWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Gets information about the specified Task.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task to get information about.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return batch will retry Tasks when a recovery operation is triggered on a Node. Examples of recovery operations
     *     include (but are not limited to) when an unhealthy Node is rebooted or a Compute Node disappeared due to host
     *     failure. Retries due to recovery operations are independent of and are not counted against the
     *     maxTaskRetryCount.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchTask get(String jobId, String taskId) {
        // Generated convenience method for getWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getWithResponse(jobId, taskId, requestOptions).getValue().toObject(BatchTask.class);
    }

    /**
     * Updates the properties of the specified Task.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to update.
     * @param parameters The parameters for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void update(String jobId, String taskId, BatchTask parameters) {
        // Generated convenience method for updateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        updateWithResponse(jobId, taskId, BinaryData.fromObject(parameters), requestOptions).getValue();
    }

    /**
     * Terminates the specified Task.
     *
     * <p>When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate
     * Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the
     * background.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to terminate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void terminate(String jobId, String taskId) {
        // Generated convenience method for terminateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        terminateWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Reactivates a Task, allowing it to run again even if its retry count has been exhausted.
     *
     * <p>Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task's state is
     * changed to active. As the Task is no longer in the completed state, any previous exit code or failure information
     * is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0.
     * Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit
     * code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting).
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to reactivate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void reactivate(String jobId, String taskId) {
        // Generated convenience method for reactivateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        reactivateWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Lists all of the subtasks that are associated with the specified multi-instance Task.
     *
     * <p>If the Task is not a multi-instance Task then this returns an empty collection.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Optional): [
     *          (Optional){
     *             id: Integer (Optional)
     *             nodeInfo (Optional): {
     *                 affinityId: String (Optional)
     *                 nodeUrl: String (Optional)
     *                 poolId: String (Optional)
     *                 nodeId: String (Optional)
     *                 taskRootDirectory: String (Optional)
     *                 taskRootDirectoryUrl: String (Optional)
     *             }
     *             startTime: OffsetDateTime (Optional)
     *             endTime: OffsetDateTime (Optional)
     *             exitCode: Integer (Optional)
     *             containerInfo (Optional): {
     *                 containerId: String (Optional)
     *                 state: String (Optional)
     *                 error: String (Optional)
     *             }
     *             failureInfo (Optional): {
     *                 category: String(usererror/servererror) (Required)
     *                 code: String (Optional)
     *                 message: String (Optional)
     *                 details (Optional): [
     *                      (Optional){
     *                         name: String (Optional)
     *                         value: String (Optional)
     *                     }
     *                 ]
     *             }
     *             state: String(preparing/running/completed) (Optional)
     *             stateTransitionTime: OffsetDateTime (Optional)
     *             previousState: String(preparing/running/completed) (Optional)
     *             previousStateTransitionTime: OffsetDateTime (Optional)
     *             result: String(success/failure) (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param taskId The ID of the Task.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the subtasks of a Task along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> listSubtasksWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.listSubtasksWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Lists all of the subtasks that are associated with the specified multi-instance Task.
     *
     * <p>If the Task is not a multi-instance Task then this returns an empty collection.
     *
     * @param jobId The ID of the Job.
     * @param taskId The ID of the Task.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the subtasks of a Task.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchTaskListSubtasksResult listSubtasks(String jobId, String taskId) {
        // Generated convenience method for listSubtasksWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return listSubtasksWithResponse(jobId, taskId, requestOptions)
                .getValue()
                .toObject(BatchTaskListSubtasksResult.class);
    }

    @Generated private final TasksImpl serviceClient;

    /**
     * Initializes an instance of TaskClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    TaskClient(TasksImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Creates a Task to the specified Job.
     *
     * <p>The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180
     * days of being added it will be terminated by the Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task is to be created.
     * @param task The Task to be created.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void create(String jobId, BatchTaskCreateParameters task, Integer timeOut, OffsetDateTime ocpDate) {
        // Generated convenience method for createWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        createWithResponse(jobId, BinaryData.fromObject(task), requestOptions).getValue();
    }

    /**
     * Lists all of the Tasks that are associated with the specified Job.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job.
     * @param maxresults The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     *     https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Tasks in a Job as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchTask> list(
            String jobId,
            Integer maxresults,
            OffsetDateTime ocpDate,
            Integer timeOut,
            String filter,
            String select,
            String expand) {
        // Generated convenience method for list
        RequestOptions requestOptions = new RequestOptions();
        if (maxresults != null) {
            requestOptions.addQueryParam("maxresults", String.valueOf(maxresults), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select", select, false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand", expand, false);
        }
        return serviceClient
                .list(jobId, requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchTask.class));
    }

    /**
     * Adds a collection of Tasks to the specified Job.
     *
     * <p>Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the
     * same order the Tasks were submitted in this request. If the server times out or the connection is closed during
     * the request, the request may have been partially or fully processed, or not at all. In such cases, the user
     * should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a
     * request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded,
     * the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a
     * client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to
     * omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to
     * completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the
     * Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task collection is to be added.
     * @param collection The Tasks to be added.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of adding a collection of Tasks to a Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TaskAddCollectionResult addCollection(
            String jobId, BatchTaskCollection collection, Integer timeOut, OffsetDateTime ocpDate) {
        // Generated convenience method for addCollectionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        return addCollectionWithResponse(jobId, BinaryData.fromObject(collection), requestOptions)
                .getValue()
                .toObject(TaskAddCollectionResult.class);
    }

    /**
     * Deletes a Task from the specified Job.
     *
     * <p>When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted
     * (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to
     * the primary task; subtasks and their files are then deleted asynchronously in the background.
     *
     * @param jobId The ID of the Job from which to delete the Task.
     * @param taskId The ID of the Task to delete.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(
            String jobId, String taskId, Integer timeOut, OffsetDateTime ocpDate, RequestConditions requestConditions) {
        // Generated convenience method for deleteWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        deleteWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Gets information about the specified Task.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task to get information about.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return batch will retry Tasks when a recovery operation is triggered on a Node. Examples of recovery operations
     *     include (but are not limited to) when an unhealthy Node is rebooted or a Compute Node disappeared due to host
     *     failure. Retries due to recovery operations are independent of and are not counted against the
     *     maxTaskRetryCount.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchTask get(
            String jobId,
            String taskId,
            Integer timeOut,
            OffsetDateTime ocpDate,
            String select,
            String expand,
            RequestConditions requestConditions) {
        // Generated convenience method for getWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (select != null) {
            requestOptions.addQueryParam("$select", select, false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand", expand, false);
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        return getWithResponse(jobId, taskId, requestOptions).getValue().toObject(BatchTask.class);
    }

    /**
     * Updates the properties of the specified Task.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to update.
     * @param parameters The parameters for the request.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void update(
            String jobId,
            String taskId,
            BatchTask parameters,
            Integer timeOut,
            OffsetDateTime ocpDate,
            RequestConditions requestConditions) {
        // Generated convenience method for updateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        updateWithResponse(jobId, taskId, BinaryData.fromObject(parameters), requestOptions).getValue();
    }

    /**
     * Lists all of the subtasks that are associated with the specified multi-instance Task.
     *
     * <p>If the Task is not a multi-instance Task then this returns an empty collection.
     *
     * @param jobId The ID of the Job.
     * @param taskId The ID of the Task.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param select An OData $select clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the subtasks of a Task.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchTaskListSubtasksResult listSubtasks(
            String jobId, String taskId, Integer timeOut, OffsetDateTime ocpDate, String select) {
        // Generated convenience method for listSubtasksWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (select != null) {
            requestOptions.addQueryParam("$select", select, false);
        }
        return listSubtasksWithResponse(jobId, taskId, requestOptions)
                .getValue()
                .toObject(BatchTaskListSubtasksResult.class);
    }

    /**
     * Terminates the specified Task.
     *
     * <p>When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate
     * Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the
     * background.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to terminate.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void terminate(
            String jobId, String taskId, Integer timeOut, OffsetDateTime ocpDate, RequestConditions requestConditions) {
        // Generated convenience method for terminateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        terminateWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Reactivates a Task, allowing it to run again even if its retry count has been exhausted.
     *
     * <p>Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task's state is
     * changed to active. As the Task is no longer in the completed state, any previous exit code or failure information
     * is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0.
     * Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit
     * code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting).
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to reactivate.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void reactivate(
            String jobId, String taskId, Integer timeOut, OffsetDateTime ocpDate, RequestConditions requestConditions) {
        // Generated convenience method for reactivateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        reactivateWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Adds multiple tasks to a job.
     *
     * @param jobId The ID of the job to which to add the task.
     * @param taskList A list of {@link BatchTaskCreateParameters tasks} to add.
     * @throws RuntimeException Exception thrown when an error response is received from the Batch service or any
     *     network exception.
     * @throws InterruptedException Exception thrown if any thread has interrupted the current thread.
     */
    public void createTasks(String jobId, List<BatchTaskCreateParameters> taskList)
            throws RuntimeException, InterruptedException {
        createTasks(jobId, taskList, null);
    }

    private static class WorkingThread implements Runnable {

        static final int MAX_TASKS_PER_REQUEST = 100;

        private static final AtomicInteger CURRENT_MAX_TASKS = new AtomicInteger(MAX_TASKS_PER_REQUEST);

        TaskClient client;

        String jobId;

        Queue<BatchTaskCreateParameters> pendingList;

        List<TaskAddResult> failures;

        volatile Exception exception;

        final Object lock;

        WorkingThread(
                TaskClient client,
                String jobId,
                Queue<BatchTaskCreateParameters> pendingList,
                List<TaskAddResult> failures,
                Object lock) {
            this.client = client;
            this.jobId = jobId;
            this.pendingList = pendingList;
            this.failures = failures;
            this.exception = null;
            this.lock = lock;
        }

        public Exception getException() {
            return this.exception;
        }

        /**
         * Submits one chunk of tasks to a job.
         *
         * @param taskList A list of {@link BatchTask tasks} to add.
         */
        private void submitChunk(List<BatchTaskCreateParameters> taskList) {
            try {
                TaskAddCollectionResult response =
                        this.client.addCollection(this.jobId, new BatchTaskCollection(taskList));
                if (response != null && response.getValue() != null) {
                    for (TaskAddResult result : response.getValue()) {
                        if (result.getError() != null) {
                            if (result.getStatus() == TaskAddStatus.SERVER_ERROR) {
                                // Server error will be retried
                                for (BatchTaskCreateParameters batchTaskToCreate : taskList) {
                                    if (batchTaskToCreate.getId().equals(result.getTaskId())) {
                                        pendingList.add(batchTaskToCreate);
                                        break;
                                    }
                                }
                            } else if (result.getStatus() == TaskAddStatus.CLIENT_ERROR
                                    && !result.getError().getMessage().getValue().contains("Status code 409")) {
                                // Client error will be recorded
                                failures.add(result);
                            }
                        }
                    }
                }
            } /*
               * TODO: Track 1 SDK had an autogenerated BatchErrorException which encapsulated a {@link BatchError} - Investigate why custom exception type is not generated
               * */ catch (HttpResponseException e) {
                // If we get RequestBodyTooLarge could be that we chunked the tasks too large.
                // Try decreasing the size unless caused by 1 task.
                if (e.getResponse().getStatusCode() == 413 && taskList.size() > 1) {
                    // Use binary reduction to decrease size of submitted chunks
                    int midpoint = taskList.size() / 2;
                    // If the midpoint is less than the CURRENT_MAX_TASKS used to create new chunks,
                    // attempt to atomically reduce CURRENT_MAX_TASKS.
                    // In the case where compareAndSet fails, that means that CURRENT_MAX_TASKS which
                    // was the goal
                    int max = CURRENT_MAX_TASKS.get();
                    while (midpoint < max) {
                        CURRENT_MAX_TASKS.compareAndSet(max, midpoint);
                        max = CURRENT_MAX_TASKS.get();
                    }
                    // Resubmit chunk as a smaller list and requeue remaining tasks.
                    pendingList.addAll(taskList.subList(midpoint, taskList.size()));
                    submitChunk(taskList.subList(0, midpoint));
                } else {
                    // Any exception will stop further call
                    exception = e;
                    pendingList.addAll(taskList);
                }
            } catch (RuntimeException e) {
                // Any exception will stop further call
                exception = e;
                pendingList.addAll(taskList);
            }
        }

        @Override
        public void run() {
            try {
                List<BatchTaskCreateParameters> taskList = new LinkedList<>();
                // Take the task from the queue up to MAX_TASKS_PER_REQUEST
                int count = 0;
                int maxAmount = CURRENT_MAX_TASKS.get();
                while (count < maxAmount) {
                    BatchTaskCreateParameters param = pendingList.poll();
                    if (param != null) {
                        taskList.add(param);
                        count++;
                    } else {
                        break;
                    }
                }
                if (taskList.size() > 0) {
                    submitChunk(taskList);
                }
            } finally {
                synchronized (lock) {
                    // Notify main thread that sub thread finished
                    lock.notifyAll();
                }
            }
        }
    }

    /**
     * Creates a collection of Tasks to the specified Job.
     *
     * <p>Note that each Task must have a unique ID.This method can work with multiple threads. The parallel degree can
     * be specified by the user. If the server times out or the connection is closed during the request, the request may
     * have been partially or fully processed, or not at all. In such cases, the user should re-issue the request. Note
     * that it is up to the user to correctly handle failures when re-issuing a request. For example, you should use the
     * same Task IDs during a retry so that if the prior operation succeeded, the retry will not create extra Tasks
     * unexpectedly. If the response contains any Tasks which failed to add, a client can retry the request. In a retry,
     * it is most efficient to resubmit only Tasks that failed to add, and to omit Tasks that were successfully added on
     * the first attempt. The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not
     * completed within 180 days of being added it will be terminated by the Batch service and left in whatever state it
     * was in at that time.
     *
     * @param jobId The ID of the job to which to add the task.
     * @param taskList A list of {@link BatchTaskCreateParameters tasks} to add.
     * @param batchClientParallelOptions Option that configure the parallelization of the method.
     * @throws RuntimeException Exception thrown when an error response is received from the Batch service or any
     *     network exception.
     * @throws InterruptedException Exception thrown if any thread has interrupted the current thread.
     */
    public void createTasks(
            String jobId,
            List<BatchTaskCreateParameters> taskList,
            BatchClientParallelOptions batchClientParallelOptions)
            throws RuntimeException, InterruptedException {
        int threadNumber = 1;
        // Get user defined thread number
        if (batchClientParallelOptions != null) {
            threadNumber = batchClientParallelOptions.maxDegreeOfParallelism();
        }
        final Object lock = new Object();
        ConcurrentLinkedQueue<BatchTaskCreateParameters> pendingList = new ConcurrentLinkedQueue<>(taskList);
        CopyOnWriteArrayList<TaskAddResult> failures = new CopyOnWriteArrayList<>();
        Map<Thread, WorkingThread> threads = new HashMap<>();
        Exception innerException = null;
        synchronized (lock) {
            while (!pendingList.isEmpty()) {
                if (threads.size() < threadNumber) {
                    // Kick as many as possible add tasks requests by max allowed threads
                    WorkingThread worker = new WorkingThread(this, jobId, pendingList, failures, lock);
                    Thread thread = new Thread(worker);
                    thread.start();
                    threads.put(thread, worker);
                } else {
                    lock.wait();
                    List<Thread> finishedThreads = new ArrayList<>();
                    for (Map.Entry<Thread, WorkingThread> entry : threads.entrySet()) {
                        if (entry.getKey().getState() == Thread.State.TERMINATED) {
                            finishedThreads.add(entry.getKey());
                            // If any exception is encountered, then stop immediately without waiting for
                            // remaining active threads.
                            innerException = entry.getValue().getException();
                            if (innerException != null) {
                                break;
                            }
                        }
                    }
                    // Free the thread pool so we can start more threads to send the remaining add
                    // tasks requests.
                    threads.keySet().removeAll(finishedThreads);
                    // Any errors happened, we stop.
                    if (innerException != null || !failures.isEmpty()) {
                        break;
                    }
                }
            }
        }
        // Wait for all remaining threads to finish.
        for (Thread t : threads.keySet()) {
            t.join();
        }
        if (innerException == null) {
            // Check for errors in any of the threads.
            for (Map.Entry<Thread, WorkingThread> entry : threads.entrySet()) {
                innerException = entry.getValue().getException();
                if (innerException != null) {
                    break;
                }
            }
        }
        if (innerException != null) {
            // If an exception happened in any of the threads, throw it.
            if (innerException instanceof HttpResponseException) {
                throw (HttpResponseException) innerException;
            } else if (innerException instanceof RuntimeException) {
                // WorkingThread will only catch and store a BatchErrorException or a
                // RuntimeException in its run() method.
                // WorkingThread.getException() should therefore only return one of these two
                // types, making the cast safe.
                throw (RuntimeException) innerException;
            }
        }
        if (!failures.isEmpty()) {
            // Report any client error with leftover request
            List<BatchTaskCreateParameters> notFinished = new ArrayList<>();
            for (BatchTaskCreateParameters param : pendingList) {
                notFinished.add(param);
            }
            throw new CreateTasksErrorException("At least one task failed to be added.", failures, notFinished);
        }
        // We succeed here
    }

    /**
     * Deletes the specified Task file from the Compute Node where the Task ran.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>recursive</td><td>Boolean</td><td>No</td><td>Whether to delete children of a directory. If the filePath parameter represents
     * a directory instead of a file, you can set recursive to true to delete the
     * directory and all of the files and subdirectories in it. If recursive is false
     * then the directory must be empty or deletion will fail.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteFileFromTaskWithResponse(
            String jobId, String taskId, String filePath, RequestOptions requestOptions) {
        return this.serviceClient.deleteFileFromTaskWithResponse(jobId, taskId, filePath, requestOptions);
    }

    /**
     * Returns the content of the specified Task file.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     *     <tr><td>ocp-range</td><td>String</td><td>No</td><td>The byte range to be retrieved. The default is to retrieve the entire file. The
     * format is bytes=startRange-endRange.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * BinaryData
     * }</pre>
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getFileFromTaskWithResponse(
            String jobId, String taskId, String filePath, RequestOptions requestOptions) {
        return this.serviceClient.getFileFromTaskWithResponse(jobId, taskId, filePath, requestOptions);
    }

    /**
     * Gets the properties of the specified Task file.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the properties of the specified Task file along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> getFilePropertiesFromTaskWithResponse(
            String jobId, String taskId, String filePath, RequestOptions requestOptions) {
        return this.serviceClient.getFilePropertiesFromTaskWithResponse(jobId, taskId, filePath, requestOptions);
    }

    /**
     * Lists the files in a Task's directory on its Compute Node.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-task-files.</td></tr>
     *     <tr><td>recursive</td><td>Boolean</td><td>No</td><td>Whether to list children of the Task directory. This parameter can be used in
     * combination with the filter parameter to list specific type of files.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     name: String (Optional)
     *     url: String (Optional)
     *     isDirectory: Boolean (Optional)
     *     properties (Optional): {
     *         creationTime: OffsetDateTime (Optional)
     *         lastModified: OffsetDateTime (Required)
     *         contentLength: int (Required)
     *         contentType: String (Optional)
     *         fileMode: String (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose files you want to list.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the files on a Compute Node, or the files associated with a Task on a Compute Node
     *     as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listFilesFromTask(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.listFilesFromTask(jobId, taskId, requestOptions);
    }

    /**
     * Deletes the specified Task file from the Compute Node where the Task ran.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param recursive Whether to delete children of a directory. If the filePath parameter represents a directory
     *     instead of a file, you can set recursive to true to delete the directory and all of the files and
     *     subdirectories in it. If recursive is false then the directory must be empty or deletion will fail.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteFileFromTask(
            String jobId, String taskId, String filePath, Integer timeOut, OffsetDateTime ocpDate, Boolean recursive) {
        // Generated convenience method for deleteFileFromTaskWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (recursive != null) {
            requestOptions.addQueryParam("recursive", String.valueOf(recursive), false);
        }
        deleteFileFromTaskWithResponse(jobId, taskId, filePath, requestOptions).getValue();
    }

    /**
     * Deletes the specified Task file from the Compute Node where the Task ran.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteFileFromTask(String jobId, String taskId, String filePath) {
        // Generated convenience method for deleteFileFromTaskWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteFileFromTaskWithResponse(jobId, taskId, filePath, requestOptions).getValue();
    }

    /**
     * Returns the content of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param ifModifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has been modified since the specified time.
     * @param ifUnmodifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has not been modified since the specified
     *     time.
     * @param ocpRange The byte range to be retrieved. The default is to retrieve the entire file. The format is
     *     bytes=startRange-endRange.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BinaryData getFileFromTask(
            String jobId,
            String taskId,
            String filePath,
            Integer timeOut,
            OffsetDateTime ocpDate,
            OffsetDateTime ifModifiedSince,
            OffsetDateTime ifUnmodifiedSince,
            String ocpRange) {
        // Generated convenience method for getFileFromTaskWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        if (ocpRange != null) {
            requestOptions.setHeader(HttpHeaderName.fromString("ocp-range"), ocpRange);
        }
        return getFileFromTaskWithResponse(jobId, taskId, filePath, requestOptions).getValue();
    }

    /**
     * Returns the content of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BinaryData getFileFromTask(String jobId, String taskId, String filePath) {
        // Generated convenience method for getFileFromTaskWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getFileFromTaskWithResponse(jobId, taskId, filePath, requestOptions).getValue();
    }

    /**
     * Gets the properties of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param ifModifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has been modified since the specified time.
     * @param ifUnmodifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has not been modified since the specified
     *     time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void getFilePropertiesFromTask(
            String jobId,
            String taskId,
            String filePath,
            Integer timeOut,
            OffsetDateTime ocpDate,
            OffsetDateTime ifModifiedSince,
            OffsetDateTime ifUnmodifiedSince) {
        // Generated convenience method for getFilePropertiesFromTaskWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        getFilePropertiesFromTaskWithResponse(jobId, taskId, filePath, requestOptions).getValue();
    }

    /**
     * Gets the properties of the specified Task file.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose file you want to retrieve.
     * @param filePath The path to the Task file that you want to get the content of.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void getFilePropertiesFromTask(String jobId, String taskId, String filePath) {
        // Generated convenience method for getFilePropertiesFromTaskWithResponse
        RequestOptions requestOptions = new RequestOptions();
        getFilePropertiesFromTaskWithResponse(jobId, taskId, filePath, requestOptions).getValue();
    }

    /**
     * Lists the files in a Task's directory on its Compute Node.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose files you want to list.
     * @param maxresults The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     *     https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-task-files.
     * @param recursive Whether to list children of the Task directory. This parameter can be used in combination with
     *     the filter parameter to list specific type of files.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the files on a Compute Node, or the files associated with a Task on a Compute Node
     *     as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<NodeFile> listFilesFromTask(
            String jobId,
            String taskId,
            Integer maxresults,
            OffsetDateTime ocpDate,
            Integer timeOut,
            String filter,
            Boolean recursive) {
        // Generated convenience method for listFilesFromTask
        RequestOptions requestOptions = new RequestOptions();
        if (maxresults != null) {
            requestOptions.addQueryParam("maxresults", String.valueOf(maxresults), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (recursive != null) {
            requestOptions.addQueryParam("recursive", String.valueOf(recursive), false);
        }
        return serviceClient
                .listFilesFromTask(jobId, taskId, requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(NodeFile.class));
    }

    /**
     * Lists the files in a Task's directory on its Compute Node.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task whose files you want to list.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the files on a Compute Node, or the files associated with a Task on a Compute Node
     *     as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<NodeFile> listFilesFromTask(String jobId, String taskId) {
        // Generated convenience method for listFilesFromTask
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient
                .listFilesFromTask(jobId, taskId, requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(NodeFile.class));
    }
}
