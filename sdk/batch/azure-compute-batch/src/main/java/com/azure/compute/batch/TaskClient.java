// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
package com.azure.compute.batch;

import com.azure.compute.batch.implementation.TasksImpl;
import com.azure.compute.batch.models.BatchTask;
import com.azure.compute.batch.models.BatchTaskCollection;
import com.azure.compute.batch.models.BatchTaskCreateParameters;
import com.azure.compute.batch.models.BatchTaskListSubtasksResult;
import com.azure.compute.batch.models.TaskAddCollectionResult;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpHeaderName;
import com.azure.core.http.RequestConditions;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.DateTimeRfc1123;
import java.time.OffsetDateTime;

/** Initializes a new instance of the synchronous BatchServiceClient type. */
@ServiceClient(builder = BatchServiceClientBuilder.class)
public final class TaskClient {

    /**
     * Creates a Task to the specified Job.
     *
     * <p>The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180
     * days of being added it will be terminated by the Batch service and left in whatever state it was in at that time.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     commandLine: String (Required)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to which the Task is to be created.
     * @param task The Task to be created.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createWithResponse(String jobId, BinaryData task, RequestOptions requestOptions) {
        return this.serviceClient.createWithResponse(jobId, task, requestOptions);
    }

    /**
     * Lists all of the Tasks that are associated with the specified Job.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     state: String(active/preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     commandLine: String (Optional)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Optional)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         requeueCount: int (Required)
     *         lastRequeueTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         waitTime: Duration (Required)
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Tasks in a Job as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> list(String jobId, RequestOptions requestOptions) {
        return this.serviceClient.list(jobId, requestOptions);
    }

    /**
     * Adds a collection of Tasks to the specified Job.
     *
     * <p>Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the
     * same order the Tasks were submitted in this request. If the server times out or the connection is closed during
     * the request, the request may have been partially or fully processed, or not at all. In such cases, the user
     * should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a
     * request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded,
     * the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a
     * client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to
     * omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to
     * completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the
     * Batch service and left in whatever state it was in at that time.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             id: String (Required)
     *             displayName: String (Optional)
     *             exitConditions (Optional): {
     *                 exitCodes (Optional): [
     *                      (Optional){
     *                         code: int (Required)
     *                         exitOptions (Required): {
     *                             jobAction: String(none/disable/terminate) (Optional)
     *                             dependencyAction: String(satisfy/block) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 exitCodeRanges (Optional): [
     *                      (Optional){
     *                         start: int (Required)
     *                         end: int (Required)
     *                         exitOptions (Required): (recursive schema, see exitOptions above)
     *                     }
     *                 ]
     *                 preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *                 fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *                 default (Optional): (recursive schema, see default above)
     *             }
     *             commandLine: String (Required)
     *             containerSettings (Optional): {
     *                 containerRunOptions: String (Optional)
     *                 imageName: String (Required)
     *                 registry (Optional): {
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *                 workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *             }
     *             resourceFiles (Optional): [
     *                  (Optional){
     *                     autoStorageContainerName: String (Optional)
     *                     storageContainerUrl: String (Optional)
     *                     httpUrl: String (Optional)
     *                     blobPrefix: String (Optional)
     *                     filePath: String (Optional)
     *                     fileMode: String (Optional)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                 }
     *             ]
     *             outputFiles (Optional): [
     *                  (Optional){
     *                     filePattern: String (Required)
     *                     destination (Required): {
     *                         container (Optional): {
     *                             path: String (Optional)
     *                             containerUrl: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                             uploadHeaders (Optional): [
     *                                  (Optional){
     *                                     name: String (Required)
     *                                     value: String (Optional)
     *                                 }
     *                             ]
     *                         }
     *                     }
     *                     uploadOptions (Required): {
     *                         uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                     }
     *                 }
     *             ]
     *             environmentSettings (Optional): [
     *                  (Optional){
     *                     name: String (Required)
     *                     value: String (Optional)
     *                 }
     *             ]
     *             affinityInfo (Optional): {
     *                 affinityId: String (Required)
     *             }
     *             constraints (Optional): {
     *                 maxWallClockTime: Duration (Optional)
     *                 retentionTime: Duration (Optional)
     *                 maxTaskRetryCount: Integer (Optional)
     *             }
     *             requiredSlots: Integer (Optional)
     *             userIdentity (Optional): {
     *                 username: String (Optional)
     *                 autoUser (Optional): {
     *                     scope: String(task/pool) (Optional)
     *                     elevationLevel: String(nonadmin/admin) (Optional)
     *                 }
     *             }
     *             multiInstanceSettings (Optional): {
     *                 numberOfInstances: Integer (Optional)
     *                 coordinationCommandLine: String (Required)
     *                 commonResourceFiles (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *             }
     *             dependsOn (Optional): {
     *                 taskIds (Optional): [
     *                     String (Optional)
     *                 ]
     *                 taskIdRanges (Optional): [
     *                      (Optional){
     *                         start: int (Required)
     *                         end: int (Required)
     *                     }
     *                 ]
     *             }
     *             applicationPackageReferences (Optional): [
     *                  (Optional){
     *                     applicationId: String (Required)
     *                     version: String (Optional)
     *                 }
     *             ]
     *             authenticationTokenSettings (Optional): {
     *                 access (Optional): [
     *                     String(job) (Optional)
     *                 ]
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Optional): [
     *          (Optional){
     *             status: String(Success/clienterror/servererror) (Required)
     *             taskId: String (Required)
     *             eTag: String (Optional)
     *             lastModified: OffsetDateTime (Optional)
     *             location: String (Optional)
     *             error (Optional): {
     *                 code: String (Required)
     *                 message (Optional): {
     *                     lang: String (Optional)
     *                     value: String (Optional)
     *                 }
     *                 values (Optional): [
     *                      (Optional){
     *                         key: String (Optional)
     *                         value: String (Optional)
     *                     }
     *                 ]
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to which the Task collection is to be added.
     * @param collection The Tasks to be added.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of adding a collection of Tasks to a Job along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> addCollectionWithResponse(
            String jobId, BinaryData collection, RequestOptions requestOptions) {
        return this.serviceClient.addCollectionWithResponse(jobId, collection, requestOptions);
    }

    /**
     * Deletes a Task from the specified Job.
     *
     * <p>When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted
     * (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to
     * the primary task; subtasks and their files are then deleted asynchronously in the background.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job from which to delete the Task.
     * @param taskId The ID of the Task to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.deleteWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Gets information about the specified Task.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     state: String(active/preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     commandLine: String (Optional)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Optional)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         requeueCount: int (Required)
     *         lastRequeueTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         waitTime: Duration (Required)
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task to get information about.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return batch will retry Tasks when a recovery operation is triggered on a Node. Examples of recovery operations
     *     include (but are not limited to) when an unhealthy Node is rebooted or a Compute Node disappeared due to host
     *     failure. Retries due to recovery operations are independent of and are not counted against the
     *     maxTaskRetryCount along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.getWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Updates the properties of the specified Task.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     exitConditions (Optional): {
     *         exitCodes (Optional): [
     *              (Optional){
     *                 code: int (Required)
     *                 exitOptions (Required): {
     *                     jobAction: String(none/disable/terminate) (Optional)
     *                     dependencyAction: String(satisfy/block) (Optional)
     *                 }
     *             }
     *         ]
     *         exitCodeRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *                 exitOptions (Required): (recursive schema, see exitOptions above)
     *             }
     *         ]
     *         preProcessingError (Optional): (recursive schema, see preProcessingError above)
     *         fileUploadError (Optional): (recursive schema, see fileUploadError above)
     *         default (Optional): (recursive schema, see default above)
     *     }
     *     state: String(active/preparing/running/completed) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/preparing/running/completed) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     commandLine: String (Optional)
     *     containerSettings (Optional): {
     *         containerRunOptions: String (Optional)
     *         imageName: String (Required)
     *         registry (Optional): {
     *             username: String (Optional)
     *             password: String (Optional)
     *             registryServer: String (Optional)
     *             identityReference (Optional): {
     *                 resourceId: String (Optional)
     *             }
     *         }
     *         workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *     }
     *     resourceFiles (Optional): [
     *          (Optional){
     *             autoStorageContainerName: String (Optional)
     *             storageContainerUrl: String (Optional)
     *             httpUrl: String (Optional)
     *             blobPrefix: String (Optional)
     *             filePath: String (Optional)
     *             fileMode: String (Optional)
     *             identityReference (Optional): (recursive schema, see identityReference above)
     *         }
     *     ]
     *     outputFiles (Optional): [
     *          (Optional){
     *             filePattern: String (Required)
     *             destination (Required): {
     *                 container (Optional): {
     *                     path: String (Optional)
     *                     containerUrl: String (Required)
     *                     identityReference (Optional): (recursive schema, see identityReference above)
     *                     uploadHeaders (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             value: String (Optional)
     *                         }
     *                     ]
     *                 }
     *             }
     *             uploadOptions (Required): {
     *                 uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *             }
     *         }
     *     ]
     *     environmentSettings (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Optional)
     *         }
     *     ]
     *     affinityInfo (Optional): {
     *         affinityId: String (Required)
     *     }
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     requiredSlots: Integer (Optional)
     *     userIdentity (Optional): {
     *         username: String (Optional)
     *         autoUser (Optional): {
     *             scope: String(task/pool) (Optional)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *         }
     *     }
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Optional)
     *         endTime: OffsetDateTime (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         requeueCount: int (Required)
     *         lastRequeueTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     nodeInfo (Optional): {
     *         affinityId: String (Optional)
     *         nodeUrl: String (Optional)
     *         poolId: String (Optional)
     *         nodeId: String (Optional)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *     }
     *     multiInstanceSettings (Optional): {
     *         numberOfInstances: Integer (Optional)
     *         coordinationCommandLine: String (Required)
     *         commonResourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         waitTime: Duration (Required)
     *     }
     *     dependsOn (Optional): {
     *         taskIds (Optional): [
     *             String (Optional)
     *         ]
     *         taskIdRanges (Optional): [
     *              (Optional){
     *                 start: int (Required)
     *                 end: int (Required)
     *             }
     *         ]
     *     }
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     authenticationTokenSettings (Optional): {
     *         access (Optional): [
     *             String(job) (Optional)
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to update.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updateWithResponse(
            String jobId, String taskId, BinaryData parameters, RequestOptions requestOptions) {
        return this.serviceClient.updateWithResponse(jobId, taskId, parameters, requestOptions);
    }

    /**
     * Terminates the specified Task.
     *
     * <p>When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate
     * Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the
     * background.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to terminate.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> terminateWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.terminateWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Reactivates a Task, allowing it to run again even if its retry count has been exhausted.
     *
     * <p>Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task's state is
     * changed to active. As the Task is no longer in the completed state, any previous exit code or failure information
     * is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0.
     * Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit
     * code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting).
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to reactivate.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> reactivateWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.reactivateWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Creates a Task to the specified Job.
     *
     * <p>The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180
     * days of being added it will be terminated by the Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task is to be created.
     * @param task The Task to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void create(String jobId, BatchTaskCreateParameters task) {
        // Generated convenience method for createWithResponse
        RequestOptions requestOptions = new RequestOptions();
        createWithResponse(jobId, BinaryData.fromObject(task), requestOptions).getValue();
    }

    /**
     * Lists all of the Tasks that are associated with the specified Job.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Tasks in a Job as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchTask> list(String jobId) {
        // Generated convenience method for list
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient
                .list(jobId, requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchTask.class));
    }

    /**
     * Adds a collection of Tasks to the specified Job.
     *
     * <p>Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the
     * same order the Tasks were submitted in this request. If the server times out or the connection is closed during
     * the request, the request may have been partially or fully processed, or not at all. In such cases, the user
     * should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a
     * request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded,
     * the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a
     * client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to
     * omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to
     * completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the
     * Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task collection is to be added.
     * @param collection The Tasks to be added.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of adding a collection of Tasks to a Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TaskAddCollectionResult addCollection(String jobId, BatchTaskCollection collection) {
        // Generated convenience method for addCollectionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return addCollectionWithResponse(jobId, BinaryData.fromObject(collection), requestOptions)
                .getValue()
                .toObject(TaskAddCollectionResult.class);
    }

    /**
     * Deletes a Task from the specified Job.
     *
     * <p>When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted
     * (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to
     * the primary task; subtasks and their files are then deleted asynchronously in the background.
     *
     * @param jobId The ID of the Job from which to delete the Task.
     * @param taskId The ID of the Task to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String jobId, String taskId) {
        // Generated convenience method for deleteWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Gets information about the specified Task.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task to get information about.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return batch will retry Tasks when a recovery operation is triggered on a Node. Examples of recovery operations
     *     include (but are not limited to) when an unhealthy Node is rebooted or a Compute Node disappeared due to host
     *     failure. Retries due to recovery operations are independent of and are not counted against the
     *     maxTaskRetryCount.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchTask get(String jobId, String taskId) {
        // Generated convenience method for getWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getWithResponse(jobId, taskId, requestOptions).getValue().toObject(BatchTask.class);
    }

    /**
     * Updates the properties of the specified Task.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to update.
     * @param parameters The parameters for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void update(String jobId, String taskId, BatchTask parameters) {
        // Generated convenience method for updateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        updateWithResponse(jobId, taskId, BinaryData.fromObject(parameters), requestOptions).getValue();
    }

    /**
     * Terminates the specified Task.
     *
     * <p>When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate
     * Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the
     * background.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to terminate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void terminate(String jobId, String taskId) {
        // Generated convenience method for terminateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        terminateWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Reactivates a Task, allowing it to run again even if its retry count has been exhausted.
     *
     * <p>Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task's state is
     * changed to active. As the Task is no longer in the completed state, any previous exit code or failure information
     * is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0.
     * Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit
     * code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting).
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to reactivate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void reactivate(String jobId, String taskId) {
        // Generated convenience method for reactivateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        reactivateWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Lists all of the subtasks that are associated with the specified multi-instance Task.
     *
     * <p>If the Task is not a multi-instance Task then this returns an empty collection.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Optional): [
     *          (Optional){
     *             id: Integer (Optional)
     *             nodeInfo (Optional): {
     *                 affinityId: String (Optional)
     *                 nodeUrl: String (Optional)
     *                 poolId: String (Optional)
     *                 nodeId: String (Optional)
     *                 taskRootDirectory: String (Optional)
     *                 taskRootDirectoryUrl: String (Optional)
     *             }
     *             startTime: OffsetDateTime (Optional)
     *             endTime: OffsetDateTime (Optional)
     *             exitCode: Integer (Optional)
     *             containerInfo (Optional): {
     *                 containerId: String (Optional)
     *                 state: String (Optional)
     *                 error: String (Optional)
     *             }
     *             failureInfo (Optional): {
     *                 category: String(usererror/servererror) (Required)
     *                 code: String (Optional)
     *                 message: String (Optional)
     *                 details (Optional): [
     *                      (Optional){
     *                         name: String (Optional)
     *                         value: String (Optional)
     *                     }
     *                 ]
     *             }
     *             state: String(preparing/running/completed) (Optional)
     *             stateTransitionTime: OffsetDateTime (Optional)
     *             previousState: String(preparing/running/completed) (Optional)
     *             previousStateTransitionTime: OffsetDateTime (Optional)
     *             result: String(success/failure) (Optional)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param taskId The ID of the Task.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the subtasks of a Task along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> listSubtasksWithResponse(String jobId, String taskId, RequestOptions requestOptions) {
        return this.serviceClient.listSubtasksWithResponse(jobId, taskId, requestOptions);
    }

    /**
     * Lists all of the subtasks that are associated with the specified multi-instance Task.
     *
     * <p>If the Task is not a multi-instance Task then this returns an empty collection.
     *
     * @param jobId The ID of the Job.
     * @param taskId The ID of the Task.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the subtasks of a Task.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchTaskListSubtasksResult listSubtasks(String jobId, String taskId) {
        // Generated convenience method for listSubtasksWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return listSubtasksWithResponse(jobId, taskId, requestOptions)
                .getValue()
                .toObject(BatchTaskListSubtasksResult.class);
    }

    @Generated private final TasksImpl serviceClient;

    /**
     * Initializes an instance of TaskClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    TaskClient(TasksImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Creates a Task to the specified Job.
     *
     * <p>The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180
     * days of being added it will be terminated by the Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task is to be created.
     * @param task The Task to be created.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void create(String jobId, BatchTaskCreateParameters task, Integer timeOut, OffsetDateTime ocpDate) {
        // Generated convenience method for createWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        createWithResponse(jobId, BinaryData.fromObject(task), requestOptions).getValue();
    }

    /**
     * Lists all of the Tasks that are associated with the specified Job.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job.
     * @param maxresults The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     *     https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Tasks in a Job as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchTask> list(
            String jobId,
            Integer maxresults,
            OffsetDateTime ocpDate,
            Integer timeOut,
            String filter,
            String select,
            String expand) {
        // Generated convenience method for list
        RequestOptions requestOptions = new RequestOptions();
        if (maxresults != null) {
            requestOptions.addQueryParam("maxresults", String.valueOf(maxresults), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select", select, false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand", expand, false);
        }
        return serviceClient
                .list(jobId, requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(BatchTask.class));
    }

    /**
     * Adds a collection of Tasks to the specified Job.
     *
     * <p>Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the
     * same order the Tasks were submitted in this request. If the server times out or the connection is closed during
     * the request, the request may have been partially or fully processed, or not at all. In such cases, the user
     * should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a
     * request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded,
     * the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a
     * client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to
     * omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to
     * completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the
     * Batch service and left in whatever state it was in at that time.
     *
     * @param jobId The ID of the Job to which the Task collection is to be added.
     * @param collection The Tasks to be added.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of adding a collection of Tasks to a Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TaskAddCollectionResult addCollection(
            String jobId, BatchTaskCollection collection, Integer timeOut, OffsetDateTime ocpDate) {
        // Generated convenience method for addCollectionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        return addCollectionWithResponse(jobId, BinaryData.fromObject(collection), requestOptions)
                .getValue()
                .toObject(TaskAddCollectionResult.class);
    }

    /**
     * Deletes a Task from the specified Job.
     *
     * <p>When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted
     * (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to
     * the primary task; subtasks and their files are then deleted asynchronously in the background.
     *
     * @param jobId The ID of the Job from which to delete the Task.
     * @param taskId The ID of the Task to delete.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(
            String jobId, String taskId, Integer timeOut, OffsetDateTime ocpDate, RequestConditions requestConditions) {
        // Generated convenience method for deleteWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        deleteWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Gets information about the specified Task.
     *
     * <p>For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary
     * Task. Use the list subtasks API to retrieve information about subtasks.
     *
     * @param jobId The ID of the Job that contains the Task.
     * @param taskId The ID of the Task to get information about.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return batch will retry Tasks when a recovery operation is triggered on a Node. Examples of recovery operations
     *     include (but are not limited to) when an unhealthy Node is rebooted or a Compute Node disappeared due to host
     *     failure. Retries due to recovery operations are independent of and are not counted against the
     *     maxTaskRetryCount.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchTask get(
            String jobId,
            String taskId,
            Integer timeOut,
            OffsetDateTime ocpDate,
            String select,
            String expand,
            RequestConditions requestConditions) {
        // Generated convenience method for getWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (select != null) {
            requestOptions.addQueryParam("$select", select, false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand", expand, false);
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        return getWithResponse(jobId, taskId, requestOptions).getValue().toObject(BatchTask.class);
    }

    /**
     * Updates the properties of the specified Task.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to update.
     * @param parameters The parameters for the request.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void update(
            String jobId,
            String taskId,
            BatchTask parameters,
            Integer timeOut,
            OffsetDateTime ocpDate,
            RequestConditions requestConditions) {
        // Generated convenience method for updateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        updateWithResponse(jobId, taskId, BinaryData.fromObject(parameters), requestOptions).getValue();
    }

    /**
     * Lists all of the subtasks that are associated with the specified multi-instance Task.
     *
     * <p>If the Task is not a multi-instance Task then this returns an empty collection.
     *
     * @param jobId The ID of the Job.
     * @param taskId The ID of the Task.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param select An OData $select clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the subtasks of a Task.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchTaskListSubtasksResult listSubtasks(
            String jobId, String taskId, Integer timeOut, OffsetDateTime ocpDate, String select) {
        // Generated convenience method for listSubtasksWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (select != null) {
            requestOptions.addQueryParam("$select", select, false);
        }
        return listSubtasksWithResponse(jobId, taskId, requestOptions)
                .getValue()
                .toObject(BatchTaskListSubtasksResult.class);
    }

    /**
     * Terminates the specified Task.
     *
     * <p>When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate
     * Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the
     * background.
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to terminate.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void terminate(
            String jobId, String taskId, Integer timeOut, OffsetDateTime ocpDate, RequestConditions requestConditions) {
        // Generated convenience method for terminateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        terminateWithResponse(jobId, taskId, requestOptions).getValue();
    }

    /**
     * Reactivates a Task, allowing it to run again even if its retry count has been exhausted.
     *
     * <p>Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task's state is
     * changed to active. As the Task is no longer in the completed state, any previous exit code or failure information
     * is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0.
     * Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit
     * code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting).
     *
     * @param jobId The ID of the Job containing the Task.
     * @param taskId The ID of the Task to reactivate.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param requestConditions Specifies HTTP options for conditional requests based on modification time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void reactivate(
            String jobId, String taskId, Integer timeOut, OffsetDateTime ocpDate, RequestConditions requestConditions) {
        // Generated convenience method for reactivateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        String ifMatch = requestConditions == null ? null : requestConditions.getIfMatch();
        String ifNoneMatch = requestConditions == null ? null : requestConditions.getIfNoneMatch();
        OffsetDateTime ifModifiedSince = requestConditions == null ? null : requestConditions.getIfModifiedSince();
        OffsetDateTime ifUnmodifiedSince = requestConditions == null ? null : requestConditions.getIfUnmodifiedSince();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader(
                    HttpHeaderName.fromString("ocp-date"), String.valueOf(new DateTimeRfc1123(ocpDate)));
        }
        if (ifMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_MATCH, ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader(HttpHeaderName.IF_NONE_MATCH, ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_MODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifModifiedSince)));
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader(
                    HttpHeaderName.IF_UNMODIFIED_SINCE, String.valueOf(new DateTimeRfc1123(ifUnmodifiedSince)));
        }
        reactivateWithResponse(jobId, taskId, requestOptions).getValue();
    }
}
