// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.compute.batch.models;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * The number of Compute Nodes in each Compute Node state.
 */
@Immutable
public final class BatchNodeCounts implements JsonSerializable<BatchNodeCounts> {

    /*
     * The number of Compute Nodes in the creating state.
     */
    @Generated
    private final int creating;

    /*
     * The number of Compute Nodes in the idle state.
     */
    @Generated
    private final int idle;

    /*
     * The number of Compute Nodes in the offline state.
     */
    @Generated
    private final int offline;

    /*
     * The number of Compute Nodes in the preempted state.
     */
    @Generated
    private final int preempted;

    /*
     * The count of Compute Nodes in the rebooting state.
     */
    @Generated
    private final int rebooting;

    /*
     * The number of Compute Nodes in the reimaging state.
     */
    @Generated
    private final int reimaging;

    /*
     * The number of Compute Nodes in the running state.
     */
    @Generated
    private final int running;

    /*
     * The number of Compute Nodes in the starting state.
     */
    @Generated
    private final int starting;

    /*
     * The number of Compute Nodes in the startTaskFailed state.
     */
    @Generated
    private final int startTaskFailed;

    /*
     * The number of Compute Nodes in the leavingPool state.
     */
    @Generated
    private final int leavingPool;

    /*
     * The number of Compute Nodes in the unknown state.
     */
    @Generated
    private final int unknown;

    /*
     * The number of Compute Nodes in the unusable state.
     */
    @Generated
    private final int unusable;

    /*
     * The number of Compute Nodes in the waitingForStartTask state.
     */
    @Generated
    private final int waitingForStartTask;

    /*
     * The total number of Compute Nodes.
     */
    @Generated
    private final int total;

    /**
     * Get the creating property: The number of Compute Nodes in the creating state.
     *
     * @return the creating value.
     */
    @Generated
    public int getCreating() {
        return this.creating;
    }

    /**
     * Get the idle property: The number of Compute Nodes in the idle state.
     *
     * @return the idle value.
     */
    @Generated
    public int getIdle() {
        return this.idle;
    }

    /**
     * Get the offline property: The number of Compute Nodes in the offline state.
     *
     * @return the offline value.
     */
    @Generated
    public int getOffline() {
        return this.offline;
    }

    /**
     * Get the preempted property: The number of Compute Nodes in the preempted state.
     *
     * @return the preempted value.
     */
    @Generated
    public int getPreempted() {
        return this.preempted;
    }

    /**
     * Get the rebooting property: The count of Compute Nodes in the rebooting state.
     *
     * @return the rebooting value.
     */
    @Generated
    public int getRebooting() {
        return this.rebooting;
    }

    /**
     * Get the reimaging property: The number of Compute Nodes in the reimaging state.
     *
     * @return the reimaging value.
     */
    @Generated
    public int getReimaging() {
        return this.reimaging;
    }

    /**
     * Get the running property: The number of Compute Nodes in the running state.
     *
     * @return the running value.
     */
    @Generated
    public int getRunning() {
        return this.running;
    }

    /**
     * Get the starting property: The number of Compute Nodes in the starting state.
     *
     * @return the starting value.
     */
    @Generated
    public int getStarting() {
        return this.starting;
    }

    /**
     * Get the startTaskFailed property: The number of Compute Nodes in the startTaskFailed state.
     *
     * @return the startTaskFailed value.
     */
    @Generated
    public int getStartTaskFailed() {
        return this.startTaskFailed;
    }

    /**
     * Get the leavingPool property: The number of Compute Nodes in the leavingPool state.
     *
     * @return the leavingPool value.
     */
    @Generated
    public int getLeavingPool() {
        return this.leavingPool;
    }

    /**
     * Get the unknown property: The number of Compute Nodes in the unknown state.
     *
     * @return the unknown value.
     */
    @Generated
    public int getUnknown() {
        return this.unknown;
    }

    /**
     * Get the unusable property: The number of Compute Nodes in the unusable state.
     *
     * @return the unusable value.
     */
    @Generated
    public int getUnusable() {
        return this.unusable;
    }

    /**
     * Get the waitingForStartTask property: The number of Compute Nodes in the waitingForStartTask state.
     *
     * @return the waitingForStartTask value.
     */
    @Generated
    public int getWaitingForStartTask() {
        return this.waitingForStartTask;
    }

    /**
     * Get the total property: The total number of Compute Nodes.
     *
     * @return the total value.
     */
    @Generated
    public int getTotal() {
        return this.total;
    }

    /**
     * Creates an instance of BatchNodeCounts class.
     *
     * @param creating the creating value to set.
     * @param idle the idle value to set.
     * @param offline the offline value to set.
     * @param preempted the preempted value to set.
     * @param rebooting the rebooting value to set.
     * @param reimaging the reimaging value to set.
     * @param running the running value to set.
     * @param starting the starting value to set.
     * @param startTaskFailed the startTaskFailed value to set.
     * @param leavingPool the leavingPool value to set.
     * @param unknown the unknown value to set.
     * @param unusable the unusable value to set.
     * @param waitingForStartTask the waitingForStartTask value to set.
     * @param total the total value to set.
     * @param upgradingOs the upgradingOs value to set.
     */
    @Generated
    private BatchNodeCounts(int creating, int idle, int offline, int preempted, int rebooting, int reimaging,
        int running, int starting, int startTaskFailed, int leavingPool, int unknown, int unusable,
        int waitingForStartTask, int total, int upgradingOs) {
        this.creating = creating;
        this.idle = idle;
        this.offline = offline;
        this.preempted = preempted;
        this.rebooting = rebooting;
        this.reimaging = reimaging;
        this.running = running;
        this.starting = starting;
        this.startTaskFailed = startTaskFailed;
        this.leavingPool = leavingPool;
        this.unknown = unknown;
        this.unusable = unusable;
        this.waitingForStartTask = waitingForStartTask;
        this.total = total;
        this.upgradingOs = upgradingOs;
    }

    /*
     * The number of Compute Nodes in the upgradingOS state.
     */
    @Generated
    private final int upgradingOs;

    /**
     * Get the upgradingOs property: The number of Compute Nodes in the upgradingOS state.
     *
     * @return the upgradingOs value.
     */
    @Generated
    public int getUpgradingOs() {
        return this.upgradingOs;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeIntField("creating", this.creating);
        jsonWriter.writeIntField("idle", this.idle);
        jsonWriter.writeIntField("offline", this.offline);
        jsonWriter.writeIntField("preempted", this.preempted);
        jsonWriter.writeIntField("rebooting", this.rebooting);
        jsonWriter.writeIntField("reimaging", this.reimaging);
        jsonWriter.writeIntField("running", this.running);
        jsonWriter.writeIntField("starting", this.starting);
        jsonWriter.writeIntField("startTaskFailed", this.startTaskFailed);
        jsonWriter.writeIntField("leavingPool", this.leavingPool);
        jsonWriter.writeIntField("unknown", this.unknown);
        jsonWriter.writeIntField("unusable", this.unusable);
        jsonWriter.writeIntField("waitingForStartTask", this.waitingForStartTask);
        jsonWriter.writeIntField("total", this.total);
        jsonWriter.writeIntField("upgradingOS", this.upgradingOs);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of BatchNodeCounts from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of BatchNodeCounts if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the BatchNodeCounts.
     */
    @Generated
    public static BatchNodeCounts fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            int creating = 0;
            int idle = 0;
            int offline = 0;
            int preempted = 0;
            int rebooting = 0;
            int reimaging = 0;
            int running = 0;
            int starting = 0;
            int startTaskFailed = 0;
            int leavingPool = 0;
            int unknown = 0;
            int unusable = 0;
            int waitingForStartTask = 0;
            int total = 0;
            int upgradingOs = 0;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("creating".equals(fieldName)) {
                    creating = reader.getInt();
                } else if ("idle".equals(fieldName)) {
                    idle = reader.getInt();
                } else if ("offline".equals(fieldName)) {
                    offline = reader.getInt();
                } else if ("preempted".equals(fieldName)) {
                    preempted = reader.getInt();
                } else if ("rebooting".equals(fieldName)) {
                    rebooting = reader.getInt();
                } else if ("reimaging".equals(fieldName)) {
                    reimaging = reader.getInt();
                } else if ("running".equals(fieldName)) {
                    running = reader.getInt();
                } else if ("starting".equals(fieldName)) {
                    starting = reader.getInt();
                } else if ("startTaskFailed".equals(fieldName)) {
                    startTaskFailed = reader.getInt();
                } else if ("leavingPool".equals(fieldName)) {
                    leavingPool = reader.getInt();
                } else if ("unknown".equals(fieldName)) {
                    unknown = reader.getInt();
                } else if ("unusable".equals(fieldName)) {
                    unusable = reader.getInt();
                } else if ("waitingForStartTask".equals(fieldName)) {
                    waitingForStartTask = reader.getInt();
                } else if ("total".equals(fieldName)) {
                    total = reader.getInt();
                } else if ("upgradingOS".equals(fieldName)) {
                    upgradingOs = reader.getInt();
                } else {
                    reader.skipChildren();
                }
            }
            return new BatchNodeCounts(creating, idle, offline, preempted, rebooting, reimaging, running, starting,
                startTaskFailed, leavingPool, unknown, unusable, waitingForStartTask, total, upgradingOs);
        });
    }
}
