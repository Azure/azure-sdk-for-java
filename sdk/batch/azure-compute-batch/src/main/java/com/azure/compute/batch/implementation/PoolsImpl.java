// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.compute.batch.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.Head;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import reactor.core.publisher.Mono;

/** An instance of this class provides access to all the operations defined in Pools. */
public final class PoolsImpl {
    /** The proxy service used to perform REST calls. */
    private final PoolsService service;

    /** The service client containing this operation class. */
    private final BatchServiceClientImpl client;

    /**
     * Initializes an instance of PoolsImpl.
     *
     * @param client the instance of the service client containing this operation class.
     */
    PoolsImpl(BatchServiceClientImpl client) {
        this.service = RestProxy.create(PoolsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for BatchServiceClientPools to be used by the proxy service to perform
     * REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "BatchServiceClientPo")
    public interface PoolsService {
        @Get("/poolusagemetrics")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listUsageMetrics(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/poolusagemetrics")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listUsageMetricsSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> create(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("content-type") String contentType,
                @HeaderParam("accept") String accept,
                @BodyParam("application/json; odata=minimalmetadata") BinaryData parameters,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> createSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("content-type") String contentType,
                @HeaderParam("accept") String accept,
                @BodyParam("application/json; odata=minimalmetadata") BinaryData parameters,
                RequestOptions requestOptions,
                Context context);

        @Get("/pools")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> list(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/pools")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Delete("/pools/{poolId}")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> delete(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Delete("/pools/{poolId}")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> deleteSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Head("/pools/{poolId}")
        @ExpectedResponses({200, 404})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Boolean>> exists(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Head("/pools/{poolId}")
        @ExpectedResponses({200, 404})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Boolean> existsSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/pools/{poolId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> get(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/pools/{poolId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Patch("/pools/{poolId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> patch(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("content-type") String contentType,
                @HeaderParam("accept") String accept,
                @BodyParam("application/json; odata=minimalmetadata") BinaryData parameters,
                RequestOptions requestOptions,
                Context context);

        @Patch("/pools/{poolId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> patchSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("content-type") String contentType,
                @HeaderParam("accept") String accept,
                @BodyParam("application/json; odata=minimalmetadata") BinaryData parameters,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools/{poolId}/disableautoscale")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> disableAutoScale(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools/{poolId}/disableautoscale")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> disableAutoScaleSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools/{poolId}/enableautoscale")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> enableAutoScale(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("content-type") String contentType,
                @HeaderParam("accept") String accept,
                @BodyParam("application/json; odata=minimalmetadata") BinaryData parameters,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools/{poolId}/enableautoscale")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> enableAutoScaleSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("content-type") String contentType,
                @HeaderParam("accept") String accept,
                @BodyParam("application/json; odata=minimalmetadata") BinaryData parameters,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools/{poolId}/evaluateautoscale")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> evaluateAutoScale(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("content-type") String contentType,
                @PathParam("poolId") String poolId,
                @HeaderParam("accept") String accept,
                @BodyParam("application/json; odata=minimalmetadata") BinaryData parameters,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools/{poolId}/evaluateautoscale")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> evaluateAutoScaleSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("content-type") String contentType,
                @PathParam("poolId") String poolId,
                @HeaderParam("accept") String accept,
                @BodyParam("application/json; odata=minimalmetadata") BinaryData parameters,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools/{poolId}/resize")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> resize(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("content-type") String contentType,
                @HeaderParam("accept") String accept,
                @BodyParam("application/json; odata=minimalmetadata") BinaryData parameters,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools/{poolId}/resize")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> resizeSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("content-type") String contentType,
                @HeaderParam("accept") String accept,
                @BodyParam("application/json; odata=minimalmetadata") BinaryData parameters,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools/{poolId}/stopresize")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> stopResize(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools/{poolId}/stopresize")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> stopResizeSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools/{poolId}/updateproperties")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> updateProperties(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("content-type") String contentType,
                @PathParam("poolId") String poolId,
                @HeaderParam("accept") String accept,
                @BodyParam("application/json; odata=minimalmetadata") BinaryData parameters,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools/{poolId}/updateproperties")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> updatePropertiesSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("content-type") String contentType,
                @PathParam("poolId") String poolId,
                @HeaderParam("accept") String accept,
                @BodyParam("application/json; odata=minimalmetadata") BinaryData parameters,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools/{poolId}/removenodes")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> removeNodes(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("content-type") String contentType,
                @HeaderParam("accept") String accept,
                @BodyParam("application/json; odata=minimalmetadata") BinaryData parameters,
                RequestOptions requestOptions,
                Context context);

        @Post("/pools/{poolId}/removenodes")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<Void> removeNodesSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("poolId") String poolId,
                @HeaderParam("content-type") String contentType,
                @HeaderParam("accept") String accept,
                @BodyParam("application/json; odata=minimalmetadata") BinaryData parameters,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listUsageMetricsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listUsageMetricsNextSync(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listNextSync(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);
    }

    /**
     * Lists the usage metrics, aggregated by Pool across individual time intervals, for the specified Account.
     *
     * <p>If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the
     * Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including
     * a startTime or endTime these filters default to the start and end times of the last aggregation interval
     * currently available; that is, only the last aggregation interval is returned.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>starttime</td><td>OffsetDateTime</td><td>No</td><td>The earliest time from which to include metrics. This must be at least two and
     * a half hours before the current time. If not specified this defaults to the
     * start time of the last aggregation interval currently available.</td></tr>
     *     <tr><td>endtime</td><td>OffsetDateTime</td><td>No</td><td>The latest time from which to include metrics. This must be at least two hours
     * before the current time. If not specified this defaults to the end time of the
     * last aggregation interval currently available.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     poolId: String (Required)
     *     startTime: OffsetDateTime (Required)
     *     endTime: OffsetDateTime (Required)
     *     vmSize: String (Required)
     *     totalCoreHours: double (Required)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of a listing the usage metrics for an Account along with {@link PagedResponse} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listUsageMetricsSinglePageAsync(RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listUsageMetrics(
                                        this.client.getEndpoint(),
                                        this.client.getServiceVersion().getVersion(),
                                        accept,
                                        requestOptions,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "odata.nextLink"),
                                        null));
    }

    /**
     * Lists the usage metrics, aggregated by Pool across individual time intervals, for the specified Account.
     *
     * <p>If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the
     * Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including
     * a startTime or endTime these filters default to the start and end times of the last aggregation interval
     * currently available; that is, only the last aggregation interval is returned.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>starttime</td><td>OffsetDateTime</td><td>No</td><td>The earliest time from which to include metrics. This must be at least two and
     * a half hours before the current time. If not specified this defaults to the
     * start time of the last aggregation interval currently available.</td></tr>
     *     <tr><td>endtime</td><td>OffsetDateTime</td><td>No</td><td>The latest time from which to include metrics. This must be at least two hours
     * before the current time. If not specified this defaults to the end time of the
     * last aggregation interval currently available.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     poolId: String (Required)
     *     startTime: OffsetDateTime (Required)
     *     endTime: OffsetDateTime (Required)
     *     vmSize: String (Required)
     *     totalCoreHours: double (Required)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of a listing the usage metrics for an Account as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listUsageMetricsAsync(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedFlux<>(
                () -> listUsageMetricsSinglePageAsync(requestOptions),
                nextLink -> listUsageMetricsNextSinglePageAsync(nextLink, requestOptionsForNextPage));
    }

    /**
     * Lists the usage metrics, aggregated by Pool across individual time intervals, for the specified Account.
     *
     * <p>If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the
     * Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including
     * a startTime or endTime these filters default to the start and end times of the last aggregation interval
     * currently available; that is, only the last aggregation interval is returned.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>starttime</td><td>OffsetDateTime</td><td>No</td><td>The earliest time from which to include metrics. This must be at least two and
     * a half hours before the current time. If not specified this defaults to the
     * start time of the last aggregation interval currently available.</td></tr>
     *     <tr><td>endtime</td><td>OffsetDateTime</td><td>No</td><td>The latest time from which to include metrics. This must be at least two hours
     * before the current time. If not specified this defaults to the end time of the
     * last aggregation interval currently available.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     poolId: String (Required)
     *     startTime: OffsetDateTime (Required)
     *     endTime: OffsetDateTime (Required)
     *     vmSize: String (Required)
     *     totalCoreHours: double (Required)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of a listing the usage metrics for an Account along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listUsageMetricsSinglePage(RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res =
                service.listUsageMetricsSync(
                        this.client.getEndpoint(),
                        this.client.getServiceVersion().getVersion(),
                        accept,
                        requestOptions,
                        Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                getValues(res.getValue(), "value"),
                getNextLink(res.getValue(), "odata.nextLink"),
                null);
    }

    /**
     * Lists the usage metrics, aggregated by Pool across individual time intervals, for the specified Account.
     *
     * <p>If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the
     * Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including
     * a startTime or endTime these filters default to the start and end times of the last aggregation interval
     * currently available; that is, only the last aggregation interval is returned.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>starttime</td><td>OffsetDateTime</td><td>No</td><td>The earliest time from which to include metrics. This must be at least two and
     * a half hours before the current time. If not specified this defaults to the
     * start time of the last aggregation interval currently available.</td></tr>
     *     <tr><td>endtime</td><td>OffsetDateTime</td><td>No</td><td>The latest time from which to include metrics. This must be at least two hours
     * before the current time. If not specified this defaults to the end time of the
     * last aggregation interval currently available.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     poolId: String (Required)
     *     startTime: OffsetDateTime (Required)
     *     endTime: OffsetDateTime (Required)
     *     vmSize: String (Required)
     *     totalCoreHours: double (Required)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of a listing the usage metrics for an Account as paginated response with {@link
     *     PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listUsageMetrics(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedIterable<>(
                () -> listUsageMetricsSinglePage(requestOptions),
                nextLink -> listUsageMetricsNextSinglePage(nextLink, requestOptionsForNextPage));
    }

    /**
     * Creates a Pool to the specified Account.
     *
     * <p>When naming Pools, avoid including sensitive information such as user names or secret project names. This
     * information may appear in telemetry logs accessible to Microsoft Support engineers.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Optional)
     *     vmSize: String (Required)
     *     cloudServiceConfiguration (Optional): {
     *         osFamily: String (Required)
     *         osVersion: String (Optional)
     *     }
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     applicationLicenses (Optional): [
     *         String (Optional)
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param parameters The Pool to be created.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> createWithResponseAsync(BinaryData parameters, RequestOptions requestOptions) {
        final String contentType = "application/json; odata=minimalmetadata";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.create(
                                this.client.getEndpoint(),
                                this.client.getServiceVersion().getVersion(),
                                contentType,
                                accept,
                                parameters,
                                requestOptions,
                                context));
    }

    /**
     * Creates a Pool to the specified Account.
     *
     * <p>When naming Pools, avoid including sensitive information such as user names or secret project names. This
     * information may appear in telemetry logs accessible to Microsoft Support engineers.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Required)
     *     displayName: String (Optional)
     *     vmSize: String (Required)
     *     cloudServiceConfiguration (Optional): {
     *         osFamily: String (Required)
     *         osVersion: String (Optional)
     *     }
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     applicationLicenses (Optional): [
     *         String (Optional)
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param parameters The Pool to be created.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> createWithResponse(BinaryData parameters, RequestOptions requestOptions) {
        final String contentType = "application/json; odata=minimalmetadata";
        final String accept = "application/json";
        return service.createSync(
                this.client.getEndpoint(),
                this.client.getServiceVersion().getVersion(),
                contentType,
                accept,
                parameters,
                requestOptions,
                Context.NONE);
    }

    /**
     * Lists all of the Pools in the specified Account.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     allocationState: String(steady/resizing/stopping) (Optional)
     *     allocationStateTransitionTime: OffsetDateTime (Optional)
     *     vmSize: String (Optional)
     *     cloudServiceConfiguration (Optional): {
     *         osFamily: String (Required)
     *         osVersion: String (Optional)
     *     }
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     resizeErrors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     *     currentDedicatedNodes: Integer (Optional)
     *     currentLowPriorityNodes: Integer (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     autoScaleRun (Optional): {
     *         timestamp: OffsetDateTime (Required)
     *         results: String (Optional)
     *         error (Optional): {
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     applicationLicenses (Optional): [
     *         String (Optional)
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         usageStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             dedicatedCoreTime: Duration (Required)
     *         }
     *         resourceStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             avgCPUPercentage: double (Required)
     *             avgMemoryGiB: double (Required)
     *             peakMemoryGiB: double (Required)
     *             avgDiskGiB: double (Required)
     *             peakDiskGiB: double (Required)
     *             diskReadIOps: int (Required)
     *             diskWriteIOps: int (Required)
     *             diskReadGiB: double (Required)
     *             diskWriteGiB: double (Required)
     *             networkReadGiB: double (Required)
     *             networkWriteGiB: double (Required)
     *         }
     *     }
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     identity (Optional): {
     *         type: String(UserAssigned/None) (Required)
     *         userAssignedIdentities (Optional): [
     *              (Optional){
     *                 resourceId: String (Required)
     *                 clientId: String (Optional)
     *                 principalId: String (Optional)
     *             }
     *         ]
     *     }
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     currentNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Pools in an Account along with {@link PagedResponse} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listSinglePageAsync(RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.list(
                                        this.client.getEndpoint(),
                                        this.client.getServiceVersion().getVersion(),
                                        accept,
                                        requestOptions,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "odata.nextLink"),
                                        null));
    }

    /**
     * Lists all of the Pools in the specified Account.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     allocationState: String(steady/resizing/stopping) (Optional)
     *     allocationStateTransitionTime: OffsetDateTime (Optional)
     *     vmSize: String (Optional)
     *     cloudServiceConfiguration (Optional): {
     *         osFamily: String (Required)
     *         osVersion: String (Optional)
     *     }
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     resizeErrors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     *     currentDedicatedNodes: Integer (Optional)
     *     currentLowPriorityNodes: Integer (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     autoScaleRun (Optional): {
     *         timestamp: OffsetDateTime (Required)
     *         results: String (Optional)
     *         error (Optional): {
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     applicationLicenses (Optional): [
     *         String (Optional)
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         usageStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             dedicatedCoreTime: Duration (Required)
     *         }
     *         resourceStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             avgCPUPercentage: double (Required)
     *             avgMemoryGiB: double (Required)
     *             peakMemoryGiB: double (Required)
     *             avgDiskGiB: double (Required)
     *             peakDiskGiB: double (Required)
     *             diskReadIOps: int (Required)
     *             diskWriteIOps: int (Required)
     *             diskReadGiB: double (Required)
     *             diskWriteGiB: double (Required)
     *             networkReadGiB: double (Required)
     *             networkWriteGiB: double (Required)
     *         }
     *     }
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     identity (Optional): {
     *         type: String(UserAssigned/None) (Required)
     *         userAssignedIdentities (Optional): [
     *              (Optional){
     *                 resourceId: String (Required)
     *                 clientId: String (Optional)
     *                 principalId: String (Optional)
     *             }
     *         ]
     *     }
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     currentNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Pools in an Account as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listAsync(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedFlux<>(
                () -> listSinglePageAsync(requestOptions),
                nextLink -> listNextSinglePageAsync(nextLink, requestOptionsForNextPage));
    }

    /**
     * Lists all of the Pools in the specified Account.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     allocationState: String(steady/resizing/stopping) (Optional)
     *     allocationStateTransitionTime: OffsetDateTime (Optional)
     *     vmSize: String (Optional)
     *     cloudServiceConfiguration (Optional): {
     *         osFamily: String (Required)
     *         osVersion: String (Optional)
     *     }
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     resizeErrors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     *     currentDedicatedNodes: Integer (Optional)
     *     currentLowPriorityNodes: Integer (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     autoScaleRun (Optional): {
     *         timestamp: OffsetDateTime (Required)
     *         results: String (Optional)
     *         error (Optional): {
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     applicationLicenses (Optional): [
     *         String (Optional)
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         usageStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             dedicatedCoreTime: Duration (Required)
     *         }
     *         resourceStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             avgCPUPercentage: double (Required)
     *             avgMemoryGiB: double (Required)
     *             peakMemoryGiB: double (Required)
     *             avgDiskGiB: double (Required)
     *             peakDiskGiB: double (Required)
     *             diskReadIOps: int (Required)
     *             diskWriteIOps: int (Required)
     *             diskReadGiB: double (Required)
     *             diskWriteGiB: double (Required)
     *             networkReadGiB: double (Required)
     *             networkWriteGiB: double (Required)
     *         }
     *     }
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     identity (Optional): {
     *         type: String(UserAssigned/None) (Required)
     *         userAssignedIdentities (Optional): [
     *              (Optional){
     *                 resourceId: String (Required)
     *                 clientId: String (Optional)
     *                 principalId: String (Optional)
     *             }
     *         ]
     *     }
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     currentNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Pools in an Account along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listSinglePage(RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res =
                service.listSync(
                        this.client.getEndpoint(),
                        this.client.getServiceVersion().getVersion(),
                        accept,
                        requestOptions,
                        Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                getValues(res.getValue(), "value"),
                getNextLink(res.getValue(), "odata.nextLink"),
                null);
    }

    /**
     * Lists all of the Pools in the specified Account.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     allocationState: String(steady/resizing/stopping) (Optional)
     *     allocationStateTransitionTime: OffsetDateTime (Optional)
     *     vmSize: String (Optional)
     *     cloudServiceConfiguration (Optional): {
     *         osFamily: String (Required)
     *         osVersion: String (Optional)
     *     }
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     resizeErrors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     *     currentDedicatedNodes: Integer (Optional)
     *     currentLowPriorityNodes: Integer (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     autoScaleRun (Optional): {
     *         timestamp: OffsetDateTime (Required)
     *         results: String (Optional)
     *         error (Optional): {
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     applicationLicenses (Optional): [
     *         String (Optional)
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         usageStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             dedicatedCoreTime: Duration (Required)
     *         }
     *         resourceStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             avgCPUPercentage: double (Required)
     *             avgMemoryGiB: double (Required)
     *             peakMemoryGiB: double (Required)
     *             avgDiskGiB: double (Required)
     *             peakDiskGiB: double (Required)
     *             diskReadIOps: int (Required)
     *             diskWriteIOps: int (Required)
     *             diskReadGiB: double (Required)
     *             diskWriteGiB: double (Required)
     *             networkReadGiB: double (Required)
     *             networkWriteGiB: double (Required)
     *         }
     *     }
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     identity (Optional): {
     *         type: String(UserAssigned/None) (Required)
     *         userAssignedIdentities (Optional): [
     *              (Optional){
     *                 resourceId: String (Required)
     *                 clientId: String (Optional)
     *                 principalId: String (Optional)
     *             }
     *         ]
     *     }
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     currentNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Pools in an Account as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> list(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedIterable<>(
                () -> listSinglePage(requestOptions),
                nextLink -> listNextSinglePage(nextLink, requestOptionsForNextPage));
    }

    /**
     * Deletes a Pool from the specified Account.
     *
     * <p>When you request that a Pool be deleted, the following actions occur: the Pool state is set to deleting; any
     * ongoing resize operation on the Pool are stopped; the Batch service starts resizing the Pool to zero Compute
     * Nodes; any Tasks running on existing Compute Nodes are terminated and requeued (as if a resize Pool operation had
     * been requested with the default requeue option); finally, the Pool is removed from the system. Because running
     * Tasks are requeued, the user can rerun these Tasks by updating their Job to target a different Pool. The Tasks
     * can then run on the new Pool. If you want to override the requeue behavior, then you should call resize Pool
     * explicitly to shrink the Pool to zero size before deleting the Pool. If you call an Update, Patch or Delete API
     * on a Pool in the deleting state, it will fail with HTTP status code 409 with error code PoolBeingDeleted.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteWithResponseAsync(String poolId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.delete(
                                this.client.getEndpoint(),
                                this.client.getServiceVersion().getVersion(),
                                poolId,
                                accept,
                                requestOptions,
                                context));
    }

    /**
     * Deletes a Pool from the specified Account.
     *
     * <p>When you request that a Pool be deleted, the following actions occur: the Pool state is set to deleting; any
     * ongoing resize operation on the Pool are stopped; the Batch service starts resizing the Pool to zero Compute
     * Nodes; any Tasks running on existing Compute Nodes are terminated and requeued (as if a resize Pool operation had
     * been requested with the default requeue option); finally, the Pool is removed from the system. Because running
     * Tasks are requeued, the user can rerun these Tasks by updating their Job to target a different Pool. The Tasks
     * can then run on the new Pool. If you want to override the requeue behavior, then you should call resize Pool
     * explicitly to shrink the Pool to zero size before deleting the Pool. If you call an Update, Patch or Delete API
     * on a Pool in the deleting state, it will fail with HTTP status code 409 with error code PoolBeingDeleted.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteWithResponse(String poolId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.deleteSync(
                this.client.getEndpoint(),
                this.client.getServiceVersion().getVersion(),
                poolId,
                accept,
                requestOptions,
                Context.NONE);
    }

    /**
     * Gets basic properties of a Pool.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * boolean
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return basic properties of a Pool along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Boolean>> existsWithResponseAsync(String poolId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.exists(
                                this.client.getEndpoint(),
                                this.client.getServiceVersion().getVersion(),
                                poolId,
                                accept,
                                requestOptions,
                                context));
    }

    /**
     * Gets basic properties of a Pool.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * boolean
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return basic properties of a Pool along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Boolean> existsWithResponse(String poolId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.existsSync(
                this.client.getEndpoint(),
                this.client.getServiceVersion().getVersion(),
                poolId,
                accept,
                requestOptions,
                Context.NONE);
    }

    /**
     * Gets information about the specified Pool.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     allocationState: String(steady/resizing/stopping) (Optional)
     *     allocationStateTransitionTime: OffsetDateTime (Optional)
     *     vmSize: String (Optional)
     *     cloudServiceConfiguration (Optional): {
     *         osFamily: String (Required)
     *         osVersion: String (Optional)
     *     }
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     resizeErrors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     *     currentDedicatedNodes: Integer (Optional)
     *     currentLowPriorityNodes: Integer (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     autoScaleRun (Optional): {
     *         timestamp: OffsetDateTime (Required)
     *         results: String (Optional)
     *         error (Optional): {
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     applicationLicenses (Optional): [
     *         String (Optional)
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         usageStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             dedicatedCoreTime: Duration (Required)
     *         }
     *         resourceStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             avgCPUPercentage: double (Required)
     *             avgMemoryGiB: double (Required)
     *             peakMemoryGiB: double (Required)
     *             avgDiskGiB: double (Required)
     *             peakDiskGiB: double (Required)
     *             diskReadIOps: int (Required)
     *             diskWriteIOps: int (Required)
     *             diskReadGiB: double (Required)
     *             diskWriteGiB: double (Required)
     *             networkReadGiB: double (Required)
     *             networkWriteGiB: double (Required)
     *         }
     *     }
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     identity (Optional): {
     *         type: String(UserAssigned/None) (Required)
     *         userAssignedIdentities (Optional): [
     *              (Optional){
     *                 resourceId: String (Required)
     *                 clientId: String (Optional)
     *                 principalId: String (Optional)
     *             }
     *         ]
     *     }
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     currentNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about the specified Pool along with {@link Response} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getWithResponseAsync(String poolId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.get(
                                this.client.getEndpoint(),
                                this.client.getServiceVersion().getVersion(),
                                poolId,
                                accept,
                                requestOptions,
                                context));
    }

    /**
     * Gets information about the specified Pool.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     allocationState: String(steady/resizing/stopping) (Optional)
     *     allocationStateTransitionTime: OffsetDateTime (Optional)
     *     vmSize: String (Optional)
     *     cloudServiceConfiguration (Optional): {
     *         osFamily: String (Required)
     *         osVersion: String (Optional)
     *     }
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     resizeErrors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     *     currentDedicatedNodes: Integer (Optional)
     *     currentLowPriorityNodes: Integer (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     autoScaleRun (Optional): {
     *         timestamp: OffsetDateTime (Required)
     *         results: String (Optional)
     *         error (Optional): {
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     applicationLicenses (Optional): [
     *         String (Optional)
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         usageStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             dedicatedCoreTime: Duration (Required)
     *         }
     *         resourceStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             avgCPUPercentage: double (Required)
     *             avgMemoryGiB: double (Required)
     *             peakMemoryGiB: double (Required)
     *             avgDiskGiB: double (Required)
     *             peakDiskGiB: double (Required)
     *             diskReadIOps: int (Required)
     *             diskWriteIOps: int (Required)
     *             diskReadGiB: double (Required)
     *             diskWriteGiB: double (Required)
     *             networkReadGiB: double (Required)
     *             networkWriteGiB: double (Required)
     *         }
     *     }
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     identity (Optional): {
     *         type: String(UserAssigned/None) (Required)
     *         userAssignedIdentities (Optional): [
     *              (Optional){
     *                 resourceId: String (Required)
     *                 clientId: String (Optional)
     *                 principalId: String (Optional)
     *             }
     *         ]
     *     }
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     currentNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about the specified Pool along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getWithResponse(String poolId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getSync(
                this.client.getEndpoint(),
                this.client.getServiceVersion().getVersion(),
                poolId,
                accept,
                requestOptions,
                Context.NONE);
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * <p>This only replaces the Pool properties specified in the request. For example, if the Pool has a StartTask
     * associated with it, and a request does not specify a StartTask element, then the Pool keeps the existing
     * StartTask.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> patchWithResponseAsync(
            String poolId, BinaryData parameters, RequestOptions requestOptions) {
        final String contentType = "application/json; odata=minimalmetadata";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.patch(
                                this.client.getEndpoint(),
                                this.client.getServiceVersion().getVersion(),
                                poolId,
                                contentType,
                                accept,
                                parameters,
                                requestOptions,
                                context));
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * <p>This only replaces the Pool properties specified in the request. For example, if the Pool has a StartTask
     * associated with it, and a request does not specify a StartTask element, then the Pool keeps the existing
     * StartTask.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> patchWithResponse(String poolId, BinaryData parameters, RequestOptions requestOptions) {
        final String contentType = "application/json; odata=minimalmetadata";
        final String accept = "application/json";
        return service.patchSync(
                this.client.getEndpoint(),
                this.client.getServiceVersion().getVersion(),
                poolId,
                contentType,
                accept,
                parameters,
                requestOptions,
                Context.NONE);
    }

    /**
     * Disables automatic scaling for a Pool.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param poolId The ID of the Pool on which to disable automatic scaling.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> disableAutoScaleWithResponseAsync(String poolId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.disableAutoScale(
                                this.client.getEndpoint(),
                                this.client.getServiceVersion().getVersion(),
                                poolId,
                                accept,
                                requestOptions,
                                context));
    }

    /**
     * Disables automatic scaling for a Pool.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param poolId The ID of the Pool on which to disable automatic scaling.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> disableAutoScaleWithResponse(String poolId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.disableAutoScaleSync(
                this.client.getEndpoint(),
                this.client.getServiceVersion().getVersion(),
                poolId,
                accept,
                requestOptions,
                Context.NONE);
    }

    /**
     * Enables automatic scaling for a Pool.
     *
     * <p>You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If automatic
     * scaling of the Pool is currently disabled, you must specify a valid autoscale formula as part of the request. If
     * automatic scaling of the Pool is already enabled, you may specify a new autoscale formula and/or a new evaluation
     * interval. You cannot call this API for the same Pool more than once every 30 seconds.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> enableAutoScaleWithResponseAsync(
            String poolId, BinaryData parameters, RequestOptions requestOptions) {
        final String contentType = "application/json; odata=minimalmetadata";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.enableAutoScale(
                                this.client.getEndpoint(),
                                this.client.getServiceVersion().getVersion(),
                                poolId,
                                contentType,
                                accept,
                                parameters,
                                requestOptions,
                                context));
    }

    /**
     * Enables automatic scaling for a Pool.
     *
     * <p>You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If automatic
     * scaling of the Pool is currently disabled, you must specify a valid autoscale formula as part of the request. If
     * automatic scaling of the Pool is already enabled, you may specify a new autoscale formula and/or a new evaluation
     * interval. You cannot call this API for the same Pool more than once every 30 seconds.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> enableAutoScaleWithResponse(
            String poolId, BinaryData parameters, RequestOptions requestOptions) {
        final String contentType = "application/json; odata=minimalmetadata";
        final String accept = "application/json";
        return service.enableAutoScaleSync(
                this.client.getEndpoint(),
                this.client.getServiceVersion().getVersion(),
                poolId,
                contentType,
                accept,
                parameters,
                requestOptions,
                Context.NONE);
    }

    /**
     * Gets the result of evaluating an automatic scaling formula on the Pool.
     *
     * <p>This API is primarily for validating an autoscale formula, as it simply returns the result without applying
     * the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a formula.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     autoScaleFormula: String (Required)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     timestamp: OffsetDateTime (Required)
     *     results: String (Optional)
     *     error (Optional): {
     *         code: String (Optional)
     *         message: String (Optional)
     *         values (Optional): [
     *              (Optional){
     *                 name: String (Optional)
     *                 value: String (Optional)
     *             }
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool on which to evaluate the automatic scaling formula.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the results and errors from an execution of a Pool autoscale formula along with {@link Response} on
     *     successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> evaluateAutoScaleWithResponseAsync(
            String poolId, BinaryData parameters, RequestOptions requestOptions) {
        final String contentType = "application/json; odata=minimalmetadata";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.evaluateAutoScale(
                                this.client.getEndpoint(),
                                this.client.getServiceVersion().getVersion(),
                                contentType,
                                poolId,
                                accept,
                                parameters,
                                requestOptions,
                                context));
    }

    /**
     * Gets the result of evaluating an automatic scaling formula on the Pool.
     *
     * <p>This API is primarily for validating an autoscale formula, as it simply returns the result without applying
     * the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a formula.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     autoScaleFormula: String (Required)
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     timestamp: OffsetDateTime (Required)
     *     results: String (Optional)
     *     error (Optional): {
     *         code: String (Optional)
     *         message: String (Optional)
     *         values (Optional): [
     *              (Optional){
     *                 name: String (Optional)
     *                 value: String (Optional)
     *             }
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool on which to evaluate the automatic scaling formula.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the results and errors from an execution of a Pool autoscale formula along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> evaluateAutoScaleWithResponse(
            String poolId, BinaryData parameters, RequestOptions requestOptions) {
        final String contentType = "application/json; odata=minimalmetadata";
        final String accept = "application/json";
        return service.evaluateAutoScaleSync(
                this.client.getEndpoint(),
                this.client.getServiceVersion().getVersion(),
                contentType,
                poolId,
                accept,
                parameters,
                requestOptions,
                Context.NONE);
    }

    /**
     * Changes the number of Compute Nodes that are assigned to a Pool.
     *
     * <p>You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the request
     * fails with status code 409. When you resize a Pool, the Pool's allocation state changes from steady to resizing.
     * You cannot resize Pools which are configured for automatic scaling. If you try to do this, the Batch service
     * returns an error 409. If you resize a Pool downwards, the Batch service chooses which Compute Nodes to remove. To
     * remove specific Compute Nodes, use the Pool remove Compute Nodes API instead.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     resizeTimeout: Duration (Optional)
     *     nodeDeallocationOption: String(requeue/terminate/taskcompletion/retaineddata) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> resizeWithResponseAsync(
            String poolId, BinaryData parameters, RequestOptions requestOptions) {
        final String contentType = "application/json; odata=minimalmetadata";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.resize(
                                this.client.getEndpoint(),
                                this.client.getServiceVersion().getVersion(),
                                poolId,
                                contentType,
                                accept,
                                parameters,
                                requestOptions,
                                context));
    }

    /**
     * Changes the number of Compute Nodes that are assigned to a Pool.
     *
     * <p>You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the request
     * fails with status code 409. When you resize a Pool, the Pool's allocation state changes from steady to resizing.
     * You cannot resize Pools which are configured for automatic scaling. If you try to do this, the Batch service
     * returns an error 409. If you resize a Pool downwards, the Batch service chooses which Compute Nodes to remove. To
     * remove specific Compute Nodes, use the Pool remove Compute Nodes API instead.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     resizeTimeout: Duration (Optional)
     *     nodeDeallocationOption: String(requeue/terminate/taskcompletion/retaineddata) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> resizeWithResponse(String poolId, BinaryData parameters, RequestOptions requestOptions) {
        final String contentType = "application/json; odata=minimalmetadata";
        final String accept = "application/json";
        return service.resizeSync(
                this.client.getEndpoint(),
                this.client.getServiceVersion().getVersion(),
                poolId,
                contentType,
                accept,
                parameters,
                requestOptions,
                Context.NONE);
    }

    /**
     * Stops an ongoing resize operation on the Pool.
     *
     * <p>This does not restore the Pool to its previous state before the resize operation: it only stops any further
     * changes being made, and the Pool maintains its current state. After stopping, the Pool stabilizes at the number
     * of Compute Nodes it was at when the stop operation was done. During the stop operation, the Pool allocation state
     * changes first to stopping and then to steady. A resize operation need not be an explicit resize Pool request;
     * this API can also be used to halt the initial sizing of the Pool when it is created.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> stopResizeWithResponseAsync(String poolId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.stopResize(
                                this.client.getEndpoint(),
                                this.client.getServiceVersion().getVersion(),
                                poolId,
                                accept,
                                requestOptions,
                                context));
    }

    /**
     * Stops an ongoing resize operation on the Pool.
     *
     * <p>This does not restore the Pool to its previous state before the resize operation: it only stops any further
     * changes being made, and the Pool maintains its current state. After stopping, the Pool stabilizes at the number
     * of Compute Nodes it was at when the stop operation was done. During the stop operation, the Pool allocation state
     * changes first to stopping and then to steady. A resize operation need not be an explicit resize Pool request;
     * this API can also be used to halt the initial sizing of the Pool when it is created.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param poolId The ID of the Pool to get.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> stopResizeWithResponse(String poolId, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.stopResizeSync(
                this.client.getEndpoint(),
                this.client.getServiceVersion().getVersion(),
                poolId,
                accept,
                requestOptions,
                Context.NONE);
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * <p>This fully replaces all the updatable properties of the Pool. For example, if the Pool has a StartTask
     * associated with it and if StartTask is not specified with this request, then the Batch service will remove the
     * existing StartTask.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Required): [
     *          (Required){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Required): [
     *          (Required){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     metadata (Required): [
     *          (Required){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to update.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updatePropertiesWithResponseAsync(
            String poolId, BinaryData parameters, RequestOptions requestOptions) {
        final String contentType = "application/json; odata=minimalmetadata";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.updateProperties(
                                this.client.getEndpoint(),
                                this.client.getServiceVersion().getVersion(),
                                contentType,
                                poolId,
                                accept,
                                parameters,
                                requestOptions,
                                context));
    }

    /**
     * Updates the properties of the specified Pool.
     *
     * <p>This fully replaces all the updatable properties of the Pool. For example, if the Pool has a StartTask
     * associated with it and if StartTask is not specified with this request, then the Batch service will remove the
     * existing StartTask.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Required): [
     *          (Required){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Required): [
     *          (Required){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     metadata (Required): [
     *          (Required){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to update.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updatePropertiesWithResponse(
            String poolId, BinaryData parameters, RequestOptions requestOptions) {
        final String contentType = "application/json; odata=minimalmetadata";
        final String accept = "application/json";
        return service.updatePropertiesSync(
                this.client.getEndpoint(),
                this.client.getServiceVersion().getVersion(),
                contentType,
                poolId,
                accept,
                parameters,
                requestOptions,
                Context.NONE);
    }

    /**
     * Removes Compute Nodes from the specified Pool.
     *
     * <p>This operation can only run when the allocation state of the Pool is steady. When this operation runs, the
     * allocation state changes from steady to resizing. Each request may remove up to 100 nodes.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nodeList (Required): [
     *         String (Required)
     *     ]
     *     resizeTimeout: Duration (Optional)
     *     nodeDeallocationOption: String(requeue/terminate/taskcompletion/retaineddata) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> removeNodesWithResponseAsync(
            String poolId, BinaryData parameters, RequestOptions requestOptions) {
        final String contentType = "application/json; odata=minimalmetadata";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.removeNodes(
                                this.client.getEndpoint(),
                                this.client.getServiceVersion().getVersion(),
                                poolId,
                                contentType,
                                accept,
                                parameters,
                                requestOptions,
                                context));
    }

    /**
     * Removes Compute Nodes from the specified Pool.
     *
     * <p>This operation can only run when the allocation state of the Pool is steady. When this operation runs, the
     * allocation state changes from steady to resizing. Each request may remove up to 100 nodes.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>OffsetDateTime</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     nodeList (Required): [
     *         String (Required)
     *     ]
     *     resizeTimeout: Duration (Optional)
     *     nodeDeallocationOption: String(requeue/terminate/taskcompletion/retaineddata) (Optional)
     * }
     * }</pre>
     *
     * @param poolId The ID of the Pool to get.
     * @param parameters The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> removeNodesWithResponse(String poolId, BinaryData parameters, RequestOptions requestOptions) {
        final String contentType = "application/json; odata=minimalmetadata";
        final String accept = "application/json";
        return service.removeNodesSync(
                this.client.getEndpoint(),
                this.client.getServiceVersion().getVersion(),
                poolId,
                contentType,
                accept,
                parameters,
                requestOptions,
                Context.NONE);
    }

    /**
     * Lists the usage metrics, aggregated by Pool across individual time intervals, for the specified Account.
     *
     * <p>Get the next page of items.
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     poolId: String (Required)
     *     startTime: OffsetDateTime (Required)
     *     endTime: OffsetDateTime (Required)
     *     vmSize: String (Required)
     *     totalCoreHours: double (Required)
     * }
     * }</pre>
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of a listing the usage metrics for an Account along with {@link PagedResponse} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listUsageMetricsNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listUsageMetricsNext(
                                        nextLink, this.client.getEndpoint(), accept, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "odata.nextLink"),
                                        null));
    }

    /**
     * Lists the usage metrics, aggregated by Pool across individual time intervals, for the specified Account.
     *
     * <p>Get the next page of items.
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     poolId: String (Required)
     *     startTime: OffsetDateTime (Required)
     *     endTime: OffsetDateTime (Required)
     *     vmSize: String (Required)
     *     totalCoreHours: double (Required)
     * }
     * }</pre>
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of a listing the usage metrics for an Account along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listUsageMetricsNextSinglePage(String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res =
                service.listUsageMetricsNextSync(
                        nextLink, this.client.getEndpoint(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                getValues(res.getValue(), "value"),
                getNextLink(res.getValue(), "odata.nextLink"),
                null);
    }

    /**
     * Lists all of the Pools in the specified Account.
     *
     * <p>Get the next page of items.
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     allocationState: String(steady/resizing/stopping) (Optional)
     *     allocationStateTransitionTime: OffsetDateTime (Optional)
     *     vmSize: String (Optional)
     *     cloudServiceConfiguration (Optional): {
     *         osFamily: String (Required)
     *         osVersion: String (Optional)
     *     }
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     resizeErrors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     *     currentDedicatedNodes: Integer (Optional)
     *     currentLowPriorityNodes: Integer (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     autoScaleRun (Optional): {
     *         timestamp: OffsetDateTime (Required)
     *         results: String (Optional)
     *         error (Optional): {
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     applicationLicenses (Optional): [
     *         String (Optional)
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         usageStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             dedicatedCoreTime: Duration (Required)
     *         }
     *         resourceStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             avgCPUPercentage: double (Required)
     *             avgMemoryGiB: double (Required)
     *             peakMemoryGiB: double (Required)
     *             avgDiskGiB: double (Required)
     *             peakDiskGiB: double (Required)
     *             diskReadIOps: int (Required)
     *             diskWriteIOps: int (Required)
     *             diskReadGiB: double (Required)
     *             diskWriteGiB: double (Required)
     *             networkReadGiB: double (Required)
     *             networkWriteGiB: double (Required)
     *         }
     *     }
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     identity (Optional): {
     *         type: String(UserAssigned/None) (Required)
     *         userAssignedIdentities (Optional): [
     *              (Optional){
     *                 resourceId: String (Required)
     *                 clientId: String (Optional)
     *                 principalId: String (Optional)
     *             }
     *         ]
     *     }
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     currentNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Pools in an Account along with {@link PagedResponse} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listNextSinglePageAsync(String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listNext(nextLink, this.client.getEndpoint(), accept, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "odata.nextLink"),
                                        null));
    }

    /**
     * Lists all of the Pools in the specified Account.
     *
     * <p>Get the next page of items.
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>OffsetDateTime</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     allocationState: String(steady/resizing/stopping) (Optional)
     *     allocationStateTransitionTime: OffsetDateTime (Optional)
     *     vmSize: String (Optional)
     *     cloudServiceConfiguration (Optional): {
     *         osFamily: String (Required)
     *         osVersion: String (Optional)
     *     }
     *     virtualMachineConfiguration (Optional): {
     *         imageReference (Required): {
     *             publisher: String (Optional)
     *             offer: String (Optional)
     *             sku: String (Optional)
     *             version: String (Optional)
     *             virtualMachineImageId: String (Optional)
     *             exactVersion: String (Optional)
     *         }
     *         nodeAgentSKUId: String (Required)
     *         windowsConfiguration (Optional): {
     *             enableAutomaticUpdates: Boolean (Optional)
     *         }
     *         dataDisks (Optional): [
     *              (Optional){
     *                 lun: int (Required)
     *                 caching: String(none/readonly/readwrite) (Optional)
     *                 diskSizeGB: int (Required)
     *                 storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *             }
     *         ]
     *         licenseType: String (Optional)
     *         containerConfiguration (Optional): {
     *             type: String(dockerCompatible/criCompatible) (Required)
     *             containerImageNames (Optional): [
     *                 String (Optional)
     *             ]
     *             containerRegistries (Optional): [
     *                  (Optional){
     *                     username: String (Optional)
     *                     password: String (Optional)
     *                     registryServer: String (Optional)
     *                     identityReference (Optional): {
     *                         resourceId: String (Optional)
     *                     }
     *                 }
     *             ]
     *         }
     *         diskEncryptionConfiguration (Optional): {
     *             targets (Optional): [
     *                 String(osdisk/temporarydisk) (Optional)
     *             ]
     *         }
     *         nodePlacementConfiguration (Optional): {
     *             policy: String(regional/zonal) (Optional)
     *         }
     *         extensions (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 publisher: String (Required)
     *                 type: String (Required)
     *                 typeHandlerVersion: String (Optional)
     *                 autoUpgradeMinorVersion: Boolean (Optional)
     *                 enableAutomaticUpgrade: Boolean (Optional)
     *                 settings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 protectedSettings (Optional): {
     *                     String: String (Optional)
     *                 }
     *                 provisionAfterExtensions (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *         ]
     *         osDisk (Optional): {
     *             ephemeralOSDiskSettings (Optional): {
     *                 placement: String(cachedisk) (Optional)
     *             }
     *         }
     *     }
     *     resizeTimeout: Duration (Optional)
     *     resizeErrors (Optional): [
     *          (Optional){
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *     ]
     *     currentDedicatedNodes: Integer (Optional)
     *     currentLowPriorityNodes: Integer (Optional)
     *     targetDedicatedNodes: Integer (Optional)
     *     targetLowPriorityNodes: Integer (Optional)
     *     enableAutoScale: Boolean (Optional)
     *     autoScaleFormula: String (Optional)
     *     autoScaleEvaluationInterval: Duration (Optional)
     *     autoScaleRun (Optional): {
     *         timestamp: OffsetDateTime (Required)
     *         results: String (Optional)
     *         error (Optional): {
     *             code: String (Optional)
     *             message: String (Optional)
     *             values (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     enableInterNodeCommunication: Boolean (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Optional)
     *         dynamicVNetAssignmentScope: String(none/job) (Optional)
     *         endpointConfiguration (Optional): {
     *             inboundNATPools (Required): [
     *                  (Required){
     *                     name: String (Required)
     *                     protocol: String(tcp/udp) (Required)
     *                     backendPort: int (Required)
     *                     frontendPortRangeStart: int (Required)
     *                     frontendPortRangeEnd: int (Required)
     *                     networkSecurityGroupRules (Optional): [
     *                          (Optional){
     *                             priority: int (Required)
     *                             access: String(allow/deny) (Required)
     *                             sourceAddressPrefix: String (Required)
     *                             sourcePortRanges (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *         publicIPAddressConfiguration (Optional): {
     *             provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *             ipAddressIds (Optional): [
     *                 String (Optional)
     *             ]
     *         }
     *         enableAcceleratedNetworking: Boolean (Optional)
     *     }
     *     startTask (Optional): {
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): (recursive schema, see registry above)
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         maxTaskRetryCount: Integer (Optional)
     *         waitForSuccess: Boolean (Optional)
     *     }
     *     certificateReferences (Optional): [
     *          (Optional){
     *             thumbprint: String (Required)
     *             thumbprintAlgorithm: String (Required)
     *             storeLocation: String(currentuser/localmachine) (Optional)
     *             storeName: String (Optional)
     *             visibility (Optional): [
     *                 String(starttask/task/remoteuser) (Optional)
     *             ]
     *         }
     *     ]
     *     applicationPackageReferences (Optional): [
     *          (Optional){
     *             applicationId: String (Required)
     *             version: String (Optional)
     *         }
     *     ]
     *     applicationLicenses (Optional): [
     *         String (Optional)
     *     ]
     *     taskSlotsPerNode: Integer (Optional)
     *     taskSchedulingPolicy (Optional): {
     *         nodeFillType: String(spread/pack) (Required)
     *     }
     *     userAccounts (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             password: String (Required)
     *             elevationLevel: String(nonadmin/admin) (Optional)
     *             linuxUserConfiguration (Optional): {
     *                 uid: Integer (Optional)
     *                 gid: Integer (Optional)
     *                 sshPrivateKey: String (Optional)
     *             }
     *             windowsUserConfiguration (Optional): {
     *                 loginMode: String(batch/interactive) (Optional)
     *             }
     *         }
     *     ]
     *     metadata (Optional): [
     *          (Optional){
     *             name: String (Required)
     *             value: String (Required)
     *         }
     *     ]
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         usageStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             dedicatedCoreTime: Duration (Required)
     *         }
     *         resourceStats (Optional): {
     *             startTime: OffsetDateTime (Required)
     *             lastUpdateTime: OffsetDateTime (Required)
     *             avgCPUPercentage: double (Required)
     *             avgMemoryGiB: double (Required)
     *             peakMemoryGiB: double (Required)
     *             avgDiskGiB: double (Required)
     *             peakDiskGiB: double (Required)
     *             diskReadIOps: int (Required)
     *             diskWriteIOps: int (Required)
     *             diskReadGiB: double (Required)
     *             diskWriteGiB: double (Required)
     *             networkReadGiB: double (Required)
     *             networkWriteGiB: double (Required)
     *         }
     *     }
     *     mountConfiguration (Optional): [
     *          (Optional){
     *             azureBlobFileSystemConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 containerName: String (Required)
     *                 accountKey: String (Optional)
     *                 sasKey: String (Optional)
     *                 blobfuseOptions: String (Optional)
     *                 relativeMountPath: String (Required)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *             nfsMountConfiguration (Optional): {
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *             cifsMountConfiguration (Optional): {
     *                 username: String (Required)
     *                 source: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *                 password: String (Required)
     *             }
     *             azureFileShareConfiguration (Optional): {
     *                 accountName: String (Required)
     *                 azureFileUrl: String (Required)
     *                 accountKey: String (Required)
     *                 relativeMountPath: String (Required)
     *                 mountOptions: String (Optional)
     *             }
     *         }
     *     ]
     *     identity (Optional): {
     *         type: String(UserAssigned/None) (Required)
     *         userAssignedIdentities (Optional): [
     *              (Optional){
     *                 resourceId: String (Required)
     *                 clientId: String (Optional)
     *                 principalId: String (Optional)
     *             }
     *         ]
     *     }
     *     targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *     currentNodeCommunicationMode: String(default/classic/simplified) (Optional)
     * }
     * }</pre>
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Pools in an Account along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listNextSinglePage(String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res =
                service.listNextSync(nextLink, this.client.getEndpoint(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                getValues(res.getValue(), "value"),
                getNextLink(res.getValue(), "odata.nextLink"),
                null);
    }

    private List<BinaryData> getValues(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            List<?> values = (List<?>) obj.get(path);
            return values.stream().map(BinaryData::fromObject).collect(Collectors.toList());
        } catch (RuntimeException e) {
            return null;
        }
    }

    private String getNextLink(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            return (String) obj.get(path);
        } catch (RuntimeException e) {
            return null;
        }
    }
}
