// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.
package com.azure.compute.batch;

import com.azure.compute.batch.models.BatchJob;
import com.azure.compute.batch.models.BatchJobDisableParameters;
import com.azure.compute.batch.models.BatchJobTerminateParameters;
import com.azure.compute.batch.models.JobPreparationAndReleaseTaskExecutionInformation;
import com.azure.compute.batch.models.JobStatistics;
import com.azure.compute.batch.models.TaskCountsResult;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;

/** Initializes a new instance of the synchronous BatchServiceClient type. */
@ServiceClient(builder = BatchServiceClientBuilder.class)
public final class JobClient {

    @Generated private final JobAsyncClient client;

    /**
     * Initializes an instance of JobClient class.
     *
     * @param client the async client.
     */
    @Generated
    JobClient(JobAsyncClient client) {
        this.client = client;
    }

    /**
     * Gets lifetime summary statistics for all of the Jobs in the specified Account.
     *
     * <p>Statistics are aggregated across all Jobs that have ever existed in the Account, from Account creation to the
     * last update time of the statistics. The statistics may not be immediately available. The Batch service performs
     * periodic roll-up of statistics. The typical delay is about 30 minutes.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>client-request-id</td><td>String</td><td>No</td><td>The caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</td></tr>
     *     <tr><td>return-client-request-id</td><td>Boolean</td><td>No</td><td>Whether the server should return the client-request-id in the response.</td></tr>
     *     <tr><td>ocp-date</td><td>String</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     url: String (Required)
     *     startTime: OffsetDateTime (Required)
     *     lastUpdateTime: OffsetDateTime (Required)
     *     userCPUTime: Duration (Required)
     *     kernelCPUTime: Duration (Required)
     *     wallClockTime: Duration (Required)
     *     readIOps: int (Required)
     *     writeIOps: int (Required)
     *     readIOGiB: double (Required)
     *     writeIOGiB: double (Required)
     *     numSucceededTasks: int (Required)
     *     numFailedTasks: int (Required)
     *     numTaskRetries: int (Required)
     *     waitTime: Duration (Required)
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return resource usage statistics for a Job along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getAllLifetimeStatisticsWithResponse(RequestOptions requestOptions) {
        return this.client.getAllLifetimeStatisticsWithResponse(requestOptions).block();
    }

    /**
     * Deletes a Job.
     *
     * <p>Deleting a Job also deletes all Tasks that are part of that Job, and all Job statistics. This also overrides
     * the retention period for Task data; that is, if the Job contains Tasks which are still retained on Compute Nodes,
     * the Batch services deletes those Tasks' working directories and all their contents. When a Delete Job request is
     * received, the Batch service sets the Job to the deleting state. All update operations on a Job that is in
     * deleting state will fail with status code 409 (Conflict), with additional information indicating that the Job is
     * being deleted.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>client-request-id</td><td>String</td><td>No</td><td>The caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</td></tr>
     *     <tr><td>return-client-request-id</td><td>Boolean</td><td>No</td><td>Whether the server should return the client-request-id in the response.</td></tr>
     *     <tr><td>ocp-date</td><td>String</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>String</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>String</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteWithResponse(String jobId, RequestOptions requestOptions) {
        return this.client.deleteWithResponse(jobId, requestOptions).block();
    }

    /**
     * Gets information about the specified Job.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>client-request-id</td><td>String</td><td>No</td><td>The caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</td></tr>
     *     <tr><td>return-client-request-id</td><td>Boolean</td><td>No</td><td>Whether the server should return the client-request-id in the response.</td></tr>
     *     <tr><td>ocp-date</td><td>String</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>String</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>String</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Optional): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 cloudServiceConfiguration (Optional): {
     *                     osFamily: String (Required)
     *                     osVersion: String (Optional)
     *                 }
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             settings: Object (Optional)
     *                             protectedSettings: Object (Optional)
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 certificateReferences (Optional): [
     *                      (Optional){
     *                         thumbprint: String (Required)
     *                         thumbprintAlgorithm: String (Required)
     *                         storeLocation: String(currentuser/localmachine) (Optional)
     *                         storeName: String (Optional)
     *                         visibility (Optional): [
     *                             String(starttask/task/remoteuser) (Optional)
     *                         ]
     *                     }
     *                 ]
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 applicationLicenses (Optional): [
     *                     String (Optional)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         poolId: String (Optional)
     *         schedulingError (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         terminateReason: String (Optional)
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: int (Required)
     *         numFailedTasks: int (Required)
     *         numTaskRetries: int (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return information about the specified Job along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getWithResponse(String jobId, RequestOptions requestOptions) {
        return this.client.getWithResponse(jobId, requestOptions).block();
    }

    /**
     * Updates the properties of the specified Job.
     *
     * <p>This replaces only the Job properties specified in the request. For example, if the Job has constraints, and a
     * request does not specify the constraints element, then the Job keeps the existing constraints.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>client-request-id</td><td>String</td><td>No</td><td>The caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</td></tr>
     *     <tr><td>return-client-request-id</td><td>Boolean</td><td>No</td><td>Whether the server should return the client-request-id in the response.</td></tr>
     *     <tr><td>ocp-date</td><td>String</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>String</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>String</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Optional): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 cloudServiceConfiguration (Optional): {
     *                     osFamily: String (Required)
     *                     osVersion: String (Optional)
     *                 }
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             settings: Object (Optional)
     *                             protectedSettings: Object (Optional)
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 certificateReferences (Optional): [
     *                      (Optional){
     *                         thumbprint: String (Required)
     *                         thumbprintAlgorithm: String (Required)
     *                         storeLocation: String(currentuser/localmachine) (Optional)
     *                         storeName: String (Optional)
     *                         visibility (Optional): [
     *                             String(starttask/task/remoteuser) (Optional)
     *                         ]
     *                     }
     *                 ]
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 applicationLicenses (Optional): [
     *                     String (Optional)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         poolId: String (Optional)
     *         schedulingError (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         terminateReason: String (Optional)
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: int (Required)
     *         numFailedTasks: int (Required)
     *         numTaskRetries: int (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param jobPatchParameter The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> patchWithResponse(String jobId, BinaryData jobPatchParameter, RequestOptions requestOptions) {
        return this.client.patchWithResponse(jobId, jobPatchParameter, requestOptions).block();
    }

    /**
     * Updates the properties of the specified Job.
     *
     * <p>This fully replaces all the updatable properties of the Job. For example, if the Job has constraints
     * associated with it and if constraints is not specified with this request, then the Batch service will remove the
     * existing constraints.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>client-request-id</td><td>String</td><td>No</td><td>The caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</td></tr>
     *     <tr><td>return-client-request-id</td><td>Boolean</td><td>No</td><td>Whether the server should return the client-request-id in the response.</td></tr>
     *     <tr><td>ocp-date</td><td>String</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>String</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>String</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Optional): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 cloudServiceConfiguration (Optional): {
     *                     osFamily: String (Required)
     *                     osVersion: String (Optional)
     *                 }
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             settings: Object (Optional)
     *                             protectedSettings: Object (Optional)
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 certificateReferences (Optional): [
     *                      (Optional){
     *                         thumbprint: String (Required)
     *                         thumbprintAlgorithm: String (Required)
     *                         storeLocation: String(currentuser/localmachine) (Optional)
     *                         storeName: String (Optional)
     *                         visibility (Optional): [
     *                             String(starttask/task/remoteuser) (Optional)
     *                         ]
     *                     }
     *                 ]
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 applicationLicenses (Optional): [
     *                     String (Optional)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         poolId: String (Optional)
     *         schedulingError (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         terminateReason: String (Optional)
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: int (Required)
     *         numFailedTasks: int (Required)
     *         numTaskRetries: int (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param jobUpdateParameter The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> updateWithResponse(
            String jobId, BinaryData jobUpdateParameter, RequestOptions requestOptions) {
        return this.client.updateWithResponse(jobId, jobUpdateParameter, requestOptions).block();
    }

    /**
     * Disables the specified Job, preventing new Tasks from running.
     *
     * <p>The Batch Service immediately moves the Job to the disabling state. Batch then uses the disableTasks parameter
     * to determine what to do with the currently running Tasks of the Job. The Job remains in the disabling state until
     * the disable operation is completed and all Tasks have been dealt with according to the disableTasks option; the
     * Job then moves to the disabled state. No new Tasks are started under the Job until it moves back to active state.
     * If you try to disable a Job that is in any state other than active, disabling, or disabled, the request fails
     * with status code 409.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>client-request-id</td><td>String</td><td>No</td><td>The caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</td></tr>
     *     <tr><td>return-client-request-id</td><td>Boolean</td><td>No</td><td>Whether the server should return the client-request-id in the response.</td></tr>
     *     <tr><td>ocp-date</td><td>String</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>String</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>String</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     disableTasks: String(requeue/terminate/wait) (Required)
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to disable.
     * @param jobDisableParameter The parameters for the request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> disableWithResponse(
            String jobId, BinaryData jobDisableParameter, RequestOptions requestOptions) {
        return this.client.disableWithResponse(jobId, jobDisableParameter, requestOptions).block();
    }

    /**
     * Enables the specified Job, allowing new Tasks to run.
     *
     * <p>When you call this API, the Batch service sets a disabled Job to the enabling state. After the this operation
     * is completed, the Job moves to the active state, and scheduling of new Tasks under the Job resumes. The Batch
     * service does not allow a Task to remain in the active state for more than 180 days. Therefore, if you enable a
     * Job containing active Tasks which were added more than 180 days ago, those Tasks will not run.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>client-request-id</td><td>String</td><td>No</td><td>The caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</td></tr>
     *     <tr><td>return-client-request-id</td><td>Boolean</td><td>No</td><td>Whether the server should return the client-request-id in the response.</td></tr>
     *     <tr><td>ocp-date</td><td>String</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>String</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>String</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * @param jobId The ID of the Job to enable.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> enableWithResponse(String jobId, RequestOptions requestOptions) {
        return this.client.enableWithResponse(jobId, requestOptions).block();
    }

    /**
     * Terminates the specified Job, marking it as completed.
     *
     * <p>When a Terminate Job request is received, the Batch service sets the Job to the terminating state. The Batch
     * service then terminates any running Tasks associated with the Job and runs any required Job release Tasks. Then
     * the Job moves into the completed state. If there are any Tasks in the Job in the active state, they will remain
     * in the active state. Once a Job is terminated, new Tasks cannot be added and any remaining active Tasks will not
     * be scheduled.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>client-request-id</td><td>String</td><td>No</td><td>The caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</td></tr>
     *     <tr><td>return-client-request-id</td><td>Boolean</td><td>No</td><td>Whether the server should return the client-request-id in the response.</td></tr>
     *     <tr><td>ocp-date</td><td>String</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>if-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service exactly matches the value specified by the client.</td></tr>
     *     <tr><td>if-none-match</td><td>String</td><td>No</td><td>An ETag value associated with the version of the resource known to the client.
     * The operation will be performed only if the resource's current ETag on the
     * service does not match the value specified by the client.</td></tr>
     *     <tr><td>if-modified-since</td><td>String</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * been modified since the specified time.</td></tr>
     *     <tr><td>if-unmodified-since</td><td>String</td><td>No</td><td>A timestamp indicating the last modified time of the resource known to the
     * client. The operation will be performed only if the resource on the service has
     * not been modified since the specified time.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     terminateReason: String (Optional)
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job to terminate.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> terminateWithResponse(String jobId, RequestOptions requestOptions) {
        return this.client.terminateWithResponse(jobId, requestOptions).block();
    }

    /**
     * Adds a Job to the specified Account.
     *
     * <p>The Batch service supports two ways to control the work done as part of a Job. In the first approach, the user
     * specifies a Job Manager Task. The Batch service launches this Task when it is ready to start the Job. The Job
     * Manager Task controls all other Tasks that run under this Job, by using the Task APIs. In the second approach,
     * the user directly controls the execution of Tasks under an active Job, by using the Task APIs. Also note: when
     * naming Jobs, avoid including sensitive information such as user names or secret project names. This information
     * may appear in telemetry logs accessible to Microsoft Support engineers.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>client-request-id</td><td>String</td><td>No</td><td>The caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</td></tr>
     *     <tr><td>return-client-request-id</td><td>Boolean</td><td>No</td><td>Whether the server should return the client-request-id in the response.</td></tr>
     *     <tr><td>ocp-date</td><td>String</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Optional): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 cloudServiceConfiguration (Optional): {
     *                     osFamily: String (Required)
     *                     osVersion: String (Optional)
     *                 }
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             settings: Object (Optional)
     *                             protectedSettings: Object (Optional)
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 certificateReferences (Optional): [
     *                      (Optional){
     *                         thumbprint: String (Required)
     *                         thumbprintAlgorithm: String (Required)
     *                         storeLocation: String(currentuser/localmachine) (Optional)
     *                         storeName: String (Optional)
     *                         visibility (Optional): [
     *                             String(starttask/task/remoteuser) (Optional)
     *                         ]
     *                     }
     *                 ]
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 applicationLicenses (Optional): [
     *                     String (Optional)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         poolId: String (Optional)
     *         schedulingError (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         terminateReason: String (Optional)
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: int (Required)
     *         numFailedTasks: int (Required)
     *         numTaskRetries: int (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param job The Job to be added.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> addWithResponse(BinaryData job, RequestOptions requestOptions) {
        return this.client.addWithResponse(job, requestOptions).block();
    }

    /**
     * Lists all of the Jobs in the specified Account.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>String</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>client-request-id</td><td>String</td><td>No</td><td>The caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</td></tr>
     *     <tr><td>return-client-request-id</td><td>Boolean</td><td>No</td><td>Whether the server should return the client-request-id in the response.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Optional): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 cloudServiceConfiguration (Optional): {
     *                     osFamily: String (Required)
     *                     osVersion: String (Optional)
     *                 }
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             settings: Object (Optional)
     *                             protectedSettings: Object (Optional)
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 certificateReferences (Optional): [
     *                      (Optional){
     *                         thumbprint: String (Required)
     *                         thumbprintAlgorithm: String (Required)
     *                         storeLocation: String(currentuser/localmachine) (Optional)
     *                         storeName: String (Optional)
     *                         visibility (Optional): [
     *                             String(starttask/task/remoteuser) (Optional)
     *                         ]
     *                     }
     *                 ]
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 applicationLicenses (Optional): [
     *                     String (Optional)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         poolId: String (Optional)
     *         schedulingError (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         terminateReason: String (Optional)
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: int (Required)
     *         numFailedTasks: int (Required)
     *         numTaskRetries: int (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> list(RequestOptions requestOptions) {
        return new PagedIterable<>(this.client.list(requestOptions));
    }

    /**
     * Lists the Jobs that have been created under the specified Job Schedule.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     *     <tr><td>$expand</td><td>String</td><td>No</td><td>An OData $expand clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>String</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>client-request-id</td><td>String</td><td>No</td><td>The caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</td></tr>
     *     <tr><td>return-client-request-id</td><td>Boolean</td><td>No</td><td>Whether the server should return the client-request-id in the response.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String (Optional)
     *     displayName: String (Optional)
     *     usesTaskDependencies: Boolean (Optional)
     *     url: String (Optional)
     *     eTag: String (Optional)
     *     lastModified: OffsetDateTime (Optional)
     *     creationTime: OffsetDateTime (Optional)
     *     state: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     stateTransitionTime: OffsetDateTime (Optional)
     *     previousState: String(active/disabling/disabled/enabling/terminating/completed/deleting) (Optional)
     *     previousStateTransitionTime: OffsetDateTime (Optional)
     *     priority: Integer (Optional)
     *     allowTaskPreemption: Boolean (Optional)
     *     maxParallelTasks: Integer (Optional)
     *     constraints (Optional): {
     *         maxWallClockTime: Duration (Optional)
     *         maxTaskRetryCount: Integer (Optional)
     *     }
     *     jobManagerTask (Optional): {
     *         id: String (Required)
     *         displayName: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): {
     *             containerRunOptions: String (Optional)
     *             imageName: String (Required)
     *             registry (Optional): {
     *                 username: String (Optional)
     *                 password: String (Optional)
     *                 registryServer: String (Optional)
     *                 identityReference (Optional): {
     *                     resourceId: String (Optional)
     *                 }
     *             }
     *             workingDirectory: String(taskWorkingDirectory/containerImageDefault) (Optional)
     *         }
     *         resourceFiles (Optional): [
     *              (Optional){
     *                 autoStorageContainerName: String (Optional)
     *                 storageContainerUrl: String (Optional)
     *                 httpUrl: String (Optional)
     *                 blobPrefix: String (Optional)
     *                 filePath: String (Optional)
     *                 fileMode: String (Optional)
     *                 identityReference (Optional): (recursive schema, see identityReference above)
     *             }
     *         ]
     *         outputFiles (Optional): [
     *              (Optional){
     *                 filePattern: String (Required)
     *                 destination (Required): {
     *                     container (Optional): {
     *                         path: String (Optional)
     *                         containerUrl: String (Required)
     *                         identityReference (Optional): (recursive schema, see identityReference above)
     *                         uploadHeaders (Optional): [
     *                              (Optional){
     *                                 name: String (Required)
     *                                 value: String (Optional)
     *                             }
     *                         ]
     *                     }
     *                 }
     *                 uploadOptions (Required): {
     *                     uploadCondition: String(tasksuccess/taskfailure/taskcompletion) (Required)
     *                 }
     *             }
     *         ]
     *         environmentSettings (Optional): [
     *              (Optional){
     *                 name: String (Required)
     *                 value: String (Optional)
     *             }
     *         ]
     *         constraints (Optional): {
     *             maxWallClockTime: Duration (Optional)
     *             retentionTime: Duration (Optional)
     *             maxTaskRetryCount: Integer (Optional)
     *         }
     *         requiredSlots: Integer (Optional)
     *         killJobOnCompletion: Boolean (Optional)
     *         userIdentity (Optional): {
     *             username: String (Optional)
     *             autoUser (Optional): {
     *                 scope: String(task/pool) (Optional)
     *                 elevationLevel: String(nonadmin/admin) (Optional)
     *             }
     *         }
     *         runExclusive: Boolean (Optional)
     *         applicationPackageReferences (Optional): [
     *              (Optional){
     *                 applicationId: String (Required)
     *                 version: String (Optional)
     *             }
     *         ]
     *         authenticationTokenSettings (Optional): {
     *             access (Optional): [
     *                 String(job) (Optional)
     *             ]
     *         }
     *         allowLowPriorityNode: Boolean (Optional)
     *     }
     *     jobPreparationTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         constraints (Optional): (recursive schema, see constraints above)
     *         waitForSuccess: Boolean (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *         rerunOnNodeRebootAfterSuccess: Boolean (Optional)
     *     }
     *     jobReleaseTask (Optional): {
     *         id: String (Optional)
     *         commandLine: String (Required)
     *         containerSettings (Optional): (recursive schema, see containerSettings above)
     *         resourceFiles (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         environmentSettings (Optional): [
     *             (recursive schema, see above)
     *         ]
     *         maxWallClockTime: Duration (Optional)
     *         retentionTime: Duration (Optional)
     *         userIdentity (Optional): (recursive schema, see userIdentity above)
     *     }
     *     commonEnvironmentSettings (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     poolInfo (Optional): {
     *         poolId: String (Optional)
     *         autoPoolSpecification (Optional): {
     *             autoPoolIdPrefix: String (Optional)
     *             poolLifetimeOption: String(jobschedule/job) (Required)
     *             keepAlive: Boolean (Optional)
     *             pool (Optional): {
     *                 displayName: String (Optional)
     *                 vmSize: String (Required)
     *                 cloudServiceConfiguration (Optional): {
     *                     osFamily: String (Required)
     *                     osVersion: String (Optional)
     *                 }
     *                 virtualMachineConfiguration (Optional): {
     *                     imageReference (Required): {
     *                         publisher: String (Optional)
     *                         offer: String (Optional)
     *                         sku: String (Optional)
     *                         version: String (Optional)
     *                         virtualMachineImageId: String (Optional)
     *                         exactVersion: String (Optional)
     *                     }
     *                     nodeAgentSKUId: String (Required)
     *                     windowsConfiguration (Optional): {
     *                         enableAutomaticUpdates: Boolean (Optional)
     *                     }
     *                     dataDisks (Optional): [
     *                          (Optional){
     *                             lun: int (Required)
     *                             caching: String(none/readonly/readwrite) (Optional)
     *                             diskSizeGB: int (Required)
     *                             storageAccountType: String(standard_lrs/premium_lrs) (Optional)
     *                         }
     *                     ]
     *                     licenseType: String (Optional)
     *                     containerConfiguration (Optional): {
     *                         type: String(dockerCompatible) (Required)
     *                         containerImageNames (Optional): [
     *                             String (Optional)
     *                         ]
     *                         containerRegistries (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                     diskEncryptionConfiguration (Optional): {
     *                         targets (Optional): [
     *                             String(osdisk/temporarydisk) (Optional)
     *                         ]
     *                     }
     *                     nodePlacementConfiguration (Optional): {
     *                         policy: String(regional/zonal) (Optional)
     *                     }
     *                     extensions (Optional): [
     *                          (Optional){
     *                             name: String (Required)
     *                             publisher: String (Required)
     *                             type: String (Required)
     *                             typeHandlerVersion: String (Optional)
     *                             autoUpgradeMinorVersion: Boolean (Optional)
     *                             settings: Object (Optional)
     *                             protectedSettings: Object (Optional)
     *                             provisionAfterExtensions (Optional): [
     *                                 String (Optional)
     *                             ]
     *                         }
     *                     ]
     *                     osDisk (Optional): {
     *                         ephemeralOSDiskSettings (Optional): {
     *                             placement: String(cachedisk) (Optional)
     *                         }
     *                     }
     *                 }
     *                 taskSlotsPerNode: Integer (Optional)
     *                 taskSchedulingPolicy (Optional): {
     *                     nodeFillType: String(spread/pack) (Required)
     *                 }
     *                 resizeTimeout: Duration (Optional)
     *                 targetDedicatedNodes: Integer (Optional)
     *                 targetLowPriorityNodes: Integer (Optional)
     *                 enableAutoScale: Boolean (Optional)
     *                 autoScaleFormula: String (Optional)
     *                 autoScaleEvaluationInterval: Duration (Optional)
     *                 enableInterNodeCommunication: Boolean (Optional)
     *                 networkConfiguration (Optional): {
     *                     subnetId: String (Optional)
     *                     dynamicVNetAssignmentScope: String(none/job) (Optional)
     *                     endpointConfiguration (Optional): {
     *                         inboundNATPools (Required): [
     *                              (Required){
     *                                 name: String (Required)
     *                                 protocol: String(tcp/udp) (Required)
     *                                 backendPort: int (Required)
     *                                 frontendPortRangeStart: int (Required)
     *                                 frontendPortRangeEnd: int (Required)
     *                                 networkSecurityGroupRules (Optional): [
     *                                      (Optional){
     *                                         priority: int (Required)
     *                                         access: String(allow/deny) (Required)
     *                                         sourceAddressPrefix: String (Required)
     *                                         sourcePortRanges (Optional): [
     *                                             String (Optional)
     *                                         ]
     *                                     }
     *                                 ]
     *                             }
     *                         ]
     *                     }
     *                     publicIPAddressConfiguration (Optional): {
     *                         provision: String(batchmanaged/usermanaged/nopublicipaddresses) (Optional)
     *                         ipAddressIds (Optional): [
     *                             String (Optional)
     *                         ]
     *                     }
     *                 }
     *                 startTask (Optional): {
     *                     commandLine: String (Required)
     *                     containerSettings (Optional): (recursive schema, see containerSettings above)
     *                     resourceFiles (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     environmentSettings (Optional): [
     *                         (recursive schema, see above)
     *                     ]
     *                     userIdentity (Optional): (recursive schema, see userIdentity above)
     *                     maxTaskRetryCount: Integer (Optional)
     *                     waitForSuccess: Boolean (Optional)
     *                 }
     *                 certificateReferences (Optional): [
     *                      (Optional){
     *                         thumbprint: String (Required)
     *                         thumbprintAlgorithm: String (Required)
     *                         storeLocation: String(currentuser/localmachine) (Optional)
     *                         storeName: String (Optional)
     *                         visibility (Optional): [
     *                             String(starttask/task/remoteuser) (Optional)
     *                         ]
     *                     }
     *                 ]
     *                 applicationPackageReferences (Optional): [
     *                     (recursive schema, see above)
     *                 ]
     *                 applicationLicenses (Optional): [
     *                     String (Optional)
     *                 ]
     *                 userAccounts (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         password: String (Required)
     *                         elevationLevel: String(nonadmin/admin) (Optional)
     *                         linuxUserConfiguration (Optional): {
     *                             uid: Integer (Optional)
     *                             gid: Integer (Optional)
     *                             sshPrivateKey: String (Optional)
     *                         }
     *                         windowsUserConfiguration (Optional): {
     *                             loginMode: String(batch/interactive) (Optional)
     *                         }
     *                     }
     *                 ]
     *                 metadata (Optional): [
     *                      (Optional){
     *                         name: String (Required)
     *                         value: String (Required)
     *                     }
     *                 ]
     *                 mountConfiguration (Optional): [
     *                      (Optional){
     *                         azureBlobFileSystemConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             containerName: String (Required)
     *                             accountKey: String (Optional)
     *                             sasKey: String (Optional)
     *                             blobfuseOptions: String (Optional)
     *                             relativeMountPath: String (Required)
     *                             identityReference (Optional): (recursive schema, see identityReference above)
     *                         }
     *                         nfsMountConfiguration (Optional): {
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                         cifsMountConfiguration (Optional): {
     *                             username: String (Required)
     *                             source: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                             password: String (Required)
     *                         }
     *                         azureFileShareConfiguration (Optional): {
     *                             accountName: String (Required)
     *                             azureFileUrl: String (Required)
     *                             accountKey: String (Required)
     *                             relativeMountPath: String (Required)
     *                             mountOptions: String (Optional)
     *                         }
     *                     }
     *                 ]
     *                 targetNodeCommunicationMode: String(default/classic/simplified) (Optional)
     *             }
     *         }
     *     }
     *     onAllTasksComplete: String(noaction/terminatejob) (Optional)
     *     onTaskFailure: String(noaction/performexitoptionsjobaction) (Optional)
     *     networkConfiguration (Optional): {
     *         subnetId: String (Required)
     *     }
     *     metadata (Optional): [
     *         (recursive schema, see above)
     *     ]
     *     executionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         poolId: String (Optional)
     *         schedulingError (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         terminateReason: String (Optional)
     *     }
     *     stats (Optional): {
     *         url: String (Required)
     *         startTime: OffsetDateTime (Required)
     *         lastUpdateTime: OffsetDateTime (Required)
     *         userCPUTime: Duration (Required)
     *         kernelCPUTime: Duration (Required)
     *         wallClockTime: Duration (Required)
     *         readIOps: int (Required)
     *         writeIOps: int (Required)
     *         readIOGiB: double (Required)
     *         writeIOGiB: double (Required)
     *         numSucceededTasks: int (Required)
     *         numFailedTasks: int (Required)
     *         numTaskRetries: int (Required)
     *         waitTime: Duration (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobScheduleId The ID of the Job Schedule from which you want to get a list of Jobs.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listFromJobSchedule(String jobScheduleId, RequestOptions requestOptions) {
        return new PagedIterable<>(this.client.listFromJobSchedule(jobScheduleId, requestOptions));
    }

    /**
     * Lists the execution status of the Job Preparation and Job Release Task for the specified Job across the Compute
     * Nodes where the Job has run.
     *
     * <p>This API returns the Job Preparation and Job Release Task status on all Compute Nodes that have run the Job
     * Preparation or Job Release Task. This includes Compute Nodes which have since been removed from the Pool. If this
     * API is invoked on a Job which has no Job Preparation or Job Release Task, the Batch service returns HTTP status
     * code 409 (Conflict) with an error code of JobPreparationTaskNotSpecified.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>maxresults</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     *     <tr><td>$filter</td><td>String</td><td>No</td><td>An OData $filter clause. For more information on constructing this filter, see
     * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.</td></tr>
     *     <tr><td>$select</td><td>String</td><td>No</td><td>An OData $select clause.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>ocp-date</td><td>String</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     *     <tr><td>client-request-id</td><td>String</td><td>No</td><td>The caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</td></tr>
     *     <tr><td>return-client-request-id</td><td>Boolean</td><td>No</td><td>Whether the server should return the client-request-id in the response.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     poolId: String (Optional)
     *     nodeId: String (Optional)
     *     nodeUrl: String (Optional)
     *     jobPreparationTaskExecutionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         state: String(running/completed) (Required)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): {
     *             containerId: String (Optional)
     *             state: String (Optional)
     *             error: String (Optional)
     *         }
     *         failureInfo (Optional): {
     *             category: String(usererror/servererror) (Required)
     *             code: String (Optional)
     *             message: String (Optional)
     *             details (Optional): [
     *                  (Optional){
     *                     name: String (Optional)
     *                     value: String (Optional)
     *                 }
     *             ]
     *         }
     *         retryCount: int (Required)
     *         lastRetryTime: OffsetDateTime (Optional)
     *         result: String(success/failure) (Optional)
     *     }
     *     jobReleaseTaskExecutionInfo (Optional): {
     *         startTime: OffsetDateTime (Required)
     *         endTime: OffsetDateTime (Optional)
     *         state: String(running/completed) (Required)
     *         taskRootDirectory: String (Optional)
     *         taskRootDirectoryUrl: String (Optional)
     *         exitCode: Integer (Optional)
     *         containerInfo (Optional): (recursive schema, see containerInfo above)
     *         failureInfo (Optional): (recursive schema, see failureInfo above)
     *         result: String(success/failure) (Optional)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of listing the status of the Job Preparation and Job Release Tasks for a Job as paginated
     *     response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listPreparationAndReleaseTaskStatus(String jobId, RequestOptions requestOptions) {
        return new PagedIterable<>(this.client.listPreparationAndReleaseTaskStatus(jobId, requestOptions));
    }

    /**
     * Gets the Task counts for the specified Job.
     *
     * <p>Task counts provide a count of the Tasks by active, running or completed Task state, and a count of Tasks
     * which succeeded or failed. Tasks in the preparing state are counted as running. Note that the numbers returned
     * may not always be up to date. If you need exact task counts, use a list query.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>timeOut</td><td>Integer</td><td>No</td><td>The maximum number of items to return in the response. A maximum of 1000
     * applications can be returned.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>client-request-id</td><td>String</td><td>No</td><td>The caller-generated request identity, in the form of a GUID with no decoration
     * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</td></tr>
     *     <tr><td>return-client-request-id</td><td>Boolean</td><td>No</td><td>Whether the server should return the client-request-id in the response.</td></tr>
     *     <tr><td>ocp-date</td><td>String</td><td>No</td><td>The time the request was issued. Client libraries typically set this to the
     * current system clock time; set it explicitly if you are calling the REST API
     * directly.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addHeader}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     taskCounts (Required): {
     *         active: int (Required)
     *         running: int (Required)
     *         completed: int (Required)
     *         succeeded: int (Required)
     *         failed: int (Required)
     *     }
     *     taskSlotCounts (Required): {
     *         active: int (Required)
     *         running: int (Required)
     *         completed: int (Required)
     *         succeeded: int (Required)
     *         failed: int (Required)
     *     }
     * }
     * }</pre>
     *
     * @param jobId The ID of the Job.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the Task and TaskSlot counts for a Job along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getTaskCountsWithResponse(String jobId, RequestOptions requestOptions) {
        return this.client.getTaskCountsWithResponse(jobId, requestOptions).block();
    }

    /**
     * Gets lifetime summary statistics for all of the Jobs in the specified Account.
     *
     * <p>Statistics are aggregated across all Jobs that have ever existed in the Account, from Account creation to the
     * last update time of the statistics. The statistics may not be immediately available. The Batch service performs
     * periodic roll-up of statistics. The typical delay is about 30 minutes.
     *
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param clientRequestId The caller-generated request identity, in the form of a GUID with no decoration such as
     *     curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     * @param returnClientRequestId Whether the server should return the client-request-id in the response.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return resource usage statistics for a Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public JobStatistics getAllLifetimeStatistics(
            Integer timeOut, String clientRequestId, Boolean returnClientRequestId, String ocpDate) {
        // Generated convenience method for getAllLifetimeStatisticsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (clientRequestId != null) {
            requestOptions.setHeader("client-request-id", clientRequestId);
        }
        if (returnClientRequestId != null) {
            requestOptions.setHeader("return-client-request-id", String.valueOf(returnClientRequestId));
        }
        if (ocpDate != null) {
            requestOptions.setHeader("ocp-date", ocpDate);
        }
        return getAllLifetimeStatisticsWithResponse(requestOptions).getValue().toObject(JobStatistics.class);
    }

    /**
     * Gets lifetime summary statistics for all of the Jobs in the specified Account.
     *
     * <p>Statistics are aggregated across all Jobs that have ever existed in the Account, from Account creation to the
     * last update time of the statistics. The statistics may not be immediately available. The Batch service performs
     * periodic roll-up of statistics. The typical delay is about 30 minutes.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return resource usage statistics for a Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public JobStatistics getAllLifetimeStatistics() {
        // Generated convenience method for getAllLifetimeStatisticsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getAllLifetimeStatisticsWithResponse(requestOptions).getValue().toObject(JobStatistics.class);
    }

    /**
     * Deletes a Job.
     *
     * <p>Deleting a Job also deletes all Tasks that are part of that Job, and all Job statistics. This also overrides
     * the retention period for Task data; that is, if the Job contains Tasks which are still retained on Compute Nodes,
     * the Batch services deletes those Tasks' working directories and all their contents. When a Delete Job request is
     * received, the Batch service sets the Job to the deleting state. All update operations on a Job that is in
     * deleting state will fail with status code 409 (Conflict), with additional information indicating that the Job is
     * being deleted.
     *
     * @param jobId The ID of the Job to delete.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param clientRequestId The caller-generated request identity, in the form of a GUID with no decoration such as
     *     curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     * @param returnClientRequestId Whether the server should return the client-request-id in the response.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param ifMatch An ETag value associated with the version of the resource known to the client. The operation will
     *     be performed only if the resource's current ETag on the service exactly matches the value specified by the
     *     client.
     * @param ifNoneMatch An ETag value associated with the version of the resource known to the client. The operation
     *     will be performed only if the resource's current ETag on the service does not match the value specified by
     *     the client.
     * @param ifModifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has been modified since the specified time.
     * @param ifUnmodifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has not been modified since the specified
     *     time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(
            String jobId,
            Integer timeOut,
            String clientRequestId,
            Boolean returnClientRequestId,
            String ocpDate,
            String ifMatch,
            String ifNoneMatch,
            String ifModifiedSince,
            String ifUnmodifiedSince) {
        // Generated convenience method for deleteWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (clientRequestId != null) {
            requestOptions.setHeader("client-request-id", clientRequestId);
        }
        if (returnClientRequestId != null) {
            requestOptions.setHeader("return-client-request-id", String.valueOf(returnClientRequestId));
        }
        if (ocpDate != null) {
            requestOptions.setHeader("ocp-date", ocpDate);
        }
        if (ifMatch != null) {
            requestOptions.setHeader("if-match", ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader("if-none-match", ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader("if-modified-since", ifModifiedSince);
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader("if-unmodified-since", ifUnmodifiedSince);
        }
        deleteWithResponse(jobId, requestOptions).getValue();
    }

    /**
     * Deletes a Job.
     *
     * <p>Deleting a Job also deletes all Tasks that are part of that Job, and all Job statistics. This also overrides
     * the retention period for Task data; that is, if the Job contains Tasks which are still retained on Compute Nodes,
     * the Batch services deletes those Tasks' working directories and all their contents. When a Delete Job request is
     * received, the Batch service sets the Job to the deleting state. All update operations on a Job that is in
     * deleting state will fail with status code 409 (Conflict), with additional information indicating that the Job is
     * being deleted.
     *
     * @param jobId The ID of the Job to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String jobId) {
        // Generated convenience method for deleteWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteWithResponse(jobId, requestOptions).getValue();
    }

    /**
     * Gets information about the specified Job.
     *
     * @param jobId The ID of the Job.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param clientRequestId The caller-generated request identity, in the form of a GUID with no decoration such as
     *     curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     * @param returnClientRequestId Whether the server should return the client-request-id in the response.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param ifMatch An ETag value associated with the version of the resource known to the client. The operation will
     *     be performed only if the resource's current ETag on the service exactly matches the value specified by the
     *     client.
     * @param ifNoneMatch An ETag value associated with the version of the resource known to the client. The operation
     *     will be performed only if the resource's current ETag on the service does not match the value specified by
     *     the client.
     * @param ifModifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has been modified since the specified time.
     * @param ifUnmodifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has not been modified since the specified
     *     time.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchJob get(
            String jobId,
            Integer timeOut,
            String clientRequestId,
            Boolean returnClientRequestId,
            String ocpDate,
            String ifMatch,
            String ifNoneMatch,
            String ifModifiedSince,
            String ifUnmodifiedSince,
            String select,
            String expand) {
        // Generated convenience method for getWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (clientRequestId != null) {
            requestOptions.setHeader("client-request-id", clientRequestId);
        }
        if (returnClientRequestId != null) {
            requestOptions.setHeader("return-client-request-id", String.valueOf(returnClientRequestId));
        }
        if (ocpDate != null) {
            requestOptions.setHeader("ocp-date", ocpDate);
        }
        if (ifMatch != null) {
            requestOptions.setHeader("if-match", ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader("if-none-match", ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader("if-modified-since", ifModifiedSince);
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader("if-unmodified-since", ifUnmodifiedSince);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select", select, false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand", expand, false);
        }
        return getWithResponse(jobId, requestOptions).getValue().toObject(BatchJob.class);
    }

    /**
     * Gets information about the specified Job.
     *
     * @param jobId The ID of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about the specified Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BatchJob get(String jobId) {
        // Generated convenience method for getWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getWithResponse(jobId, requestOptions).getValue().toObject(BatchJob.class);
    }

    /**
     * Updates the properties of the specified Job.
     *
     * <p>This replaces only the Job properties specified in the request. For example, if the Job has constraints, and a
     * request does not specify the constraints element, then the Job keeps the existing constraints.
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param jobPatchParameter The parameters for the request.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param clientRequestId The caller-generated request identity, in the form of a GUID with no decoration such as
     *     curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     * @param returnClientRequestId Whether the server should return the client-request-id in the response.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param ifMatch An ETag value associated with the version of the resource known to the client. The operation will
     *     be performed only if the resource's current ETag on the service exactly matches the value specified by the
     *     client.
     * @param ifNoneMatch An ETag value associated with the version of the resource known to the client. The operation
     *     will be performed only if the resource's current ETag on the service does not match the value specified by
     *     the client.
     * @param ifModifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has been modified since the specified time.
     * @param ifUnmodifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has not been modified since the specified
     *     time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void patch(
            String jobId,
            BatchJob jobPatchParameter,
            Integer timeOut,
            String clientRequestId,
            Boolean returnClientRequestId,
            String ocpDate,
            String ifMatch,
            String ifNoneMatch,
            String ifModifiedSince,
            String ifUnmodifiedSince) {
        // Generated convenience method for patchWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (clientRequestId != null) {
            requestOptions.setHeader("client-request-id", clientRequestId);
        }
        if (returnClientRequestId != null) {
            requestOptions.setHeader("return-client-request-id", String.valueOf(returnClientRequestId));
        }
        if (ocpDate != null) {
            requestOptions.setHeader("ocp-date", ocpDate);
        }
        if (ifMatch != null) {
            requestOptions.setHeader("if-match", ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader("if-none-match", ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader("if-modified-since", ifModifiedSince);
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader("if-unmodified-since", ifUnmodifiedSince);
        }
        patchWithResponse(jobId, BinaryData.fromObject(jobPatchParameter), requestOptions).getValue();
    }

    /**
     * Updates the properties of the specified Job.
     *
     * <p>This replaces only the Job properties specified in the request. For example, if the Job has constraints, and a
     * request does not specify the constraints element, then the Job keeps the existing constraints.
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param jobPatchParameter The parameters for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void patch(String jobId, BatchJob jobPatchParameter) {
        // Generated convenience method for patchWithResponse
        RequestOptions requestOptions = new RequestOptions();
        patchWithResponse(jobId, BinaryData.fromObject(jobPatchParameter), requestOptions).getValue();
    }

    /**
     * Updates the properties of the specified Job.
     *
     * <p>This fully replaces all the updatable properties of the Job. For example, if the Job has constraints
     * associated with it and if constraints is not specified with this request, then the Batch service will remove the
     * existing constraints.
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param jobUpdateParameter The parameters for the request.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param clientRequestId The caller-generated request identity, in the form of a GUID with no decoration such as
     *     curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     * @param returnClientRequestId Whether the server should return the client-request-id in the response.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param ifMatch An ETag value associated with the version of the resource known to the client. The operation will
     *     be performed only if the resource's current ETag on the service exactly matches the value specified by the
     *     client.
     * @param ifNoneMatch An ETag value associated with the version of the resource known to the client. The operation
     *     will be performed only if the resource's current ETag on the service does not match the value specified by
     *     the client.
     * @param ifModifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has been modified since the specified time.
     * @param ifUnmodifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has not been modified since the specified
     *     time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void update(
            String jobId,
            BatchJob jobUpdateParameter,
            Integer timeOut,
            String clientRequestId,
            Boolean returnClientRequestId,
            String ocpDate,
            String ifMatch,
            String ifNoneMatch,
            String ifModifiedSince,
            String ifUnmodifiedSince) {
        // Generated convenience method for updateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (clientRequestId != null) {
            requestOptions.setHeader("client-request-id", clientRequestId);
        }
        if (returnClientRequestId != null) {
            requestOptions.setHeader("return-client-request-id", String.valueOf(returnClientRequestId));
        }
        if (ocpDate != null) {
            requestOptions.setHeader("ocp-date", ocpDate);
        }
        if (ifMatch != null) {
            requestOptions.setHeader("if-match", ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader("if-none-match", ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader("if-modified-since", ifModifiedSince);
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader("if-unmodified-since", ifUnmodifiedSince);
        }
        updateWithResponse(jobId, BinaryData.fromObject(jobUpdateParameter), requestOptions).getValue();
    }

    /**
     * Updates the properties of the specified Job.
     *
     * <p>This fully replaces all the updatable properties of the Job. For example, if the Job has constraints
     * associated with it and if constraints is not specified with this request, then the Batch service will remove the
     * existing constraints.
     *
     * @param jobId The ID of the Job whose properties you want to update.
     * @param jobUpdateParameter The parameters for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void update(String jobId, BatchJob jobUpdateParameter) {
        // Generated convenience method for updateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        updateWithResponse(jobId, BinaryData.fromObject(jobUpdateParameter), requestOptions).getValue();
    }

    /**
     * Disables the specified Job, preventing new Tasks from running.
     *
     * <p>The Batch Service immediately moves the Job to the disabling state. Batch then uses the disableTasks parameter
     * to determine what to do with the currently running Tasks of the Job. The Job remains in the disabling state until
     * the disable operation is completed and all Tasks have been dealt with according to the disableTasks option; the
     * Job then moves to the disabled state. No new Tasks are started under the Job until it moves back to active state.
     * If you try to disable a Job that is in any state other than active, disabling, or disabled, the request fails
     * with status code 409.
     *
     * @param jobId The ID of the Job to disable.
     * @param jobDisableParameter The parameters for the request.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param clientRequestId The caller-generated request identity, in the form of a GUID with no decoration such as
     *     curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     * @param returnClientRequestId Whether the server should return the client-request-id in the response.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param ifMatch An ETag value associated with the version of the resource known to the client. The operation will
     *     be performed only if the resource's current ETag on the service exactly matches the value specified by the
     *     client.
     * @param ifNoneMatch An ETag value associated with the version of the resource known to the client. The operation
     *     will be performed only if the resource's current ETag on the service does not match the value specified by
     *     the client.
     * @param ifModifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has been modified since the specified time.
     * @param ifUnmodifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has not been modified since the specified
     *     time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void disable(
            String jobId,
            BatchJobDisableParameters jobDisableParameter,
            Integer timeOut,
            String clientRequestId,
            Boolean returnClientRequestId,
            String ocpDate,
            String ifMatch,
            String ifNoneMatch,
            String ifModifiedSince,
            String ifUnmodifiedSince) {
        // Generated convenience method for disableWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (clientRequestId != null) {
            requestOptions.setHeader("client-request-id", clientRequestId);
        }
        if (returnClientRequestId != null) {
            requestOptions.setHeader("return-client-request-id", String.valueOf(returnClientRequestId));
        }
        if (ocpDate != null) {
            requestOptions.setHeader("ocp-date", ocpDate);
        }
        if (ifMatch != null) {
            requestOptions.setHeader("if-match", ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader("if-none-match", ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader("if-modified-since", ifModifiedSince);
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader("if-unmodified-since", ifUnmodifiedSince);
        }
        disableWithResponse(jobId, BinaryData.fromObject(jobDisableParameter), requestOptions).getValue();
    }

    /**
     * Disables the specified Job, preventing new Tasks from running.
     *
     * <p>The Batch Service immediately moves the Job to the disabling state. Batch then uses the disableTasks parameter
     * to determine what to do with the currently running Tasks of the Job. The Job remains in the disabling state until
     * the disable operation is completed and all Tasks have been dealt with according to the disableTasks option; the
     * Job then moves to the disabled state. No new Tasks are started under the Job until it moves back to active state.
     * If you try to disable a Job that is in any state other than active, disabling, or disabled, the request fails
     * with status code 409.
     *
     * @param jobId The ID of the Job to disable.
     * @param jobDisableParameter The parameters for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void disable(String jobId, BatchJobDisableParameters jobDisableParameter) {
        // Generated convenience method for disableWithResponse
        RequestOptions requestOptions = new RequestOptions();
        disableWithResponse(jobId, BinaryData.fromObject(jobDisableParameter), requestOptions).getValue();
    }

    /**
     * Enables the specified Job, allowing new Tasks to run.
     *
     * <p>When you call this API, the Batch service sets a disabled Job to the enabling state. After the this operation
     * is completed, the Job moves to the active state, and scheduling of new Tasks under the Job resumes. The Batch
     * service does not allow a Task to remain in the active state for more than 180 days. Therefore, if you enable a
     * Job containing active Tasks which were added more than 180 days ago, those Tasks will not run.
     *
     * @param jobId The ID of the Job to enable.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param clientRequestId The caller-generated request identity, in the form of a GUID with no decoration such as
     *     curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     * @param returnClientRequestId Whether the server should return the client-request-id in the response.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param ifMatch An ETag value associated with the version of the resource known to the client. The operation will
     *     be performed only if the resource's current ETag on the service exactly matches the value specified by the
     *     client.
     * @param ifNoneMatch An ETag value associated with the version of the resource known to the client. The operation
     *     will be performed only if the resource's current ETag on the service does not match the value specified by
     *     the client.
     * @param ifModifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has been modified since the specified time.
     * @param ifUnmodifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has not been modified since the specified
     *     time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void enable(
            String jobId,
            Integer timeOut,
            String clientRequestId,
            Boolean returnClientRequestId,
            String ocpDate,
            String ifMatch,
            String ifNoneMatch,
            String ifModifiedSince,
            String ifUnmodifiedSince) {
        // Generated convenience method for enableWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (clientRequestId != null) {
            requestOptions.setHeader("client-request-id", clientRequestId);
        }
        if (returnClientRequestId != null) {
            requestOptions.setHeader("return-client-request-id", String.valueOf(returnClientRequestId));
        }
        if (ocpDate != null) {
            requestOptions.setHeader("ocp-date", ocpDate);
        }
        if (ifMatch != null) {
            requestOptions.setHeader("if-match", ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader("if-none-match", ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader("if-modified-since", ifModifiedSince);
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader("if-unmodified-since", ifUnmodifiedSince);
        }
        enableWithResponse(jobId, requestOptions).getValue();
    }

    /**
     * Enables the specified Job, allowing new Tasks to run.
     *
     * <p>When you call this API, the Batch service sets a disabled Job to the enabling state. After the this operation
     * is completed, the Job moves to the active state, and scheduling of new Tasks under the Job resumes. The Batch
     * service does not allow a Task to remain in the active state for more than 180 days. Therefore, if you enable a
     * Job containing active Tasks which were added more than 180 days ago, those Tasks will not run.
     *
     * @param jobId The ID of the Job to enable.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void enable(String jobId) {
        // Generated convenience method for enableWithResponse
        RequestOptions requestOptions = new RequestOptions();
        enableWithResponse(jobId, requestOptions).getValue();
    }

    /**
     * Terminates the specified Job, marking it as completed.
     *
     * <p>When a Terminate Job request is received, the Batch service sets the Job to the terminating state. The Batch
     * service then terminates any running Tasks associated with the Job and runs any required Job release Tasks. Then
     * the Job moves into the completed state. If there are any Tasks in the Job in the active state, they will remain
     * in the active state. Once a Job is terminated, new Tasks cannot be added and any remaining active Tasks will not
     * be scheduled.
     *
     * @param jobId The ID of the Job to terminate.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param clientRequestId The caller-generated request identity, in the form of a GUID with no decoration such as
     *     curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     * @param returnClientRequestId Whether the server should return the client-request-id in the response.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param ifMatch An ETag value associated with the version of the resource known to the client. The operation will
     *     be performed only if the resource's current ETag on the service exactly matches the value specified by the
     *     client.
     * @param ifNoneMatch An ETag value associated with the version of the resource known to the client. The operation
     *     will be performed only if the resource's current ETag on the service does not match the value specified by
     *     the client.
     * @param ifModifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has been modified since the specified time.
     * @param ifUnmodifiedSince A timestamp indicating the last modified time of the resource known to the client. The
     *     operation will be performed only if the resource on the service has not been modified since the specified
     *     time.
     * @param parameters The parameters for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void terminate(
            String jobId,
            Integer timeOut,
            String clientRequestId,
            Boolean returnClientRequestId,
            String ocpDate,
            String ifMatch,
            String ifNoneMatch,
            String ifModifiedSince,
            String ifUnmodifiedSince,
            BatchJobTerminateParameters parameters) {
        // Generated convenience method for terminateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (clientRequestId != null) {
            requestOptions.setHeader("client-request-id", clientRequestId);
        }
        if (returnClientRequestId != null) {
            requestOptions.setHeader("return-client-request-id", String.valueOf(returnClientRequestId));
        }
        if (ocpDate != null) {
            requestOptions.setHeader("ocp-date", ocpDate);
        }
        if (ifMatch != null) {
            requestOptions.setHeader("if-match", ifMatch);
        }
        if (ifNoneMatch != null) {
            requestOptions.setHeader("if-none-match", ifNoneMatch);
        }
        if (ifModifiedSince != null) {
            requestOptions.setHeader("if-modified-since", ifModifiedSince);
        }
        if (ifUnmodifiedSince != null) {
            requestOptions.setHeader("if-unmodified-since", ifUnmodifiedSince);
        }
        if (parameters != null) {
            requestOptions.setBody(BinaryData.fromObject(parameters));
        }
        terminateWithResponse(jobId, requestOptions).getValue();
    }

    /**
     * Terminates the specified Job, marking it as completed.
     *
     * <p>When a Terminate Job request is received, the Batch service sets the Job to the terminating state. The Batch
     * service then terminates any running Tasks associated with the Job and runs any required Job release Tasks. Then
     * the Job moves into the completed state. If there are any Tasks in the Job in the active state, they will remain
     * in the active state. Once a Job is terminated, new Tasks cannot be added and any remaining active Tasks will not
     * be scheduled.
     *
     * @param jobId The ID of the Job to terminate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void terminate(String jobId) {
        // Generated convenience method for terminateWithResponse
        RequestOptions requestOptions = new RequestOptions();
        terminateWithResponse(jobId, requestOptions).getValue();
    }

    /**
     * Adds a Job to the specified Account.
     *
     * <p>The Batch service supports two ways to control the work done as part of a Job. In the first approach, the user
     * specifies a Job Manager Task. The Batch service launches this Task when it is ready to start the Job. The Job
     * Manager Task controls all other Tasks that run under this Job, by using the Task APIs. In the second approach,
     * the user directly controls the execution of Tasks under an active Job, by using the Task APIs. Also note: when
     * naming Jobs, avoid including sensitive information such as user names or secret project names. This information
     * may appear in telemetry logs accessible to Microsoft Support engineers.
     *
     * @param job The Job to be added.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param clientRequestId The caller-generated request identity, in the form of a GUID with no decoration such as
     *     curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     * @param returnClientRequestId Whether the server should return the client-request-id in the response.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void add(
            BatchJob job, Integer timeOut, String clientRequestId, Boolean returnClientRequestId, String ocpDate) {
        // Generated convenience method for addWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (clientRequestId != null) {
            requestOptions.setHeader("client-request-id", clientRequestId);
        }
        if (returnClientRequestId != null) {
            requestOptions.setHeader("return-client-request-id", String.valueOf(returnClientRequestId));
        }
        if (ocpDate != null) {
            requestOptions.setHeader("ocp-date", ocpDate);
        }
        addWithResponse(BinaryData.fromObject(job), requestOptions).getValue();
    }

    /**
     * Adds a Job to the specified Account.
     *
     * <p>The Batch service supports two ways to control the work done as part of a Job. In the first approach, the user
     * specifies a Job Manager Task. The Batch service launches this Task when it is ready to start the Job. The Job
     * Manager Task controls all other Tasks that run under this Job, by using the Task APIs. In the second approach,
     * the user directly controls the execution of Tasks under an active Job, by using the Task APIs. Also note: when
     * naming Jobs, avoid including sensitive information such as user names or secret project names. This information
     * may appear in telemetry logs accessible to Microsoft Support engineers.
     *
     * @param job The Job to be added.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void add(BatchJob job) {
        // Generated convenience method for addWithResponse
        RequestOptions requestOptions = new RequestOptions();
        addWithResponse(BinaryData.fromObject(job), requestOptions).getValue();
    }

    /**
     * Lists all of the Jobs in the specified Account.
     *
     * @param maxresults The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param clientRequestId The caller-generated request identity, in the form of a GUID with no decoration such as
     *     curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     * @param returnClientRequestId Whether the server should return the client-request-id in the response.
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     *     https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchJob> list(
            Integer maxresults,
            String ocpDate,
            Integer timeOut,
            String clientRequestId,
            Boolean returnClientRequestId,
            String filter,
            String select,
            String expand) {
        // Generated convenience method for list
        RequestOptions requestOptions = new RequestOptions();
        if (maxresults != null) {
            requestOptions.addQueryParam("maxresults", String.valueOf(maxresults), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader("ocp-date", ocpDate);
        }
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (clientRequestId != null) {
            requestOptions.setHeader("client-request-id", clientRequestId);
        }
        if (returnClientRequestId != null) {
            requestOptions.setHeader("return-client-request-id", String.valueOf(returnClientRequestId));
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select", select, false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand", expand, false);
        }
        return new PagedIterable<>(
                client.list(
                        maxresults, ocpDate, timeOut, clientRequestId, returnClientRequestId, filter, select, expand));
    }

    /**
     * Lists all of the Jobs in the specified Account.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchJob> list() {
        // Generated convenience method for list
        RequestOptions requestOptions = new RequestOptions();
        return new PagedIterable<>(client.list());
    }

    /**
     * Lists the Jobs that have been created under the specified Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule from which you want to get a list of Jobs.
     * @param maxresults The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param clientRequestId The caller-generated request identity, in the form of a GUID with no decoration such as
     *     curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     * @param returnClientRequestId Whether the server should return the client-request-id in the response.
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     *     https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.
     * @param select An OData $select clause.
     * @param expand An OData $expand clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchJob> listFromJobSchedule(
            String jobScheduleId,
            Integer maxresults,
            String ocpDate,
            Integer timeOut,
            String clientRequestId,
            Boolean returnClientRequestId,
            String filter,
            String select,
            String expand) {
        // Generated convenience method for listFromJobSchedule
        RequestOptions requestOptions = new RequestOptions();
        if (maxresults != null) {
            requestOptions.addQueryParam("maxresults", String.valueOf(maxresults), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader("ocp-date", ocpDate);
        }
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (clientRequestId != null) {
            requestOptions.setHeader("client-request-id", clientRequestId);
        }
        if (returnClientRequestId != null) {
            requestOptions.setHeader("return-client-request-id", String.valueOf(returnClientRequestId));
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select", select, false);
        }
        if (expand != null) {
            requestOptions.addQueryParam("$expand", expand, false);
        }
        return new PagedIterable<>(
                client.listFromJobSchedule(
                        jobScheduleId,
                        maxresults,
                        ocpDate,
                        timeOut,
                        clientRequestId,
                        returnClientRequestId,
                        filter,
                        select,
                        expand));
    }

    /**
     * Lists the Jobs that have been created under the specified Job Schedule.
     *
     * @param jobScheduleId The ID of the Job Schedule from which you want to get a list of Jobs.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the Jobs in an Account as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BatchJob> listFromJobSchedule(String jobScheduleId) {
        // Generated convenience method for listFromJobSchedule
        RequestOptions requestOptions = new RequestOptions();
        return new PagedIterable<>(client.listFromJobSchedule(jobScheduleId));
    }

    /**
     * Lists the execution status of the Job Preparation and Job Release Task for the specified Job across the Compute
     * Nodes where the Job has run.
     *
     * <p>This API returns the Job Preparation and Job Release Task status on all Compute Nodes that have run the Job
     * Preparation or Job Release Task. This includes Compute Nodes which have since been removed from the Pool. If this
     * API is invoked on a Job which has no Job Preparation or Job Release Task, the Batch service returns HTTP status
     * code 409 (Conflict) with an error code of JobPreparationTaskNotSpecified.
     *
     * @param jobId The ID of the Job.
     * @param maxresults The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param clientRequestId The caller-generated request identity, in the form of a GUID with no decoration such as
     *     curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     * @param returnClientRequestId Whether the server should return the client-request-id in the response.
     * @param filter An OData $filter clause. For more information on constructing this filter, see
     *     https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.
     * @param select An OData $select clause.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the status of the Job Preparation and Job Release Tasks for a Job as paginated
     *     response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<JobPreparationAndReleaseTaskExecutionInformation> listPreparationAndReleaseTaskStatus(
            String jobId,
            Integer maxresults,
            String ocpDate,
            Integer timeOut,
            String clientRequestId,
            Boolean returnClientRequestId,
            String filter,
            String select) {
        // Generated convenience method for listPreparationAndReleaseTaskStatus
        RequestOptions requestOptions = new RequestOptions();
        if (maxresults != null) {
            requestOptions.addQueryParam("maxresults", String.valueOf(maxresults), false);
        }
        if (ocpDate != null) {
            requestOptions.setHeader("ocp-date", ocpDate);
        }
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (clientRequestId != null) {
            requestOptions.setHeader("client-request-id", clientRequestId);
        }
        if (returnClientRequestId != null) {
            requestOptions.setHeader("return-client-request-id", String.valueOf(returnClientRequestId));
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select", select, false);
        }
        return new PagedIterable<>(
                client.listPreparationAndReleaseTaskStatus(
                        jobId, maxresults, ocpDate, timeOut, clientRequestId, returnClientRequestId, filter, select));
    }

    /**
     * Lists the execution status of the Job Preparation and Job Release Task for the specified Job across the Compute
     * Nodes where the Job has run.
     *
     * <p>This API returns the Job Preparation and Job Release Task status on all Compute Nodes that have run the Job
     * Preparation or Job Release Task. This includes Compute Nodes which have since been removed from the Pool. If this
     * API is invoked on a Job which has no Job Preparation or Job Release Task, the Batch service returns HTTP status
     * code 409 (Conflict) with an error code of JobPreparationTaskNotSpecified.
     *
     * @param jobId The ID of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of listing the status of the Job Preparation and Job Release Tasks for a Job as paginated
     *     response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<JobPreparationAndReleaseTaskExecutionInformation> listPreparationAndReleaseTaskStatus(
            String jobId) {
        // Generated convenience method for listPreparationAndReleaseTaskStatus
        RequestOptions requestOptions = new RequestOptions();
        return new PagedIterable<>(client.listPreparationAndReleaseTaskStatus(jobId));
    }

    /**
     * Gets the Task counts for the specified Job.
     *
     * <p>Task counts provide a count of the Tasks by active, running or completed Task state, and a count of Tasks
     * which succeeded or failed. Tasks in the preparing state are counted as running. Note that the numbers returned
     * may not always be up to date. If you need exact task counts, use a list query.
     *
     * @param jobId The ID of the Job.
     * @param timeOut The maximum number of items to return in the response. A maximum of 1000 applications can be
     *     returned.
     * @param clientRequestId The caller-generated request identity, in the form of a GUID with no decoration such as
     *     curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
     * @param returnClientRequestId Whether the server should return the client-request-id in the response.
     * @param ocpDate The time the request was issued. Client libraries typically set this to the current system clock
     *     time; set it explicitly if you are calling the REST API directly.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the Task and TaskSlot counts for a Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TaskCountsResult getTaskCounts(
            String jobId, Integer timeOut, String clientRequestId, Boolean returnClientRequestId, String ocpDate) {
        // Generated convenience method for getTaskCountsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (timeOut != null) {
            requestOptions.addQueryParam("timeOut", String.valueOf(timeOut), false);
        }
        if (clientRequestId != null) {
            requestOptions.setHeader("client-request-id", clientRequestId);
        }
        if (returnClientRequestId != null) {
            requestOptions.setHeader("return-client-request-id", String.valueOf(returnClientRequestId));
        }
        if (ocpDate != null) {
            requestOptions.setHeader("ocp-date", ocpDate);
        }
        return getTaskCountsWithResponse(jobId, requestOptions).getValue().toObject(TaskCountsResult.class);
    }

    /**
     * Gets the Task counts for the specified Job.
     *
     * <p>Task counts provide a count of the Tasks by active, running or completed Task state, and a count of Tasks
     * which succeeded or failed. Tasks in the preparing state are counted as running. Note that the numbers returned
     * may not always be up to date. If you need exact task counts, use a list query.
     *
     * @param jobId The ID of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the Task and TaskSlot counts for a Job.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TaskCountsResult getTaskCounts(String jobId) {
        // Generated convenience method for getTaskCountsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getTaskCountsWithResponse(jobId, requestOptions).getValue().toObject(TaskCountsResult.class);
    }
}
